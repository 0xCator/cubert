code,godclass,dataclass,longmethod,longparamlist
"private void start(String props, String cluster_name, long rpc_timeout, long caching_time, boolean migrate_data, boolean use_l1_cache, int l1_max_entries, long l1_reaping_interval, int l2_max_entries, long l2_reaping_interval) throws Exception;",0,0,0,1
"abstract class UOfKind extends UExpression {
	 public static UOfKind create(UExpression expression, Set<Kind> allowed) {
		 return new AutoValue_UOfKind(expression, allowed);
	 }
	 abstract UExpression expression();
	 abstract Set<Kind> allowed();
	 public JCExpression inline(Inliner inliner) throws CouldNotResolveImportException {
		 return expression().inline(inliner);
	 }
	 public <R, D> R accept(TreeVisitor<R, D> visitor, D data) {
		 return expression().accept(visitor, data);
	 }
	 public Kind getKind() {
		 return expression().getKind();
	 }
	 protected Choice<Unifier> defaultAction(Tree tree, Unifier unifier) {
		 return Choice.condition(allowed().contains(tree.getKind()), unifier) .thenChoose(unifications(expression(), tree));
	 }
}",0,1,0,0
"public class CoordActionQueryExecutor extends QueryExecutor<CoordinatorActionBean, CoordActionQueryExecutor.CoordActionQuery> {
	 public enum CoordActionQuery {
	 UPDATE_COORD_ACTION, UPDATE_COORD_ACTION_STATUS_PENDING_TIME, UPDATE_COORD_ACTION_FOR_INPUTCHECK, UPDATE_COORD_ACTION_FOR_PUSH_INPUTCHECK, UPDATE_COORD_ACTION_DEPENDENCIES, UPDATE_COORD_ACTION_FOR_START, UPDATE_COORD_ACTION_FOR_MODIFIED_DATE, UPDATE_COORD_ACTION_RERUN, GET_COORD_ACTION, GET_COORD_ACTION_STATUS, GET_COORD_ACTIVE_ACTIONS_COUNT_BY_JOBID, GET_COORD_ACTIONS_BY_LAST_MODIFIED_TIME, GET_COORD_ACTIONS_STATUS_UNIGNORED, GET_COORD_ACTIONS_PENDING_COUNT, GET_ACTIVE_ACTIONS_IDS_FOR_SLA_CHANGE, GET_ACTIVE_ACTIONS_JOBID_FOR_SLA_CHANGE, GET_TERMINATED_ACTIONS_FOR_DATES, GET_TERMINATED_ACTION_IDS_FOR_DATES, GET_ACTIVE_ACTIONS_FOR_DATES, GET_COORD_ACTIONS_WAITING_READY_SUBMITTED_OLDER_THAN, GET_COORD_ACTIONS_FOR_RECOVERY_OLDER_THAN, GET_COORD_ACTION_FOR_SLA, GET_COORD_ACTION_FOR_INPUTCHECK }
	;
	 private static CoordActionQueryExecutor instance = new CoordActionQueryExecutor();
	 private CoordActionQueryExecutor() {
	 }
	 public static QueryExecutor<CoordinatorActionBean, CoordActionQueryExecutor.CoordActionQuery> getInstance() {
		 return CoordActionQueryExecutor.instance;
	 }
	 public Query getUpdateQuery(CoordActionQuery namedQuery, CoordinatorActionBean actionBean, EntityManager em) throws JPAExecutorException {
		 Query query = em.createNamedQuery(namedQuery.name());
		 switch (namedQuery) {
			 case UPDATE_COORD_ACTION: query.setParameter(""actionNumber"", actionBean.getActionNumber());
			 query.setParameter(""actionXml"", actionBean.getActionXmlBlob());
			 query.setParameter(""consoleUrl"", actionBean.getConsoleUrl());
			 query.setParameter(""createdConf"", actionBean.getCreatedConfBlob());
			 query.setParameter(""errorCode"", actionBean.getErrorCode());
			 query.setParameter(""errorMessage"", actionBean.getErrorMessage());
			 query.setParameter(""externalStatus"", actionBean.getExternalStatus());
			 query.setParameter(""missingDependencies"", actionBean.getMissingDependenciesBlob());
			 query.setParameter(""runConf"", actionBean.getRunConfBlob());
			 query.setParameter(""timeOut"", actionBean.getTimeOut());
			 query.setParameter(""trackerUri"", actionBean.getTrackerUri());
			 query.setParameter(""type"", actionBean.getType());
			 query.setParameter(""createdTime"", actionBean.getCreatedTimestamp());
			 query.setParameter(""externalId"", actionBean.getExternalId());
			 query.setParameter(""jobId"", actionBean.getJobId());
			 query.setParameter(""lastModifiedTime"", new Date());
			 query.setParameter(""nominalTime"", actionBean.getNominalTimestamp());
			 query.setParameter(""slaXml"", actionBean.getSlaXmlBlob());
			 query.setParameter(""status"", actionBean.getStatus().toString());
			 query.setParameter(""id"", actionBean.getId());
			 break;
			 case UPDATE_COORD_ACTION_STATUS_PENDING_TIME: query.setParameter(""status"", actionBean.getStatus().toString());
			 query.setParameter(""pending"", actionBean.getPending());
			 query.setParameter(""lastModifiedTime"", new Date());
			 query.setParameter(""id"", actionBean.getId());
			 break;
			 case UPDATE_COORD_ACTION_FOR_INPUTCHECK: query.setParameter(""status"", actionBean.getStatus().toString());
			 query.setParameter(""lastModifiedTime"", new Date());
			 query.setParameter(""actionXml"", actionBean.getActionXmlBlob());
			 query.setParameter(""missingDependencies"", actionBean.getMissingDependenciesBlob());
			 query.setParameter(""id"", actionBean.getId());
			 break;
			 case UPDATE_COORD_ACTION_FOR_PUSH_INPUTCHECK: query.setParameter(""status"", actionBean.getStatus().toString());
			 query.setParameter(""lastModifiedTime"", new Date());
			 query.setParameter(""actionXml"", actionBean.getActionXmlBlob());
			 query.setParameter(""pushMissingDependencies"", actionBean.getPushMissingDependenciesBlob());
			 query.setParameter(""id"", actionBean.getId());
			 break;
			 case UPDATE_COORD_ACTION_DEPENDENCIES: query.setParameter(""missingDependencies"", actionBean.getMissingDependenciesBlob());
			 query.setParameter(""pushMissingDependencies"", actionBean.getPushMissingDependenciesBlob());
			 query.setParameter(""id"", actionBean.getId());
			 break;
			 case UPDATE_COORD_ACTION_FOR_START: query.setParameter(""status"", actionBean.getStatus().toString());
			 query.setParameter(""lastModifiedTime"", new Date());
			 query.setParameter(""runConf"", actionBean.getRunConfBlob());
			 query.setParameter(""externalId"", actionBean.getExternalId());
			 query.setParameter(""pending"", actionBean.getPending());
			 query.setParameter(""errorCode"", actionBean.getErrorCode());
			 query.setParameter(""errorMessage"", actionBean.getErrorMessage());
			 query.setParameter(""id"", actionBean.getId());
			 break;
			 case UPDATE_COORD_ACTION_FOR_MODIFIED_DATE: query.setParameter(""lastModifiedTime"", actionBean.getLastModifiedTimestamp());
			 query.setParameter(""id"", actionBean.getId());
			 break;
			 case UPDATE_COORD_ACTION_RERUN: query.setParameter(""actionXml"", actionBean.getActionXmlBlob());
			 query.setParameter(""status"", actionBean.getStatusStr());
			 query.setParameter(""externalId"", actionBean.getExternalId());
			 query.setParameter(""externalStatus"", actionBean.getExternalStatus());
			 query.setParameter(""rerunTime"", actionBean.getRerunTimestamp());
			 query.setParameter(""lastModifiedTime"", actionBean.getLastModifiedTimestamp());
			 query.setParameter(""createdTime"", actionBean.getCreatedTimestamp());
			 query.setParameter(""createdConf"", actionBean.getCreatedConfBlob());
			 query.setParameter(""runConf"", actionBean.getRunConfBlob());
			 query.setParameter(""missingDependencies"", actionBean.getMissingDependenciesBlob());
			 query.setParameter(""pushMissingDependencies"", actionBean.getPushMissingDependenciesBlob());
			 query.setParameter(""errorCode"", actionBean.getErrorCode());
			 query.setParameter(""errorMessage"", actionBean.getErrorMessage());
			 query.setParameter(""id"", actionBean.getId());
			 break;
			 default: throw new JPAExecutorException(ErrorCode.E0603, ""QueryExecutor cannot set parameters for "" + namedQuery.name());
		 }
		 return query;
	 }
	 public Query getSelectQuery(CoordActionQuery namedQuery, EntityManager em, Object... parameters) throws JPAExecutorException {
		 Query query = em.createNamedQuery(namedQuery.name());
		 CoordActionQuery caQuery = (CoordActionQuery) namedQuery;
		 switch (caQuery) {
			 case GET_COORD_ACTION: case GET_COORD_ACTION_STATUS: case GET_COORD_ACTION_FOR_SLA: case GET_COORD_ACTION_FOR_INPUTCHECK: query.setParameter(""id"", parameters[0]);
			 break;
			 case GET_COORD_ACTIONS_BY_LAST_MODIFIED_TIME: query.setParameter(""lastModifiedTime"", new Timestamp(((Date) parameters[0]).getTime()));
			 break;
			 case GET_COORD_ACTIONS_STATUS_UNIGNORED: query.setParameter(""jobId"", parameters[0]);
			 break;
			 case GET_COORD_ACTIONS_PENDING_COUNT: query.setParameter(""jobId"", parameters[0]);
			 break;
			 case GET_ACTIVE_ACTIONS_IDS_FOR_SLA_CHANGE: query.setParameter(""ids"", parameters[0]);
			 break;
			 case GET_ACTIVE_ACTIONS_JOBID_FOR_SLA_CHANGE: query.setParameter(""jobId"", parameters[0]);
			 break;
			 case GET_TERMINATED_ACTIONS_FOR_DATES: case GET_TERMINATED_ACTION_IDS_FOR_DATES: case GET_ACTIVE_ACTIONS_FOR_DATES: query.setParameter(""jobId"", parameters[0]);
			 query.setParameter(""startTime"", new Timestamp(((Date) parameters[1]).getTime()));
			 query.setParameter(""endTime"", new Timestamp(((Date) parameters[2]).getTime()));
			 break;
			 case GET_COORD_ACTIONS_FOR_RECOVERY_OLDER_THAN: query.setParameter(""lastModifiedTime"", new Timestamp(((Date) parameters[0]).getTime()));
			 break;
			 case GET_COORD_ACTIONS_WAITING_READY_SUBMITTED_OLDER_THAN: query.setParameter(""lastModifiedTime"", new Timestamp(((Date) parameters[0]).getTime()));
			 query.setParameter(""currentTime"", new Timestamp(new Date().getTime()));
			 break;
			 default: throw new JPAExecutorException(ErrorCode.E0603, ""QueryExecutor cannot set parameters for "" + caQuery.name());
		 }
		 return query;
	 }
	 public int executeUpdate(CoordActionQuery namedQuery, CoordinatorActionBean jobBean) throws JPAExecutorException {
		 JPAService jpaService = Services.get().get(JPAService.class);
		 EntityManager em = jpaService.getEntityManager();
		 Query query = getUpdateQuery(namedQuery, jobBean, em);
		 int ret = jpaService.executeUpdate(namedQuery.name(), query, em);
		 return ret;
	 }
	 public CoordinatorActionBean get(CoordActionQuery namedQuery, Object... parameters) throws JPAExecutorException {
		 CoordinatorActionBean bean = getIfExist(namedQuery, parameters);
		 if (bean == null) {
			 throw new JPAExecutorException(ErrorCode.E0605, getSelectQuery(namedQuery, Services.get().get(JPAService.class).getEntityManager(), parameters).toString());
		 }
		 return bean;
	 }
	 public CoordinatorActionBean getIfExist(CoordActionQuery namedQuery, Object... parameters) throws JPAExecutorException {
		 JPAService jpaService = Services.get().get(JPAService.class);
		 EntityManager em = jpaService.getEntityManager();
		 Query query = getSelectQuery(namedQuery, em, parameters);
		 Object ret = jpaService.executeGet(namedQuery.name(), query, em);
		 if (ret == null) {
			 return null;
		 }
		 CoordinatorActionBean bean = constructBean(namedQuery, ret);
		 return bean;
	 }
	 public List<CoordinatorActionBean> getList(CoordActionQuery namedQuery, Object... parameters) throws JPAExecutorException {
		 JPAService jpaService = Services.get().get(JPAService.class);
		 EntityManager em = jpaService.getEntityManager();
		 Query query = getSelectQuery(namedQuery, em, parameters);
		 List<?> retList = (List<?>) jpaService.executeGetList(namedQuery.name(), query, em);
		 List<CoordinatorActionBean> beanList = new ArrayList<CoordinatorActionBean>();
		 if (retList != null) {
			 for (Object ret : retList) {
				 beanList.add(constructBean(namedQuery, ret));
			 }
		 }
		 return beanList;
	 }
	 private CoordinatorActionBean constructBean(CoordActionQuery namedQuery, Object ret) throws JPAExecutorException {
		 CoordinatorActionBean bean;
		 Object[] arr;
		 switch (namedQuery) {
			 case GET_COORD_ACTION: bean = (CoordinatorActionBean) ret;
			 break;
			 case GET_COORD_ACTIONS_BY_LAST_MODIFIED_TIME: bean = new CoordinatorActionBean();
			 bean.setJobId((String) ret);
			 break;
			 case GET_COORD_ACTION_STATUS: bean = new CoordinatorActionBean();
			 bean.setStatusStr((String)ret);
			 break;
			 case GET_COORD_ACTIONS_STATUS_UNIGNORED: arr = (Object[]) ret;
			 bean = new CoordinatorActionBean();
			 bean.setStatusStr((String)arr[0]);
			 bean.setPending((Integer)arr[1]);
			 break;
			 case GET_ACTIVE_ACTIONS_IDS_FOR_SLA_CHANGE: case GET_ACTIVE_ACTIONS_JOBID_FOR_SLA_CHANGE: arr = (Object[]) ret;
			 bean = new CoordinatorActionBean();
			 bean.setId((String)arr[0]);
			 bean.setNominalTime((Timestamp)arr[1]);
			 bean.setCreatedTime((Timestamp)arr[2]);
			 bean.setActionXmlBlob((StringBlob)arr[3]);
			 break;
			 case GET_TERMINATED_ACTIONS_FOR_DATES: bean = (CoordinatorActionBean) ret;
			 break;
			 case GET_TERMINATED_ACTION_IDS_FOR_DATES: bean = new CoordinatorActionBean();
			 bean.setId((String) ret);
			 break;
			 case GET_ACTIVE_ACTIONS_FOR_DATES: arr = (Object[]) ret;
			 bean = new CoordinatorActionBean();
			 bean.setId((String)arr[0]);
			 bean.setJobId((String)arr[1]);
			 bean.setStatusStr((String) arr[2]);
			 bean.setExternalId((String) arr[3]);
			 bean.setPending((Integer) arr[4]);
			 bean.setNominalTime((Timestamp) arr[5]);
			 bean.setCreatedTime((Timestamp) arr[6]);
			 break;
			 case GET_COORD_ACTIONS_FOR_RECOVERY_OLDER_THAN: arr = (Object[]) ret;
			 bean = new CoordinatorActionBean();
			 bean.setId((String)arr[0]);
			 bean.setJobId((String)arr[1]);
			 bean.setStatusStr((String) arr[2]);
			 bean.setExternalId((String) arr[3]);
			 bean.setPending((Integer) arr[4]);
			 break;
			 case GET_COORD_ACTIONS_WAITING_READY_SUBMITTED_OLDER_THAN: arr = (Object[]) ret;
			 bean = new CoordinatorActionBean();
			 bean.setId((String)arr[0]);
			 bean.setJobId((String)arr[1]);
			 bean.setStatusStr((String) arr[2]);
			 bean.setExternalId((String) arr[3]);
			 bean.setPushMissingDependenciesBlob((StringBlob) arr[4]);
			 break;
			 case GET_COORD_ACTION_FOR_SLA: arr = (Object[]) ret;
			 bean = new CoordinatorActionBean();
			 bean.setId((String) arr[0]);
			 bean.setJobId((String) arr[1]);
			 bean.setStatusStr((String) arr[2]);
			 bean.setExternalId((String) arr[3]);
			 bean.setLastModifiedTime((Timestamp) arr[4]);
			 break;
			 case GET_COORD_ACTION_FOR_INPUTCHECK: arr = (Object[]) ret;
			 bean = new CoordinatorActionBean();
			 bean.setId((String) arr[0]);
			 bean.setActionNumber((Integer) arr[1]);
			 bean.setJobId((String) arr[2]);
			 bean.setStatus(CoordinatorAction.Status.valueOf((String) arr[3]));
			 bean.setRunConfBlob((StringBlob) arr[4]);
			 bean.setNominalTime(DateUtils.toDate((Timestamp) arr[5]));
			 bean.setCreatedTime(DateUtils.toDate((Timestamp) arr[6]));
			 bean.setActionXmlBlob((StringBlob) arr[7]);
			 bean.setMissingDependenciesBlob((StringBlob) arr[8]);
			 bean.setPushMissingDependenciesBlob((StringBlob) arr[9]);
			 bean.setTimeOut((Integer) arr[10]);
			 bean.setExternalId((String) arr[11]);
			 break;
			 default: throw new JPAExecutorException(ErrorCode.E0603, ""QueryExecutor cannot construct action bean for "" + namedQuery.name());
		 }
		 return bean;
	 }
	 public Object getSingleValue(CoordActionQuery namedQuery, Object... parameters) throws JPAExecutorException {
		 JPAService jpaService = Services.get().get(JPAService.class);
		 EntityManager em = jpaService.getEntityManager();
		 Query query = getSelectQuery(namedQuery, em, parameters);
		 Object ret = jpaService.executeGet(namedQuery.name(), query, em);
		 if (ret == null) {
			 throw new JPAExecutorException(ErrorCode.E0604, query.toString());
		 }
		 return ret;
	 }
}",1,0,0,0
"final public void disable_tracing() {
 }",0,0,0,0
"public class Context{
	 public static final int VERSION_UNKNOWN = -1;
	 public static final int VERSION_DEFAULT = 0;
	 public static final int VERSION_1_0 = 100;
	 public static final int VERSION_1_1 = 110;
	 public static final int VERSION_1_2 = 120;
	 public static final int VERSION_1_3 = 130;
	 public static final int VERSION_1_4 = 140;
	 public static final int VERSION_1_5 = 150;
	 public static final int VERSION_1_6 = 160;
	 public static final int FEATURE_NON_ECMA_GET_YEAR = 1;
	 public static final int FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME = 2;
	 public static final int FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER = 3;
	 public static final int FEATURE_TO_STRING_AS_SOURCE = 4;
	 public static final int FEATURE_PARENT_PROTO_PROPERTIES = 5;
	 public static final int FEATURE_PARENT_PROTO_PROPRTIES = 5;
	 public static final int FEATURE_E4X = 6;
	 public static final int FEATURE_DYNAMIC_SCOPE = 7;
	 public static final int FEATURE_STRICT_VARS = 8;
	 public static final int FEATURE_STRICT_EVAL = 9;
	 public static final int FEATURE_LOCATION_INFORMATION_IN_ERROR = 10;
	 public static final int FEATURE_STRICT_MODE = 11;
	 public static final int FEATURE_WARNING_AS_ERROR = 12;
	 public static final String languageVersionProperty = ""language version"";
	 public static final String errorReporterProperty = ""error reporter"";
	 public static final Object[] emptyArgs = ScriptRuntime.emptyArgs;
	 public Context() {
		 setLanguageVersion(VERSION_DEFAULT);
		 optimizationLevel = codegenClass != null ? 0 : -1;
		 maximumInterpreterStackDepth = Integer.MAX_VALUE;
	 }
	 public static Context getCurrentContext() {
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 return VMBridge.instance.getContext(helper);
	 }
	 public static Context enter() {
		 return enter(null);
	 }
	 public static Context enter(Context cx) {
		 return enter(cx, ContextFactory.getGlobal());
	 }
	 static final Context enter(Context cx, ContextFactory factory) {
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 Context old = VMBridge.instance.getContext(helper);
		 if (old != null) {
			 if (cx != null && cx != old && cx.enterCount != 0) {
				 throw new IllegalArgumentException( ""Cannot enter Context active on another thread"");
			 }
			 if (old.factory != null) {
				 return old;
			 }
			 if (old.sealed) onSealedMutation();
			 cx = old;
		 }
		 else {
			 if (cx == null) {
				 cx = factory.makeContext();
			 }
			 else {
				 if (cx.sealed) onSealedMutation();
			 }
			 if (cx.enterCount != 0 || cx.factory != null) {
				 throw new IllegalStateException();
			 }
			 if (!cx.creationEventWasSent) {
				 cx.creationEventWasSent = true;
				 factory.onContextCreated(cx);
			 }
		 }
		 if (old == null) {
			 VMBridge.instance.setContext(helper, cx);
		 }
		 ++cx.enterCount;
		 return cx;
	 }
	 public static void exit() {
		 exit(ContextFactory.getGlobal());
	 }
	 static void exit(ContextFactory factory) {
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 Context cx = VMBridge.instance.getContext(helper);
		 if (cx == null) {
			 throw new IllegalStateException( ""Calling Context.exit without previous Context.enter"");
		 }
		 if (cx.factory != null) {
			 return;
		 }
		 if (cx.enterCount < 1) Kit.codeBug();
		 if (cx.sealed) onSealedMutation();
		 --cx.enterCount;
		 if (cx.enterCount == 0) {
			 VMBridge.instance.setContext(helper, null);
			 factory.onContextReleased(cx);
		 }
	 }
	 public static Object call(ContextAction action) {
		 return call(ContextFactory.getGlobal(), action);
	 }
	 public static Object call(ContextFactory factory, Callable callable, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (factory == null) {
			 factory = ContextFactory.getGlobal();
		 }
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 Context cx = VMBridge.instance.getContext(helper);
		 if (cx != null) {
			 Object result;
			 if (cx.factory != null) {
				 result = callable.call(cx, scope, thisObj, args);
			 }
			 else {
				 cx.factory = factory;
				 try {
					 result = callable.call(cx, scope, thisObj, args);
				 }
				 finally {
					 cx.factory = null;
				 }
			 }
			 return result;
		 }
		 cx = prepareNewContext(factory, helper);
		 try {
			 return callable.call(cx, scope, thisObj, args);
		 }
		 finally {
			 releaseContext(helper, cx);
		 }
	 }
	 static Object call(ContextFactory factory, ContextAction action) {
		 Object helper = VMBridge.instance.getThreadContextHelper();
		 Context cx = VMBridge.instance.getContext(helper);
		 if (cx != null) {
			 if (cx.factory != null) {
				 return action.run(cx);
			 }
			 else {
				 cx.factory = factory;
				 try {
					 return action.run(cx);
				 }
				 finally {
					 cx.factory = null;
				 }
			 }
		 }
		 cx = prepareNewContext(factory, helper);
		 try {
			 return action.run(cx);
		 }
		 finally {
			 releaseContext(helper, cx);
		 }
	 }
	 private static Context prepareNewContext(ContextFactory factory, Object contextHelper) {
		 Context cx = factory.makeContext();
		 if (cx.factory != null || cx.enterCount != 0) {
			 throw new IllegalStateException(""factory.makeContext() returned Context instance already associated with some thread"");
		 }
		 cx.factory = factory;
		 factory.onContextCreated(cx);
		 if (factory.isSealed() && !cx.isSealed()) {
			 cx.seal(null);
		 }
		 VMBridge.instance.setContext(contextHelper, cx);
		 return cx;
	 }
	 private static void releaseContext(Object contextHelper, Context cx) {
		 VMBridge.instance.setContext(contextHelper, null);
		 try {
			 cx.factory.onContextReleased(cx);
		 }
		 finally {
			 cx.factory = null;
		 }
	 }
	 public static void addContextListener(ContextListener listener) {
		 String DBG = ""org.mozilla.javascript.tools.debugger.Main"";
		 if (DBG.equals(listener.getClass().getName())) {
			 Class cl = listener.getClass();
			 Class factoryClass = Kit.classOrNull( ""org.mozilla.javascript.ContextFactory"");
			 Class[] sig = {
			 factoryClass }
			;
			 Object[] args = {
			 ContextFactory.getGlobal() }
			;
			 try {
				 Method m = cl.getMethod(""attachTo"", sig);
				 m.invoke(listener, args);
			 }
			 catch (Exception ex) {
				 RuntimeException rex = new RuntimeException();
				 Kit.initCause(rex, ex);
				 throw rex;
			 }
			 return;
		 }
		 ContextFactory.getGlobal().addListener(listener);
	 }
	 public static void removeContextListener(ContextListener listener) {
		 ContextFactory.getGlobal().addListener(listener);
	 }
	 public final ContextFactory getFactory() {
		 ContextFactory result = factory;
		 if (result == null) {
			 result = ContextFactory.getGlobal();
		 }
		 return result;
	 }
	 public final boolean isSealed() {
		 return sealed;
	 }
	 public final void seal(Object sealKey) {
		 if (sealed) onSealedMutation();
		 sealed = true;
		 this.sealKey = sealKey;
	 }
	 public final void unseal(Object sealKey) {
		 if (sealKey == null) throw new IllegalArgumentException();
		 if (this.sealKey != sealKey) throw new IllegalArgumentException();
		 if (!sealed) throw new IllegalStateException();
		 sealed = false;
		 this.sealKey = null;
	 }
	 static void onSealedMutation() {
		 throw new IllegalStateException();
	 }
	 public final int getLanguageVersion() {
		 return version;
	 }
	 public void setLanguageVersion(int version) {
		 if (sealed) onSealedMutation();
		 checkLanguageVersion(version);
		 Object listeners = propertyListeners;
		 if (listeners != null && version != this.version) {
			 firePropertyChangeImpl(listeners, languageVersionProperty, new Integer(this.version), new Integer(version));
		 }
		 this.version = version;
	 }
	 public static boolean isValidLanguageVersion(int version) {
		 switch (version) {
			 case VERSION_DEFAULT: case VERSION_1_0: case VERSION_1_1: case VERSION_1_2: case VERSION_1_3: case VERSION_1_4: case VERSION_1_5: case VERSION_1_6: return true;
		 }
		 return false;
	 }
	 public static void checkLanguageVersion(int version) {
		 if (isValidLanguageVersion(version)) {
			 return;
		 }
		 throw new IllegalArgumentException(""Bad language version: ""+version);
	 }
	 public final String getImplementationVersion() {
		 if (implementationVersion == null) {
			 implementationVersion = ScriptRuntime.getMessage0(""implementation.version"");
		 }
		 return implementationVersion;
	 }
	 public final ErrorReporter getErrorReporter() {
		 if (errorReporter == null) {
			 return DefaultErrorReporter.instance;
		 }
		 return errorReporter;
	 }
	 public final ErrorReporter setErrorReporter(ErrorReporter reporter) {
		 if (sealed) onSealedMutation();
		 if (reporter == null) throw new IllegalArgumentException();
		 ErrorReporter old = getErrorReporter();
		 if (reporter == old) {
			 return old;
		 }
		 Object listeners = propertyListeners;
		 if (listeners != null) {
			 firePropertyChangeImpl(listeners, errorReporterProperty, old, reporter);
		 }
		 this.errorReporter = reporter;
		 return old;
	 }
	 public final Locale getLocale() {
		 if (locale == null) locale = Locale.getDefault();
		 return locale;
	 }
	 public final Locale setLocale(Locale loc) {
		 if (sealed) onSealedMutation();
		 Locale result = locale;
		 locale = loc;
		 return result;
	 }
	 public final void addPropertyChangeListener(PropertyChangeListener l) {
		 if (sealed) onSealedMutation();
		 propertyListeners = Kit.addListener(propertyListeners, l);
	 }
	 public final void removePropertyChangeListener(PropertyChangeListener l) {
		 if (sealed) onSealedMutation();
		 propertyListeners = Kit.removeListener(propertyListeners, l);
	 }
	 final void firePropertyChange(String property, Object oldValue, Object newValue) {
		 Object listeners = propertyListeners;
		 if (listeners != null) {
			 firePropertyChangeImpl(listeners, property, oldValue, newValue);
		 }
	 }
	 private void firePropertyChangeImpl(Object listeners, String property, Object oldValue, Object newValue) {
		 for (int i = 0;
		 ;
		 ++i) {
			 Object l = Kit.getListener(listeners, i);
			 if (l == null) break;
			 if (l instanceof PropertyChangeListener) {
				 PropertyChangeListener pcl = (PropertyChangeListener)l;
				 pcl.propertyChange(new PropertyChangeEvent( this, property, oldValue, newValue));
			 }
		 }
	 }
	 public static void reportWarning(String message, String sourceName, int lineno, String lineSource, int lineOffset) {
		 Context cx = Context.getContext();
		 if (cx.hasFeature(FEATURE_WARNING_AS_ERROR)) reportError(message, sourceName, lineno, lineSource, lineOffset);
		 else cx.getErrorReporter().warning(message, sourceName, lineno, lineSource, lineOffset);
	 }
	 public static void reportWarning(String message) {
		 int[] linep = {
		 0 }
		;
		 String filename = getSourcePositionFromStack(linep);
		 Context.reportWarning(message, filename, linep[0], null, 0);
	 }
	 public static void reportWarning(String message, Throwable t) {
		 int[] linep = {
		 0 }
		;
		 String filename = getSourcePositionFromStack(linep);
		 Writer sw = new StringWriter();
		 PrintWriter pw = new PrintWriter(sw);
		 pw.println(message);
		 t.printStackTrace(pw);
		 pw.flush();
		 Context.reportWarning(sw.toString(), filename, linep[0], null, 0);
	 }
	 public static void reportError(String message, String sourceName, int lineno, String lineSource, int lineOffset) {
		 Context cx = getCurrentContext();
		 if (cx != null) {
			 cx.getErrorReporter().error(message, sourceName, lineno, lineSource, lineOffset);
		 }
		 else {
			 throw new EvaluatorException(message, sourceName, lineno, lineSource, lineOffset);
		 }
	 }
	 public static void reportError(String message) {
		 int[] linep = {
		 0 }
		;
		 String filename = getSourcePositionFromStack(linep);
		 Context.reportError(message, filename, linep[0], null, 0);
	 }
	 public static EvaluatorException reportRuntimeError(String message, String sourceName, int lineno, String lineSource, int lineOffset) {
		 Context cx = getCurrentContext();
		 if (cx != null) {
			 return cx.getErrorReporter(). runtimeError(message, sourceName, lineno, lineSource, lineOffset);
		 }
		 else {
			 throw new EvaluatorException(message, sourceName, lineno, lineSource, lineOffset);
		 }
	 }
	 static EvaluatorException reportRuntimeError0(String messageId) {
		 String msg = ScriptRuntime.getMessage0(messageId);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError1(String messageId, Object arg1) {
		 String msg = ScriptRuntime.getMessage1(messageId, arg1);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError2(String messageId, Object arg1, Object arg2) {
		 String msg = ScriptRuntime.getMessage2(messageId, arg1, arg2);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError3(String messageId, Object arg1, Object arg2, Object arg3) {
		 String msg = ScriptRuntime.getMessage3(messageId, arg1, arg2, arg3);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError4(String messageId, Object arg1, Object arg2, Object arg3, Object arg4) {
		 String msg = ScriptRuntime.getMessage4(messageId, arg1, arg2, arg3, arg4);
		 return reportRuntimeError(msg);
	 }
	 public static EvaluatorException reportRuntimeError(String message) {
		 int[] linep = {
		 0 }
		;
		 String filename = getSourcePositionFromStack(linep);
		 return Context.reportRuntimeError(message, filename, linep[0], null, 0);
	 }
	 public final ScriptableObject initStandardObjects() {
		 return initStandardObjects(null, false);
	 }
	 public final Scriptable initStandardObjects(ScriptableObject scope) {
		 return initStandardObjects(scope, false);
	 }
	 public ScriptableObject initStandardObjects(ScriptableObject scope, boolean sealed) {
		 return ScriptRuntime.initStandardObjects(this, scope, sealed);
	 }
	 public static Object getUndefinedValue() {
		 return Undefined.instance;
	 }
	 public final Object evaluateString(Scriptable scope, String source, String sourceName, int lineno, Object securityDomain) {
		 Script script = compileString(source, sourceName, lineno, securityDomain);
		 if (script != null) {
			 return script.exec(this, scope);
		 }
		 else {
			 return null;
		 }
	 }
	 public final Object evaluateReader(Scriptable scope, Reader in, String sourceName, int lineno, Object securityDomain) throws IOException {
		 Script script = compileReader(scope, in, sourceName, lineno, securityDomain);
		 if (script != null) {
			 return script.exec(this, scope);
		 }
		 else {
			 return null;
		 }
	 }
	 public final boolean stringIsCompilableUnit(String source) {
		 boolean errorseen = false;
		 CompilerEnvirons compilerEnv = new CompilerEnvirons();
		 compilerEnv.initFromContext(this);
		 compilerEnv.setGeneratingSource(false);
		 Parser p = new Parser(compilerEnv, DefaultErrorReporter.instance);
		 try {
			 p.parse(source, null, 1);
		 }
		 catch (EvaluatorException ee) {
			 errorseen = true;
		 }
		 if (errorseen && p.eof()) return false;
		 else return true;
	 }
	 public final Script compileReader(Scriptable scope, Reader in, String sourceName, int lineno, Object securityDomain) throws IOException {
		 return compileReader(in, sourceName, lineno, securityDomain);
	 }
	 public final Script compileReader(Reader in, String sourceName, int lineno, Object securityDomain) throws IOException {
		 if (lineno < 0) {
			 lineno = 0;
		 }
		 return (Script) compileImpl(null, in, null, sourceName, lineno, securityDomain, false, null, null);
	 }
	 public final Script compileString(String source, String sourceName, int lineno, Object securityDomain) {
		 if (lineno < 0) {
			 lineno = 0;
		 }
		 return compileString(source, null, null, sourceName, lineno, securityDomain);
	 }
	 final Script compileString(String source, Interpreter compiler, ErrorReporter compilationErrorReporter, String sourceName, int lineno, Object securityDomain) {
		 try {
			 return (Script) compileImpl(null, null, source, sourceName, lineno, securityDomain, false, compiler, compilationErrorReporter);
		 }
		 catch (IOException ex) {
			 throw new RuntimeException();
		 }
	 }
	 public final Function compileFunction(Scriptable scope, String source, String sourceName, int lineno, Object securityDomain) {
		 return compileFunction(scope, source, null, null, sourceName, lineno, securityDomain);
	 }
	 final Function compileFunction(Scriptable scope, String source, Interpreter compiler, ErrorReporter compilationErrorReporter, String sourceName, int lineno, Object securityDomain) {
		 try {
			 return (Function) compileImpl(scope, null, source, sourceName, lineno, securityDomain, true, compiler, compilationErrorReporter);
		 }
		 catch (IOException ioe) {
			 throw new RuntimeException();
		 }
	 }
	 public final String decompileScript(Script script, int indent) {
		 NativeFunction scriptImpl = (NativeFunction) script;
		 return scriptImpl.decompile(indent, 0);
	 }
	 public final String decompileFunction(Function fun, int indent) {
		 if (fun instanceof BaseFunction) return ((BaseFunction)fun).decompile(indent, 0);
		 else return ""function "" + fun.getClassName() + ""() {
		\n\t[native code]\n}
		\n"";
	 }
	 public final String decompileFunctionBody(Function fun, int indent) {
		 if (fun instanceof BaseFunction) {
			 BaseFunction bf = (BaseFunction)fun;
			 return bf.decompile(indent, Decompiler.ONLY_BODY_FLAG);
		 }
		 return ""[native code]\n"";
	 }
	 public final Scriptable newObject(Scriptable scope) {
		 return newObject(scope, ""Object"", ScriptRuntime.emptyArgs);
	 }
	 public final Scriptable newObject(Scriptable scope, String constructorName) {
		 return newObject(scope, constructorName, ScriptRuntime.emptyArgs);
	 }
	 public final Scriptable newObject(Scriptable scope, String constructorName, Object[] args) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 Function ctor = ScriptRuntime.getExistingCtor(this, scope, constructorName);
		 if (args == null) {
			 args = ScriptRuntime.emptyArgs;
		 }
		 return ctor.construct(this, scope, args);
	 }
	 public final Scriptable newArray(Scriptable scope, int length) {
		 NativeArray result = new NativeArray(length);
		 ScriptRuntime.setObjectProtoAndParent(result, scope);
		 return result;
	 }
	 public final Scriptable newArray(Scriptable scope, Object[] elements) {
		 if (elements.getClass().getComponentType() != ScriptRuntime.ObjectClass) throw new IllegalArgumentException();
		 NativeArray result = new NativeArray(elements);
		 ScriptRuntime.setObjectProtoAndParent(result, scope);
		 return result;
	 }
	 public final Object[] getElements(Scriptable object) {
		 return ScriptRuntime.getArrayElements(object);
	 }
	 public static boolean toBoolean(Object value) {
		 return ScriptRuntime.toBoolean(value);
	 }
	 public static double toNumber(Object value) {
		 return ScriptRuntime.toNumber(value);
	 }
	 public static String toString(Object value) {
		 return ScriptRuntime.toString(value);
	 }
	 public static Scriptable toObject(Object value, Scriptable scope) {
		 return ScriptRuntime.toObject(scope, value);
	 }
	 public static Scriptable toObject(Object value, Scriptable scope, Class staticType) {
		 return ScriptRuntime.toObject(scope, value);
	 }
	 public static Object javaToJS(Object value, Scriptable scope) {
		 if (value instanceof String || value instanceof Number || value instanceof Boolean || value instanceof Scriptable) {
			 return value;
		 }
		 else if (value instanceof Character) {
			 return String.valueOf(((Character)value).charValue());
		 }
		 else {
			 Context cx = Context.getContext();
			 return cx.getWrapFactory().wrap(cx, scope, value, null);
		 }
	 }
	 public static Object jsToJava(Object value, Class desiredType) throws EvaluatorException {
		 return NativeJavaObject.coerceTypeImpl(desiredType, value);
	 }
	 public static Object toType(Object value, Class desiredType) throws IllegalArgumentException {
		 try {
			 return jsToJava(value, desiredType);
		 }
		 catch (EvaluatorException ex) {
			 IllegalArgumentException ex2 = new IllegalArgumentException(ex.getMessage());
			 Kit.initCause(ex2, ex);
			 throw ex2;
		 }
	 }
	 public static RuntimeException throwAsScriptRuntimeEx(Throwable e) {
		 while ((e instanceof InvocationTargetException)) {
			 e = ((InvocationTargetException) e).getTargetException();
		 }
		 if (e instanceof Error) {
			 throw (Error)e;
		 }
		 if (e instanceof RhinoException) {
			 throw (RhinoException)e;
		 }
		 throw new WrappedException(e);
	 }
	 public final boolean isGeneratingDebug() {
		 return generatingDebug;
	 }
	 public final void setGeneratingDebug(boolean generatingDebug) {
		 if (sealed) onSealedMutation();
		 generatingDebugChanged = true;
		 if (generatingDebug && getOptimizationLevel() > 0) setOptimizationLevel(0);
		 this.generatingDebug = generatingDebug;
	 }
	 public final boolean isGeneratingSource() {
		 return generatingSource;
	 }
	 public final void setGeneratingSource(boolean generatingSource) {
		 if (sealed) onSealedMutation();
		 this.generatingSource = generatingSource;
	 }
	 public final int getOptimizationLevel() {
		 return optimizationLevel;
	 }
	 public final void setOptimizationLevel(int optimizationLevel) {
		 if (sealed) onSealedMutation();
		 if (optimizationLevel == -2) {
			 optimizationLevel = -1;
		 }
		 checkOptimizationLevel(optimizationLevel);
		 if (codegenClass == null) optimizationLevel = -1;
		 this.optimizationLevel = optimizationLevel;
	 }
	 public static boolean isValidOptimizationLevel(int optimizationLevel) {
		 return -1 <= optimizationLevel && optimizationLevel <= 9;
	 }
	 public static void checkOptimizationLevel(int optimizationLevel) {
		 if (isValidOptimizationLevel(optimizationLevel)) {
			 return;
		 }
		 throw new IllegalArgumentException( ""Optimization level outside [-1..9]: ""+optimizationLevel);
	 }
	 public final int getMaximumInterpreterStackDepth() {
		 return maximumInterpreterStackDepth;
	 }
	 public final void setMaximumInterpreterStackDepth(int max) {
		 if(sealed) onSealedMutation();
		 if(optimizationLevel != -1) {
			 throw new IllegalStateException(""Cannot set maximumInterpreterStackDepth when optimizationLevel != -1"");
		 }
		 if(max < 1) {
			 throw new IllegalArgumentException(""Cannot set maximumInterpreterStackDepth to less than 1"");
		 }
		 maximumInterpreterStackDepth = max;
	 }
	 public final void setSecurityController(SecurityController controller) {
		 if (sealed) onSealedMutation();
		 if (controller == null) throw new IllegalArgumentException();
		 if (securityController != null) {
			 throw new SecurityException(""Can not overwrite existing SecurityController object"");
		 }
		 if (SecurityController.hasGlobal()) {
			 throw new SecurityException(""Can not overwrite existing global SecurityController object"");
		 }
		 securityController = controller;
	 }
	 public final void setClassShutter(ClassShutter shutter) {
		 if (sealed) onSealedMutation();
		 if (shutter == null) throw new IllegalArgumentException();
		 if (classShutter != null) {
			 throw new SecurityException(""Cannot overwrite existing "" + ""ClassShutter object"");
		 }
		 classShutter = shutter;
	 }
	 final ClassShutter getClassShutter() {
		 return classShutter;
	 }
	 public final Object getThreadLocal(Object key) {
		 if (hashtable == null) return null;
		 return hashtable.get(key);
	 }
	 public final void putThreadLocal(Object key, Object value) {
		 if (sealed) onSealedMutation();
		 if (hashtable == null) hashtable = new Hashtable();
		 hashtable.put(key, value);
	 }
	 public final void removeThreadLocal(Object key) {
		 if (sealed) onSealedMutation();
		 if (hashtable == null) return;
		 hashtable.remove(key);
	 }
	 public final boolean hasCompileFunctionsWithDynamicScope() {
		 return compileFunctionsWithDynamicScopeFlag;
	 }
	 public final void setCompileFunctionsWithDynamicScope(boolean flag) {
		 if (sealed) onSealedMutation();
		 compileFunctionsWithDynamicScopeFlag = flag;
	 }
	 public static void setCachingEnabled(boolean cachingEnabled) {
	 }
	 public final void setWrapFactory(WrapFactory wrapFactory) {
		 if (sealed) onSealedMutation();
		 if (wrapFactory == null) throw new IllegalArgumentException();
		 this.wrapFactory = wrapFactory;
	 }
	 public final WrapFactory getWrapFactory() {
		 if (wrapFactory == null) {
			 wrapFactory = new WrapFactory();
		 }
		 return wrapFactory;
	 }
	 public final Debugger getDebugger() {
		 return debugger;
	 }
	 public final Object getDebuggerContextData() {
		 return debuggerData;
	 }
	 public final void setDebugger(Debugger debugger, Object contextData) {
		 if (sealed) onSealedMutation();
		 this.debugger = debugger;
		 debuggerData = contextData;
	 }
	 public static DebuggableScript getDebuggableView(Script script) {
		 if (script instanceof NativeFunction) {
			 return ((NativeFunction)script).getDebuggableView();
		 }
		 return null;
	 }
	 public boolean hasFeature(int featureIndex) {
		 ContextFactory f = getFactory();
		 return f.hasFeature(this, featureIndex);
	 }
	public XMLLib.Factory getE4xImplementationFactory() {
		return getFactory().getE4xImplementationFactory();
	}
	 public final int getInstructionObserverThreshold() {
		 return instructionThreshold;
	 }
	 public final void setInstructionObserverThreshold(int threshold) {
		 if (sealed) onSealedMutation();
		 if (threshold < 0) throw new IllegalArgumentException();
		 instructionThreshold = threshold;
	 }
	 protected void observeInstructionCount(int instructionCount) {
		 ContextFactory f = getFactory();
		 f.observeInstructionCount(this, instructionCount);
	 }
	 public GeneratedClassLoader createClassLoader(ClassLoader parent) {
		 ContextFactory f = getFactory();
		 return f.createClassLoader(parent);
	 }
	 public final ClassLoader getApplicationClassLoader() {
		 if (applicationClassLoader == null) {
			 ContextFactory f = getFactory();
			 ClassLoader loader = f.getApplicationClassLoader();
			 if (loader == null) {
				 ClassLoader threadLoader = VMBridge.instance.getCurrentThreadClassLoader();
				 if (threadLoader != null && Kit.testIfCanLoadRhinoClasses(threadLoader)) {
					 return threadLoader;
				 }
				 Class fClass = f.getClass();
				 if (fClass != ScriptRuntime.ContextFactoryClass) {
					 loader = fClass.getClassLoader();
				 }
				 else {
					 loader = getClass().getClassLoader();
				 }
			 }
			 applicationClassLoader = loader;
		 }
		 return applicationClassLoader;
	 }
	 public final void setApplicationClassLoader(ClassLoader loader) {
		 if (sealed) onSealedMutation();
		 if (loader == null) {
			 applicationClassLoader = null;
			 return;
		 }
		 if (!Kit.testIfCanLoadRhinoClasses(loader)) {
			 throw new IllegalArgumentException( ""Loader can not resolve Rhino classes"");
		 }
		 applicationClassLoader = loader;
	 }
	 static Context getContext() {
		 Context cx = getCurrentContext();
		 if (cx == null) {
			 throw new RuntimeException( ""No Context associated with current Thread"");
		 }
		 return cx;
	 }
	 private Object compileImpl(Scriptable scope, Reader sourceReader, String sourceString, String sourceName, int lineno, Object securityDomain, boolean returnFunction, Interpreter compiler, ErrorReporter compilationErrorReporter) throws IOException {
		 if (securityDomain != null && securityController == null) {
			 throw new IllegalArgumentException( ""securityDomain should be null if setSecurityController() was never called"");
		 }
		 if (!(sourceReader == null ^ sourceString == null)) Kit.codeBug();
		 if (!(scope == null ^ returnFunction)) Kit.codeBug();
		 CompilerEnvirons compilerEnv = new CompilerEnvirons();
		 compilerEnv.initFromContext(this);
		 if (compilationErrorReporter == null) {
			 compilationErrorReporter = compilerEnv.getErrorReporter();
		 }
		 if (debugger != null) {
			 if (sourceReader != null) {
				 sourceString = Kit.readReader(sourceReader);
				 sourceReader = null;
			 }
		 }
		 Parser p = new Parser(compilerEnv, compilationErrorReporter);
		 if (returnFunction) {
			 p.calledByCompileFunction = true;
		 }
		 ScriptOrFnNode tree;
		 if (sourceString != null) {
			 tree = p.parse(sourceString, sourceName, lineno);
		 }
		 else {
			 tree = p.parse(sourceReader, sourceName, lineno);
		 }
		 if (returnFunction) {
			 if (!(tree.getFunctionCount() == 1 && tree.getFirstChild() != null && tree.getFirstChild().getType() == Token.FUNCTION)) {
				 throw new IllegalArgumentException( ""compileFunction only accepts source with single JS function: ""+sourceString);
			 }
		 }
		 if (compiler == null) {
			 compiler = createCompiler();
		 }
		 String encodedSource = p.getEncodedSource();
		 Object bytecode = compiler.compile(compilerEnv, tree, encodedSource, returnFunction);
		 if (debugger != null) {
			 if (sourceString == null) Kit.codeBug();
			 if (bytecode instanceof DebuggableScript) {
				 DebuggableScript dscript = (DebuggableScript)bytecode;
				 notifyDebugger_r(this, dscript, sourceString);
			 }
			 else {
				 throw new RuntimeException(""NOT SUPPORTED"");
			 }
		 }
		 Object result;
		 if (returnFunction) {
			 result = compiler.createFunctionObject(this, scope, bytecode, securityDomain);
		 }
		 else {
			 result = compiler.createScriptObject(bytecode, securityDomain);
		 }
		 return result;
	 }
	 private static void notifyDebugger_r(Context cx, DebuggableScript dscript, String debugSource) {
		 cx.debugger.handleCompilationDone(cx, dscript, debugSource);
		 for (int i = 0;
		 i != dscript.getFunctionCount();
		 ++i) {
			 notifyDebugger_r(cx, dscript.getFunction(i), debugSource);
		 }
	 }
	 private static Class codegenClass = Kit.classOrNull( ""org.mozilla.javascript.optimizer.Codegen"");
	 private Interpreter createCompiler() {
		 Interpreter result = null;
		 if (optimizationLevel >= 0 && codegenClass != null) {
			 result = (Interpreter)Kit.newInstanceOrNull(codegenClass);
		 }
		 if (result == null) {
			 result = new Interpreter();
		 }
		 return result;
	 }
	 static String getSourcePositionFromStack(int[] linep) {
		 Context cx = getCurrentContext();
		 if (cx == null) return null;
		 if (cx.lastInterpreterFrame != null) {
			 return Interpreter.getSourcePositionFromStack(cx, linep);
		 }
		 CharArrayWriter writer = new CharArrayWriter();
		 RuntimeException re = new RuntimeException();
		 re.printStackTrace(new PrintWriter(writer));
		 String s = writer.toString();
		 int open = -1;
		 int close = -1;
		 int colon = -1;
		 for (int i=0;
		 i < s.length();
		 i++) {
			 char c = s.charAt(i);
			 if (c == ':') colon = i;
			 else if (c == '(') open = i;
			 else if (c == ')') close = i;
			 else if (c == '\n' && open != -1 && close != -1 && colon != -1 && open < colon && colon < close) {
				 String fileStr = s.substring(open + 1, colon);
				 if (!fileStr.endsWith("".java"")) {
					 String lineStr = s.substring(colon + 1, close);
					 try {
						 linep[0] = Integer.parseInt(lineStr);
						 if (linep[0] < 0) {
							 linep[0] = 0;
						 }
						 return fileStr;
					 }
					 catch (NumberFormatException e) {
					 }
				 }
				 open = close = colon = -1;
			 }
		 }
		 return null;
	 }
	 RegExpProxy getRegExpProxy() {
		 if (regExpProxy == null) {
			 Class cl = Kit.classOrNull( ""org.mozilla.javascript.regexp.RegExpImpl"");
			 if (cl != null) {
				 regExpProxy = (RegExpProxy)Kit.newInstanceOrNull(cl);
			 }
		 }
		 return regExpProxy;
	 }
	 final boolean isVersionECMA1() {
		 return version == VERSION_DEFAULT || version >= VERSION_1_3;
	 }
	 SecurityController getSecurityController() {
		 SecurityController global = SecurityController.global();
		 if (global != null) {
			 return global;
		 }
		 return securityController;
	 }
	 public final boolean isGeneratingDebugChanged() {
		 return generatingDebugChanged;
	 }
	 public void addActivationName(String name) {
		 if (sealed) onSealedMutation();
		 if (activationNames == null) activationNames = new Hashtable(5);
		 activationNames.put(name, name);
	 }
	 public final boolean isActivationNeeded(String name) {
		 return activationNames != null && activationNames.containsKey(name);
	 }
	 public void removeActivationName(String name) {
		 if (sealed) onSealedMutation();
		 if (activationNames != null) activationNames.remove(name);
	 }
	 private static String implementationVersion;
	 private ContextFactory factory;
	 private boolean sealed;
	 private Object sealKey;
	 Scriptable topCallScope;
	 NativeCall currentActivationCall;
	 XMLLib cachedXMLLib;
	 ObjToIntMap iterating;
	 Object interpreterSecurityDomain;
	 int version;
	 private SecurityController securityController;
	 private ClassShutter classShutter;
	 private ErrorReporter errorReporter;
	 RegExpProxy regExpProxy;
	 private Locale locale;
	 private boolean generatingDebug;
	 private boolean generatingDebugChanged;
	 private boolean generatingSource=true;
	 boolean compileFunctionsWithDynamicScopeFlag;
	 boolean useDynamicScope;
	 private int optimizationLevel;
	 private int maximumInterpreterStackDepth;
	 private WrapFactory wrapFactory;
	 Debugger debugger;
	 private Object debuggerData;
	 private int enterCount;
	 private Object propertyListeners;
	 private Hashtable hashtable;
	 private ClassLoader applicationClassLoader;
	 private boolean creationEventWasSent;
	 Hashtable activationNames;
	 Object lastInterpreterFrame;
	 ObjArray previousInterpreterInvocations;
	 int instructionCount;
	 int instructionThreshold;
	 int scratchIndex;
	 long scratchUint32;
	 Scriptable scratchScriptable;
}",1,0,0,0
"public class ServerFormatListPDU extends BaseElement {
	 protected ClipboardState state;
	 public ServerFormatListPDU(String id, ClipboardState state) {
		 super(id);
		 this.state = state;
	 }
	 public void handleData(ByteBuffer buf, Link link) {
		 if (verbose) System.out.println(""["" + this + ""] INFO: Data received: "" + buf + ""."");
		 parseFormatNames(buf);
		 buf.unref();
		 ClipboardDataFormat textFormat = ClipboardDataFormat.findBestTextFormat(state.serverClipboardDataFormats);
		 if (textFormat != null) {
			 sendFormatListParseResponse(true);
			 sendFormatDataRequest(textFormat);
		 }
		 else {
			 sendFormatListParseResponse(false);
		 }
	 }
	 protected void sendFormatDataRequest(ClipboardDataFormat textFormat) {
		 if (verbose) System.out.println(""["" + this + ""] INFO: Sending request for data in following format: "" + textFormat + ""."");
		 state.serverRequestedFormat = textFormat;
		 ByteBuffer buf = new ByteBuffer(12, true);
		 buf.writeShortLE(ServerClipRdrChannelRouter.CB_FORMAT_DATA_REQUEST);
		 buf.writeShortLE(0);
		 buf.writeIntLE(4);
		 buf.writeIntLE(textFormat.id);
		 buf.trimAtCursor();
		 pushDataToPad(STDOUT, buf);
	 }
	 protected void sendFormatListParseResponse(boolean ok) {
		 ByteBuffer buf = new ByteBuffer(8, true);
		 buf.writeShortLE(ServerClipRdrChannelRouter.CB_FORMAT_LIST_RESPONSE);
		 buf.writeShortLE((ok) ? ServerClipRdrChannelRouter.CB_RESPONSE_OK : ServerClipRdrChannelRouter.CB_RESPONSE_FAIL);
		 buf.writeIntLE(0);
		 buf.trimAtCursor();
		 pushDataToPad(STDOUT, buf);
	 }
	 protected void parseFormatNames(ByteBuffer buf) {
		 Map<Object, ClipboardDataFormat> formats = new HashMap<Object, ClipboardDataFormat>();
		 while (buf.cursor < buf.length) {
			 int id = buf.readSignedIntLE();
			 String name;
			 if (state.serverUseLongFormatNames) {
				 name = buf.readVariableWideString(RdpConstants.CHARSET_16);
			 }
			 else {
				 Boolean asciiNames = (Boolean)buf.getMetadata(ServerClipRdrChannelRouter.ASCII_NAMES);
				 if (asciiNames != null && asciiNames) {
					 name = buf.readString(32, RdpConstants.CHARSET_8);
				 }
				 else {
					 name = buf.readString(32, RdpConstants.CHARSET_16);
				 }
			 }
			 formats.put(id, new ClipboardDataFormat(id, name));
			 if (name.length() > 0) formats.put(name, new ClipboardDataFormat(id, name));
		 }
		 if (verbose) System.out.println(""Server supports following formats for clipboard data: "" + formats.values().toString() + ""."");
		 state.serverClipboardDataFormats = formats;
	 }
	 public static void main(String[] args) {
		 System.setProperty(""streamer.Element.debug"", ""true"");
		 byte[] packet = new byte[] {
		 0x02, 0x00, 0x00, 0x00, (byte) 0xe0, 0x00, 0x00, 0x00, (byte) 0x8a, (byte) 0xc0, 0x00, 0x00, 0x52, 0x00, 0x69, 0x00, 0x63, 0x00, 0x68, 0x00, 0x20, 0x00, 0x54, 0x00, 0x65, 0x00, 0x78, 0x00, 0x74, 0x00, 0x20, 0x00, 0x46, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x74, 0x00, 0x00, 0x00, 0x45, (byte) 0xc1, 0x00, 0x00, 0x52, 0x00, 0x69, 0x00, 0x63, 0x00, 0x68, 0x00, 0x20, 0x00, 0x54, 0x00, 0x65, 0x00, 0x78, 0x00, 0x74, 0x00, 0x20, 0x00, 0x46, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x74, 0x00, 0x20, 0x00, 0x57, 0x00, 0x69, 0x00, 0x74, 0x00, 0x68, 0x00, 0x6f, 0x00, 0x75, 0x00, 0x74, 0x00, 0x20, 0x00, 0x4f, 0x00, 0x62, 0x00, 0x6a, 0x00, 0x65, 0x00, 0x63, 0x00, 0x74, 0x00, 0x73, 0x00, 0x00, 0x00, 0x43, (byte) 0xc1, 0x00, 0x00, 0x52, 0x00, 0x54, 0x00, 0x46, 0x00, 0x20, 0x00, 0x41, 0x00, 0x73, 0x00, 0x20, 0x00, 0x54, 0x00, 0x65, 0x00, 0x78, 0x00, 0x74, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, (byte) 0xc0, 0x00, 0x00, 0x4e, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x00, 0x00, 0x0e, (byte) 0xc0, 0x00, 0x00, 0x4f, 0x00, 0x62, 0x00, 0x6a, 0x00, 0x65, 0x00, 0x63, 0x00, 0x74, 0x00, 0x20, 0x00, 0x44, 0x00, 0x65, 0x00, 0x73, 0x00, 0x63, 0x00, 0x72, 0x00, 0x69, 0x00, 0x70, 0x00, 0x74, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, }
		;
		 MockSource source = new MockSource(""source"", ByteBuffer.convertByteArraysToByteBuffers(packet));
		 Element router = new ServerClipRdrChannelRouter(""router"");
		 ClipboardState state = new ClipboardState();
		 state.serverUseLongFormatNames = true;
		 Element format_list = new ServerFormatListPDU(""format_list"", state);
		 Element sink = new MockSink(""sink"", ByteBuffer.convertByteArraysToByteBuffers(new byte[] {
		 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, }
		, new byte[] {
		 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, }
		));
		 Pipeline pipeline = new PipelineImpl(""test"");
		 pipeline.add(source, router, format_list, sink);
		 pipeline.link(""source"", ""router >format_list"", ""format_list"", ""sink"");
		 pipeline.runMainLoop(""source"", STDOUT, false, false);
		 if (!(state.serverClipboardDataFormats.containsKey(49475) && state.serverClipboardDataFormats.containsKey(""Rich Text Format""))) throw new RuntimeException(""Server format list packet parsed incorrectly."");
	 }
}",1,0,0,0
"public void loadFolder(boolean pConnectStore) throws OperationCancelledException {
	 if (cache == null) {
		 try {
			 this.cache = new SimpleFileCache(this, getCacheDirectory());
			 type = type | Folder.HOLDS_MESSAGES;
			 setStatus(DISCONNECTED);
		 }
		 catch (java.io.IOException ioe) {
			 System.out.println(""Error creating cache!"");
			 ioe.printStackTrace();
			 return;
		 }
	 }
	 if (isLoaded() || (loading && children == null)) return;
	 Folder[] tmpFolder = null;
	 Folder tmpParentFolder;
	 try {
		 loading = true;
		 if (getParentStore().isConnected()) {
			 if (getParentFolder() == null) {
				 try {
					 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, Thread.currentThread() + ""loading folder "" + getFolderID() + "": checking parent store connection."");
					 Store store = getParentStore().getStore();
					 try {
						 if (getLogger().isLoggable(Level.FINE)) {
							 getLogger().log(Level.FINE, ""checking to see if "" + getFolderID() + "" is a shared folder."");
						 }
						 Folder[] sharedFolders = store.getSharedNamespaces();
						 if (sharedFolders != null && sharedFolders.length > 0) {
							 for (int i = 0;
							 ( tmpFolder == null || tmpFolder.length == 0 ) && i < sharedFolders.length;
							 i++) {
								 if (sharedFolders[i].getName().equalsIgnoreCase(getFolderName())) {
									 if (!mNamespace) {
										 Pooka.setProperty(getFolderID() + ""._namespace"", ""true"");
										 mNamespace = true;
									 }
									 tmpFolder = new Folder[1];
									 tmpFolder[0] = sharedFolders[i] ;
								 }
							 }
						 }
					 }
					 catch (Exception e) {
					 }
					 if (tmpFolder == null || tmpFolder.length == 0) {
						 tmpParentFolder = store.getDefaultFolder();
						 if (getLogger().isLoggable(Level.FINE)) {
							 getLogger().log(Level.FINE, ""got "" + tmpParentFolder + "" as Default Folder for store."");
							 getLogger().log(Level.FINE, ""doing a list on default folder "" + tmpParentFolder + "" for folder "" + getFolderName());
						 }
						 tmpFolder = tmpParentFolder.list(getFolderName());
					 }
					 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""got "" + tmpFolder + "" as Folder for folder "" + getFolderID() + ""."");
				 }
				 catch (MessagingException me) {
					 me.printStackTrace();
					 if (getLogger().isLoggable(Level.FINE)) {
						 getLogger().log(Level.FINE, Thread.currentThread() + ""loading folder "" + getFolderID() + "": caught messaging exception from parentStore getting folder: "" + me);
						 me.printStackTrace();
					 }
					 tmpFolder =null;
				 }
			 }
			 else {
				 if (!getParentFolder().isLoaded()) getParentFolder().loadFolder();
				 if (!getParentFolder().isLoaded()) {
					 tmpFolder = null;
				 }
				 else {
					 tmpParentFolder = getParentFolder().getFolder();
					 if (tmpParentFolder != null) {
						 tmpFolder = tmpParentFolder.list(getFolderName());
					 }
					 else {
						 tmpFolder = null;
					 }
				 }
			 }
			 if (tmpFolder != null && tmpFolder.length > 0) {
				 setFolder(tmpFolder[0]);
				 if (! getFolder().isSubscribed()) getFolder().setSubscribed(true);
				 setStatus(CLOSED);
				 getFolder().addMessageChangedListener(this);
			 }
			 else {
				 if (cache != null) setStatus(CACHE_ONLY);
				 else setStatus(INVALID);
				 setFolder(new FolderProxy(getFolderName()));
			 }
		 }
		 else {
			 setFolder(new FolderProxy(getFolderName()));
		 }
	 }
	 catch (MessagingException me) {
		 if (getLogger().isLoggable(Level.FINE)) {
			 getLogger().log(Level.FINE, Thread.currentThread() + ""loading folder "" + getFolderID() + "": caught messaging exception;
			 setting loaded to false: "" + me.getMessage() );
			 me.printStackTrace();
		 }
		 setStatus(NOT_LOADED);
		 setFolder(new FolderProxy(getFolderName()));
	 }
	 finally {
		 initializeFolderInfo();
		 loading = false;
	 }
 }",0,0,1,0
"final class Arguments extends IdScriptableObject{
	 static final long serialVersionUID = 4275508002492040609L;
	 public Arguments(NativeCall activation) {
		 this.activation = activation;
		 Scriptable parent = activation.getParentScope();
		 setParentScope(parent);
		 setPrototype(ScriptableObject.getObjectPrototype(parent));
		 args = activation.originalArgs;
		 lengthObj = new Integer(args.length);
		 NativeFunction f = activation.function;
		 calleeObj = f;
		 int version = f.getLanguageVersion();
		 if (version <= Context.VERSION_1_3 && version != Context.VERSION_DEFAULT) {
			 callerObj = null;
		 }
		 else {
			 callerObj = NOT_FOUND;
		 }
	 }
	 public String getClassName() {
		 return ""Arguments"";
	 }
	 public boolean has(int index, Scriptable start) {
		 if (0 <= index && index < args.length) {
			 if (args[index] != NOT_FOUND) {
				 return true;
			 }
		 }
		 return super.has(index, start);
	 }
	 public Object get(int index, Scriptable start) {
		 if (0 <= index && index < args.length) {
			 Object value = args[index];
			 if (value != NOT_FOUND) {
				 if (sharedWithActivation(index)) {
					 NativeFunction f = activation.function;
					 String argName = f.getParamOrVarName(index);
					 value = activation.get(argName, activation);
					 if (value == NOT_FOUND) Kit.codeBug();
				 }
				 return value;
			 }
		 }
		 return super.get(index, start);
	 }
	 private boolean sharedWithActivation(int index) {
		 NativeFunction f = activation.function;
		 int definedCount = f.getParamCount();
		 if (index < definedCount) {
			 if (index < definedCount - 1) {
				 String argName = f.getParamOrVarName(index);
				 for (int i = index + 1;
				 i < definedCount;
				 i++) {
					 if (argName.equals(f.getParamOrVarName(i))) {
						 return false;
					 }
				 }
			 }
			 return true;
		 }
		 return false;
	 }
	 public void put(int index, Scriptable start, Object value) {
		 if (0 <= index && index < args.length) {
			 if (args[index] != NOT_FOUND) {
				 if (sharedWithActivation(index)) {
					 String argName;
					 argName = activation.function.getParamOrVarName(index);
					 activation.put(argName, activation, value);
					 return;
				 }
				 synchronized (this) {
					 if (args[index] != NOT_FOUND) {
						 if (args == activation.originalArgs) {
							 args = (Object[])args.clone();
						 }
						 args[index] = value;
						 return;
					 }
				 }
			 }
		 }
		 super.put(index, start, value);
	 }
	 public void delete(int index) {
		 if (0 <= index && index < args.length) {
			 synchronized (this) {
				 if (args[index] != NOT_FOUND) {
					 if (args == activation.originalArgs) {
						 args = (Object[])args.clone();
					 }
					 args[index] = NOT_FOUND;
					 return;
				 }
			 }
		 }
		 super.delete(index);
	 }
	 private static final int Id_callee = 1, Id_length = 2, Id_caller = 3, MAX_INSTANCE_ID = 3;
	 protected int getMaxInstanceId() {
		 return MAX_INSTANCE_ID;
	 }
	 protected int findInstanceIdInfo(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 if (s.length()==6) {
				 c=s.charAt(5);
				 if (c=='e') {
					 X=""callee"";
					id=Id_callee;
				 }
				 else if (c=='h') {
					 X=""length"";
					id=Id_length;
				 }
				 else if (c=='r') {
					 X=""caller"";
					id=Id_caller;
				 }
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
			 break L0;
		 }
		 if (id == 0) return super.findInstanceIdInfo(s);
		 int attr;
		 switch (id) {
			 case Id_callee: case Id_caller: case Id_length: attr = DONTENUM;
			 break;
			 default: throw new IllegalStateException();
		 }
		 return instanceIdInfo(attr, id);
	 }
	 protected String getInstanceIdName(int id) {
		 switch (id) {
			 case Id_callee: return ""callee"";
			 case Id_length: return ""length"";
			 case Id_caller: return ""caller"";
		 }
		 return null;
	 }
	 protected Object getInstanceIdValue(int id) {
		 switch (id) {
			 case Id_callee: return calleeObj;
			 case Id_length: return lengthObj;
			 case Id_caller: {
				 Object value = callerObj;
				 if (value == UniqueTag.NULL_VALUE) {
					 value = null;
				 }
				 else if (value == null) {
					 NativeCall caller = activation.parentActivationCall;
					 if (caller != null) {
						 value = caller.get(""arguments"", caller);
					 }
				 }
				 return value;
			 }
		 }
		 return super.getInstanceIdValue(id);
	 }
	 protected void setInstanceIdValue(int id, Object value) {
		 switch (id) {
			 case Id_callee: calleeObj = value;
			 return;
			 case Id_length: lengthObj = value;
			 return;
			 case Id_caller: callerObj = (value != null) ? value : UniqueTag.NULL_VALUE;
			 return;
		 }
		 super.setInstanceIdValue(id, value);
	 }
	 Object[] getIds(boolean getAll) {
		 Object[] ids = super.getIds(getAll);
		 if (getAll && args.length != 0) {
			 boolean[] present = null;
			 int extraCount = args.length;
			 for (int i = 0;
			 i != ids.length;
			 ++i) {
				 Object id = ids[i];
				 if (id instanceof Integer) {
					 int index = ((Integer)id).intValue();
					 if (0 <= index && index < args.length) {
						 if (present == null) {
							 present = new boolean[args.length];
						 }
						 if (!present[index]) {
							 present[index] = true;
							 extraCount--;
						 }
					 }
				 }
			 }
			 if (extraCount != 0) {
				 Object[] tmp = new Object[extraCount + ids.length];
				 System.arraycopy(ids, 0, tmp, extraCount, ids.length);
				 ids = tmp;
				 int offset = 0;
				 for (int i = 0;
				 i != args.length;
				 ++i) {
					 if (present == null || !present[i]) {
						 ids[offset] = new Integer(i);
						 ++offset;
					 }
				 }
				 if (offset != extraCount) Kit.codeBug();
			 }
		 }
		 return ids;
	 }
	 private Object callerObj;
	 private Object calleeObj;
	 private Object lengthObj;
	 private NativeCall activation;
	 private Object[] args;
}",0,0,0,0
"public class InvalidStateTransitionException extends Exception {
	 private Enum<?> currentState;
	 private Enum<?> event;
	 public InvalidStateTransitionException(Enum<?> currentState, Enum<?> event) {
		 super(""Invalid event: "" + event + "" at "" + currentState);
		 this.currentState = currentState;
		 this.event = event;
	 }
	 public Enum<?> getCurrentState() {
		 return currentState;
	 }
	 public Enum<?> getEvent() {
		 return event;
	 }
}",0,1,0,0
"public class BuildProperties extends AbstractProperties {
	 public BuildProperties(PropertiesAccessor accessor) {
		 super(accessor);
	 }
	 public Map<String, String> getAllProps() {
		 return accessor.getBuildProperties();
	 }
}",0,1,0,0
"public class TestParamSubPreproc {
	 private final Log log = LogFactory.getLog(getClass());
	 private BufferedReader pigIStream;
	 private FileWriter pigOStream;
	 private FileInputStream pigExResultStream;
	 private String basedir = ""test/org/apache/pig/test/data"";
	 private void compareResults(InputStream expected, InputStream result) throws IOException {
		 BufferedReader inExpected = new BufferedReader(new InputStreamReader(expected));
		 BufferedReader inResult = new BufferedReader(new InputStreamReader(result));
		 String exLine;
		 String resLine;
		 int lineNum=0;
		 while (true) {
			 lineNum++;
			 exLine = inExpected.readLine();
			 resLine = inResult.readLine();
			 if (exLine==null || resLine==null) break;
			 assertEquals(""Command line parameter substitution failed. "" + ""Expected : ""+exLine+"" , but got : ""+resLine+"" in line num : ""+lineNum ,exLine.trim(), resLine.trim());
		 }
		 if (!(exLine==null && resLine==null)) {
			 fail (""Command line parameter substitution failed. "" + ""Expected : ""+exLine+"" , but got : ""+resLine+"" in line num : ""+lineNum);
		 }
		 inExpected.close();
		 inResult.close();
	 }
	 public void testCmdlineParam() throws Exception{
		 log.info(""Starting test testCmdlineParam() ..."");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input1.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date=20080228""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testFileParam() throws Exception{
		 log.info (""Starting test testFileParam()"");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input1.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = {
		basedir+""/ConfFile1.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testShellCommand() throws Exception{
		 log.info(""Starting test testShellCommand()"");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = WithConditionalReplacement(basedir + ""/input4.pig"", ""sh test/org/apache/pig/test/data/generate_date.sh"", ""test/org/apache/pig/test/data/generate_date.bat"", Shell.WINDOWS);
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResultDefault.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testPigParamNotResolved() throws Exception{
		 log.info(""Starting test testPigParamNotResolved()"");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input3.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = null;
		 try {
			 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 }
		 catch (RuntimeException e) {
			 if (e.getMessage().equals(""Undefined parameter : 4"")) {
				 fail(""Pig supported parameter $4 should not have been resolved."");
			 }
		 }
		 log.info(""Done"");
	 }
	 public void testUndefinedParam() throws Exception{
		 log.info(""Starting test testUndefinedParam()"");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input2.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = null;
		 try {
			 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
			 fail (""Should have thrown an Undefined parameter exception"");
		 }
		 catch (ParseException e) {
			 assertEquals(e.getMessage(), ""Undefined parameter : param"");
		 }
		 log.info(""Done"");
	 }
	 public void testSubstitutionWithinValue() throws Exception{
		 log.info(""Starting test testSubstitutionWithinValue()"");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputSubstitutionWithinValue.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = {
		basedir+""/ConfFile1.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult4.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testSubstitutionWithinShellCommand() throws Exception{
		 log.info(""Starting test testSubstitutionWithinShellCommand()"");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = WithConditionalReplacement(basedir + ""/inputSubstitutionWithinShellCommand.pig"", ""sh test/org/apache/pig/test/data/generate_date.sh"", ""test/org/apache/pig/test/data/generate_date.bat"", Shell.WINDOWS);
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult4.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testCmdlineParamPriortoDeclare() throws Exception{
		 log.info(""Starting test testCmdlineParamPriortoDeclare()"");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input2.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""param='20080228'""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResultCmdLnPriorDeclare.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testCmdnameAsParamDeclare() throws Exception{
		 log.info(""Starting test testCmdnameAsParamDeclare()"");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = WithConditionalReplacement(basedir + ""/inputCmdnameAsParamDeclare.pig"", ""sh \\$cmd.sh \\$date"", ""\\$cmd.bat \\$date"", Shell.WINDOWS);
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult4.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testMultipleCmdlineParam() throws Exception{
		 log.info(""Starting test testCmdnameAsParamDeclare()"");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input1.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date='092487'"",""date='20080228'""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testFileParamsFromMultipleFiles() throws Exception{
		 log.info(""Starting test testFileParamsFromMultipleFiles()"");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputMultipleParams.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = {
		basedir+""/ConfFile1.txt"" , basedir+""/ConfFile2.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testSameParamInMultipleFiles() throws Exception{
		 log.info(""Starting test testSameParamInMultipleFiles()"");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputMultipleParams.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = {
		basedir+""/ConfFile3.txt"" , basedir+""/ConfFile2.txt"", basedir+""/ConfFile1.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testMultipleParamsFromSingleFile() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input1.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = {
		basedir+""/ConfFileSameParamMultipleTimes.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
	 }
	 public void testEmptyCommentLineinConfigfile() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input1.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = {
		basedir+""/ConfFileWithEmptyComments.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
	 }
	 public void testInvalidLineinConfigfile() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input1.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = {
		basedir+""/ConfFileWithInvalidLines.txt""}
		;
		 try {
			 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
			 fail (""Should have thrown an exception"");
		 }
		 catch (ParseException e) {
			 assertTrue(e.getMessage().startsWith(""Encountered \"" <IDENTIFIER> \""is \""\"" at line 2, column 6.""));
		 }
	 }
	 public void testValidLinesinConfigfile() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputMultipleParams.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = {
		basedir+""/ConfFileWithValidLines.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
	 }
	 public void testCmdlineFileCombo() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputMultipleParams.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date='20080228'""}
		;
		 String[] argFiles = {
		basedir+""/ConfFile2.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
	 }
	 public void testCmdlineFileComboDuplicate() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputMultipleParams.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date='20080228'""}
		;
		 String[] argFiles = {
		basedir+""/ConfFileDuplicates.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
	 }
	 public void testCmdlineFileDeclareCombo() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputThreeParams.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date='20080228'""}
		;
		 String[] argFiles = {
		basedir+""/ConfFile2.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
	 }
	 public void testCmdlineFileDeclareComboDuplicates() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputThreeParams.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date='20080228'"" , ""tableName=\""skip this\""""}
		;
		 String[] argFiles = {
		basedir+""/ConfFile2.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
	 }
	 public void testMultipleDeclareScope() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputMultipleDeclares.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date='20080228'""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResultMulDecs.pig"");
		 compareResults(pigExResultStream, pigResultStream);
	 }
	 public void testDefaultParam() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputDefault.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
	 }
	 public void testCmdlineFileDeclareDefaultComboDuplicates() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputThreeParams.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date='20080228'"" , ""tableName=\""skip this\""""}
		;
		 String[] argFiles = {
		basedir+""/ConfFile2.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
	 }
	 public void testMultipleParamsinSingleLine() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputThreeParams.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date='20080228'""}
		;
		 String[] argFiles = {
		basedir+""/ConfFile2.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
	 }
	 public void testSubstituteWithinLiteral() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input1.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date='20080228'""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
	 }
	 public void testEscaping() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputEscape.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date='20080228'""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult2.pig"");
		 compareResults(pigExResultStream, pigResultStream);
	 }
	 public void testCmdlineParamWithInlineCmd() throws Exception{
		 log.info(""Starting test testCmdlineParamWithInlineCmd() ..."");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input1.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date=`perl -e \""print qq\\n20070101@\"" | head -n 1`""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testNoVars() throws Exception{
		 log.info(""Starting test testNoVars() ..."");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputNoVars.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = null;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/inputNoVars.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testComplexVals() throws Exception{
		 log.info(""Starting test testComplexVals() ..."");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input5.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""loadfile = /user/pig/tests/data/singlefile/textdoc.txt""}
		;
		 String[] argFiles = {
		basedir+""/ConfFileComplexVal.txt""}
		;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult3.txt"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testCommentWithParam() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputComment.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date='20080228'""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResultComment.pig"");
		 compareResults(pigExResultStream, pigResultStream);
	 }
	 public void testSubstitutionInFuncArgs() throws Exception{
		 log.info(""Starting test testSubstitutionInFuncArgs()"");
		 final String queryString = "" avro = LOAD '/data/part-m-00000.avro' USING PigStorage ();
		\n"" + "" avro2 = FOREACH avro GENERATE browser_id, component_version, "" + ""member_id, page_key, session_id, tracking_time, type;
		\n"" + "" fs -rmr testOut/out1;
		\n"" + "" STORE avro2 INTO 'testOut/out2'\n"" + "" USING PigStorage (\n"" + "" ' {
			\n"" + "" \""debug\"": $debug,\n"" + "" \""schema\"":\n"" + "" {
				 \""type\"":\""record\"",\""name\"":\""$name\"", \n"" + "" \""fields\"": [ {
				\""name\"":\""browser_id\"", \""type\"":[\""null\"",\""string\""]}
				, \n"" + "" {
				\""name\"":\""component_version\"",\""type\"":\""int\""}
				,\n"" + "" {
				\""name\"":\""member_id\"",\""type\"":\""int\""}
				,\n"" + "" {
				\""name\"":\""page_key\"",\""type\"":[\""null\"",\""string\""]}
				,\n"" + "" {
				\""name\"":\""session_id\"",\""type\"":\""long\""}
				,\n"" + "" {
				\""name\"":\""tracking_time\"",\""type\"":\""long\""}
				,\n"" + "" {
				\""name\"":\""type\"",\""type\"":[\""null\"",\""string\""]}
			\n"" + "" ]\n"" + "" }
		\n"" + "" }
		\n""+ "" ');
		"";
		 final String expectedString = "" avro = LOAD '/data/part-m-00000.avro' USING PigStorage ();
		\n"" + "" avro2 = FOREACH avro GENERATE browser_id, component_version, "" + ""member_id, page_key, session_id, tracking_time, type;
		\n"" + "" fs -rmr testOut/out1;
		\n"" + "" STORE avro2 INTO 'testOut/out2'\n"" + "" USING PigStorage (\n"" + "" ' {
			\n"" + "" \""debug\"": 5,\n"" + "" \""schema\"":\n"" + "" {
				 \""type\"":\""record\"",\""name\"":\""TestRecord\"", \n"" + "" \""fields\"": [ {
				\""name\"":\""browser_id\"", \""type\"":[\""null\"",\""string\""]}
				, \n"" + "" {
				\""name\"":\""component_version\"",\""type\"":\""int\""}
				,\n"" + "" {
				\""name\"":\""member_id\"",\""type\"":\""int\""}
				,\n"" + "" {
				\""name\"":\""page_key\"",\""type\"":[\""null\"",\""string\""]}
				,\n"" + "" {
				\""name\"":\""session_id\"",\""type\"":\""long\""}
				,\n"" + "" {
				\""name\"":\""tracking_time\"",\""type\"":\""long\""}
				,\n"" + "" {
				\""name\"":\""type\"",\""type\"":[\""null\"",\""string\""]}
			\n"" + "" ]\n"" + "" }
		\n"" + "" }
		\n""+ "" ');
		"";
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader( new InputStreamReader(new ByteArrayInputStream(queryString.getBytes(""UTF-8""))));
		 pigOStream = new FileWriter(basedir + ""/output26.pig"");
		 String[] arg = {
		""debug = '5'"", ""name = 'TestRecord'""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output26.pig"");
		 InputStream expected = new ByteArrayInputStream(expectedString.getBytes(""UTF-8""));
		 compareResults(expected, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testSubstitutionWithDollarSign() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/inputDollarSign.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""filter=\""($0 == 'x') and ($1 == 'y')\""""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResultDollarSign.pig"");
		 compareResults(pigExResultStream, pigResultStream);
	 }
	 public void testMacroDef() throws Exception{
		 log.info(""Starting test testMacroDef() ..."");
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input6.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date=20080228""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult6.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testCmdlineParamCurlySyntax() throws Exception{
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader(new FileReader(basedir + ""/input7.pig""));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""date=20080228""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 pigExResultStream = new FileInputStream(basedir + ""/ExpectedResult7.pig"");
		 compareResults(pigExResultStream, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testGruntWithParamSub() throws Exception{
		 log.info(""Starting test testGruntWithParamSub()"");
		 File inputFile = Util.createFile(new String[]{
		""daniel\t10"",""jenny\t20""}
		);
		 File outputFile = File.createTempFile(""tmp"", """");
		 outputFile.delete();
		 PigContext pc = new PigContext(ExecType.LOCAL, new Properties());
		 String command = ""%default agelimit `echo 15`\n"" + ""rmf $outputFile;
		\n"" + ""a = load '"" + Util.generateURI(inputFile.toString(), pc) + ""' as ($param1:chararray, $param2:int);
		\n"" + ""b = filter a by age > $agelimit;
		"" + ""store b into '$outputFile';
		\n"" + ""quit\n"";
		 System.setProperty(""jline.WindowsTerminal.directConsole"", ""false"");
		 System.setIn(new ByteArrayInputStream(command.getBytes()));
		 org.apache.pig.PigRunner.run(new String[] {
		""-x"", ""local"", ""-p"", ""param1=name"", ""-p"", ""param2=age"", ""-p"", ""outputFile="" + Util.generateURI(outputFile.toString(), pc)}
		, null);
		 File[] partFiles = outputFile.listFiles(new FilenameFilter() {
			 public boolean accept(File dir, String name) {
				 return name.startsWith(""part"");
			 }
		 }
		);
		 String resultContent = Util.readFile(partFiles[0]);
		 assertEquals(resultContent, ""jenny\t20\n"");
	 }
	 public void testGruntMultilineDefine() throws Exception{
		 log.info(""Starting test testGruntMultilineDefine()"");
		 File inputFile = Util.createFile(new String[]{
		""daniel\t10"",""jenny\t20""}
		);
		 File outputFile = File.createTempFile(""tmp"", """");
		 outputFile.delete();
		 PigContext pc = new PigContext(ExecType.LOCAL, new Properties());
		 String command = ""DEFINE process(input_file) returns data {
			\n"" + ""$data = load '$input_file' using PigStorage(',');
		}
		;
		\n"" + ""b = process('"" + Util.generateURI(inputFile.toString(), pc) + ""');
		\n"" + ""store b into '"" + Util.generateURI(outputFile.toString(), pc) + ""';
		"" + ""quit\n"";
		 System.setProperty(""jline.WindowsTerminal.directConsole"", ""false"");
		 System.setIn(new ByteArrayInputStream(command.getBytes()));
		 org.apache.pig.PigRunner.run(new String[] {
		""-x"", ""local""}
		, null);
		 File[] partFiles = outputFile.listFiles(new FilenameFilter() {
			 public boolean accept(File dir, String name) {
				 return name.startsWith(""part"");
			 }
		 }
		);
		 String resultContent = Util.readFile(partFiles[0]);
		 assertEquals(resultContent, ""daniel\t10\njenny\t20\n"");
	 }
	 public void testCommandLineParamOverwritingDefault() throws Exception {
		 log.info(""Starting test testCommandLineParamOverwritingDefault()"");
		 File inputFile = Util.createFile( ""runinput"", new String[] {
			 ""daniel\t10"", ""jenny\t20;
		""}
		);
		 File output1 = File.createTempFile(""output1_"", """");
		 output1.delete();
		 File script1 = Util.createFile(""runscript1.pig"", new String[] {
			 ""%default output /invalidpathThatShouldFail;
			"", ""a = load 'runinput';
			"", ""store a into '$output';
		""}
		);
		 PigStats stats = org.apache.pig.PigRunner.run(new String[] {
		 ""-x"", Util.getLocalTestMode().toString(), ""-p"", ""output="" + output1.getAbsolutePath(), script1.getAbsolutePath()}
		 , null);
		 Util.deleteDirectory(output1);
		 assertTrue(""job should succeed"", stats.isSuccessful());
		 assertTrue(""Default param should be overridden by the commandline param"", output1.getAbsolutePath().endsWith(stats.getOutputNames().get(0)));
	 }
	 public void testRunWithParamOverwritingDefault() throws Exception {
		 log.info(""Starting test testScopeOfParamWithRunCommand()"");
		 File inputFile = Util.createFile( ""runinput"", new String[] {
			 ""daniel\t10"", ""jenny\t20;
		""}
		);
		 File output1 = File.createTempFile(""output1_"", """");
		 File output2 = File.createTempFile(""output2_"", """");
		 output1.delete();
		 output2.delete();
		 File script1 = Util.createFile(""runscript1.pig"", new String[] {
			 ""%default output '"" + output2.getAbsolutePath() + ""';
			"", ""a = load 'runinput';
			"", ""store a into '$output';
		""}
		);
		 File mainscript = Util.createFile(""mainscript.pig"", new String[] {
			""run -param output="" + output1.getAbsolutePath() + "" "" + script1.getAbsolutePath() + "";
		""}
		);
		 PigStats stats = org.apache.pig.PigRunner.run(new String[] {
		 ""-x"", Util.getLocalTestMode().toString(), mainscript.getAbsolutePath()}
		 , null);
		 Util.deleteDirectory(output1);
		 Util.deleteDirectory(output2);
		 assertTrue(""job should succeed"", stats.isSuccessful());
		 assertEquals(""There should only be 1 output."", 1, stats.getOutputNames().size());
		 assertEquals(""Output name should be from output1 and not output2"", output1.getAbsolutePath(), stats.getOutputLocations().get(0));
	 }
	 public void testScopeOfParamWithRunCommand() throws Exception {
		 log.info(""Starting test testScopeOfParamWithRunCommand()"");
		 File inputFile = Util.createFile( ""runinput"", new String[] {
			 ""daniel\t10"", ""jenny\t20;
		""}
		);
		 File output1 = File.createTempFile(""output1_"", """");
		 File output2 = File.createTempFile(""output2_"", """");
		 output1.delete();
		 output2.delete();
		 File script1 = Util.createFile(""runscript1.pig"", new String[] {
			 ""%default output '"" + output1.getAbsolutePath() + ""';
			"", ""a = load 'runinput';
			"", ""store a into '$output';
		""}
		);
		 File script2 = Util.createFile(""runscript2.pig"", new String[] {
			 ""%default output '"" + output2.getAbsolutePath() + ""';
			"", ""a = load 'runinput';
			"", ""store a into '$output';
		""}
		);
		 File mainscript = Util.createFile(""mainscript.pig"", new String[] {
			 ""run "" + script1.getAbsolutePath() + "";
			"", ""run "" + script2.getAbsolutePath() + "";
		"" }
		);
		 PigStats stats = org.apache.pig.PigRunner.run(new String[] {
		 ""-x"", Util.getLocalTestMode().toString(), mainscript.getAbsolutePath()}
		 , null);
		 Util.deleteDirectory(output1);
		 Util.deleteDirectory(output2);
		 assertTrue(""job should succeed"", stats.isSuccessful());
		 assertNotEquals(""Two output paths should differ"", stats.getOutputNames().get(0), stats.getOutputNames().get(1));
		 assertEquals(""Each output should contain 2 records"", 2, stats.getOutputStats().get(0).getNumberRecords());
		 assertEquals(""Each output should contain 2 records"", 2, stats.getOutputStats().get(1).getNumberRecords());
	 }
	 public void testScopeOfParamWithNestedRunCommand() throws Exception {
		 log.info(""Starting test testScopeOfParamWithRunCommand()"");
		 File inputFile = Util.createFile( ""runinput"", new String[] {
			 ""daniel\t10"", ""jenny\t20;
		""}
		);
		 File script3 = Util.createFile(""runscript3.pig"", new String[] {
			 ""%declare c '333';
			"", ""a = load 'runinput';
			"", ""store a into 'testScopeOfParamWithNestedRunCommand${
			a}
			${
			b}
			${
			c}
			';
		""}
		);
		 File script2 = Util.createFile(""runscript2.pig"", new String[] {
			 ""run "" + script3.getAbsolutePath() + "";
			"", ""a = load 'runinput';
			"", ""store a into 'testScopeOfParamWithNestedRunCommand${
			a}
			${
			b}
			${
			c}
			';
		""}
		);
		 File script1 = Util.createFile(""runscript1.pig"", new String[] {
			 ""%declare a '1';
			"", ""%declare b '2';
			"", ""%declare c '3';
			"", ""run -param b=22 "" + script2.getAbsolutePath() + "";
			"", ""a = load 'runinput';
			"", ""store a into 'testScopeOfParamWithNestedRunCommand${
			a}
			${
			b}
			${
			c}
			';
		""}
		);
		 PigStats stats = org.apache.pig.PigRunner.run(new String[] {
		 ""-x"", Util.getLocalTestMode().toString(), script1.getAbsolutePath()}
		 , null);
		 for( String output : stats.getOutputNames() ) {
			 assertTrue(output.contains(""testScopeOfParamWithNestedRunCommand""));
			 Util.deleteDirectory(new File(output));
		 }
		 assertTrue(""job should succeed"", stats.isSuccessful());
		 assertEquals(""There should be three outputs."", 3, stats.getOutputNames().size());
		 for( String expectedoutput : new String [] {
		""testScopeOfParamWithNestedRunCommand123"", ""testScopeOfParamWithNestedRunCommand1223"", ""testScopeOfParamWithNestedRunCommand122333""}
		 ) {
			 boolean found=false;
			 for( String output : stats.getOutputNames() ) {
				 if( output.endsWith(expectedoutput) ) {
					 found=true;
				 }
			 }
			 assertTrue(""Output "" + expectedoutput + "" should exist."", found);
		 }
	 }
	 public void testSubstitutionWithRegisterGlobbing() throws Exception{
		 log.info(""Starting test testSubstitutionWithRegisterGlobbing()"");
		 final String queryString = ""register /abc/$regdir\n"";
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader( new InputStreamReader(new ByteArrayInputStream(queryString.getBytes(""UTF-8""))));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""input = 'input.txt'"", ""output = 'output.txt'"", ""regdir = 'def'""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 String expectedString = queryString.replaceAll(""\\$input"",""input.txt"") .replaceAll(""\\$output"",""output.txt"") .replaceAll(""\\$regdir"",""def"");
		 InputStream expected = new ByteArrayInputStream(expectedString.getBytes(""UTF-8""));
		 compareResults(expected, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testSubstitutionWithLoadGlobbing() throws Exception{
		 log.info(""Starting test testSubstitutionWithLoadGlobbing()"");
		 final String queryString = ""A = LOAD '/zzz\n"";
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader( new InputStreamReader(new ByteArrayInputStream(queryString.getBytes(""UTF-8""))));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""output = 'output.txt'""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 String expectedString = queryString.replaceAll(""\\$output"",""output.txt"");
		 InputStream expected = new ByteArrayInputStream(expectedString.getBytes(""UTF-8""));
		 compareResults(expected, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testSubstitutionWithRedeclaration() throws Exception{
		 log.info(""Starting test testSubstitutionWithRedeclaration()"");
		 final String queryString = ""%declare output '/tmp/abc';
		\n"" + ""%declare actualoutput '$output.out';
		\n"" + ""A = load 'input.txt' ;
		\n"" + ""store A into '$actualoutput';
		\n"" + ""%declare output '/tmp/def';
		\n"" + ""%declare actualoutput '$output.out';
		\n"" + ""store A into '$actualoutput';
		"";
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader( new InputStreamReader(new ByteArrayInputStream(queryString.getBytes(""UTF-8""))));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""output = 'output.txt'""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 FileInputStream pigResultStream = new FileInputStream(basedir + ""/output1.pig"");
		 String expectedString = queryString.replaceAll(""%declare [0-9a-zA-Z.'/\\$;
		 ]*\n"","";
		\n"") .replaceAll(""\\$"","""") .replaceFirst(""actualoutput"",""/tmp/abc.out"") .replaceFirst(""actualoutput"",""/tmp/def.out"");
		 InputStream expected = new ByteArrayInputStream(expectedString.getBytes(""UTF-8""));
		 compareResults(expected, pigResultStream);
		 log.info(""Done"");
	 }
	 public void testSubstitutionWithRedeclaredShell() throws Exception{
		 log.info(""Starting test testSubstitutionWithRedeclaredShell()"");
		 final String queryString = ""A = load 'input.txt' ;
		\n"" + ""%declare now `bash -c \""date +'%Y%m%d_%H:%M:%S';
		 sleep 1;
		\""`;
		\n"" + ""store A into '$now';
		\n"" + ""%declare now `bash -c \""date +'%Y%m%d_%H:%M:%S';
		 sleep 1;
		\""`;
		\n"" + ""store A into '$now';
		\n"";
		 ParameterSubstitutionPreprocessor ps = new ParameterSubstitutionPreprocessor(50);
		 pigIStream = new BufferedReader( new InputStreamReader(new ByteArrayInputStream(queryString.getBytes(""UTF-8""))));
		 pigOStream = new FileWriter(basedir + ""/output1.pig"");
		 String[] arg = {
		""output = 'output.txt'""}
		;
		 String[] argFiles = null;
		 ps.genSubstitutedFile(pigIStream , pigOStream , arg , argFiles);
		 BufferedReader pigresult = new BufferedReader(new InputStreamReader(new FileInputStream(basedir + ""/output1.pig"")));
		 String [] filenames = new String [2];
		 int index=0;
		 String line;
		 while ((line = pigresult.readLine())!=null) {
			 if( line.startsWith(""store A into"") ) {
				 filenames[index++] = line.split("" "")[3];
			 }
		 }
		 assertEquals(""There should be 2 store statements"", 2, index);
		 assertNotEquals(""Identical shell param should be reexecuted."", filenames[0], filenames[1]);
		 log.info(""Done"");
	 }
	 private BufferedReader WithConditionalReplacement(String filename, String orig, String dest, boolean replace) throws IOException {
		 BufferedReader pigOrigIStream = new BufferedReader(new FileReader(filename));
		 BufferedReader result;
		 if (replace) {
			 File tmpInputFile = File.createTempFile(""tmp"", """");
			 PrintWriter tmppw = new PrintWriter(tmpInputFile);
			 String line;
			 while ((line = pigOrigIStream.readLine())!=null) {
				 line = line.replaceAll(orig, dest);
				 tmppw.println(line);
			 }
			 pigOrigIStream.close();
			 tmppw.close();
			 result = new BufferedReader(new FileReader(tmpInputFile));
		 }
		 else {
			 result = pigOrigIStream;
		 }
		 return result;
	 }
}",1,0,0,0
"public class LongType extends AbstractType<Long>{
	 public static final LongType instance = new LongType();
	 LongType() {
	}
	 public Long compose(ByteBuffer bytes) {
		 return JdbcLong.instance.compose(bytes);
	 }
	 public ByteBuffer decompose(Long value) {
		 return JdbcLong.instance.decompose(value);
	 }
	 public int compare(ByteBuffer o1, ByteBuffer o2) {
		 if (o1.remaining() == 0) {
			 return o2.remaining() == 0 ? 0 : -1;
		 }
		 if (o2.remaining() == 0) {
			 return 1;
		 }
		 int diff = o1.get(o1.position()) - o2.get(o2.position());
		 if (diff != 0) return diff;
		 return ByteBufferUtil.compareUnsigned(o1, o2);
	 }
	 public String getString(ByteBuffer bytes) {
		 try {
			 return JdbcLong.instance.getString(bytes);
		 }
		 catch (org.apache.cassandra.cql.jdbc.MarshalException e) {
			 throw new MarshalException(e.getMessage());
		 }
	 }
	 public ByteBuffer fromString(String source) throws MarshalException {
		 if (source.isEmpty()) return ByteBufferUtil.EMPTY_BYTE_BUFFER;
		 long longType;
		 try {
			 longType = Long.parseLong(source);
		 }
		 catch (Exception e) {
			 throw new MarshalException(String.format(""unable to make long from '%s'"", source), e);
		 }
		 return decompose(longType);
	 }
	 public void validate(ByteBuffer bytes) throws MarshalException {
		 if (bytes.remaining() != 8 && bytes.remaining() != 0) throw new MarshalException(String.format(""Expected 8 or 0 byte long (%d)"", bytes.remaining()));
	 }
}",0,0,0,0
"public class CmsPermission {
	 private int stepID;
	 private int channelID;
	 private int permission;
	 public int getStepID() {
		 return stepID;
	 }
	 public void setStepID(int stepID) {
		 this.stepID = stepID;
	 }
	 public int getChannelID() {
		 return channelID;
	 }
	 public void setChannelID(int channelID) {
		 this.channelID = channelID;
	 }
	 public int getPermission() {
		 return permission;
	 }
	 public void setPermission(int permission) {
		 this.permission = permission;
	 }
}",0,1,0,0
"public class ExpiredPageClassRequestTarget extends BookmarkablePageRequestTarget{
	public ExpiredPageClassRequestTarget(){
		super(Application.get().getApplicationSettings().getPageExpiredErrorPage());
	}
}",0,0,0,0
"public final Request getRequest(){
	return request;
}",0,0,0,0
"public ValueEval evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1,ValueEval arg2, ValueEval arg3, ValueEval arg4);",0,0,0,1
"public synchronized boolean isFilesystemOnly() {
	 if (isReference()) {
		 return ((BaseResourceCollectionContainer) getCheckedRef()).isFilesystemOnly();
	 }
	 dieOnCircularReference();
	 if (rc == null || rc.isFilesystemOnly()) {
		 return true;
	 }
	 for (Iterator i = cacheCollection().iterator();
	 i.hasNext();
	) {
		 if (!(i.next() instanceof FileResource)) {
			 return false;
		 }
	 }
	 return true;
 }",0,0,0,0
"final public void DynamicExpression() throws ParseException {
	 AstDynamicExpression jjtn000 = new AstDynamicExpression(JJTDYNAMICEXPRESSION);
	 boolean jjtc000 = true;
	 jjtree.openNodeScope(jjtn000);
	 try {
		 jj_consume_token(START_DYNAMIC_EXPRESSION);
		 Expression();
		 jj_consume_token(RBRACE);
	 }
	 catch (Throwable jjte000) {
		 if (jjtc000) {
			 jjtree.clearNodeScope(jjtn000);
			 jjtc000 = false;
		 }
		 else {
			 jjtree.popNode();
		 }
		 if (jjte000 instanceof RuntimeException) {
			 {
				if (true) throw (RuntimeException)jjte000;
			}
		 }
		 if (jjte000 instanceof ParseException) {
			 {
				if (true) throw (ParseException)jjte000;
			}
		 }
		 {
			if (true) throw (Error)jjte000;
		}
	 }
	 finally {
		 if (jjtc000) {
			 jjtree.closeNodeScope(jjtn000, true);
		 }
	 }
 }",0,0,1,0
private Attribute_Code.ExceptionTableItem readExceptionTableItem(DataInputStream in) throws IOException;,0,0,0,0
"public void widgetSelected( SelectionEvent e ){
	Object widget = e.widget;
	if ( widget == btnVisible ){
		fireValueChangedEvent( GanttLineAttributesComposite.VISIBILITY_CHANGED_EVENT,Boolean.valueOf( btnVisible.getSelectionState( ) == ChartCheckbox.STATE_SELECTED ),( btnVisible.getSelectionState( ) == ChartCheckbox.STATE_GRAYED ) ? ChartUIExtensionUtil.PROPERTY_UNSET: ChartUIExtensionUtil.PROPERTY_UPDATE );
		if ( isDisposed( ) ){
			return;
		}
		boolean bEnableUI = context.getUIFactory( ).canEnableUI( btnVisible );
		if ( bEnableStyles ){
			lblStyle.setEnabled( bEnableUI );
			cmbStyle.setEnabled( bEnableUI );
		}
		if ( bEnableWidths ){
			lblWidth.setEnabled( bEnableUI );
			iscWidth.setEnabled( bEnableUI );
		}
		if ( bEnableColor ){
			lblColor.setEnabled( bEnableUI );
			cmbColor.setEnabled( bEnableUI );
		}
	}
}",0,0,1,0
"private HashMap createEntityEJBs(SimpleModel model) {
	 HashMap map = new HashMap();
	 Collection pkList = model.getAllSimpleUmlPackages(model);
	 for (Iterator pkIterator = pkList.iterator();
	 pkIterator.hasNext();
	) {
		 SimpleUmlPackage simpleUmlPackage = (SimpleUmlPackage) pkIterator.next();
		 Collection list;
		 list = simpleUmlPackage.getSimpleClassifiers();
		 for (Iterator pkit = list.iterator();
		 pkit.hasNext();
		) {
			 SimpleModelElement el = (SimpleModelElement) pkit.next();
			 if ((el instanceof SimpleUmlClass) && model.getStereoType(el) != null && model.getStereoType(el).equalsIgnoreCase(JagUMLProfile.STEREOTYPE_CLASS_ENTITY)) {
				 SimpleUmlClass suc = (SimpleUmlClass) el;
				 String rootPackage = simpleUmlPackage.getFullPackageName();
				 String tableName = getTaggedValue(model, JagUMLProfile.TAGGED_VALUE_CLASS_TABLE_NAME, suc, Utils.unformat(Utils.firstToLowerCase(suc.getName())));
				 Entity entity = new Entity(EMPTY_STRING, tableName, EMPTY_STRING);
				 entity.setRootPackage(rootPackage);
				 entity.setName(suc.getName());
				 entity.setDescription(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_DOCUMENTATION, suc));
				 if (model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DISPLAY_NAME, suc) != null) {
					 entity.setDisplayName(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_DISPLAY_NAME, suc));
				 }
				 if (model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_IS_ASSOCIATION, suc) != null) {
					 entity.isAssociationEntity.setSelectedItem(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_IS_ASSOCIATION, suc));
				 }
				 entity.setRefName(entity.getName().toString());
				 int pkCount = 0;
				 Collection attributes = suc.getSimpleAttributes();
				 Field primaryKeyField = null;
				 for (Iterator iterator = attributes.iterator();
				 iterator.hasNext();
				) {
					 SimpleAttribute att = (SimpleAttribute) iterator.next();
					 boolean isPK = equal(model.getStereoType(att), JagUMLProfile.STEREOTYPE_ATTRIBUTE_PRIMARY_KEY);
					 boolean required = false;
					 if (isPK) {
						 required = true;
					 }
					 else {
						 required = equal(model.getStereoType(att), JagUMLProfile.STEREOTYPE_ATTRIBUTE_REQUIRED);
					 }
					 Column col = new Column();
					 String colName = model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_ATTRIBUTE_COLUMN_NAME, att);
					 if (colName == null) {
						 colName = Utils.unformat(att.getName());
					 }
					 col.setName(colName);
					 String sqlType = getTaggedValue(model, JagUMLProfile.TAGGED_VALUE_ATTRIBUTE_SQL_TYPE, att, null);
					 String jdbcType = getTaggedValue(model, JagUMLProfile.TAGGED_VALUE_ATTRIBUTE_JDBC_TYPE, att, null);
					 col.setPrimaryKey(isPK);
					 col.setNullable(!required);
					 SimpleClassifier theClassifier = att.getType();
					 String fieldType = theClassifier.getOwner().getFullPackageName();
					 if (fieldType != null && !Character.isLowerCase(theClassifier.getName().charAt(0))) {
						 fieldType = fieldType + DOT + theClassifier.getName();
					 }
					 else {
						 String primitiveType = theClassifier.getName();
						 if (CHARACTER_PRIMITIVE.equals(primitiveType)) {
							 fieldType = CHARACTER_CLASS;
						 }
						 else if (INTEGER_PRIMITIVE.equals(primitiveType)) {
							 fieldType = INTEGER_CLASS;
						 }
						 else {
							 fieldType = JAVA_LANG_PACKAGE_PREFIX + Character.toUpperCase(primitiveType.charAt(0)) + primitiveType.substring(1);
						 }
					 }
					 if (sqlType == null) {
						 String[] mappedTypes = getDatabaseColumnTypesForClass(fieldType);
						 sqlType = mappedTypes[0];
						 jdbcType = mappedTypes[1];
					 }
					 col.setSqlType(sqlType);
					 String autoGeneratedPrimaryKey = model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_ATTRIBUTE_AUTO_PRIMARY_KEY, att);
					 boolean generate = false;
					 if (""true"".equalsIgnoreCase(autoGeneratedPrimaryKey)) {
						 generate = true;
					 }
					 Field field = new Field(entity, col);
					 field.setName(att.getName());
					 field.setType(fieldType);
					 if (isPK) {
						 field.setPrimaryKey(isPK);
					 }
					 field.setSqlType(sqlType);
					 field.setJdbcType(jdbcType);
					 field.setHasAutoGenPrimaryKey(generate);
					 if (isPK) {
						 pkCount++;
						 primaryKeyField = field;
					 }
					 entity.add(field);
				 }
				 if (pkCount > 1) {
					 entity.setIsComposite(""true"");
					 String compositePK = model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_CLASS_COMPOSITE_PRIMARY_KEY, suc);
					 entity.setPKeyType(compositePK);
				 }
				 else {
					 if (primaryKeyField != null) {
						 entity.setPrimaryKey(primaryKeyField);
					 }
				 }
				 if (pkCount == 0) {
					 log(""UML Error! Entity '"" + entity.getName() + ""' has no primary key! At least one attribute "" + ""in an entity bean must have the stereotype \""PrimaryKey\""."");
					 JOptionPane.showMessageDialog(null, ""Entity '"" + entity.getName() + ""' has no primary key! At least one attribute "" + ""in an entity bean must have the stereotype \""PrimaryKey\""."", ""UML Error!"", JOptionPane.ERROR_MESSAGE);
				 }
				 else {
					 map.put(entity.getRefName(), entity);
				 }
			 }
		 }
	 }
	 return map;
 }",0,0,1,0
"public class ContextParamWebApplicationFactory implements IWebApplicationFactory{
	public static final String APP_CLASS_PARAM = ""applicationClassName"";
	public WebApplication createApplication(WicketFilter filter){
		final String applicationClassName = filter.getFilterConfig().getInitParameter(APP_CLASS_PARAM);
		if (applicationClassName == null){
			throw new WicketRuntimeException(""servlet init param ["" +APP_CLASS_PARAM +""] is missing. If you are trying to use your own implementation of IWebApplicationFactory and get this message then the servlet init param ["" +WicketFilter.APP_FACT_PARAM + ""] is missing"");
		}
		return createApplication(applicationClassName);
	}
	protected WebApplication createApplication(final String applicationClassName){
		try{
			ClassLoader loader = Thread.currentThread().getContextClassLoader();
			if (loader == null){
				loader = getClass().getClassLoader();
			}
			final Class<?> applicationClass = Class.forName(applicationClassName, false, loader);
			if (WebApplication.class.isAssignableFrom(applicationClass)){
				return (WebApplication)applicationClass.newInstance();
			}
			else{
				throw new WicketRuntimeException(""Application class "" + applicationClassName +"" must be a subclass of WebApplication"");
			}
		}
		catch (ClassNotFoundException e){
			throw new WicketRuntimeException(""Unable to create application of class "" +applicationClassName, e);
		}
		catch (InstantiationException e){
			throw new WicketRuntimeException(""Unable to create application of class "" +applicationClassName, e);
		}
		catch (IllegalAccessException e){
			throw new WicketRuntimeException(""Unable to create application of class "" +applicationClassName, e);
		}
		catch (SecurityException e){
			throw new WicketRuntimeException(""Unable to create application of class "" +applicationClassName, e);
		}
	}
}",0,0,0,0
"private static List<NameValuePair> getUserDetails(String query) {
	 List<NameValuePair> details = new ArrayList<NameValuePair>();
	 if (query != null && !query.isEmpty()) {
		 StringTokenizer allParams = new StringTokenizer(query, ""&"");
		 while (allParams.hasMoreTokens()) {
			 String param = allParams.nextToken();
			 details.add(new BasicNameValuePair(param.substring(0, param.indexOf(""="")), param.substring(param.indexOf(""="") + 1)));
		 }
	 }
	 return details;
 }",0,0,1,0
"abstract class IndirectHandle extends PrimitiveHandle {
	IndirectHandle(MethodType type, Class<?> referenceClass, String name, byte kind, int modifiers) {
		super(type, referenceClass, name, kind, modifiers, null);
	}
	IndirectHandle(MethodType type, Class<?> referenceClass, String name, byte kind) {
		super(type, referenceClass, name, kind, null);
	}
	IndirectHandle(IndirectHandle originalHandle, MethodType newType) {
		super(originalHandle, newType);
	}
	protected abstract long vtableOffset(Object receiver);
	protected final long vtableIndexArgument(Object receiver){
		 return - vtableOffset(receiver);
	 }
	protected final long jittedMethodAddress(Object receiver) {
		long receiverClass = getJ9ClassFromClass(receiver.getClass());
		long result;
		 if (VTABLE_ENTRY_SIZE == 4) {
			result = UNSAFE.getInt(receiverClass - vtableOffset(receiver));
		}
		 else {
			 result = UNSAFE.getLong(receiverClass - vtableOffset(receiver));
		}
		return result;
	}
	boolean canRevealDirect() {
		return true;
	}
	protected static final MethodType indirectMethodType(Method method) {
		MethodType originalType = MethodType.methodType(method.getReturnType(), method.getParameterTypes());
		return indirectMethodType(originalType, method.getDeclaringClass());
	}
	protected static final MethodType indirectMethodType(MethodType type, Class<?> referenceClazz) {
		return type.insertParameterTypes(0, referenceClazz);
	}
	public MethodHandle bindTo(Object value) throws IllegalArgumentException, ClassCastException {
		if (null == value) {
			return super.bindTo(value);
		}
		Class<?> firstParameterType = type().parameterType(0);
		if (firstParameterType.isPrimitive()) {
			throw new IllegalArgumentException();
		}
		value = firstParameterType.cast(value);
		try {
			MethodHandle result = MethodHandles.Lookup.internalPrivilegedLookup.bind(value, name, type().dropFirstParameterType());
			if (this instanceof InterfaceHandle) {
				 if ((result.getModifiers() & Modifier.PUBLIC) == 0) {
					throw new IllegalAccessException();
				}
			}
			return result;
		}
		 catch (IllegalAccessException e) {
			return MethodHandles.insertArguments(this, 0, value);
		}
		 catch (NoSuchMethodException e) {
			throw new Error(e);
		}
	}
	final void compareWithIndirect(IndirectHandle left, Comparator c) {
		c.compareStructuralParameter(left.referenceClass, this.referenceClass);
		c.compareStructuralParameter(left.vmSlot, this.vmSlot);
	}
}",0,0,0,0
"int offerService() throws Exception {
	 long lastHeartbeat = 0;
	 this.fs = FileSystem.getNamed(jobClient.getFilesystemName(), this.fConf);
	 while (running && !shuttingDown) {
		 long now = System.currentTimeMillis();
		 long waitTime = HEARTBEAT_INTERVAL - (now - lastHeartbeat);
		 if (waitTime > 0) {
			 try {
				 synchronized(finishedCount) {
					 if (finishedCount[0] == 0) {
						 finishedCount.wait(waitTime);
					 }
					 finishedCount[0] = 0;
				 }
			 }
			 catch (InterruptedException ie) {
			 }
		 }
		 lastHeartbeat = now;
		 Vector taskReports = new Vector();
		 synchronized (this) {
			 for (Iterator it = runningTasks.values().iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 TaskStatus status = tip.createStatus();
				 taskReports.add(status);
			 }
		 }
		 TaskTrackerStatus status = new TaskTrackerStatus(taskTrackerName, localHostname, httpPort, taskReports, failures);
		 int resultCode = jobClient.emitHeartbeat(status, justStarted);
		 synchronized (this) {
			 for (Iterator it = taskReports.iterator();
			 it.hasNext();
			 ) {
				 TaskStatus taskStatus = (TaskStatus) it.next();
				 if (taskStatus.getRunState() != TaskStatus.State.RUNNING) {
					 if (taskStatus.getIsMap()) {
						 mapTotal--;
					 }
					 else {
						 reduceTotal--;
					 }
					 myMetrics.completeTask();
					 runningTasks.remove(taskStatus.getTaskId());
				 }
			 }
		 }
		 justStarted = false;
		 if (resultCode == InterTrackerProtocol.UNKNOWN_TASKTRACKER) {
			 return STALE_STATE;
		 }
		 try {
			 if ((mapTotal < maxCurrentTasks || reduceTotal < maxCurrentTasks) && acceptNewTasks) {
				 checkLocalDirs(fConf.getLocalDirs());
				 if (enoughFreeSpace(minSpaceStart)) {
					 Task t = jobClient.pollForNewTask(taskTrackerName);
					 if (t != null) {
						 startNewTask(t);
					 }
				 }
			 }
		 }
		 catch (DiskErrorException de ) {
			 LOG.warn(""Exiting task tracker because ""+de.getMessage());
			 jobClient.reportTaskTrackerError(taskTrackerName, ""DiskErrorException"", de.getMessage());
			 return STALE_STATE;
		 }
		 catch (IOException ie) {
			 LOG.info(""Problem launching task: "" + StringUtils.stringifyException(ie));
		 }
		 synchronized (this) {
			 for (Iterator it = runningTasks.values().iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 long timeSinceLastReport = System.currentTimeMillis() - tip.getLastProgressReport();
				 if ((tip.getRunState() == TaskStatus.State.RUNNING) && (timeSinceLastReport > this.taskTimeout) && !tip.wasKilled) {
					 String msg = ""Task failed to report status for "" + (timeSinceLastReport / 1000) + "" seconds. Killing."";
					 LOG.info(tip.getTask().getTaskId() + "": "" + msg);
					 getCallStacks();
					 tip.reportDiagnosticInfo(msg);
					 try {
						 tip.killAndCleanup(true);
					 }
					 catch (IOException ie) {
						 LOG.info(""Problem cleaning task up: "" + StringUtils.stringifyException(ie));
					 }
				 }
			 }
		 }
		 try {
			 String[] toCloseIds = jobClient.pollForTaskWithClosedJob(taskTrackerName);
			 if (toCloseIds != null) {
				 synchronized (this) {
					 for (int i = 0;
					 i < toCloseIds.length;
					 i++) {
						 Object tip = tasks.get(toCloseIds[i]);
						 synchronized(runningJobs){
							 runningJobs.remove(((TaskInProgress) tasks.get(toCloseIds[i])).getTask().getJobId());
						 }
						 if (tip != null) {
							 tasksToCleanup.put(tip);
						 }
						 else {
							 LOG.info(""Attempt to cleanup unknown tip "" + toCloseIds[i]);
						 }
					 }
				 }
			 }
		 }
		 catch (IOException ie) {
			 LOG.info(""Problem getting closed tasks: "" + StringUtils.stringifyException(ie));
		 }
		 if (!enoughFreeSpace(minSpaceKill)) {
			 acceptNewTasks=false;
			 synchronized (this) {
				 TaskInProgress killMe = null;
				 for (Iterator it = runningTasks.values().iterator();
				 it.hasNext();
				 ) {
					 TaskInProgress tip = (TaskInProgress) it.next();
					 if ((tip.getRunState() == TaskStatus.State.RUNNING) && !tip.wasKilled) {
						 if (killMe == null) {
							 killMe = tip;
						 }
						 else if (!tip.getTask().isMapTask()) {
							 if (killMe.getTask().isMapTask() || (tip.getTask().getProgress().get() < killMe.getTask().getProgress().get())) {
								 killMe = tip;
							 }
						 }
						 else if (killMe.getTask().isMapTask() && tip.getTask().getProgress().get() < killMe.getTask().getProgress().get()) {
							 killMe = tip;
						 }
					 }
				 }
				 if (killMe!=null) {
					 String msg = ""Tasktracker running out of space. Killing task."";
					 LOG.info(killMe.getTask().getTaskId() + "": "" + msg);
					 killMe.reportDiagnosticInfo(msg);
					 try {
						 killMe.killAndCleanup(true);
					 }
					 catch (IOException ie) {
						 LOG.info(""Problem cleaning task up: "" + StringUtils.stringifyException(ie));
					 }
				 }
			 }
		 }
		 if (!acceptNewTasks && tasks.isEmpty()) {
			 acceptNewTasks=true;
		 }
	 }
	 return 0;
 }",0,0,1,0
"public class MachineStoppedEvent extends GwtEvent<MachineStoppedEvent.Handler> {
	 public static final Type<MachineStoppedEvent.Handler> TYPE = new Type<>();
	 private final MachineImpl machine;
	 public MachineStoppedEvent(MachineImpl machine) {
		 this.machine = machine;
	 }
	 public MachineImpl getMachine() {
		 return machine;
	 }
	 public Type<Handler> getAssociatedType() {
		 return TYPE;
	 }
	 protected void dispatch(Handler handler) {
		 handler.onMachineStopped(this);
	 }
	 public interface Handler extends EventHandler {
		 void onMachineStopped(MachineStoppedEvent event);
	 }
}",0,1,0,0
"public String getExplicitChoice() {
	 return userChoice;
 }",0,0,0,0
"protected void writeVersion(final JsonWriter out, final Integer value) throws IOException {
	 if ((value == null)) {
		 final boolean previousSerializeNulls = out.getSerializeNulls();
		 out.setSerializeNulls(true);
		 out.nullValue();
		 out.setSerializeNulls(previousSerializeNulls);
	 }
	 else {
		 out.value(value);
	 }
 }",0,0,0,0
"public class Customer388 {
	 private long id;
	private String firstName;
	private String lastName;
	protected Customer388() {
	}
	public Customer388(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	public String toString() {
		return String.format(""Customer388[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}
}",0,1,0,0
"private void checkOptions(Commandline cmd) {
	 if (getKeepCopy()) {
		 cmd.createArgument().setValue(FLAG_KEEPCOPY);
	 }
	 else {
		 cmd.createArgument().setValue(FLAG_RM);
	 }
	 cmd.createArgument().setValue(getViewPath());
 }",0,0,0,0
"private final class SymbolProcessor implements FunctionVisitor, InstructionVisitorAdapter {
	 private final SourceFunction function;
	 private final LinkedList<Integer> removeFromBlock = new LinkedList<>();
	 private int blockInstIndex = 0;
	 private DbgValueInstruction lastDbgValue = null;
	 private InstructionBlock currentBlock = null;
	 private SymbolProcessor(SourceFunction function) {
		 this.function = function;
	 }
	 public void visit(InstructionBlock block) {
		 currentBlock = block;
		 lastDbgValue = null;
		 for (blockInstIndex = 0;
		 blockInstIndex < block.getInstructionCount();
		 blockInstIndex++) {
			 block.getInstruction(blockInstIndex).accept(this);
		 }
		 if (!removeFromBlock.isEmpty()) {
			 for (int i : removeFromBlock) {
				 currentBlock.remove(i);
			 }
			 removeFromBlock.clear();
		 }
	 }
	 public void visitInstruction(Instruction instruction) {
		 final MDLocation loc = instruction.getDebugLocation();
		 if (loc != null) {
			 final LLVMSourceLocation scope = cache.buildLocation(loc);
			 if (scope != null) {
				 instruction.setSourceLocation(scope);
			 }
		 }
	 }
	 public void visit(VoidCallInstruction call) {
		 final SymbolImpl callTarget = call.getCallTarget();
		 if (callTarget instanceof FunctionDeclaration) {
			 switch (((FunctionDeclaration) callTarget).getName()) {
				 case LLVM_DBG_DECLARE_NAME: handleDebugIntrinsic(call, true);
				 return;
				 case LLVM_DBG_ADDR_NAME: handleDebugIntrinsic(call, true);
				 return;
				 case LLVM_DBG_VALUE_NAME: handleDebugIntrinsic(call, false);
				 return;
				 case LLVM_DEBUGTRAP_NAME: visitDebugTrap(call);
				 return;
			 }
		 }
		 visitInstruction(call);
	 }
	 private void visitDebugTrap(VoidCallInstruction call) {
		 final DebugTrapInstruction trap = DebugTrapInstruction.create(call);
		 currentBlock.set(blockInstIndex, trap);
		 visitInstruction(trap);
	 }
	 private SourceVariable getVariable(VoidCallInstruction call, int index) {
		 final SymbolImpl varSymbol = getArg(call, index);
		 if (varSymbol instanceof MetadataSymbol) {
			 final MDBaseNode mdLocal = ((MetadataSymbol) varSymbol).getNode();
			 final LLVMSourceSymbol symbol = cache.getSourceSymbol(mdLocal, false);
			 return function.getLocal(symbol);
		 }
		 return null;
	 }
	 private void handleDebugIntrinsic(VoidCallInstruction call, boolean isDeclaration) {
		 SymbolImpl value = getArg(call, LLVM_DBG_INTRINSICS_VALUE_ARGINDEX);
		 if (value instanceof MetadataSymbol) {
			 value = MDSymbolExtractor.getSymbol(((MetadataSymbol) value).getNode());
		 }
		 if (value == null) {
			 value = new NullConstant(MetaType.DEBUG);
		 }
		 else if (value instanceof ValueInstruction) {
			 ((ValueInstruction) value).setSourceVariable(true);
		 }
		 else if (value instanceof FunctionParameter) {
			 ((FunctionParameter) value).setSourceVariable(true);
		 }
		 int mdLocalArgIndex;
		 int mdExprArgIndex;
		 if (isDeclaration) {
			 mdLocalArgIndex = LLVM_DBG_DECLARE_LOCALREF_ARGINDEX;
			 mdExprArgIndex = LLVM_DBG_DECLARE_EXPR_ARGINDEX;
		 }
		 else if (call.getArgumentCount() == LLVM_DBG_VALUE_LOCALREF_ARGSIZE_NEW) {
			 mdLocalArgIndex = LLVM_DBG_VALUE_LOCALREF_ARGINDEX_NEW;
			 mdExprArgIndex = LLVM_DBG_VALUE_EXPR_ARGINDEX_NEW;
		 }
		 else if (call.getArgumentCount() == LLVM_DBG_VALUE_LOCALREF_ARGSIZE_OLD) {
			 mdLocalArgIndex = LLVM_DBG_VALUE_LOCALREF_ARGINDEX_OLD;
			 mdExprArgIndex = LLVM_DBG_VALUE_EXPR_ARGINDEX_OLD;
		 }
		 else {
			 return;
		 }
		 final SourceVariable variable = getVariable(call, mdLocalArgIndex);
		 if (variable == null) {
			 removeFromBlock.addFirst(blockInstIndex);
			 return;
		 }
		 final MDExpression expression = getExpression(call, mdExprArgIndex);
		 if (ValueFragment.describesFragment(expression)) {
			 variable.addFragment(ValueFragment.parse(expression));
		 }
		 else {
			 variable.addFullDefinition();
		 }
		 if (isDeclaration) {
			 final DbgDeclareInstruction dbgDeclare = new DbgDeclareInstruction(value, variable, expression);
			 variable.addDeclaration(dbgDeclare);
			 currentBlock.set(blockInstIndex, dbgDeclare);
		 }
		 else {
			 long index = 0;
			 if (call.getArgumentCount() == LLVM_DBG_VALUE_LOCALREF_ARGSIZE_OLD) {
				 final SymbolImpl indexSymbol = call.getArgument(LLVM_DBG_VALUE_INDEX_ARGINDEX_OLD);
				 final Long l = LLVMSymbolReadResolver.evaluateLongIntegerConstant(indexSymbol);
				 if (l != null) {
					 index = l;
				 }
			 }
			 final DbgValueInstruction dbgValue = new DbgValueInstruction(value, variable, index, expression);
			 if (dbgValue.equals(lastDbgValue)) {
				 removeFromBlock.addFirst(blockInstIndex);
			 }
			 else {
				 variable.addValue(dbgValue);
				 currentBlock.set(blockInstIndex, dbgValue);
				 lastDbgValue = dbgValue;
			 }
		 }
	 }
 }",1,0,0,0
"public boolean isRunning() {
	 return !activeTasks.isEmpty();
 }",0,0,0,0
"public class ImmutableBitSet implements Iterable<Integer>, Serializable, Comparable<ImmutableBitSet> {
	 public static final Comparator<ImmutableBitSet> COMPARATOR = (o1, o2) -> {
		 if (o1.equals(o2)) {
			 return 0;
		 }
		 if (o1.contains(o2)) {
			 return -1;
		 }
		 if (o2.contains(o1)) {
			 return 1;
		 }
		 return o1.compareTo(o2);
	 }
	;
	 public static final Ordering<ImmutableBitSet> ORDERING = Ordering.from(COMPARATOR);
	 private static final int ADDRESS_BITS_PER_WORD = 6;
	 private static final int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;
	 private static final long WORD_MASK = 0xffffffffffffffffL;
	 private static final long[] EMPTY_LONGS = new long[0];
	 private static final ImmutableBitSet EMPTY = new ImmutableBitSet(EMPTY_LONGS);
	 public static final com.google.common.base.Function<? super BitSet, ImmutableBitSet> FROM_BIT_SET = ImmutableBitSet::fromBitSet;
	 private final long[] words;
	 private ImmutableBitSet(long[] words) {
		 this.words = words;
		 assert words.length == 0 ? words == EMPTY_LONGS : words[words.length - 1] != 0L;
	 }
	 public static ImmutableBitSet of() {
		 return EMPTY;
	 }
	 public static ImmutableBitSet of(int... bits) {
		 int max = -1;
		 for (int bit : bits) {
			 max = Math.max(bit, max);
		 }
		 if (max == -1) {
			 return EMPTY;
		 }
		 long[] words = new long[wordIndex(max) + 1];
		 for (int bit : bits) {
			 int wordIndex = wordIndex(bit);
			 words[wordIndex] |= 1L << bit;
		 }
		 return new ImmutableBitSet(words);
	 }
	 public static ImmutableBitSet of(Iterable<Integer> bits) {
		 if (bits instanceof ImmutableBitSet) {
			 return (ImmutableBitSet) bits;
		 }
		 int max = -1;
		 for (int bit : bits) {
			 max = Math.max(bit, max);
		 }
		 if (max == -1) {
			 return EMPTY;
		 }
		 long[] words = new long[wordIndex(max) + 1];
		 for (int bit : bits) {
			 int wordIndex = wordIndex(bit);
			 words[wordIndex] |= 1L << bit;
		 }
		 return new ImmutableBitSet(words);
	 }
	 public static ImmutableBitSet of(ImmutableIntList bits) {
		 return builder().addAll(bits).build();
	 }
	 public static ImmutableBitSet valueOf(long... longs) {
		 int n = longs.length;
		 while (n > 0 && longs[n - 1] == 0) {
			 --n;
		 }
		 if (n == 0) {
			 return EMPTY;
		 }
		 return new ImmutableBitSet(Arrays.copyOf(longs, n));
	 }
	 public static ImmutableBitSet valueOf(LongBuffer longs) {
		 longs = longs.slice();
		 int n = longs.remaining();
		 while (n > 0 && longs.get(n - 1) == 0) {
			 --n;
		 }
		 if (n == 0) {
			 return EMPTY;
		 }
		 long[] words = new long[n];
		 longs.get(words);
		 return new ImmutableBitSet(words);
	 }
	 public static ImmutableBitSet fromBitSet(BitSet input) {
		 return ImmutableBitSet.of(BitSets.toIter(input));
	 }
	 public static ImmutableBitSet range(int fromIndex, int toIndex) {
		 if (fromIndex > toIndex) {
			 throw new IllegalArgumentException();
		 }
		 if (toIndex < 0) {
			 throw new IllegalArgumentException();
		 }
		 if (fromIndex == toIndex) {
			 return EMPTY;
		 }
		 int startWordIndex = wordIndex(fromIndex);
		 int endWordIndex = wordIndex(toIndex - 1);
		 long[] words = new long[endWordIndex + 1];
		 long firstWordMask = WORD_MASK << fromIndex;
		 long lastWordMask = WORD_MASK >>> -toIndex;
		 if (startWordIndex == endWordIndex) {
			 words[startWordIndex] |= firstWordMask & lastWordMask;
		 }
		 else {
			 words[startWordIndex] |= firstWordMask;
			 for (int i = startWordIndex + 1;
			 i < endWordIndex;
			 i++) {
				 words[i] = WORD_MASK;
			 }
			 words[endWordIndex] |= lastWordMask;
		 }
		 return new ImmutableBitSet(words);
	 }
	 public static ImmutableBitSet range(int toIndex) {
		 return range(0, toIndex);
	 }
	 private static int wordIndex(int bitIndex) {
		 return bitIndex >> ADDRESS_BITS_PER_WORD;
	 }
	 public Iterable<ImmutableBitSet> powerSet() {
		 List<List<ImmutableBitSet>> singletons = new ArrayList<>();
		 for (int bit : this) {
			 singletons.add( ImmutableList.of(ImmutableBitSet.of(), ImmutableBitSet.of(bit)));
		 }
		 return Iterables.transform(Linq4j.product(singletons), ImmutableBitSet::union);
	 }
	 public boolean get(int bitIndex) {
		 if (bitIndex < 0) {
			 throw new IndexOutOfBoundsException(""bitIndex < 0: "" + bitIndex);
		 }
		 int wordIndex = wordIndex(bitIndex);
		 return (wordIndex < words.length) && ((words[wordIndex] & (1L << bitIndex)) != 0);
	 }
	 public ImmutableBitSet get(int fromIndex, int toIndex) {
		 checkRange(fromIndex, toIndex);
		 final Builder builder = builder();
		 for (int i = nextSetBit(fromIndex);
		 i >= 0 && i < toIndex;
		 i = nextSetBit(i + 1)) {
			 builder.set(i);
		 }
		 return builder.build();
	 }
	 private static void checkRange(int fromIndex, int toIndex) {
		 if (fromIndex < 0) {
			 throw new IndexOutOfBoundsException(""fromIndex < 0: "" + fromIndex);
		 }
		 if (toIndex < 0) {
			 throw new IndexOutOfBoundsException(""toIndex < 0: "" + toIndex);
		 }
		 if (fromIndex > toIndex) {
			 throw new IndexOutOfBoundsException(""fromIndex: "" + fromIndex + "" > toIndex: "" + toIndex);
		 }
	 }
	 public String toString() {
		 int numBits = words.length * BITS_PER_WORD;
		 StringBuilder b = new StringBuilder(6 * numBits + 2);
		 b.append('{
			');
			 int i = nextSetBit(0);
			 if (i != -1) {
				 b.append(i);
				 for (i = nextSetBit(i + 1);
				 i >= 0;
				 i = nextSetBit(i + 1)) {
					 int endOfRun = nextClearBit(i);
					 do {
						 b.append("", "").append(i);
					 }
					 while (++i < endOfRun);
				 }
			 }
		 b.append('}
		');
		 return b.toString();
	 }
	 public boolean intersects(ImmutableBitSet set) {
		 for (int i = Math.min(words.length, set.words.length) - 1;
		 i >= 0;
		 i--) {
			 if ((words[i] & set.words[i]) != 0) {
				 return true;
			 }
		 }
		 return false;
	 }
	 public int cardinality() {
		 return countBits(words);
	 }
	 private static int countBits(long[] words) {
		 int sum = 0;
		 for (long word : words) {
			 sum += Long.bitCount(word);
		 }
		 return sum;
	 }
	 public int hashCode() {
		 long h = 1234;
		 for (int i = words.length;
		 --i >= 0;
		) {
			 h ^= words[i] * (i + 1);
		 }
		 return (int) ((h >> 32) ^ h);
	 }
	 public int size() {
		 return words.length * BITS_PER_WORD;
	 }
	 public boolean equals(Object obj) {
		 if (this == obj) {
			 return true;
		 }
		 if (!(obj instanceof ImmutableBitSet)) {
			 return false;
		 }
		 ImmutableBitSet set = (ImmutableBitSet) obj;
		 return Arrays.equals(words, set.words);
	 }
	 public int compareTo( ImmutableBitSet o) {
		 int i = 0;
		 for (;
		;
		) {
			 int n0 = nextSetBit(i);
			 int n1 = o.nextSetBit(i);
			 int c = Utilities.compare(n0, n1);
			 if (c != 0 || n0 < 0) {
				 return c;
			 }
			 i = n0 + 1;
		 }
	 }
	 public int nextSetBit(int fromIndex) {
		 if (fromIndex < 0) {
			 throw new IndexOutOfBoundsException(""fromIndex < 0: "" + fromIndex);
		 }
		 int u = wordIndex(fromIndex);
		 if (u >= words.length) {
			 return -1;
		 }
		 long word = words[u] & (WORD_MASK << fromIndex);
		 while (true) {
			 if (word != 0) {
				 return (u * BITS_PER_WORD) + Long.numberOfTrailingZeros(word);
			 }
			 if (++u == words.length) {
				 return -1;
			 }
			 word = words[u];
		 }
	 }
	 public int nextClearBit(int fromIndex) {
		 if (fromIndex < 0) {
			 throw new IndexOutOfBoundsException(""fromIndex < 0: "" + fromIndex);
		 }
		 int u = wordIndex(fromIndex);
		 if (u >= words.length) {
			 return fromIndex;
		 }
		 long word = ~words[u] & (WORD_MASK << fromIndex);
		 while (true) {
			 if (word != 0) {
				 return (u * BITS_PER_WORD) + Long.numberOfTrailingZeros(word);
			 }
			 if (++u == words.length) {
				 return words.length * BITS_PER_WORD;
			 }
			 word = ~words[u];
		 }
	 }
	 public int previousClearBit(int fromIndex) {
		 if (fromIndex < 0) {
			 if (fromIndex == -1) {
				 return -1;
			 }
			 throw new IndexOutOfBoundsException(""fromIndex < -1: "" + fromIndex);
		 }
		 int u = wordIndex(fromIndex);
		 if (u >= words.length) {
			 return fromIndex;
		 }
		 long word = ~words[u] & (WORD_MASK >>> -(fromIndex + 1));
		 while (true) {
			 if (word != 0) {
				 return (u + 1) * BITS_PER_WORD - 1 - Long.numberOfLeadingZeros(word);
			 }
			 if (u-- == 0) {
				 return -1;
			 }
			 word = ~words[u];
		 }
	 }
	 public Iterator<Integer> iterator() {
		 return new Iterator<Integer>() {
			 int i = nextSetBit(0);
			 public boolean hasNext() {
				 return i >= 0;
			 }
			 public Integer next() {
				 int prev = i;
				 i = nextSetBit(i + 1);
				 return prev;
			 }
			 public void remove() {
				 throw new UnsupportedOperationException();
			 }
		 }
		;
	 }
	 public List<Integer> toList() {
		 final List<Integer> list = new ArrayList<>();
		 for (int i = nextSetBit(0);
		 i >= 0;
		 i = nextSetBit(i + 1)) {
			 list.add(i);
		 }
		 return list;
	 }
	 public List<Integer> asList() {
		 return new AbstractList<Integer>() {
			 public Integer get(int index) {
				 return nth(index);
			 }
			 public int size() {
				 return cardinality();
			 }
			 public Iterator<Integer> iterator() {
				 return ImmutableBitSet.this.iterator();
			 }
		 }
		;
	 }
	 public Set<Integer> asSet() {
		 return new AbstractSet<Integer>() {
			 public Iterator<Integer> iterator() {
				 return ImmutableBitSet.this.iterator();
			 }
			 public int size() {
				 return cardinality();
			 }
			 public boolean contains(Object o) {
				 return ImmutableBitSet.this.get((Integer) o);
			 }
		 }
		;
	 }
	 public int[] toArray() {
		 final int[] integers = new int[cardinality()];
		 int j = 0;
		 for (int i = nextSetBit(0);
		 i >= 0;
		 i = nextSetBit(i + 1)) {
			 integers[j++] = i;
		 }
		 return integers;
	 }
	 public long[] toLongArray() {
		 return words.length == 0 ? words : words.clone();
	 }
	 public ImmutableBitSet union(BitSet other) {
		 return rebuild() .addAll(BitSets.toIter(other)) .build();
	 }
	 public ImmutableBitSet union(ImmutableBitSet other) {
		 return rebuild() .addAll(other) .build(other);
	 }
	 public static ImmutableBitSet union( Iterable<? extends ImmutableBitSet> sets) {
		 final Builder builder = builder();
		 for (ImmutableBitSet set : sets) {
			 builder.addAll(set);
		 }
		 return builder.build();
	 }
	 public ImmutableBitSet except(ImmutableBitSet that) {
		 final Builder builder = rebuild();
		 builder.removeAll(that);
		 return builder.build();
	 }
	 public ImmutableBitSet intersect(ImmutableBitSet that) {
		 final Builder builder = rebuild();
		 builder.intersect(that);
		 return builder.build();
	 }
	 public boolean contains(ImmutableBitSet set1) {
		 for (int i = set1.nextSetBit(0);
		 i >= 0;
		 i = set1.nextSetBit(i + 1)) {
			 if (!get(i)) {
				 return false;
			 }
		 }
		 return true;
	 }
	 public int indexOf(int bit) {
		 for (int i = nextSetBit(0), k = 0;
		;
		 i = nextSetBit(i + 1), ++k) {
			 if (i < 0) {
				 return -1;
			 }
			 if (i == bit) {
				 return k;
			 }
		 }
	 }
	 public static SortedMap<Integer, ImmutableBitSet> closure( SortedMap<Integer, ImmutableBitSet> equivalence) {
		 if (equivalence.isEmpty()) {
			 return ImmutableSortedMap.of();
		 }
		 int length = equivalence.lastKey();
		 for (ImmutableBitSet bitSet : equivalence.values()) {
			 length = Math.max(length, bitSet.length());
		 }
		 if (equivalence.size() < length || equivalence.firstKey() != 0) {
			 SortedMap<Integer, ImmutableBitSet> old = equivalence;
			 equivalence = new TreeMap<>();
			 for (int i = 0;
			 i < length;
			 i++) {
				 final ImmutableBitSet bitSet = old.get(i);
				 equivalence.put(i, bitSet == null ? ImmutableBitSet.of() : bitSet);
			 }
		 }
		 final Closure closure = new Closure(equivalence);
		 return closure.closure;
	 }
	 public int length() {
		 if (words.length == 0) {
			 return 0;
		 }
		 return BITS_PER_WORD * (words.length - 1) + (BITS_PER_WORD - Long.numberOfLeadingZeros(words[words.length - 1]));
	 }
	 public boolean isEmpty() {
		 return words.length == 0;
	 }
	 public static Builder builder() {
		 return new Builder(EMPTY_LONGS);
	 }
	 public static Builder builder(ImmutableBitSet bitSet) {
		 return bitSet.rebuild();
	 }
	 public Builder rebuild() {
		 return new Rebuilder(this);
	 }
	 public int nth(int n) {
		 int start = 0;
		 for (long word : words) {
			 final int bitCount = Long.bitCount(word);
			 if (n < bitCount) {
				 while (word != 0) {
					 if ((word & 1) == 1) {
						 if (n == 0) {
							 return start;
						 }
						 --n;
					 }
					 word >>= 1;
					 ++start;
				 }
			 }
			 start += 64;
			 n -= bitCount;
		 }
		 throw new IndexOutOfBoundsException(""index out of range: "" + n);
	 }
	 public ImmutableBitSet set(int i) {
		 return union(ImmutableBitSet.of(i));
	 }
	 public ImmutableBitSet set(int i, boolean b) {
		 if (get(i) == b) {
			 return this;
		 }
		 return b ? set(i) : clear(i);
	 }
	 public ImmutableBitSet setIf(int bit, boolean condition) {
		 return condition ? set(bit) : this;
	 }
	 public ImmutableBitSet clear(int i) {
		 return except(ImmutableBitSet.of(i));
	 }
	 public ImmutableBitSet clearIf(int i, boolean condition) {
		 return condition ? except(ImmutableBitSet.of(i)) : this;
	 }
	 public BitSet toBitSet() {
		 return BitSets.of(this);
	 }
	 public ImmutableBitSet permute(Map<Integer, Integer> map) {
		 final Builder builder = builder();
		 for (int i = nextSetBit(0);
		 i >= 0;
		 i = nextSetBit(i + 1)) {
			 builder.set(map.get(i));
		 }
		 return builder.build();
	 }
	 public static Iterable<ImmutableBitSet> permute( Iterable<ImmutableBitSet> bitSets, final Map<Integer, Integer> map) {
		 return Iterables.transform(bitSets, bitSet -> bitSet.permute(map));
	 }
	 public ImmutableBitSet shift(int offset) {
		 if (offset == 0) {
			 return this;
		 }
		 final Builder builder = builder();
		 for (int i = nextSetBit(0);
		 i >= 0;
		 i = nextSetBit(i + 1)) {
			 builder.set(i + offset);
		 }
		 return builder.build();
	 }
	 private static class Closure {
		 private SortedMap<Integer, ImmutableBitSet> equivalence;
		 private final SortedMap<Integer, ImmutableBitSet> closure = new TreeMap<>();
		 Closure(SortedMap<Integer, ImmutableBitSet> equivalence) {
			 this.equivalence = equivalence;
			 final ImmutableIntList keys = ImmutableIntList.copyOf(equivalence.keySet());
			 for (int pos : keys) {
				 computeClosure(pos);
			 }
		 }
		 private ImmutableBitSet computeClosure(int pos) {
			 ImmutableBitSet o = closure.get(pos);
			 if (o != null) {
				 return o;
			 }
			 final ImmutableBitSet b = equivalence.get(pos);
			 o = b;
			 int i = b.nextSetBit(pos + 1);
			 for (;
			 i >= 0;
			 i = b.nextSetBit(i + 1)) {
				 o = o.union(computeClosure(i));
			 }
			 closure.put(pos, o);
			 i = o.nextSetBit(pos + 1);
			 for (;
			 i >= 0;
			 i = b.nextSetBit(i + 1)) {
				 closure.put(i, o);
			 }
			 return o;
		 }
	 }
	 public static class Builder {
		 private long[] words;
		 private Builder(long[] words) {
			 this.words = words;
		 }
		 public ImmutableBitSet build() {
			 if (words.length == 0) {
				 return EMPTY;
			 }
			 long[] words = this.words;
			 this.words = null;
			 return new ImmutableBitSet(words);
		 }
		 public ImmutableBitSet build(ImmutableBitSet bitSet) {
			 if (wouldEqual(bitSet)) {
				 return bitSet;
			 }
			 return build();
		 }
		 public Builder set(int bit) {
			 if (words == null) {
				 throw new IllegalArgumentException(""can only use builder once"");
			 }
			 int wordIndex = wordIndex(bit);
			 if (wordIndex >= words.length) {
				 words = Arrays.copyOf(words, wordIndex + 1);
			 }
			 words[wordIndex] |= 1L << bit;
			 return this;
		 }
		 private void trim(int wordCount) {
			 while (wordCount > 0 && words[wordCount - 1] == 0L) {
				 --wordCount;
			 }
			 if (wordCount == words.length) {
				 return;
			 }
			 if (wordCount == 0) {
				 words = EMPTY_LONGS;
			 }
			 else {
				 words = Arrays.copyOfRange(words, 0, wordCount);
			 }
		 }
		 public Builder clear(int bit) {
			 int wordIndex = wordIndex(bit);
			 if (wordIndex < words.length) {
				 words[wordIndex] &= ~(1L << bit);
				 trim(words.length);
			 }
			 return this;
		 }
		 public boolean wouldEqual(ImmutableBitSet bitSet) {
			 if (words == null) {
				 throw new IllegalArgumentException(""can only use builder once"");
			 }
			 return Arrays.equals(words, bitSet.words);
		 }
		 public int cardinality() {
			 if (words == null) {
				 throw new IllegalArgumentException(""can only use builder once"");
			 }
			 return countBits(words);
		 }
		 public Builder addAll(ImmutableBitSet bitSet) {
			 for (Integer bit : bitSet) {
				 set(bit);
			 }
			 return this;
		 }
		 public Builder addAll(Iterable<Integer> integers) {
			 for (Integer integer : integers) {
				 set(integer);
			 }
			 return this;
		 }
		 public Builder addAll(ImmutableIntList integers) {
			 for (int i = 0;
			 i < integers.size();
			 i++) {
				 set(integers.get(i));
			 }
			 return this;
		 }
		 public Builder removeAll(ImmutableBitSet bitSet) {
			 for (Integer bit : bitSet) {
				 clear(bit);
			 }
			 return this;
		 }
		 public Builder set(int fromIndex, int toIndex) {
			 if (fromIndex > toIndex) {
				 throw new IllegalArgumentException();
			 }
			 if (toIndex < 0) {
				 throw new IllegalArgumentException();
			 }
			 if (fromIndex < toIndex) {
				 int startWordIndex = wordIndex(fromIndex);
				 int endWordIndex = wordIndex(toIndex - 1);
				 if (endWordIndex >= words.length) {
					 words = Arrays.copyOf(words, endWordIndex + 1);
				 }
				 long firstWordMask = WORD_MASK << fromIndex;
				 long lastWordMask = WORD_MASK >>> -toIndex;
				 if (startWordIndex == endWordIndex) {
					 words[startWordIndex] |= firstWordMask & lastWordMask;
				 }
				 else {
					 words[startWordIndex] |= firstWordMask;
					 for (int i = startWordIndex + 1;
					 i < endWordIndex;
					 i++) {
						 words[i] = WORD_MASK;
					 }
					 words[endWordIndex] |= lastWordMask;
				 }
			 }
			 return this;
		 }
		 public boolean isEmpty() {
			 return words.length == 0;
		 }
		 public void intersect(ImmutableBitSet that) {
			 int x = Math.min(words.length, that.words.length);
			 for (int i = 0;
			 i < x;
			 i++) {
				 words[i] &= that.words[i];
			 }
			 trim(x);
		 }
	 }
	 private static class Rebuilder extends Builder {
		 private final ImmutableBitSet originalBitSet;
		 private Rebuilder(ImmutableBitSet originalBitSet) {
			 super(originalBitSet.words.clone());
			 this.originalBitSet = originalBitSet;
		 }
		 public ImmutableBitSet build() {
			 if (wouldEqual(originalBitSet)) {
				 return originalBitSet;
			 }
			 return super.build();
		 }
		 public ImmutableBitSet build(ImmutableBitSet bitSet) {
			 if (wouldEqual(originalBitSet)) {
				 return originalBitSet;
			 }
			 return super.build(bitSet);
		 }
	 }
}",1,0,0,0
"private static class getDataProduct_resultStandardScheme extends StandardScheme<getDataProduct_result> {
	 public void read(org.apache.thrift.protocol.TProtocol iprot, getDataProduct_result struct) throws org.apache.thrift.TException {
		 org.apache.thrift.protocol.TField schemeField;
		 iprot.readStructBegin();
		 while (true) {
			 schemeField = iprot.readFieldBegin();
			 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
				 break;
			 }
			 switch (schemeField.id) {
				 case 0: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.success = new org.apache.airavata.model.data.replica.DataProductModel();
					 struct.success.read(iprot);
					 struct.setSuccessIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.ire = new org.apache.airavata.model.error.InvalidRequestException();
					 struct.ire.read(iprot);
					 struct.setIreIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 2: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.ace = new org.apache.airavata.model.error.AiravataClientException();
					 struct.ace.read(iprot);
					 struct.setAceIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 3: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.ase = new org.apache.airavata.model.error.AiravataSystemException();
					 struct.ase.read(iprot);
					 struct.setAseIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 4: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.ae = new org.apache.airavata.model.error.AuthorizationException();
					 struct.ae.read(iprot);
					 struct.setAeIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 iprot.readFieldEnd();
		 }
		 iprot.readStructEnd();
		 struct.validate();
	 }
	 public void write(org.apache.thrift.protocol.TProtocol oprot, getDataProduct_result struct) throws org.apache.thrift.TException {
		 struct.validate();
		 oprot.writeStructBegin(STRUCT_DESC);
		 if (struct.success != null) {
			 oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
			 struct.success.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 if (struct.ire != null) {
			 oprot.writeFieldBegin(IRE_FIELD_DESC);
			 struct.ire.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 if (struct.ace != null) {
			 oprot.writeFieldBegin(ACE_FIELD_DESC);
			 struct.ace.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 if (struct.ase != null) {
			 oprot.writeFieldBegin(ASE_FIELD_DESC);
			 struct.ase.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 if (struct.ae != null) {
			 oprot.writeFieldBegin(AE_FIELD_DESC);
			 struct.ae.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 oprot.writeFieldStop();
		 oprot.writeStructEnd();
	 }
 }",0,0,0,0
"public static void destroy(Application application){
	applicationToClassesToGetAndSetters.remove(application);
}",0,0,0,0
"void lostTaskTracker(String trackerName, String hostname) {
	 LOG.info(""Lost tracker '"" + trackerName + ""'"");
	 TreeSet lostTasks = (TreeSet) trackerToTaskMap.get(trackerName);
	 trackerToTaskMap.remove(trackerName);
	 if (lostTasks != null) {
		 for (Iterator it = lostTasks.iterator();
		 it.hasNext();
		 ) {
			 String taskId = (String) it.next();
			 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(taskId);
			 if (tip.isMapTask() || !tip.isComplete()) {
				 JobInProgress job = tip.getJob();
				 if (job.getStatus().getRunState() == JobStatus.RUNNING) {
					 job.failedTask(tip, taskId, ""Lost task tracker"", TaskStatus.Phase.MAP, hostname, trackerName, myMetrics);
				 }
			 }
		 }
	 }
 }",0,0,0,0
""")public class Assignment implements org.apache.storm.thrift.TBase<Assignment, Assignment._Fields>, java.io.Serializable, Cloneable, Comparable<Assignment> {
	 private static final org.apache.storm.thrift.protocol.TStruct STRUCT_DESC = new org.apache.storm.thrift.protocol.TStruct(""Assignment"");
	 private static final org.apache.storm.thrift.protocol.TField MASTER_CODE_DIR_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(""master_code_dir"", org.apache.storm.thrift.protocol.TType.STRING, (short)1);
	 private static final org.apache.storm.thrift.protocol.TField NODE_HOST_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(""node_host"", org.apache.storm.thrift.protocol.TType.MAP, (short)2);
	 private static final org.apache.storm.thrift.protocol.TField EXECUTOR_NODE_PORT_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(""executor_node_port"", org.apache.storm.thrift.protocol.TType.MAP, (short)3);
	 private static final org.apache.storm.thrift.protocol.TField EXECUTOR_START_TIME_SECS_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(""executor_start_time_secs"", org.apache.storm.thrift.protocol.TType.MAP, (short)4);
	 private static final org.apache.storm.thrift.protocol.TField WORKER_RESOURCES_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(""worker_resources"", org.apache.storm.thrift.protocol.TType.MAP, (short)5);
	 private static final org.apache.storm.thrift.protocol.TField TOTAL_SHARED_OFF_HEAP_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(""total_shared_off_heap"", org.apache.storm.thrift.protocol.TType.MAP, (short)6);
	 private static final org.apache.storm.thrift.protocol.TField OWNER_FIELD_DESC = new org.apache.storm.thrift.protocol.TField(""owner"", org.apache.storm.thrift.protocol.TType.STRING, (short)7);
	 private static final org.apache.storm.thrift.scheme.SchemeFactory STANDARD_SCHEME_FACTORY = new AssignmentStandardSchemeFactory();
	 private static final org.apache.storm.thrift.scheme.SchemeFactory TUPLE_SCHEME_FACTORY = new AssignmentTupleSchemeFactory();
	 private java.lang.String master_code_dir;
	 private java.util.Map<java.lang.String,java.lang.String> node_host;
	 private java.util.Map<java.util.List<java.lang.Long>,NodeInfo> executor_node_port;
	 private java.util.Map<java.util.List<java.lang.Long>,java.lang.Long> executor_start_time_secs;
	 private java.util.Map<NodeInfo,WorkerResources> worker_resources;
	 private java.util.Map<java.lang.String,java.lang.Double> total_shared_off_heap;
	 private java.lang.String owner;
	 public enum _Fields implements org.apache.storm.thrift.TFieldIdEnum {
		 MASTER_CODE_DIR((short)1, ""master_code_dir""), NODE_HOST((short)2, ""node_host""), EXECUTOR_NODE_PORT((short)3, ""executor_node_port""), EXECUTOR_START_TIME_SECS((short)4, ""executor_start_time_secs""), WORKER_RESOURCES((short)5, ""worker_resources""), TOTAL_SHARED_OFF_HEAP((short)6, ""total_shared_off_heap""), OWNER((short)7, ""owner"");
		 private static final java.util.Map<java.lang.String, _Fields> byName = new java.util.HashMap<java.lang.String, _Fields>();
		 static {
			 for (_Fields field : java.util.EnumSet.allOf(_Fields.class)) {
				 byName.put(field.getFieldName(), field);
			 }
		 }
		 public static _Fields findByThriftId(int fieldId) {
			 switch(fieldId) {
				 case 1: return MASTER_CODE_DIR;
				 case 2: return NODE_HOST;
				 case 3: return EXECUTOR_NODE_PORT;
				 case 4: return EXECUTOR_START_TIME_SECS;
				 case 5: return WORKER_RESOURCES;
				 case 6: return TOTAL_SHARED_OFF_HEAP;
				 case 7: return OWNER;
				 default: return null;
			 }
		 }
		 public static _Fields findByThriftIdOrThrow(int fieldId) {
			 _Fields fields = findByThriftId(fieldId);
			 if (fields == null) throw new java.lang.IllegalArgumentException(""Field "" + fieldId + "" doesn't exist!"");
			 return fields;
		 }
		 public static _Fields findByName(java.lang.String name) {
			 return byName.get(name);
		 }
		 private final short _thriftId;
		 private final java.lang.String _fieldName;
		 _Fields(short thriftId, java.lang.String fieldName) {
			 _thriftId = thriftId;
			 _fieldName = fieldName;
		 }
		 public short getThriftFieldId() {
			 return _thriftId;
		 }
		 public java.lang.String getFieldName() {
			 return _fieldName;
		 }
	 }
	 private static final _Fields optionals[] = {
	_Fields.NODE_HOST,_Fields.EXECUTOR_NODE_PORT,_Fields.EXECUTOR_START_TIME_SECS,_Fields.WORKER_RESOURCES,_Fields.TOTAL_SHARED_OFF_HEAP,_Fields.OWNER}
	;
	 public static final java.util.Map<_Fields, org.apache.storm.thrift.meta_data.FieldMetaData> metaDataMap;
	 static {
		 java.util.Map<_Fields, org.apache.storm.thrift.meta_data.FieldMetaData> tmpMap = new java.util.EnumMap<_Fields, org.apache.storm.thrift.meta_data.FieldMetaData>(_Fields.class);
		 tmpMap.put(_Fields.MASTER_CODE_DIR, new org.apache.storm.thrift.meta_data.FieldMetaData(""master_code_dir"", org.apache.storm.thrift.TFieldRequirementType.REQUIRED, new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.STRING)));
		 tmpMap.put(_Fields.NODE_HOST, new org.apache.storm.thrift.meta_data.FieldMetaData(""node_host"", org.apache.storm.thrift.TFieldRequirementType.OPTIONAL, new org.apache.storm.thrift.meta_data.MapMetaData(org.apache.storm.thrift.protocol.TType.MAP, new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.STRING), new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.STRING))));
		 tmpMap.put(_Fields.EXECUTOR_NODE_PORT, new org.apache.storm.thrift.meta_data.FieldMetaData(""executor_node_port"", org.apache.storm.thrift.TFieldRequirementType.OPTIONAL, new org.apache.storm.thrift.meta_data.MapMetaData(org.apache.storm.thrift.protocol.TType.MAP, new org.apache.storm.thrift.meta_data.ListMetaData(org.apache.storm.thrift.protocol.TType.LIST, new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.I64)), new org.apache.storm.thrift.meta_data.StructMetaData(org.apache.storm.thrift.protocol.TType.STRUCT, NodeInfo.class))));
		 tmpMap.put(_Fields.EXECUTOR_START_TIME_SECS, new org.apache.storm.thrift.meta_data.FieldMetaData(""executor_start_time_secs"", org.apache.storm.thrift.TFieldRequirementType.OPTIONAL, new org.apache.storm.thrift.meta_data.MapMetaData(org.apache.storm.thrift.protocol.TType.MAP, new org.apache.storm.thrift.meta_data.ListMetaData(org.apache.storm.thrift.protocol.TType.LIST, new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.I64)), new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.I64))));
		 tmpMap.put(_Fields.WORKER_RESOURCES, new org.apache.storm.thrift.meta_data.FieldMetaData(""worker_resources"", org.apache.storm.thrift.TFieldRequirementType.OPTIONAL, new org.apache.storm.thrift.meta_data.MapMetaData(org.apache.storm.thrift.protocol.TType.MAP, new org.apache.storm.thrift.meta_data.StructMetaData(org.apache.storm.thrift.protocol.TType.STRUCT, NodeInfo.class), new org.apache.storm.thrift.meta_data.StructMetaData(org.apache.storm.thrift.protocol.TType.STRUCT, WorkerResources.class))));
		 tmpMap.put(_Fields.TOTAL_SHARED_OFF_HEAP, new org.apache.storm.thrift.meta_data.FieldMetaData(""total_shared_off_heap"", org.apache.storm.thrift.TFieldRequirementType.OPTIONAL, new org.apache.storm.thrift.meta_data.MapMetaData(org.apache.storm.thrift.protocol.TType.MAP, new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.STRING), new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.DOUBLE))));
		 tmpMap.put(_Fields.OWNER, new org.apache.storm.thrift.meta_data.FieldMetaData(""owner"", org.apache.storm.thrift.TFieldRequirementType.OPTIONAL, new org.apache.storm.thrift.meta_data.FieldValueMetaData(org.apache.storm.thrift.protocol.TType.STRING)));
		 metaDataMap = java.util.Collections.unmodifiableMap(tmpMap);
		 org.apache.storm.thrift.meta_data.FieldMetaData.addStructMetaDataMap(Assignment.class, metaDataMap);
	 }
	 public Assignment() {
		 this.node_host = new java.util.HashMap<java.lang.String,java.lang.String>();
		 this.executor_node_port = new java.util.HashMap<java.util.List<java.lang.Long>,NodeInfo>();
		 this.executor_start_time_secs = new java.util.HashMap<java.util.List<java.lang.Long>,java.lang.Long>();
		 this.worker_resources = new java.util.HashMap<NodeInfo,WorkerResources>();
		 this.total_shared_off_heap = new java.util.HashMap<java.lang.String,java.lang.Double>();
	 }
	 public Assignment( java.lang.String master_code_dir) {
		 this();
		 this.master_code_dir = master_code_dir;
	 }
	 public Assignment(Assignment other) {
		 if (other.is_set_master_code_dir()) {
			 this.master_code_dir = other.master_code_dir;
		 }
		 if (other.is_set_node_host()) {
			 java.util.Map<java.lang.String,java.lang.String> __this__node_host = new java.util.HashMap<java.lang.String,java.lang.String>(other.node_host);
			 this.node_host = __this__node_host;
		 }
		 if (other.is_set_executor_node_port()) {
			 java.util.Map<java.util.List<java.lang.Long>,NodeInfo> __this__executor_node_port = new java.util.HashMap<java.util.List<java.lang.Long>,NodeInfo>(other.executor_node_port.size());
			 for (java.util.Map.Entry<java.util.List<java.lang.Long>, NodeInfo> other_element : other.executor_node_port.entrySet()) {
				 java.util.List<java.lang.Long> other_element_key = other_element.getKey();
				 NodeInfo other_element_value = other_element.getValue();
				 java.util.List<java.lang.Long> __this__executor_node_port_copy_key = new java.util.ArrayList<java.lang.Long>(other_element_key);
				 NodeInfo __this__executor_node_port_copy_value = new NodeInfo(other_element_value);
				 __this__executor_node_port.put(__this__executor_node_port_copy_key, __this__executor_node_port_copy_value);
			 }
			 this.executor_node_port = __this__executor_node_port;
		 }
		 if (other.is_set_executor_start_time_secs()) {
			 java.util.Map<java.util.List<java.lang.Long>,java.lang.Long> __this__executor_start_time_secs = new java.util.HashMap<java.util.List<java.lang.Long>,java.lang.Long>(other.executor_start_time_secs.size());
			 for (java.util.Map.Entry<java.util.List<java.lang.Long>, java.lang.Long> other_element : other.executor_start_time_secs.entrySet()) {
				 java.util.List<java.lang.Long> other_element_key = other_element.getKey();
				 java.lang.Long other_element_value = other_element.getValue();
				 java.util.List<java.lang.Long> __this__executor_start_time_secs_copy_key = new java.util.ArrayList<java.lang.Long>(other_element_key);
				 java.lang.Long __this__executor_start_time_secs_copy_value = other_element_value;
				 __this__executor_start_time_secs.put(__this__executor_start_time_secs_copy_key, __this__executor_start_time_secs_copy_value);
			 }
			 this.executor_start_time_secs = __this__executor_start_time_secs;
		 }
		 if (other.is_set_worker_resources()) {
			 java.util.Map<NodeInfo,WorkerResources> __this__worker_resources = new java.util.HashMap<NodeInfo,WorkerResources>(other.worker_resources.size());
			 for (java.util.Map.Entry<NodeInfo, WorkerResources> other_element : other.worker_resources.entrySet()) {
				 NodeInfo other_element_key = other_element.getKey();
				 WorkerResources other_element_value = other_element.getValue();
				 NodeInfo __this__worker_resources_copy_key = new NodeInfo(other_element_key);
				 WorkerResources __this__worker_resources_copy_value = new WorkerResources(other_element_value);
				 __this__worker_resources.put(__this__worker_resources_copy_key, __this__worker_resources_copy_value);
			 }
			 this.worker_resources = __this__worker_resources;
		 }
		 if (other.is_set_total_shared_off_heap()) {
			 java.util.Map<java.lang.String,java.lang.Double> __this__total_shared_off_heap = new java.util.HashMap<java.lang.String,java.lang.Double>(other.total_shared_off_heap);
			 this.total_shared_off_heap = __this__total_shared_off_heap;
		 }
		 if (other.is_set_owner()) {
			 this.owner = other.owner;
		 }
	 }
	 public Assignment deepCopy() {
		 return new Assignment(this);
	 }
	 public void clear() {
		 this.master_code_dir = null;
		 this.node_host = new java.util.HashMap<java.lang.String,java.lang.String>();
		 this.executor_node_port = new java.util.HashMap<java.util.List<java.lang.Long>,NodeInfo>();
		 this.executor_start_time_secs = new java.util.HashMap<java.util.List<java.lang.Long>,java.lang.Long>();
		 this.worker_resources = new java.util.HashMap<NodeInfo,WorkerResources>();
		 this.total_shared_off_heap = new java.util.HashMap<java.lang.String,java.lang.Double>();
		 this.owner = null;
	 }
	 public java.lang.String get_master_code_dir() {
		 return this.master_code_dir;
	 }
	 public void set_master_code_dir( java.lang.String master_code_dir) {
		 this.master_code_dir = master_code_dir;
	 }
	 public void unset_master_code_dir() {
		 this.master_code_dir = null;
	 }
	 public boolean is_set_master_code_dir() {
		 return this.master_code_dir != null;
	 }
	 public void set_master_code_dir_isSet(boolean value) {
		 if (!value) {
			 this.master_code_dir = null;
		 }
	 }
	 public int get_node_host_size() {
		 return (this.node_host == null) ? 0 : this.node_host.size();
	 }
	 public void put_to_node_host(java.lang.String key, java.lang.String val) {
		 if (this.node_host == null) {
			 this.node_host = new java.util.HashMap<java.lang.String,java.lang.String>();
		 }
		 this.node_host.put(key, val);
	 }
	 public java.util.Map<java.lang.String,java.lang.String> get_node_host() {
		 return this.node_host;
	 }
	 public void set_node_host( java.util.Map<java.lang.String,java.lang.String> node_host) {
		 this.node_host = node_host;
	 }
	 public void unset_node_host() {
		 this.node_host = null;
	 }
	 public boolean is_set_node_host() {
		 return this.node_host != null;
	 }
	 public void set_node_host_isSet(boolean value) {
		 if (!value) {
			 this.node_host = null;
		 }
	 }
	 public int get_executor_node_port_size() {
		 return (this.executor_node_port == null) ? 0 : this.executor_node_port.size();
	 }
	 public void put_to_executor_node_port(java.util.List<java.lang.Long> key, NodeInfo val) {
		 if (this.executor_node_port == null) {
			 this.executor_node_port = new java.util.HashMap<java.util.List<java.lang.Long>,NodeInfo>();
		 }
		 this.executor_node_port.put(key, val);
	 }
	 public java.util.Map<java.util.List<java.lang.Long>,NodeInfo> get_executor_node_port() {
		 return this.executor_node_port;
	 }
	 public void set_executor_node_port( java.util.Map<java.util.List<java.lang.Long>,NodeInfo> executor_node_port) {
		 this.executor_node_port = executor_node_port;
	 }
	 public void unset_executor_node_port() {
		 this.executor_node_port = null;
	 }
	 public boolean is_set_executor_node_port() {
		 return this.executor_node_port != null;
	 }
	 public void set_executor_node_port_isSet(boolean value) {
		 if (!value) {
			 this.executor_node_port = null;
		 }
	 }
	 public int get_executor_start_time_secs_size() {
		 return (this.executor_start_time_secs == null) ? 0 : this.executor_start_time_secs.size();
	 }
	 public void put_to_executor_start_time_secs(java.util.List<java.lang.Long> key, long val) {
		 if (this.executor_start_time_secs == null) {
			 this.executor_start_time_secs = new java.util.HashMap<java.util.List<java.lang.Long>,java.lang.Long>();
		 }
		 this.executor_start_time_secs.put(key, val);
	 }
	 public java.util.Map<java.util.List<java.lang.Long>,java.lang.Long> get_executor_start_time_secs() {
		 return this.executor_start_time_secs;
	 }
	 public void set_executor_start_time_secs( java.util.Map<java.util.List<java.lang.Long>,java.lang.Long> executor_start_time_secs) {
		 this.executor_start_time_secs = executor_start_time_secs;
	 }
	 public void unset_executor_start_time_secs() {
		 this.executor_start_time_secs = null;
	 }
	 public boolean is_set_executor_start_time_secs() {
		 return this.executor_start_time_secs != null;
	 }
	 public void set_executor_start_time_secs_isSet(boolean value) {
		 if (!value) {
			 this.executor_start_time_secs = null;
		 }
	 }
	 public int get_worker_resources_size() {
		 return (this.worker_resources == null) ? 0 : this.worker_resources.size();
	 }
	 public void put_to_worker_resources(NodeInfo key, WorkerResources val) {
		 if (this.worker_resources == null) {
			 this.worker_resources = new java.util.HashMap<NodeInfo,WorkerResources>();
		 }
		 this.worker_resources.put(key, val);
	 }
	 public java.util.Map<NodeInfo,WorkerResources> get_worker_resources() {
		 return this.worker_resources;
	 }
	 public void set_worker_resources( java.util.Map<NodeInfo,WorkerResources> worker_resources) {
		 this.worker_resources = worker_resources;
	 }
	 public void unset_worker_resources() {
		 this.worker_resources = null;
	 }
	 public boolean is_set_worker_resources() {
		 return this.worker_resources != null;
	 }
	 public void set_worker_resources_isSet(boolean value) {
		 if (!value) {
			 this.worker_resources = null;
		 }
	 }
	 public int get_total_shared_off_heap_size() {
		 return (this.total_shared_off_heap == null) ? 0 : this.total_shared_off_heap.size();
	 }
	 public void put_to_total_shared_off_heap(java.lang.String key, double val) {
		 if (this.total_shared_off_heap == null) {
			 this.total_shared_off_heap = new java.util.HashMap<java.lang.String,java.lang.Double>();
		 }
		 this.total_shared_off_heap.put(key, val);
	 }
	 public java.util.Map<java.lang.String,java.lang.Double> get_total_shared_off_heap() {
		 return this.total_shared_off_heap;
	 }
	 public void set_total_shared_off_heap( java.util.Map<java.lang.String,java.lang.Double> total_shared_off_heap) {
		 this.total_shared_off_heap = total_shared_off_heap;
	 }
	 public void unset_total_shared_off_heap() {
		 this.total_shared_off_heap = null;
	 }
	 public boolean is_set_total_shared_off_heap() {
		 return this.total_shared_off_heap != null;
	 }
	 public void set_total_shared_off_heap_isSet(boolean value) {
		 if (!value) {
			 this.total_shared_off_heap = null;
		 }
	 }
	 public java.lang.String get_owner() {
		 return this.owner;
	 }
	 public void set_owner( java.lang.String owner) {
		 this.owner = owner;
	 }
	 public void unset_owner() {
		 this.owner = null;
	 }
	 public boolean is_set_owner() {
		 return this.owner != null;
	 }
	 public void set_owner_isSet(boolean value) {
		 if (!value) {
			 this.owner = null;
		 }
	 }
	 public void setFieldValue(_Fields field, java.lang.Object value) {
		 switch (field) {
			 case MASTER_CODE_DIR: if (value == null) {
				 unset_master_code_dir();
			 }
			 else {
				 set_master_code_dir((java.lang.String)value);
			 }
			 break;
			 case NODE_HOST: if (value == null) {
				 unset_node_host();
			 }
			 else {
				 set_node_host((java.util.Map<java.lang.String,java.lang.String>)value);
			 }
			 break;
			 case EXECUTOR_NODE_PORT: if (value == null) {
				 unset_executor_node_port();
			 }
			 else {
				 set_executor_node_port((java.util.Map<java.util.List<java.lang.Long>,NodeInfo>)value);
			 }
			 break;
			 case EXECUTOR_START_TIME_SECS: if (value == null) {
				 unset_executor_start_time_secs();
			 }
			 else {
				 set_executor_start_time_secs((java.util.Map<java.util.List<java.lang.Long>,java.lang.Long>)value);
			 }
			 break;
			 case WORKER_RESOURCES: if (value == null) {
				 unset_worker_resources();
			 }
			 else {
				 set_worker_resources((java.util.Map<NodeInfo,WorkerResources>)value);
			 }
			 break;
			 case TOTAL_SHARED_OFF_HEAP: if (value == null) {
				 unset_total_shared_off_heap();
			 }
			 else {
				 set_total_shared_off_heap((java.util.Map<java.lang.String,java.lang.Double>)value);
			 }
			 break;
			 case OWNER: if (value == null) {
				 unset_owner();
			 }
			 else {
				 set_owner((java.lang.String)value);
			 }
			 break;
		 }
	 }
	 public java.lang.Object getFieldValue(_Fields field) {
		 switch (field) {
			 case MASTER_CODE_DIR: return get_master_code_dir();
			 case NODE_HOST: return get_node_host();
			 case EXECUTOR_NODE_PORT: return get_executor_node_port();
			 case EXECUTOR_START_TIME_SECS: return get_executor_start_time_secs();
			 case WORKER_RESOURCES: return get_worker_resources();
			 case TOTAL_SHARED_OFF_HEAP: return get_total_shared_off_heap();
			 case OWNER: return get_owner();
		 }
		 throw new java.lang.IllegalStateException();
	 }
	 public boolean isSet(_Fields field) {
		 if (field == null) {
			 throw new java.lang.IllegalArgumentException();
		 }
		 switch (field) {
			 case MASTER_CODE_DIR: return is_set_master_code_dir();
			 case NODE_HOST: return is_set_node_host();
			 case EXECUTOR_NODE_PORT: return is_set_executor_node_port();
			 case EXECUTOR_START_TIME_SECS: return is_set_executor_start_time_secs();
			 case WORKER_RESOURCES: return is_set_worker_resources();
			 case TOTAL_SHARED_OFF_HEAP: return is_set_total_shared_off_heap();
			 case OWNER: return is_set_owner();
		 }
		 throw new java.lang.IllegalStateException();
	 }
	 public boolean equals(java.lang.Object that) {
		 if (that == null) return false;
		 if (that instanceof Assignment) return this.equals((Assignment)that);
		 return false;
	 }
	 public boolean equals(Assignment that) {
		 if (that == null) return false;
		 if (this == that) return true;
		 boolean this_present_master_code_dir = true && this.is_set_master_code_dir();
		 boolean that_present_master_code_dir = true && that.is_set_master_code_dir();
		 if (this_present_master_code_dir || that_present_master_code_dir) {
			 if (!(this_present_master_code_dir && that_present_master_code_dir)) return false;
			 if (!this.master_code_dir.equals(that.master_code_dir)) return false;
		 }
		 boolean this_present_node_host = true && this.is_set_node_host();
		 boolean that_present_node_host = true && that.is_set_node_host();
		 if (this_present_node_host || that_present_node_host) {
			 if (!(this_present_node_host && that_present_node_host)) return false;
			 if (!this.node_host.equals(that.node_host)) return false;
		 }
		 boolean this_present_executor_node_port = true && this.is_set_executor_node_port();
		 boolean that_present_executor_node_port = true && that.is_set_executor_node_port();
		 if (this_present_executor_node_port || that_present_executor_node_port) {
			 if (!(this_present_executor_node_port && that_present_executor_node_port)) return false;
			 if (!this.executor_node_port.equals(that.executor_node_port)) return false;
		 }
		 boolean this_present_executor_start_time_secs = true && this.is_set_executor_start_time_secs();
		 boolean that_present_executor_start_time_secs = true && that.is_set_executor_start_time_secs();
		 if (this_present_executor_start_time_secs || that_present_executor_start_time_secs) {
			 if (!(this_present_executor_start_time_secs && that_present_executor_start_time_secs)) return false;
			 if (!this.executor_start_time_secs.equals(that.executor_start_time_secs)) return false;
		 }
		 boolean this_present_worker_resources = true && this.is_set_worker_resources();
		 boolean that_present_worker_resources = true && that.is_set_worker_resources();
		 if (this_present_worker_resources || that_present_worker_resources) {
			 if (!(this_present_worker_resources && that_present_worker_resources)) return false;
			 if (!this.worker_resources.equals(that.worker_resources)) return false;
		 }
		 boolean this_present_total_shared_off_heap = true && this.is_set_total_shared_off_heap();
		 boolean that_present_total_shared_off_heap = true && that.is_set_total_shared_off_heap();
		 if (this_present_total_shared_off_heap || that_present_total_shared_off_heap) {
			 if (!(this_present_total_shared_off_heap && that_present_total_shared_off_heap)) return false;
			 if (!this.total_shared_off_heap.equals(that.total_shared_off_heap)) return false;
		 }
		 boolean this_present_owner = true && this.is_set_owner();
		 boolean that_present_owner = true && that.is_set_owner();
		 if (this_present_owner || that_present_owner) {
			 if (!(this_present_owner && that_present_owner)) return false;
			 if (!this.owner.equals(that.owner)) return false;
		 }
		 return true;
	 }
	 public int hashCode() {
		 int hashCode = 1;
		 hashCode = hashCode * 8191 + ((is_set_master_code_dir()) ? 131071 : 524287);
		 if (is_set_master_code_dir()) hashCode = hashCode * 8191 + master_code_dir.hashCode();
		 hashCode = hashCode * 8191 + ((is_set_node_host()) ? 131071 : 524287);
		 if (is_set_node_host()) hashCode = hashCode * 8191 + node_host.hashCode();
		 hashCode = hashCode * 8191 + ((is_set_executor_node_port()) ? 131071 : 524287);
		 if (is_set_executor_node_port()) hashCode = hashCode * 8191 + executor_node_port.hashCode();
		 hashCode = hashCode * 8191 + ((is_set_executor_start_time_secs()) ? 131071 : 524287);
		 if (is_set_executor_start_time_secs()) hashCode = hashCode * 8191 + executor_start_time_secs.hashCode();
		 hashCode = hashCode * 8191 + ((is_set_worker_resources()) ? 131071 : 524287);
		 if (is_set_worker_resources()) hashCode = hashCode * 8191 + worker_resources.hashCode();
		 hashCode = hashCode * 8191 + ((is_set_total_shared_off_heap()) ? 131071 : 524287);
		 if (is_set_total_shared_off_heap()) hashCode = hashCode * 8191 + total_shared_off_heap.hashCode();
		 hashCode = hashCode * 8191 + ((is_set_owner()) ? 131071 : 524287);
		 if (is_set_owner()) hashCode = hashCode * 8191 + owner.hashCode();
		 return hashCode;
	 }
	 public int compareTo(Assignment other) {
		 if (!getClass().equals(other.getClass())) {
			 return getClass().getName().compareTo(other.getClass().getName());
		 }
		 int lastComparison = 0;
		 lastComparison = java.lang.Boolean.valueOf(is_set_master_code_dir()).compareTo(other.is_set_master_code_dir());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (is_set_master_code_dir()) {
			 lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.master_code_dir, other.master_code_dir);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 lastComparison = java.lang.Boolean.valueOf(is_set_node_host()).compareTo(other.is_set_node_host());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (is_set_node_host()) {
			 lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.node_host, other.node_host);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 lastComparison = java.lang.Boolean.valueOf(is_set_executor_node_port()).compareTo(other.is_set_executor_node_port());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (is_set_executor_node_port()) {
			 lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.executor_node_port, other.executor_node_port);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 lastComparison = java.lang.Boolean.valueOf(is_set_executor_start_time_secs()).compareTo(other.is_set_executor_start_time_secs());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (is_set_executor_start_time_secs()) {
			 lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.executor_start_time_secs, other.executor_start_time_secs);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 lastComparison = java.lang.Boolean.valueOf(is_set_worker_resources()).compareTo(other.is_set_worker_resources());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (is_set_worker_resources()) {
			 lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.worker_resources, other.worker_resources);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 lastComparison = java.lang.Boolean.valueOf(is_set_total_shared_off_heap()).compareTo(other.is_set_total_shared_off_heap());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (is_set_total_shared_off_heap()) {
			 lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.total_shared_off_heap, other.total_shared_off_heap);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 lastComparison = java.lang.Boolean.valueOf(is_set_owner()).compareTo(other.is_set_owner());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (is_set_owner()) {
			 lastComparison = org.apache.storm.thrift.TBaseHelper.compareTo(this.owner, other.owner);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 return 0;
	 }
	 public _Fields fieldForId(int fieldId) {
		 return _Fields.findByThriftId(fieldId);
	 }
	 public void read(org.apache.storm.thrift.protocol.TProtocol iprot) throws org.apache.storm.thrift.TException {
		 scheme(iprot).read(iprot, this);
	 }
	 public void write(org.apache.storm.thrift.protocol.TProtocol oprot) throws org.apache.storm.thrift.TException {
		 scheme(oprot).write(oprot, this);
	 }
	 public java.lang.String toString() {
		 java.lang.StringBuilder sb = new java.lang.StringBuilder(""Assignment("");
		 boolean first = true;
		 sb.append(""master_code_dir:"");
		 if (this.master_code_dir == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.master_code_dir);
		 }
		 first = false;
		 if (is_set_node_host()) {
			 if (!first) sb.append("", "");
			 sb.append(""node_host:"");
			 if (this.node_host == null) {
				 sb.append(""null"");
			 }
			 else {
				 sb.append(this.node_host);
			 }
			 first = false;
		 }
		 if (is_set_executor_node_port()) {
			 if (!first) sb.append("", "");
			 sb.append(""executor_node_port:"");
			 if (this.executor_node_port == null) {
				 sb.append(""null"");
			 }
			 else {
				 sb.append(this.executor_node_port);
			 }
			 first = false;
		 }
		 if (is_set_executor_start_time_secs()) {
			 if (!first) sb.append("", "");
			 sb.append(""executor_start_time_secs:"");
			 if (this.executor_start_time_secs == null) {
				 sb.append(""null"");
			 }
			 else {
				 sb.append(this.executor_start_time_secs);
			 }
			 first = false;
		 }
		 if (is_set_worker_resources()) {
			 if (!first) sb.append("", "");
			 sb.append(""worker_resources:"");
			 if (this.worker_resources == null) {
				 sb.append(""null"");
			 }
			 else {
				 sb.append(this.worker_resources);
			 }
			 first = false;
		 }
		 if (is_set_total_shared_off_heap()) {
			 if (!first) sb.append("", "");
			 sb.append(""total_shared_off_heap:"");
			 if (this.total_shared_off_heap == null) {
				 sb.append(""null"");
			 }
			 else {
				 sb.append(this.total_shared_off_heap);
			 }
			 first = false;
		 }
		 if (is_set_owner()) {
			 if (!first) sb.append("", "");
			 sb.append(""owner:"");
			 if (this.owner == null) {
				 sb.append(""null"");
			 }
			 else {
				 sb.append(this.owner);
			 }
			 first = false;
		 }
		 sb.append("")"");
		 return sb.toString();
	 }
	 public void validate() throws org.apache.storm.thrift.TException {
		 if (!is_set_master_code_dir()) {
			 throw new org.apache.storm.thrift.protocol.TProtocolException(""Required field 'master_code_dir' is unset! Struct:"" + toString());
		 }
	 }
	 private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
		 try {
			 write(new org.apache.storm.thrift.protocol.TCompactProtocol(new org.apache.storm.thrift.transport.TIOStreamTransport(out)));
		 }
		 catch (org.apache.storm.thrift.TException te) {
			 throw new java.io.IOException(te);
		 }
	 }
	 private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException {
		 try {
			 read(new org.apache.storm.thrift.protocol.TCompactProtocol(new org.apache.storm.thrift.transport.TIOStreamTransport(in)));
		 }
		 catch (org.apache.storm.thrift.TException te) {
			 throw new java.io.IOException(te);
		 }
	 }
	 private static class AssignmentStandardSchemeFactory implements org.apache.storm.thrift.scheme.SchemeFactory {
		 public AssignmentStandardScheme getScheme() {
			 return new AssignmentStandardScheme();
		 }
	 }
	 private static class AssignmentStandardScheme extends org.apache.storm.thrift.scheme.StandardScheme<Assignment> {
		 public void read(org.apache.storm.thrift.protocol.TProtocol iprot, Assignment struct) throws org.apache.storm.thrift.TException {
			 org.apache.storm.thrift.protocol.TField schemeField;
			 iprot.readStructBegin();
			 while (true) {
				 schemeField = iprot.readFieldBegin();
				 if (schemeField.type == org.apache.storm.thrift.protocol.TType.STOP) {
					 break;
				 }
				 switch (schemeField.id) {
					 case 1: if (schemeField.type == org.apache.storm.thrift.protocol.TType.STRING) {
						 struct.master_code_dir = iprot.readString();
						 struct.set_master_code_dir_isSet(true);
					 }
					 else {
						 org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 case 2: if (schemeField.type == org.apache.storm.thrift.protocol.TType.MAP) {
						 {
							 org.apache.storm.thrift.protocol.TMap _map686 = iprot.readMapBegin();
							 struct.node_host = new java.util.HashMap<java.lang.String,java.lang.String>(2*_map686.size);
							 java.lang.String _key687;
							 java.lang.String _val688;
							 for (int _i689 = 0;
							 _i689 < _map686.size;
							 ++_i689) {
								 _key687 = iprot.readString();
								 _val688 = iprot.readString();
								 struct.node_host.put(_key687, _val688);
							 }
							 iprot.readMapEnd();
						 }
						 struct.set_node_host_isSet(true);
					 }
					 else {
						 org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 case 3: if (schemeField.type == org.apache.storm.thrift.protocol.TType.MAP) {
						 {
							 org.apache.storm.thrift.protocol.TMap _map690 = iprot.readMapBegin();
							 struct.executor_node_port = new java.util.HashMap<java.util.List<java.lang.Long>,NodeInfo>(2*_map690.size);
							 java.util.List<java.lang.Long> _key691;
							 NodeInfo _val692;
							 for (int _i693 = 0;
							 _i693 < _map690.size;
							 ++_i693) {
								 {
									 org.apache.storm.thrift.protocol.TList _list694 = iprot.readListBegin();
									 _key691 = new java.util.ArrayList<java.lang.Long>(_list694.size);
									 long _elem695;
									 for (int _i696 = 0;
									 _i696 < _list694.size;
									 ++_i696) {
										 _elem695 = iprot.readI64();
										 _key691.add(_elem695);
									 }
									 iprot.readListEnd();
								 }
								 _val692 = new NodeInfo();
								 _val692.read(iprot);
								 struct.executor_node_port.put(_key691, _val692);
							 }
							 iprot.readMapEnd();
						 }
						 struct.set_executor_node_port_isSet(true);
					 }
					 else {
						 org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 case 4: if (schemeField.type == org.apache.storm.thrift.protocol.TType.MAP) {
						 {
							 org.apache.storm.thrift.protocol.TMap _map697 = iprot.readMapBegin();
							 struct.executor_start_time_secs = new java.util.HashMap<java.util.List<java.lang.Long>,java.lang.Long>(2*_map697.size);
							 java.util.List<java.lang.Long> _key698;
							 long _val699;
							 for (int _i700 = 0;
							 _i700 < _map697.size;
							 ++_i700) {
								 {
									 org.apache.storm.thrift.protocol.TList _list701 = iprot.readListBegin();
									 _key698 = new java.util.ArrayList<java.lang.Long>(_list701.size);
									 long _elem702;
									 for (int _i703 = 0;
									 _i703 < _list701.size;
									 ++_i703) {
										 _elem702 = iprot.readI64();
										 _key698.add(_elem702);
									 }
									 iprot.readListEnd();
								 }
								 _val699 = iprot.readI64();
								 struct.executor_start_time_secs.put(_key698, _val699);
							 }
							 iprot.readMapEnd();
						 }
						 struct.set_executor_start_time_secs_isSet(true);
					 }
					 else {
						 org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 case 5: if (schemeField.type == org.apache.storm.thrift.protocol.TType.MAP) {
						 {
							 org.apache.storm.thrift.protocol.TMap _map704 = iprot.readMapBegin();
							 struct.worker_resources = new java.util.HashMap<NodeInfo,WorkerResources>(2*_map704.size);
							 NodeInfo _key705;
							 WorkerResources _val706;
							 for (int _i707 = 0;
							 _i707 < _map704.size;
							 ++_i707) {
								 _key705 = new NodeInfo();
								 _key705.read(iprot);
								 _val706 = new WorkerResources();
								 _val706.read(iprot);
								 struct.worker_resources.put(_key705, _val706);
							 }
							 iprot.readMapEnd();
						 }
						 struct.set_worker_resources_isSet(true);
					 }
					 else {
						 org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 case 6: if (schemeField.type == org.apache.storm.thrift.protocol.TType.MAP) {
						 {
							 org.apache.storm.thrift.protocol.TMap _map708 = iprot.readMapBegin();
							 struct.total_shared_off_heap = new java.util.HashMap<java.lang.String,java.lang.Double>(2*_map708.size);
							 java.lang.String _key709;
							 double _val710;
							 for (int _i711 = 0;
							 _i711 < _map708.size;
							 ++_i711) {
								 _key709 = iprot.readString();
								 _val710 = iprot.readDouble();
								 struct.total_shared_off_heap.put(_key709, _val710);
							 }
							 iprot.readMapEnd();
						 }
						 struct.set_total_shared_off_heap_isSet(true);
					 }
					 else {
						 org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 case 7: if (schemeField.type == org.apache.storm.thrift.protocol.TType.STRING) {
						 struct.owner = iprot.readString();
						 struct.set_owner_isSet(true);
					 }
					 else {
						 org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 default: org.apache.storm.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 iprot.readFieldEnd();
			 }
			 iprot.readStructEnd();
			 struct.validate();
		 }
		 public void write(org.apache.storm.thrift.protocol.TProtocol oprot, Assignment struct) throws org.apache.storm.thrift.TException {
			 struct.validate();
			 oprot.writeStructBegin(STRUCT_DESC);
			 if (struct.master_code_dir != null) {
				 oprot.writeFieldBegin(MASTER_CODE_DIR_FIELD_DESC);
				 oprot.writeString(struct.master_code_dir);
				 oprot.writeFieldEnd();
			 }
			 if (struct.node_host != null) {
				 if (struct.is_set_node_host()) {
					 oprot.writeFieldBegin(NODE_HOST_FIELD_DESC);
					 {
						 oprot.writeMapBegin(new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.STRING, org.apache.storm.thrift.protocol.TType.STRING, struct.node_host.size()));
						 for (java.util.Map.Entry<java.lang.String, java.lang.String> _iter712 : struct.node_host.entrySet()) {
							 oprot.writeString(_iter712.getKey());
							 oprot.writeString(_iter712.getValue());
						 }
						 oprot.writeMapEnd();
					 }
					 oprot.writeFieldEnd();
				 }
			 }
			 if (struct.executor_node_port != null) {
				 if (struct.is_set_executor_node_port()) {
					 oprot.writeFieldBegin(EXECUTOR_NODE_PORT_FIELD_DESC);
					 {
						 oprot.writeMapBegin(new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.LIST, org.apache.storm.thrift.protocol.TType.STRUCT, struct.executor_node_port.size()));
						 for (java.util.Map.Entry<java.util.List<java.lang.Long>, NodeInfo> _iter713 : struct.executor_node_port.entrySet()) {
							 {
								 oprot.writeListBegin(new org.apache.storm.thrift.protocol.TList(org.apache.storm.thrift.protocol.TType.I64, _iter713.getKey().size()));
								 for (long _iter714 : _iter713.getKey()) {
									 oprot.writeI64(_iter714);
								 }
								 oprot.writeListEnd();
							 }
							 _iter713.getValue().write(oprot);
						 }
						 oprot.writeMapEnd();
					 }
					 oprot.writeFieldEnd();
				 }
			 }
			 if (struct.executor_start_time_secs != null) {
				 if (struct.is_set_executor_start_time_secs()) {
					 oprot.writeFieldBegin(EXECUTOR_START_TIME_SECS_FIELD_DESC);
					 {
						 oprot.writeMapBegin(new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.LIST, org.apache.storm.thrift.protocol.TType.I64, struct.executor_start_time_secs.size()));
						 for (java.util.Map.Entry<java.util.List<java.lang.Long>, java.lang.Long> _iter715 : struct.executor_start_time_secs.entrySet()) {
							 {
								 oprot.writeListBegin(new org.apache.storm.thrift.protocol.TList(org.apache.storm.thrift.protocol.TType.I64, _iter715.getKey().size()));
								 for (long _iter716 : _iter715.getKey()) {
									 oprot.writeI64(_iter716);
								 }
								 oprot.writeListEnd();
							 }
							 oprot.writeI64(_iter715.getValue());
						 }
						 oprot.writeMapEnd();
					 }
					 oprot.writeFieldEnd();
				 }
			 }
			 if (struct.worker_resources != null) {
				 if (struct.is_set_worker_resources()) {
					 oprot.writeFieldBegin(WORKER_RESOURCES_FIELD_DESC);
					 {
						 oprot.writeMapBegin(new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.STRUCT, org.apache.storm.thrift.protocol.TType.STRUCT, struct.worker_resources.size()));
						 for (java.util.Map.Entry<NodeInfo, WorkerResources> _iter717 : struct.worker_resources.entrySet()) {
							 _iter717.getKey().write(oprot);
							 _iter717.getValue().write(oprot);
						 }
						 oprot.writeMapEnd();
					 }
					 oprot.writeFieldEnd();
				 }
			 }
			 if (struct.total_shared_off_heap != null) {
				 if (struct.is_set_total_shared_off_heap()) {
					 oprot.writeFieldBegin(TOTAL_SHARED_OFF_HEAP_FIELD_DESC);
					 {
						 oprot.writeMapBegin(new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.STRING, org.apache.storm.thrift.protocol.TType.DOUBLE, struct.total_shared_off_heap.size()));
						 for (java.util.Map.Entry<java.lang.String, java.lang.Double> _iter718 : struct.total_shared_off_heap.entrySet()) {
							 oprot.writeString(_iter718.getKey());
							 oprot.writeDouble(_iter718.getValue());
						 }
						 oprot.writeMapEnd();
					 }
					 oprot.writeFieldEnd();
				 }
			 }
			 if (struct.owner != null) {
				 if (struct.is_set_owner()) {
					 oprot.writeFieldBegin(OWNER_FIELD_DESC);
					 oprot.writeString(struct.owner);
					 oprot.writeFieldEnd();
				 }
			 }
			 oprot.writeFieldStop();
			 oprot.writeStructEnd();
		 }
	 }
	 private static class AssignmentTupleSchemeFactory implements org.apache.storm.thrift.scheme.SchemeFactory {
		 public AssignmentTupleScheme getScheme() {
			 return new AssignmentTupleScheme();
		 }
	 }
	 private static class AssignmentTupleScheme extends org.apache.storm.thrift.scheme.TupleScheme<Assignment> {
		 public void write(org.apache.storm.thrift.protocol.TProtocol prot, Assignment struct) throws org.apache.storm.thrift.TException {
			 org.apache.storm.thrift.protocol.TTupleProtocol oprot = (org.apache.storm.thrift.protocol.TTupleProtocol) prot;
			 oprot.writeString(struct.master_code_dir);
			 java.util.BitSet optionals = new java.util.BitSet();
			 if (struct.is_set_node_host()) {
				 optionals.set(0);
			 }
			 if (struct.is_set_executor_node_port()) {
				 optionals.set(1);
			 }
			 if (struct.is_set_executor_start_time_secs()) {
				 optionals.set(2);
			 }
			 if (struct.is_set_worker_resources()) {
				 optionals.set(3);
			 }
			 if (struct.is_set_total_shared_off_heap()) {
				 optionals.set(4);
			 }
			 if (struct.is_set_owner()) {
				 optionals.set(5);
			 }
			 oprot.writeBitSet(optionals, 6);
			 if (struct.is_set_node_host()) {
				 {
					 oprot.writeI32(struct.node_host.size());
					 for (java.util.Map.Entry<java.lang.String, java.lang.String> _iter719 : struct.node_host.entrySet()) {
						 oprot.writeString(_iter719.getKey());
						 oprot.writeString(_iter719.getValue());
					 }
				 }
			 }
			 if (struct.is_set_executor_node_port()) {
				 {
					 oprot.writeI32(struct.executor_node_port.size());
					 for (java.util.Map.Entry<java.util.List<java.lang.Long>, NodeInfo> _iter720 : struct.executor_node_port.entrySet()) {
						 {
							 oprot.writeI32(_iter720.getKey().size());
							 for (long _iter721 : _iter720.getKey()) {
								 oprot.writeI64(_iter721);
							 }
						 }
						 _iter720.getValue().write(oprot);
					 }
				 }
			 }
			 if (struct.is_set_executor_start_time_secs()) {
				 {
					 oprot.writeI32(struct.executor_start_time_secs.size());
					 for (java.util.Map.Entry<java.util.List<java.lang.Long>, java.lang.Long> _iter722 : struct.executor_start_time_secs.entrySet()) {
						 {
							 oprot.writeI32(_iter722.getKey().size());
							 for (long _iter723 : _iter722.getKey()) {
								 oprot.writeI64(_iter723);
							 }
						 }
						 oprot.writeI64(_iter722.getValue());
					 }
				 }
			 }
			 if (struct.is_set_worker_resources()) {
				 {
					 oprot.writeI32(struct.worker_resources.size());
					 for (java.util.Map.Entry<NodeInfo, WorkerResources> _iter724 : struct.worker_resources.entrySet()) {
						 _iter724.getKey().write(oprot);
						 _iter724.getValue().write(oprot);
					 }
				 }
			 }
			 if (struct.is_set_total_shared_off_heap()) {
				 {
					 oprot.writeI32(struct.total_shared_off_heap.size());
					 for (java.util.Map.Entry<java.lang.String, java.lang.Double> _iter725 : struct.total_shared_off_heap.entrySet()) {
						 oprot.writeString(_iter725.getKey());
						 oprot.writeDouble(_iter725.getValue());
					 }
				 }
			 }
			 if (struct.is_set_owner()) {
				 oprot.writeString(struct.owner);
			 }
		 }
		 public void read(org.apache.storm.thrift.protocol.TProtocol prot, Assignment struct) throws org.apache.storm.thrift.TException {
			 org.apache.storm.thrift.protocol.TTupleProtocol iprot = (org.apache.storm.thrift.protocol.TTupleProtocol) prot;
			 struct.master_code_dir = iprot.readString();
			 struct.set_master_code_dir_isSet(true);
			 java.util.BitSet incoming = iprot.readBitSet(6);
			 if (incoming.get(0)) {
				 {
					 org.apache.storm.thrift.protocol.TMap _map726 = new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.STRING, org.apache.storm.thrift.protocol.TType.STRING, iprot.readI32());
					 struct.node_host = new java.util.HashMap<java.lang.String,java.lang.String>(2*_map726.size);
					 java.lang.String _key727;
					 java.lang.String _val728;
					 for (int _i729 = 0;
					 _i729 < _map726.size;
					 ++_i729) {
						 _key727 = iprot.readString();
						 _val728 = iprot.readString();
						 struct.node_host.put(_key727, _val728);
					 }
				 }
				 struct.set_node_host_isSet(true);
			 }
			 if (incoming.get(1)) {
				 {
					 org.apache.storm.thrift.protocol.TMap _map730 = new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.LIST, org.apache.storm.thrift.protocol.TType.STRUCT, iprot.readI32());
					 struct.executor_node_port = new java.util.HashMap<java.util.List<java.lang.Long>,NodeInfo>(2*_map730.size);
					 java.util.List<java.lang.Long> _key731;
					 NodeInfo _val732;
					 for (int _i733 = 0;
					 _i733 < _map730.size;
					 ++_i733) {
						 {
							 org.apache.storm.thrift.protocol.TList _list734 = new org.apache.storm.thrift.protocol.TList(org.apache.storm.thrift.protocol.TType.I64, iprot.readI32());
							 _key731 = new java.util.ArrayList<java.lang.Long>(_list734.size);
							 long _elem735;
							 for (int _i736 = 0;
							 _i736 < _list734.size;
							 ++_i736) {
								 _elem735 = iprot.readI64();
								 _key731.add(_elem735);
							 }
						 }
						 _val732 = new NodeInfo();
						 _val732.read(iprot);
						 struct.executor_node_port.put(_key731, _val732);
					 }
				 }
				 struct.set_executor_node_port_isSet(true);
			 }
			 if (incoming.get(2)) {
				 {
					 org.apache.storm.thrift.protocol.TMap _map737 = new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.LIST, org.apache.storm.thrift.protocol.TType.I64, iprot.readI32());
					 struct.executor_start_time_secs = new java.util.HashMap<java.util.List<java.lang.Long>,java.lang.Long>(2*_map737.size);
					 java.util.List<java.lang.Long> _key738;
					 long _val739;
					 for (int _i740 = 0;
					 _i740 < _map737.size;
					 ++_i740) {
						 {
							 org.apache.storm.thrift.protocol.TList _list741 = new org.apache.storm.thrift.protocol.TList(org.apache.storm.thrift.protocol.TType.I64, iprot.readI32());
							 _key738 = new java.util.ArrayList<java.lang.Long>(_list741.size);
							 long _elem742;
							 for (int _i743 = 0;
							 _i743 < _list741.size;
							 ++_i743) {
								 _elem742 = iprot.readI64();
								 _key738.add(_elem742);
							 }
						 }
						 _val739 = iprot.readI64();
						 struct.executor_start_time_secs.put(_key738, _val739);
					 }
				 }
				 struct.set_executor_start_time_secs_isSet(true);
			 }
			 if (incoming.get(3)) {
				 {
					 org.apache.storm.thrift.protocol.TMap _map744 = new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.STRUCT, org.apache.storm.thrift.protocol.TType.STRUCT, iprot.readI32());
					 struct.worker_resources = new java.util.HashMap<NodeInfo,WorkerResources>(2*_map744.size);
					 NodeInfo _key745;
					 WorkerResources _val746;
					 for (int _i747 = 0;
					 _i747 < _map744.size;
					 ++_i747) {
						 _key745 = new NodeInfo();
						 _key745.read(iprot);
						 _val746 = new WorkerResources();
						 _val746.read(iprot);
						 struct.worker_resources.put(_key745, _val746);
					 }
				 }
				 struct.set_worker_resources_isSet(true);
			 }
			 if (incoming.get(4)) {
				 {
					 org.apache.storm.thrift.protocol.TMap _map748 = new org.apache.storm.thrift.protocol.TMap(org.apache.storm.thrift.protocol.TType.STRING, org.apache.storm.thrift.protocol.TType.DOUBLE, iprot.readI32());
					 struct.total_shared_off_heap = new java.util.HashMap<java.lang.String,java.lang.Double>(2*_map748.size);
					 java.lang.String _key749;
					 double _val750;
					 for (int _i751 = 0;
					 _i751 < _map748.size;
					 ++_i751) {
						 _key749 = iprot.readString();
						 _val750 = iprot.readDouble();
						 struct.total_shared_off_heap.put(_key749, _val750);
					 }
				 }
				 struct.set_total_shared_off_heap_isSet(true);
			 }
			 if (incoming.get(5)) {
				 struct.owner = iprot.readString();
				 struct.set_owner_isSet(true);
			 }
		 }
	 }
	 private static <S extends org.apache.storm.thrift.scheme.IScheme> S scheme(org.apache.storm.thrift.protocol.TProtocol proto) {
		 return (org.apache.storm.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();
	 }
}",1,1,0,0
"class FSEditLog {
	 private static final byte OP_ADD = 0;
	 private static final byte OP_RENAME = 1;
	 private static final byte OP_DELETE = 2;
	 private static final byte OP_MKDIR = 3;
	 private static final byte OP_SET_REPLICATION = 4;
	 private static final byte OP_DATANODE_ADD = 5;
	 private static final byte OP_DATANODE_REMOVE = 6;
	 private File[] editFiles;
	 DataOutputStream[] editStreams = null;
	 FileDescriptor[] editDescriptors = null;
	 FSEditLog( File[] edits ) {
		 this.editFiles = edits;
	 }
	 File[] getEditFiles() {
		 return this.editFiles;
	 }
	 void create() throws IOException {
		 editStreams = new DataOutputStream[editFiles.length];
		 editDescriptors = new FileDescriptor[editFiles.length];
		 for (int idx = 0;
		 idx < editStreams.length;
		 idx++) {
			 FileOutputStream stream = new FileOutputStream(editFiles[idx]);
			 editStreams[idx] = new DataOutputStream(stream);
			 editDescriptors[idx] = stream.getFD();
			 editStreams[idx].writeInt( FSConstants.DFS_CURRENT_VERSION );
		 }
	 }
	 void close() throws IOException {
		 for (int idx = 0;
		 idx < editStreams.length;
		 idx++) {
			 editStreams[idx].flush();
			 editDescriptors[idx].sync();
			 editStreams[idx].close();
		 }
	 }
	 void delete(int idx) throws IOException {
		 if (editStreams != null) {
			 editStreams[idx].close();
		 }
		 editFiles[idx].delete();
	 }
	 void deleteAll() throws IOException {
		 for (int idx = 0;
		 idx < editFiles.length;
		 idx++ ) {
			 if (editStreams != null) {
				 editStreams[idx].close();
			 }
			 editFiles[idx].delete();
		 }
	 }
	 boolean exists() throws IOException {
		 for (int idx = 0;
		 idx < editFiles.length;
		 idx++) {
			 if (editFiles[idx].exists()) {
				 return true;
			 }
		 }
		 return false;
	 }
	 int loadFSEdits( Configuration conf ) throws IOException {
		 FSNamesystem fsNamesys = FSNamesystem.getFSNamesystem();
		 FSDirectory fsDir = fsNamesys.dir;
		 int numEdits = 0;
		 int logVersion = 0;
		 Vector<File> files = new Vector<File>();
		 for (int idx = 0;
		 idx < editFiles.length;
		 idx++) {
			 if (editFiles[idx].exists()) {
				 files.add(editFiles[idx]);
			 }
		 }
		 long maxLength = Long.MIN_VALUE;
		 File edits = null;
		 for (Iterator<File> it = files.iterator();
		 it.hasNext();
		) {
			 File f = it.next();
			 long length = f.length();
			 if (length > maxLength) {
				 maxLength = length;
				 edits = f;
			 }
		 }
		 if (edits != null) {
			 DataInputStream in = new DataInputStream( new BufferedInputStream( new FileInputStream(edits)));
			 in.mark( 4 );
			 boolean available = true;
			 try {
				 logVersion = in.readByte();
			 }
			 catch (EOFException e) {
				 available = false;
			 }
			 if (available) {
				 in.reset();
				 if( logVersion >= 0 ) logVersion = 0;
				 else logVersion = in.readInt();
				 if( logVersion < FSConstants.DFS_CURRENT_VERSION ) throw new IOException( ""Unexpected version of the file system log file: "" + logVersion + "". Current version = "" + FSConstants.DFS_CURRENT_VERSION + ""."" );
			 }
			 short replication = (short)conf.getInt(""dfs.replication"", 3);
			 try {
				 while (true) {
					 byte opcode = -1;
					 try {
						 opcode = in.readByte();
					 }
					 catch (EOFException e) {
						 break;
					 }
					 numEdits++;
					 switch (opcode) {
						 case OP_ADD: {
							 UTF8 name = new UTF8();
							 ArrayWritable aw = null;
							 Writable writables[];
							 if( logVersion >= 0 ) name.readFields(in);
							 else {
								 aw = new ArrayWritable(UTF8.class);
								 aw.readFields(in);
								 writables = aw.get();
								 if( writables.length != 2 ) throw new IOException(""Incorrect data fortmat. "" + ""Name & replication pair expected"");
								 name = (UTF8) writables[0];
								 replication = Short.parseShort( ((UTF8)writables[1]).toString());
								 replication = adjustReplication( replication, conf );
							 }
							 aw = new ArrayWritable(Block.class);
							 aw.readFields(in);
							 writables = aw.get();
							 Block blocks[] = new Block[writables.length];
							 System.arraycopy(writables, 0, blocks, 0, blocks.length);
							 fsDir.unprotectedAddFile(name, blocks, replication );
							 break;
						 }
						 case OP_SET_REPLICATION: {
							 UTF8 src = new UTF8();
							 UTF8 repl = new UTF8();
							 src.readFields(in);
							 repl.readFields(in);
							 replication = adjustReplication( fromLogReplication(repl), conf);
							 fsDir.unprotectedSetReplication(src.toString(), replication, null);
							 break;
						 }
						 case OP_RENAME: {
							 UTF8 src = new UTF8();
							 UTF8 dst = new UTF8();
							 src.readFields(in);
							 dst.readFields(in);
							 fsDir.unprotectedRenameTo(src, dst);
							 break;
						 }
						 case OP_DELETE: {
							 UTF8 src = new UTF8();
							 src.readFields(in);
							 fsDir.unprotectedDelete(src);
							 break;
						 }
						 case OP_MKDIR: {
							 UTF8 src = new UTF8();
							 src.readFields(in);
							 fsDir.unprotectedMkdir(src.toString());
							 break;
						 }
						 case OP_DATANODE_ADD: {
							 if( logVersion > -3 ) throw new IOException(""Unexpected opcode "" + opcode + "" for version "" + logVersion );
							 DatanodeDescriptor node = new DatanodeDescriptor();
							 node.readFields(in);
							 fsNamesys.unprotectedAddDatanode( node );
							 break;
						 }
						 case OP_DATANODE_REMOVE: {
							 if( logVersion > -3 ) throw new IOException(""Unexpected opcode "" + opcode + "" for version "" + logVersion );
							 DatanodeID nodeID = new DatanodeID();
							 nodeID.readFields(in);
							 DatanodeDescriptor node = fsNamesys.getDatanode( nodeID );
							 if( node != null ) {
								 fsNamesys.unprotectedRemoveDatanode( node );
								 fsNamesys.wipeDatanode( nodeID );
							 }
							 break;
						 }
						 default: {
							 throw new IOException(""Never seen opcode "" + opcode);
						 }
					 }
				 }
			 }
			 finally {
				 in.close();
			 }
		 }
		 if( logVersion != FSConstants.DFS_CURRENT_VERSION ) numEdits++;
		 return numEdits;
	 }
	 static short adjustReplication( short replication, Configuration conf) {
		 short minReplication = (short)conf.getInt(""dfs.replication.min"", 1);
		 if( replication<minReplication ) {
			 replication = minReplication;
		 }
		 short maxReplication = (short)conf.getInt(""dfs.replication.max"", 512);
		 if( replication>maxReplication ) {
			 replication = maxReplication;
		 }
		 return replication;
	 }
	 void logEdit(byte op, Writable w1, Writable w2) {
		 for (int idx = 0;
		 idx < editStreams.length;
		 idx++) {
			 synchronized (editStreams[idx]) {
				 try {
					 editStreams[idx].write(op);
					 if (w1 != null) {
						 w1.write(editStreams[idx]);
					 }
					 if (w2 != null) {
						 w2.write(editStreams[idx]);
					 }
					 editStreams[idx].flush();
					 editDescriptors[idx].sync();
				 }
				 catch (IOException ie) {
				 }
			 }
		 }
	 }
	 void logCreateFile( FSDirectory.INode newNode ) {
		 UTF8 nameReplicationPair[] = new UTF8[] {
		 new UTF8( newNode.computeName() ), FSEditLog.toLogReplication( newNode.getReplication() )}
		;
		 logEdit(OP_ADD, new ArrayWritable( UTF8.class, nameReplicationPair ), new ArrayWritable( Block.class, newNode.getBlocks() ));
	 }
	 void logMkDir( FSDirectory.INode newNode ) {
		 logEdit(OP_MKDIR, new UTF8( newNode.computeName() ), null );
	 }
	 void logRename( UTF8 src, UTF8 dst ) {
		 logEdit(OP_RENAME, src, dst);
	 }
	 void logSetReplication( String src, short replication ) {
		 logEdit(OP_SET_REPLICATION, new UTF8(src), FSEditLog.toLogReplication( replication ));
	 }
	 void logDelete( UTF8 src ) {
		 logEdit(OP_DELETE, src, null);
	 }
	 void logAddDatanode( DatanodeDescriptor node ) {
		 logEdit( OP_DATANODE_ADD, node, null );
	 }
	 void logRemoveDatanode( DatanodeID nodeID ) {
		 logEdit( OP_DATANODE_REMOVE, new DatanodeID( nodeID ), null );
	 }
	 static UTF8 toLogReplication( short replication ) {
		 return new UTF8( Short.toString(replication));
	 }
	 static short fromLogReplication( UTF8 replication ) {
		 return Short.parseShort(replication.toString());
	 }
}",0,0,0,0
"private int threshold(int[] histogram, int total) {
	 float sum = 0;
	 for (int i = 0;
	 i < 256;
	 i++) {
		 sum += i * histogram[i];
	 }
	 float sumB = 0;
	 int wB = 0;
	 int wF = 0;
	 float varMax = 0;
	 int threshold = 0;
	 for (int i = 0;
	 i < 256;
	 i++) {
		 wB += histogram[i];
		 if (wB == 0) {
			 continue;
		 }
		 wF = total - wB;
		 if (wF == 0) {
			 break;
		 }
		 sumB += (float) (i * histogram[i]);
		 float mB = sumB / wB;
		 float mF = (sum - sumB) / wF;
		 float varBetween = (float) wB * (float) wF * (mB - mF) * (mB - mF);
		 if (varBetween > varMax) {
			 varMax = varBetween;
			 threshold = i;
		 }
	 }
	 return threshold;
 }",0,0,0,0
"class ValueEncoder {
	 private final ValueSerializer valueSerializer;
	 public ValueEncoder(ValueSerializer valueSerializer) {
		 this.valueSerializer = valueSerializer;
	 }
	 BasicTypes.EncodedValue encodeValue(Object unencodedValue) {
		 BasicTypes.EncodedValue.Builder builder = BasicTypes.EncodedValue.newBuilder();
		 if (valueSerializer.supportsPrimitives()) {
			 ByteString customBytes = customSerialize(unencodedValue);
			 return builder.setCustomObjectResult(customBytes).build();
		 }
		 if (Objects.isNull(unencodedValue)) {
			 builder.setNullResult(NullValue.NULL_VALUE);
		 }
		 else if (Integer.class.equals(unencodedValue.getClass())) {
			 builder.setIntResult((Integer) unencodedValue);
		 }
		 else if (Long.class.equals(unencodedValue.getClass())) {
			 builder.setLongResult((Long) unencodedValue);
		 }
		 else if (Short.class.equals(unencodedValue.getClass())) {
			 builder.setShortResult((Short) unencodedValue);
		 }
		 else if (Byte.class.equals(unencodedValue.getClass())) {
			 builder.setByteResult((Byte) unencodedValue);
		 }
		 else if (Double.class.equals(unencodedValue.getClass())) {
			 builder.setDoubleResult((Double) unencodedValue);
		 }
		 else if (Float.class.equals(unencodedValue.getClass())) {
			 builder.setFloatResult((Float) unencodedValue);
		 }
		 else if (byte[].class.equals(unencodedValue.getClass())) {
			 builder.setBinaryResult(ByteString.copyFrom((byte[]) unencodedValue));
		 }
		 else if (Boolean.class.equals(unencodedValue.getClass())) {
			 builder.setBooleanResult((Boolean) unencodedValue);
		 }
		 else if (String.class.equals(unencodedValue.getClass())) {
			 builder.setStringResult((String) unencodedValue);
		 }
		 else if (JSONWrapper.class.isAssignableFrom(unencodedValue.getClass())) {
			 builder.setJsonObjectResult(((JSONWrapper) unencodedValue).getJSON());
		 }
		 else {
			 ByteString customBytes = customSerialize(unencodedValue);
			 if (customBytes != null) {
				 builder.setCustomObjectResult(customBytes);
			 }
			 else {
				 throw new IllegalStateException(""We don't know how to handle an object of type "" + unencodedValue.getClass() + "": "" + unencodedValue);
			 }
		 }
		 return builder.build();
	 }
	 private ByteString customSerialize(Object unencodedValue) {
		 try {
			 ByteString customBytes = valueSerializer.serialize(unencodedValue);
			 return customBytes;
		 }
		 catch (IOException e) {
			 throw new IllegalStateException(e);
		 }
	 }
	 Object decodeValue(BasicTypes.EncodedValue encodedValue) {
		 switch (encodedValue.getValueCase()) {
			 case BINARYRESULT: return encodedValue.getBinaryResult().toByteArray();
			 case BOOLEANRESULT: return encodedValue.getBooleanResult();
			 case BYTERESULT: return (byte) encodedValue.getByteResult();
			 case DOUBLERESULT: return encodedValue.getDoubleResult();
			 case FLOATRESULT: return encodedValue.getFloatResult();
			 case INTRESULT: return encodedValue.getIntResult();
			 case LONGRESULT: return encodedValue.getLongResult();
			 case SHORTRESULT: return (short) encodedValue.getShortResult();
			 case STRINGRESULT: return encodedValue.getStringResult();
			 case JSONOBJECTRESULT: return JSONWrapper.wrapJSON(encodedValue.getJsonObjectResult());
			 case NULLRESULT: return null;
			 case CUSTOMOBJECTRESULT: try {
				 return valueSerializer.deserialize(encodedValue.getCustomObjectResult());
			 }
			 catch (IOException | ClassNotFoundException e) {
				 throw new IllegalStateException(e);
			 }
			 default: throw new IllegalStateException( ""Can't decode a value of type "" + encodedValue.getValueCase() + "": "" + encodedValue);
		 }
	 }
	 BasicTypes.Entry encodeEntry(Object unencodedKey, Object unencodedValue) {
		 if (unencodedValue == null) {
			 return BasicTypes.Entry.newBuilder().setKey(encodeValue(unencodedKey)).build();
		 }
		 return BasicTypes.Entry.newBuilder().setKey(encodeValue(unencodedKey)) .setValue(encodeValue(unencodedValue)).build();
	 }
}",1,0,0,0
"public interface DbAction<T> {
	Class<T> getEntityType();
	default void executeWith(Interpreter interpreter) {
		try {
			doExecuteWith(interpreter);
		}
		 catch (Exception e) {
			throw new DbActionExecutionException(this, e);
		}
	}
	void doExecuteWith(Interpreter interpreter);
	class Insert<T> implements WithGeneratedId<T>, WithDependingOn<T> {
		 final T entity;
		 final PersistentPropertyPath<RelationalPersistentProperty> propertyPath;
		 final WithEntity<?> dependingOn;
		Map<PersistentPropertyPath<RelationalPersistentProperty>, Object> qualifiers = new HashMap<>();
		private Object generatedId;
		public void doExecuteWith(Interpreter interpreter) {
			interpreter.interpret(this);
		}
		public Class<T> getEntityType() {
			return WithDependingOn.super.getEntityType();
		}
	}
	class InsertRoot<T> implements WithEntity<T>, WithGeneratedId<T> {
		 private final T entity;
		private Object generatedId;
		public void doExecuteWith(Interpreter interpreter) {
			interpreter.interpret(this);
		}
	}
	class Update<T> implements WithEntity<T> {
		 T entity;
		 PersistentPropertyPath<RelationalPersistentProperty> propertyPath;
		public void doExecuteWith(Interpreter interpreter) {
			interpreter.interpret(this);
		}
	}
	class UpdateRoot<T> implements WithEntity<T> {
		 private final T entity;
		public void doExecuteWith(Interpreter interpreter) {
			interpreter.interpret(this);
		}
	}
	class Merge<T> implements WithDependingOn<T>, WithPropertyPath<T> {
		 T entity;
		 PersistentPropertyPath<RelationalPersistentProperty> propertyPath;
		 WithEntity<?> dependingOn;
		Map<PersistentPropertyPath<RelationalPersistentProperty>, Object> qualifiers = new HashMap<>();
		public void doExecuteWith(Interpreter interpreter) {
			interpreter.interpret(this);
		}
	}
	class Delete<T> implements WithPropertyPath<T> {
		 Object rootId;
		 PersistentPropertyPath<RelationalPersistentProperty> propertyPath;
		public void doExecuteWith(Interpreter interpreter) {
			interpreter.interpret(this);
		}
	}
	class DeleteRoot<T> implements DbAction<T> {
		 Class<T> entityType;
		 Object rootId;
		public void doExecuteWith(Interpreter interpreter) {
			interpreter.interpret(this);
		}
	}
	class DeleteAll<T> implements WithPropertyPath<T> {
		 PersistentPropertyPath<RelationalPersistentProperty> propertyPath;
		public void doExecuteWith(Interpreter interpreter) {
			interpreter.interpret(this);
		}
	}
	class DeleteAllRoot<T> implements DbAction<T> {
		 private final Class<T> entityType;
		public void doExecuteWith(Interpreter interpreter) {
			interpreter.interpret(this);
		}
	}
	interface WithDependingOn<T> extends WithPropertyPath<T>, WithEntity<T> {
		WithEntity<?> getDependingOn();
		Map<PersistentPropertyPath<RelationalPersistentProperty>, Object> getQualifiers();
		default Class<T> getEntityType() {
			return WithEntity.super.getEntityType();
		}
	}
	interface WithEntity<T> extends DbAction<T> {
		T getEntity();
		default Class<T> getEntityType() {
			return (Class<T>) getEntity().getClass();
		}
	}
	interface WithGeneratedId<T> extends WithEntity<T> {
		Object getGeneratedId();
		default Class<T> getEntityType() {
			return (Class<T>) getEntity().getClass();
		}
	}
	interface WithPropertyPath<T> extends DbAction<T> {
		PersistentPropertyPath<RelationalPersistentProperty> getPropertyPath();
		default Class<T> getEntityType() {
			return (Class<T>) getPropertyPath().getRequiredLeafProperty().getActualType();
		}
	}
}",1,0,0,0
"public String toString() {
	 return getClass().getSimpleName() + ""(name='"" + name + ""')"";
 }",0,0,0,0
"public void setBehaviorId(String behaviorId){
	this.behaviorId = behaviorId;
}",0,0,0,0
"private XMLEvent expectTag(String expected, boolean allowEnd) throws IOException {
	 XMLEvent ev = null;
	 while (true) {
		 try {
			 ev = events.nextEvent();
		 }
		 catch (XMLStreamException e) {
			 throw new IOException(""Expecting "" + expected + "", but got XMLStreamException"", e);
		 }
		 switch (ev.getEventType()) {
			 case XMLEvent.ATTRIBUTE: throw new IOException(""Got unexpected attribute: "" + ev);
			 case XMLEvent.CHARACTERS: if (!ev.asCharacters().isWhiteSpace()) {
				 throw new IOException(""Got unxpected characters while "" + ""looking for "" + expected + "": "" + ev.asCharacters().getData());
			 }
			 break;
			 case XMLEvent.END_ELEMENT: if (!allowEnd) {
				 throw new IOException(""Got unexpected end event "" + ""while looking for "" + expected);
			 }
			 return ev;
			 case XMLEvent.START_ELEMENT: if (!expected.startsWith(""["")) {
				 if (!ev.asStartElement().getName().getLocalPart(). equals(expected)) {
					 throw new IOException(""Failed to find <"" + expected + "">;
					 "" + ""got "" + ev.asStartElement().getName().getLocalPart() + "" instead."");
				 }
			 }
			 return ev;
			 default: if (LOG.isTraceEnabled()) {
				 LOG.trace(""Skipping XMLEvent of type "" + ev.getEventType() + ""("" + ev + "")"");
			 }
			 break;
		 }
	 }
 }",0,0,1,0
"protected Map<byte[], List<Path>>[] handleBulkLoad(List<TableName> sTableList) throws IOException {
	 Map<byte[], List<Path>>[] mapForSrc = new Map[sTableList.size()];
	 List<String> activeFiles = new ArrayList<>();
	 List<String> archiveFiles = new ArrayList<>();
	 Pair<Map<TableName, Map<String, Map<String, List<Pair<String, Boolean>>>>>, List<byte[]>> pair = backupManager.readBulkloadRows(sTableList);
	 Map<TableName, Map<String, Map<String, List<Pair<String, Boolean>>>>> map = pair.getFirst();
	 FileSystem tgtFs;
	 try {
		 tgtFs = FileSystem.get(new URI(backupInfo.getBackupRootDir()), conf);
	 }
	 catch (URISyntaxException use) {
		 throw new IOException(""Unable to get FileSystem"", use);
	 }
	 Path rootdir = FSUtils.getRootDir(conf);
	 Path tgtRoot = new Path(new Path(backupInfo.getBackupRootDir()), backupId);
	 for (Map.Entry<TableName, Map<String, Map<String, List<Pair<String, Boolean>>>>> tblEntry : map.entrySet()) {
		 TableName srcTable = tblEntry.getKey();
		 int srcIdx = getIndex(srcTable, sTableList);
		 if (srcIdx < 0) {
			 LOG.warn(""Couldn't find "" + srcTable + "" in source table List"");
			 continue;
		 }
		 if (mapForSrc[srcIdx] == null) {
			 mapForSrc[srcIdx] = new TreeMap<>(Bytes.BYTES_COMPARATOR);
		 }
		 Path tblDir = FSUtils.getTableDir(rootdir, srcTable);
		 Path tgtTable = new Path(new Path(tgtRoot, srcTable.getNamespaceAsString()), srcTable.getQualifierAsString());
		 for (Map.Entry<String,Map<String,List<Pair<String, Boolean>>>> regionEntry : tblEntry.getValue().entrySet()){
			 String regionName = regionEntry.getKey();
			 Path regionDir = new Path(tblDir, regionName);
			 for (Map.Entry<String,List<Pair<String, Boolean>>> famEntry : regionEntry.getValue().entrySet()) {
				 String fam = famEntry.getKey();
				 Path famDir = new Path(regionDir, fam);
				 List<Path> files;
				 if (!mapForSrc[srcIdx].containsKey(Bytes.toBytes(fam))) {
					 files = new ArrayList<>();
					 mapForSrc[srcIdx].put(Bytes.toBytes(fam), files);
				 }
				 else {
					 files = mapForSrc[srcIdx].get(Bytes.toBytes(fam));
				 }
				 Path archiveDir = HFileArchiveUtil.getStoreArchivePath(conf, srcTable, regionName, fam);
				 String tblName = srcTable.getQualifierAsString();
				 Path tgtFam = new Path(new Path(tgtTable, regionName), fam);
				 if (!tgtFs.mkdirs(tgtFam)) {
					 throw new IOException(""couldn't create "" + tgtFam);
				 }
				 for (Pair<String, Boolean> fileWithState : famEntry.getValue()) {
					 String file = fileWithState.getFirst();
					 int idx = file.lastIndexOf(""/"");
					 String filename = file;
					 if (idx > 0) {
						 filename = file.substring(idx+1);
					 }
					 Path p = new Path(famDir, filename);
					 Path tgt = new Path(tgtFam, filename);
					 Path archive = new Path(archiveDir, filename);
					 if (fs.exists(p)) {
						 if (LOG.isTraceEnabled()) {
							 LOG.trace(""found bulk hfile "" + file + "" in "" + famDir + "" for "" + tblName);
						 }
						 if (LOG.isTraceEnabled()) {
							 LOG.trace(""copying "" + p + "" to "" + tgt);
						 }
						 activeFiles.add(p.toString());
					 }
					 else if (fs.exists(archive)){
						 LOG.debug(""copying archive "" + archive + "" to "" + tgt);
						 archiveFiles.add(archive.toString());
					 }
					 files.add(tgt);
				 }
			 }
		 }
	 }
	 copyBulkLoadedFiles(activeFiles, archiveFiles);
	 backupManager.deleteBulkLoadedRows(pair.getSecond());
	 return mapForSrc;
 }",0,0,1,0
"public class TransactionIdConversion {
	 static KahaTransactionInfo convertToLocal(TransactionId tx) {
		 KahaTransactionInfo rc = new KahaTransactionInfo();
		 LocalTransactionId t = (LocalTransactionId) tx;
		 KahaLocalTransactionId kahaTxId = new KahaLocalTransactionId();
		 kahaTxId.setConnectionId(t.getConnectionId().getValue());
		 kahaTxId.setTransactionId(t.getValue());
		 rc.setLocalTransactionId(kahaTxId);
		 return rc;
	 }
	 static KahaTransactionInfo convert(TransactionId txid) {
		 if (txid == null) {
			 return null;
		 }
		 KahaTransactionInfo rc;
		 if (txid.isLocalTransaction()) {
			 rc = convertToLocal(txid);
		 }
		 else {
			 rc = new KahaTransactionInfo();
			 XATransactionId t = (XATransactionId) txid;
			 KahaXATransactionId kahaTxId = new KahaXATransactionId();
			 kahaTxId.setBranchQualifier(new Buffer(t.getBranchQualifier()));
			 kahaTxId.setGlobalTransactionId(new Buffer(t.getGlobalTransactionId()));
			 kahaTxId.setFormatId(t.getFormatId());
			 rc.setXaTransactionId(kahaTxId);
		 }
		 return rc;
	 }
	 static TransactionId convert(KahaTransactionInfo transactionInfo) {
		 if (transactionInfo.hasLocalTransactionId()) {
			 KahaLocalTransactionId tx = transactionInfo.getLocalTransactionId();
			 LocalTransactionId rc = new LocalTransactionId();
			 rc.setConnectionId(new ConnectionId(tx.getConnectionId()));
			 rc.setValue(tx.getTransactionId());
			 return rc;
		 }
		 else {
			 KahaXATransactionId tx = transactionInfo.getXaTransactionId();
			 XATransactionId rc = new XATransactionId();
			 rc.setBranchQualifier(tx.getBranchQualifier().toByteArray());
			 rc.setGlobalTransactionId(tx.getGlobalTransactionId().toByteArray());
			 rc.setFormatId(tx.getFormatId());
			 return rc;
		 }
	 }
}",1,0,0,0
"public InstrumentationFacility getInstrumentationFacility() {
	 return getRootContext().getInstrumentationFacility();
 }",0,0,0,0
"public String getFilename(){
	return filename;
}",0,0,0,0
"public PeriodAxisLabelInfo(Class periodClass, DateFormat dateFormat, RectangleInsets padding, Font labelFont, Paint labelPaint, boolean drawDividers, Stroke dividerStroke, Paint dividerPaint);",0,0,0,1
"private ShardHandler getAndPrepShardHandler(SolrQueryRequest req, ResponseBuilder rb) {
	 ShardHandler shardHandler = null;
	 CoreContainer cc = req.getCore().getCoreContainer();
	 boolean isZkAware = cc.isZooKeeperAware();
	 rb.isDistrib = req.getParams().getBool(DISTRIB, isZkAware);
	 if (!rb.isDistrib) {
		 final String shards = req.getParams().get(ShardParams.SHARDS);
		 rb.isDistrib = ((shards != null) && (shards.indexOf('/') > 0));
	 }
	 if (rb.isDistrib) {
		 shardHandler = shardHandlerFactory.getShardHandler();
		 shardHandler.prepDistributed(rb);
		 if (!rb.isDistrib) {
			 shardHandler = null;
		 }
	 }
	 if (isZkAware) {
		 String shardsTolerant = req.getParams().get(ShardParams.SHARDS_TOLERANT);
		 boolean requireZkConnected = shardsTolerant != null && shardsTolerant.equals(ShardParams.REQUIRE_ZK_CONNECTED);
		 ZkController zkController = cc.getZkController();
		 boolean zkConnected = zkController != null && ! zkController.getZkClient().getConnectionManager().isLikelyExpired();
		 if (requireZkConnected && false == zkConnected) {
			 throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, ""ZooKeeper is not connected"");
		 }
		 else {
			 NamedList<Object> headers = rb.rsp.getResponseHeader();
			 if (headers != null) {
				 headers.add(""zkConnected"", zkConnected);
			 }
		 }
	 }
	 return shardHandler;
 }",0,0,1,0
"public final WebApplication getApplication(){
	return application;
}",0,0,0,0
"public void close() throws IOException {
	 if (closed) {
		 return;
	 }
	 if (runLength > 0) {
		 writeRun();
	 }
	 currentChar = -1;
	 endBlock();
	 endCompression();
	 closed = true;
	 super.close();
	 bsStream.close();
 }",0,0,0,0
"public final synchronized <M extends Serializable> M getMetaData(final MetaDataKey<M> key){
	return key.get(metaData);
}",0,0,0,0
"public class TestStore extends TestStoreBase {
	 POStore st;
	 DataBag inpDB;
	 static MiniGenericCluster cluster = MiniGenericCluster.buildCluster();
	 PigContext pc;
	 POProject proj;
	 public void setUp() throws Exception {
		 mode = cluster.getExecType();
		 setupPigServer();
		 pc = ps.getPigContext();
		 super.setUp();
	 }
	 public void tearDown() throws Exception {
		 Util.resetStateForExecModeSwitch();
		 Util.deleteDirectory(new File(TESTDIR));
		 Util.deleteFile(cluster, TESTDIR);
	 }
	 protected void setupPigServer() throws Exception {
		 ps = new PigServer(cluster.getExecType(), cluster.getProperties());
	 }
	 private void storeAndCopyLocally(DataBag inpDB) throws Exception {
		 setUpInputFileOnCluster(inpDB);
		 String script = ""a = load '"" + inputFileName + ""';
		 "" + ""store a into '"" + outputFileName + ""' using PigStorage('\t');
		"" + ""fs -ls "" + TESTDIR;
		 ps.setBatchOn();
		 Util.registerMultiLineQuery(ps, script);
		 ps.executeBatch();
		 Path path = getFirstOutputFile(cluster.getConfiguration(), new Path(outputFileName), cluster.getExecType(), true);
		 Util.copyFromClusterToLocal( cluster, path.toString(), outputFileName);
	 }
	 public static void oneTimeTearDown() throws Exception {
		 cluster.shutDown();
	 }
	 public void testValidation() throws Exception{
		 String outputFileName = ""test-output.txt"";
		 try {
			 String query = ""a = load '"" + inputFileName + ""' as (c:chararray, "" + ""i:int,d:double);
			"" + ""store a into '"" + outputFileName + ""' using "" + ""PigStorage();
			"";
			 org.apache.pig.newplan.logical.relational.LogicalPlan lp = Util.buildLp( ps, query );
		 }
		 catch (PlanValidationException e){
			 fail(""Store validation test failed."");
		 }
		 finally {
			 Util.deleteFile(ps.getPigContext(), outputFileName);
		 }
	 }
	 public void testValidationFailure() throws Exception{
		 String input[] = new String[] {
		 ""some data"" }
		;
		 String outputFileName = ""test-output.txt"";
		 boolean sawException = false;
		 try {
			 Util.createInputFile(ps.getPigContext(),outputFileName, input);
			 String query = ""a = load '"" + inputFileName + ""' as (c:chararray, "" + ""i:int,d:double);
			"" + ""store a into '"" + outputFileName + ""' using PigStorage();
			"";
			 Util.buildLp( ps, query );
		 }
		 catch (InvocationTargetException e){
			 FrontendException pve = (FrontendException)e.getCause();
			 pve.printStackTrace();
			 assertEquals(6000,pve.getErrorCode());
			 assertEquals(PigException.REMOTE_ENVIRONMENT, pve.getErrorSource());
			 assertTrue(pve.getCause() instanceof IOException);
			 sawException = true;
		 }
		 finally {
			 assertTrue(sawException);
			 Util.deleteFile(ps.getPigContext(), outputFileName);
		 }
	 }
	 public void testStore() throws Exception {
		 inpDB = GenRandomData.genRandSmallTupDataBag(new Random(), 10, 100);
		 storeAndCopyLocally(inpDB);
		 int size = 0;
		 BufferedReader br = new BufferedReader(new FileReader(outputFileName));
		 for(String line=br.readLine();
		line!=null;
		line=br.readLine()){
			 String[] flds = line.split(""\t"",-1);
			 Tuple t = new DefaultTuple();
			 t.append(flds[0].compareTo("""")!=0 ? flds[0] : null);
			 t.append(flds[1].compareTo("""")!=0 ? Integer.parseInt(flds[1]) : null);
			 System.err.println(""Simple data: "");
			 System.err.println(line);
			 System.err.println(""t: "");
			 System.err.println(t);
			 assertTrue(TestHelper.bagContains(inpDB, t));
			 ++size;
		 }
		 assertEquals(size, inpDB.size());
		 br.close();
	 }
	 private void setUpInputFileOnCluster(DataBag inpD) throws IOException {
		 String[] data = new String[(int) inpD.size()];
		 int i = 0;
		 for (Tuple tuple : inpD) {
			 data[i] = toDelimitedString(tuple, ""\t"");
			 i++;
		 }
		 Util.createInputFile(cluster, inputFileName, data);
	 }
	 private String toDelimitedString(Tuple t, String delim) throws ExecException {
		 StringBuilder buf = new StringBuilder();
		 for (int i = 0;
		 i < t.size();
		 i++) {
			 Object field = t.get(i);
			 if(field == null) {
				 buf.append("""");
			 }
			 else {
				 if(field instanceof Map) {
					 Map<String, Object> m = (Map<String, Object>)field;
					 buf.append(DataType.mapToString(m));
				 }
				 else {
					 buf.append(field.toString());
				 }
			 }
			 if (i != t.size() - 1) buf.append(delim);
		 }
		 return buf.toString();
	 }
	 public void testStoreComplexData() throws Exception {
		 inpDB = GenRandomData.genRandFullTupTextDataBag(new Random(), 10, 100);
		 storeAndCopyLocally(inpDB);
		 PigStorage ps = new PigStorage(""\t"");
		 int size = 0;
		 BufferedReader br = new BufferedReader(new FileReader(outputFileName));
		 for(String line=br.readLine();
		line!=null;
		line=br.readLine()){
			 String[] flds = line.split(""\t"",-1);
			 Tuple t = new DefaultTuple();
			 ResourceFieldSchema mapfs = GenRandomData.getRandMapFieldSchema();
			 ResourceFieldSchema bagfs = GenRandomData.getSmallTupDataBagFieldSchema();
			 ResourceFieldSchema tuplefs = GenRandomData.getSmallTupleFieldSchema();
			 t.append(flds[0].compareTo("""")!=0 ? ps.getLoadCaster().bytesToBag(flds[0].getBytes(), bagfs) : null);
			 t.append(flds[1].compareTo("""")!=0 ? new DataByteArray(flds[1].getBytes()) : null);
			 t.append(flds[2].compareTo("""")!=0 ? ps.getLoadCaster().bytesToCharArray(flds[2].getBytes()) : null);
			 t.append(flds[3].compareTo("""")!=0 ? ps.getLoadCaster().bytesToDouble(flds[3].getBytes()) : null);
			 t.append(flds[4].compareTo("""")!=0 ? ps.getLoadCaster().bytesToFloat(flds[4].getBytes()) : null);
			 t.append(flds[5].compareTo("""")!=0 ? ps.getLoadCaster().bytesToInteger(flds[5].getBytes()) : null);
			 t.append(flds[6].compareTo("""")!=0 ? ps.getLoadCaster().bytesToLong(flds[6].getBytes()) : null);
			 t.append(flds[7].compareTo("""")!=0 ? ps.getLoadCaster().bytesToMap(flds[7].getBytes(), mapfs) : null);
			 t.append(flds[8].compareTo("""")!=0 ? ps.getLoadCaster().bytesToTuple(flds[8].getBytes(), tuplefs) : null);
			 t.append(flds[9].compareTo("""")!=0 ? ps.getLoadCaster().bytesToBoolean(flds[9].getBytes()) : null);
			 t.append(flds[10].compareTo("""")!=0 ? ps.getLoadCaster().bytesToDateTime(flds[10].getBytes()) : null);
			 assertEquals(true, TestHelper.bagContains(inpDB, t));
			 ++size;
		 }
		 assertEquals(true, size==inpDB.size());
		 br.close();
	 }
	 public void testStoreComplexDataWithNull() throws Exception {
		 Tuple inputTuple = GenRandomData.genRandSmallBagTextTupleWithNulls(new Random(), 10, 100);
		 inpDB = DefaultBagFactory.getInstance().newDefaultBag();
		 inpDB.add(inputTuple);
		 storeAndCopyLocally(inpDB);
		 PigStorage ps = new PigStorage(""\t"");
		 BufferedReader br = new BufferedReader(new FileReader(outputFileName));
		 for(String line=br.readLine();
		line!=null;
		line=br.readLine()){
			 System.err.println(""Complex data: "");
			 System.err.println(line);
			 String[] flds = line.split(""\t"",-1);
			 Tuple t = new DefaultTuple();
			 ResourceFieldSchema stringfs = new ResourceFieldSchema();
			 stringfs.setType(DataType.CHARARRAY);
			 ResourceFieldSchema intfs = new ResourceFieldSchema();
			 intfs.setType(DataType.INTEGER);
			 ResourceFieldSchema bytefs = new ResourceFieldSchema();
			 bytefs.setType(DataType.BYTEARRAY);
			 ResourceSchema tupleSchema = new ResourceSchema();
			 tupleSchema.setFields(new ResourceFieldSchema[]{
			stringfs, intfs}
			);
			 ResourceFieldSchema tuplefs = new ResourceFieldSchema();
			 tuplefs.setSchema(tupleSchema);
			 tuplefs.setType(DataType.TUPLE);
			 ResourceSchema bagSchema = new ResourceSchema();
			 bagSchema.setFields(new ResourceFieldSchema[]{
			tuplefs}
			);
			 ResourceFieldSchema bagfs = new ResourceFieldSchema();
			 bagfs.setSchema(bagSchema);
			 bagfs.setType(DataType.BAG);
			 ResourceSchema mapSchema = new ResourceSchema();
			 mapSchema.setFields(new ResourceFieldSchema[]{
			bytefs}
			);
			 ResourceFieldSchema mapfs = new ResourceFieldSchema();
			 mapfs.setSchema(mapSchema);
			 mapfs.setType(DataType.MAP);
			 t.append(flds[0].compareTo("""")!=0 ? ps.getLoadCaster().bytesToBag(flds[0].getBytes(), bagfs) : null);
			 t.append(flds[1].compareTo("""")!=0 ? new DataByteArray(flds[1].getBytes()) : null);
			 t.append(flds[2].compareTo("""")!=0 ? ps.getLoadCaster().bytesToCharArray(flds[2].getBytes()) : null);
			 t.append(flds[3].compareTo("""")!=0 ? ps.getLoadCaster().bytesToDouble(flds[3].getBytes()) : null);
			 t.append(flds[4].compareTo("""")!=0 ? ps.getLoadCaster().bytesToFloat(flds[4].getBytes()) : null);
			 t.append(flds[5].compareTo("""")!=0 ? ps.getLoadCaster().bytesToInteger(flds[5].getBytes()) : null);
			 t.append(flds[6].compareTo("""")!=0 ? ps.getLoadCaster().bytesToLong(flds[6].getBytes()) : null);
			 t.append(flds[7].compareTo("""")!=0 ? ps.getLoadCaster().bytesToMap(flds[7].getBytes(), mapfs) : null);
			 t.append(flds[8].compareTo("""")!=0 ? ps.getLoadCaster().bytesToTuple(flds[8].getBytes(), tuplefs) : null);
			 t.append(flds[9].compareTo("""")!=0 ? ps.getLoadCaster().bytesToBoolean(flds[9].getBytes()) : null);
			 t.append(flds[10].compareTo("""")!=0 ? ps.getLoadCaster().bytesToDateTime(flds[10].getBytes()) : null);
			 t.append(flds[11].compareTo("""")!=0 ? ps.getLoadCaster().bytesToCharArray(flds[10].getBytes()) : null);
			 assertEquals(inputTuple, t);
		 }
		 br.close();
	 }
	 public void testBinStorageGetSchema() throws IOException, ParserException {
		 String input[] = new String[] {
		 ""hello\t1\t10.1"", ""bye\t2\t20.2"" }
		;
		 String inputFileName = ""testGetSchema-input.txt"";
		 String outputFileName = ""testGetSchema-output.txt"";
		 try {
			 Util.createInputFile(ps.getPigContext(), inputFileName, input);
			 String query = ""a = load '"" + inputFileName + ""' as (c:chararray, "" + ""i:int,d:double);
			store a into '"" + outputFileName + ""' using "" + ""BinStorage();
			"";
			 ps.setBatchOn();
			 Util.registerMultiLineQuery(ps, query);
			 ps.executeBatch();
			 ResourceSchema rs = new BinStorage().getSchema(outputFileName, new Job(ConfigurationUtil.toConfiguration(ps.getPigContext(). getProperties())));
			 Schema expectedSchema = Utils.getSchemaFromString( ""c:chararray,i:int,d:double"");
			 assertTrue(""Checking binstorage getSchema output"", Schema.equals( expectedSchema, Schema.getPigSchema(rs), true, true));
		 }
		 finally {
			 Util.deleteFile(ps.getPigContext(), inputFileName);
			 Util.deleteFile(ps.getPigContext(), outputFileName);
		 }
	 }
	 public void testStoreRemoteRel() throws Exception {
		 checkStorePath(""test"",""/tmp/test"");
	 }
	 public void testStoreRemoteAbs() throws Exception {
		 checkStorePath(""/tmp/test"",""/tmp/test"");
	 }
	 public void testStoreRemoteRelScheme() throws Exception {
		 checkStorePath(""test"",""/tmp/test"");
	 }
	 public void testStoreRemoteAbsScheme() throws Exception {
		 checkStorePath(""hdfs:/tmp/test"",""hdfs:/tmp/test"");
	 }
	 public void testStoreRemoteAbsAuth() throws Exception {
	 checkStorePath(""hdfs: }
	 public void testStoreRemoteNormalize() throws Exception {
		 checkStorePath(""/tmp/foo/../././"",""/tmp/foo/.././."");
	 }
	 public static class FailUDF extends EvalFunc<String> {
		 public String exec(Tuple input) throws IOException {
			 throw new IOException(""FailUDFException"");
		 }
	 }
	 public static class DummyStore extends PigStorage implements StoreMetadata{
		 private boolean failInPutNext = false;
		 private String outputFileSuffix= """";
		 public DummyStore(String failInPutNextStr) {
			 failInPutNext = Boolean.parseBoolean(failInPutNextStr);
		 }
		 public DummyStore(String failInPutNextStr, String outputFileSuffix) {
			 failInPutNext = Boolean.parseBoolean(failInPutNextStr);
			 this.outputFileSuffix = outputFileSuffix;
		 }
		 public DummyStore() {
		 }
		 public void putNext(Tuple t) throws IOException {
			 if(failInPutNext) {
				 throw new IOException(""Failing in putNext"");
			 }
			 super.putNext(t);
		 }
		 public OutputFormat getOutputFormat() {
			 return new DummyOutputFormat(outputFileSuffix);
		 }
		 public void storeSchema(ResourceSchema schema, String location, Job job) throws IOException {
			 FileSystem fs = FileSystem.get(job.getConfiguration());
			 FileStatus[] outputFiles = fs.listStatus(new Path(location), Util.getSuccessMarkerPathFilter());
			 Path resultPath = null;
			 if (outputFiles != null && outputFiles.length > 0 && outputFiles[0].getPath().getName().startsWith(""part-"")) {
				 resultPath = outputFiles[0].getPath();
			 }
			 if (resultPath == null) {
				 FileStatus[] listing = fs.listStatus(new Path(location));
				 for (FileStatus fstat : listing) {
					 System.err.println(""Output File:"" + fstat.getPath());
				 }
				 throw new IOException("""" + resultPath + "" not available in storeSchema"");
			 }
			 fs.create( new Path(location + ""_storeSchema_test""), false);
		 }
		 public void cleanupOnFailure(String location, Job job) throws IOException {
			 super.cleanupOnFailure(location, job);
			 Configuration conf = job.getConfiguration();
			 FileSystem fs = FileSystem.get(conf);
			 if(fs.exists(new Path(location))) {
				 fs.create(new Path(location + ""_cleanupOnFailure_failed"" + outputFileSuffix), false);
			 }
			 fs.create( new Path(location + ""_cleanupOnFailure_succeeded"" + outputFileSuffix), false);
		 }
		 public void storeStatistics(ResourceStatistics stats, String location, Job job) throws IOException {
		 }
	 }
	 private void checkStorePath(String orig, String expected) throws Exception {
		 checkStorePath(orig, expected, false);
	 }
	 private void checkStorePath(String orig, String expected, boolean isTmp) throws Exception {
		 pc.getProperties().setProperty(PigConfiguration.PIG_OPT_MULTIQUERY,""""+true);
		 DataStorage dfs = pc.getDfs();
		 dfs.setActiveContainer(dfs.asContainer(""/tmp""));
		 Map<String, String> fileNameMap = new HashMap<String, String>();
		 QueryParserDriver builder = new QueryParserDriver(pc, ""Test-Store"", fileNameMap);
		 String query = ""a = load 'foo';
		"" + ""store a into '""+orig+""';
		"";
		 LogicalPlan lp = builder.parse(query);
		 assertTrue(lp.size()>1);
		 Operator op = lp.getSinks().get(0);
		 assertTrue(op instanceof LOStore);
		 LOStore store = (LOStore)op;
		 String p = store.getFileSpec().getFileName();
		 p = p.replaceAll(""hdfs: if (isTmp) {
			 assertTrue(p.matches(""/tmp.*""));
		 }
		 else {
			 assertEquals(expected, p);
		 }
	 }
	 static class DummyOutputFormat extends PigTextOutputFormat {
		 private String outputFileSuffix;
		 public DummyOutputFormat(String outputFileSuffix) {
			 super((byte) '\t');
			 this.outputFileSuffix = outputFileSuffix;
		 }
		 public synchronized OutputCommitter getOutputCommitter( TaskAttemptContext context) throws IOException {
			 return new DummyOutputCommitter(outputFileSuffix, super.getOutputCommitter(context));
		 }
		 public Path getDefaultWorkFile(TaskAttemptContext context, String extension) throws IOException {
			 FileOutputCommitter committer = (FileOutputCommitter) super.getOutputCommitter(context);
			 return new Path(committer.getWorkPath(), getUniqueFile(context, ""part"", extension));
		 }
	 }
	 static class DummyOutputCommitter extends OutputCommitter {
		 static String FILE_SETUPJOB_CALLED = ""/tmp/TestStore/_setupJob_called"";
		 static String FILE_SETUPTASK_CALLED = ""/tmp/TestStore/_setupTask_called"";
		 static String FILE_COMMITTASK_CALLED = ""/tmp/TestStore/_commitTask_called"";
		 static String FILE_ABORTTASK_CALLED = ""/tmp/TestStore/_abortTask_called"";
		 static String FILE_CLEANUPJOB_CALLED = ""/tmp/TestStore/_cleanupJob_called"";
		 static String FILE_COMMITJOB_CALLED = ""/tmp/TestStore/_commitJob_called"";
		 static String FILE_ABORTJOB_CALLED = ""/tmp/TestStore/_abortJob_called"";
		 private String outputFileSuffix;
		 private OutputCommitter baseCommitter;
		 public DummyOutputCommitter(String outputFileSuffix, OutputCommitter baseCommitter) throws IOException {
			 this.outputFileSuffix = outputFileSuffix;
			 this.baseCommitter = baseCommitter;
		 }
		 public void setupJob(JobContext jobContext) throws IOException {
			 baseCommitter.setupJob(jobContext);
			 createFile(jobContext, FILE_SETUPJOB_CALLED + outputFileSuffix);
		 }
		 public void setupTask(TaskAttemptContext taskContext) throws IOException {
			 baseCommitter.setupTask(taskContext);
			 createFile(taskContext, FILE_SETUPTASK_CALLED + outputFileSuffix);
		 }
		 public boolean needsTaskCommit(TaskAttemptContext taskContext) throws IOException {
			 return true;
		 }
		 public void commitTask(TaskAttemptContext taskContext) throws IOException {
			 baseCommitter.commitTask(taskContext);
			 createFile(taskContext, FILE_COMMITTASK_CALLED + outputFileSuffix);
		 }
		 public void abortTask(TaskAttemptContext taskContext) throws IOException {
			 baseCommitter.abortTask(taskContext);
			 createFile(taskContext, FILE_ABORTTASK_CALLED + outputFileSuffix);
		 }
		 public void cleanupJob(JobContext jobContext) throws IOException {
			 baseCommitter.cleanupJob(jobContext);
			 createFile(jobContext, FILE_CLEANUPJOB_CALLED + outputFileSuffix);
		 }
		 public void commitJob(JobContext jobContext) throws IOException {
			 baseCommitter.commitJob(jobContext);
			 createFile(jobContext, FILE_COMMITJOB_CALLED + outputFileSuffix);
		 }
		 public void abortJob(JobContext jobContext, State state) throws IOException {
			 baseCommitter.abortJob(jobContext, state);
			 createFile(jobContext, FILE_ABORTJOB_CALLED + outputFileSuffix);
		 }
		 public void createFile(JobContext jobContext, String fileName) throws IOException {
			 Configuration conf = jobContext.getConfiguration();
			 FileSystem fs = FileSystem.get(conf);
			 fs.mkdirs(new Path(fileName).getParent());
			 FSDataOutputStream out = fs.create(new Path(fileName), true);
			 out.close();
		 }
	 }
}",1,0,0,0
"private ParseStatus output(OutputCollector<Text, NutchWritable> output, String segmentName, Text key, CrawlDatum datum, Content content, ProtocolStatus pstatus, int status) {
	 datum.setStatus(status);
	 datum.setFetchTime(System.currentTimeMillis());
	 if (pstatus != null) datum.getMetaData().put(Nutch.WRITABLE_PROTO_STATUS_KEY, pstatus);
	 ParseResult parseResult = null;
	 if (content != null) {
		 Metadata metadata = content.getMetadata();
		 metadata.set(Nutch.SEGMENT_NAME_KEY, segmentName);
		 try {
			 scfilters.passScoreBeforeParsing(key, datum, content);
		 }
		 catch (Exception e) {
			 if (LOG.isWarnEnabled()) {
				 e.printStackTrace(LogUtil.getWarnStream(LOG));
				 LOG.warn(""Couldn't pass score, url "" + key + "" ("" + e + "")"");
			 }
		 }
		 try {
			 parseResult = this.parseUtil.parse(content);
		 }
		 catch (Exception e) {
			 LOG.warn(""Error parsing: "" + key + "": "" + StringUtils.stringifyException(e));
		 }
		 if (parseResult == null) {
			 byte[] signature = SignatureFactory.getSignature(getConf()).calculate( content, new ParseStatus().getEmptyParse(getConf()));
			 datum.setSignature(signature);
		 }
		 try {
			 output.collect(key, new NutchWritable(datum));
			 output.collect(key, new NutchWritable(content));
			 if (parseResult != null) {
				 for (Entry <Text, Parse> entry : parseResult) {
					 Text url = entry.getKey();
					 Parse parse = entry.getValue();
					 ParseStatus parseStatus = parse.getData().getStatus();
					 if (!parseStatus.isSuccess()) {
						 LOG.warn(""Error parsing: "" + key + "": "" + parseStatus);
						 parse = parseStatus.getEmptyParse(getConf());
					 }
					 byte[] signature = SignatureFactory.getSignature(getConf()).calculate( content, parse);
					 parse.getData().getContentMeta().set(Nutch.SEGMENT_NAME_KEY, segmentName);
					 parse.getData().getContentMeta().set(Nutch.SIGNATURE_KEY, StringUtil.toHexString(signature));
					 parse.getData().getContentMeta().set(Nutch.FETCH_TIME_KEY, Long.toString(datum.getFetchTime()));
					 if (url.equals(key)) datum.setSignature(signature);
					 try {
						 scfilters.passScoreAfterParsing(url, content, parse);
					 }
					 catch (Exception e) {
						 if (LOG.isWarnEnabled()) {
							 e.printStackTrace(LogUtil.getWarnStream(LOG));
							 LOG.warn(""Couldn't pass score, url "" + key + "" ("" + e + "")"");
						 }
					 }
					 output.collect(url, new NutchWritable(new ParseImpl(new ParseText( parse.getText()), parse.getData(), parse.isCanonical())));
				 }
			 }
		 }
		 catch (IOException e) {
			 if (LOG.isErrorEnabled()) {
				 LOG.error(""ArcSegmentCreator caught:"" + StringUtils.stringifyException(e));
			 }
		 }
		 if (parseResult != null && !parseResult.isEmpty()) {
			 Parse p = parseResult.get(content.getUrl());
			 if (p != null) {
				 return p.getData().getStatus();
			 }
		 }
	 }
	 return null;
 }",0,0,1,0
"public void applyTo(List<Object> target){
	original.applyDelete(target);
	revised.applyAdd(original.first(), target);
}",0,0,0,0
"public class TestGruntParser {
	 private GruntParser parser;
	 private Map<String, String> override;
	 public void setUp() throws Exception {
		 override = new HashMap<String, String>() {
			{
				 put(""STORE"", """");
				 put(""DUMP"", """");
			 }
		}
		;
		 PigServer pigServer = new PigServer(Util.getLocalTestMode());
		 parser = new GruntParser(new StringReader(""""), pigServer, override);
	 }
	 public void testRemoveStores() throws IOException {
		 Assert.assertEquals("""", parser.override(""STORE output INTO '/path';
		""));
		 override.remove(""STORE"");
		 Assert.assertEquals( ""STORE output INTO '/path';
		"", parser.override(""STORE output INTO '/path';
		""));
	 }
	 public void testRemoveDumps() throws IOException {
		 Assert.assertEquals("""", parser.override(""DUMP output;
		""));
		 override.remove(""DUMP"");
		 Assert.assertEquals(""DUMP output;
		"", parser.override(""DUMP output;
		""));
	 }
	 public void testReplaceLoad() throws IOException {
		 override.put(""A"", ""A = LOAD 'file';
		"");
		 Assert.assertEquals( ""A = LOAD 'file';
		"", parser.override(""A = LOAD 'input.txt' AS (query:CHARARRAY);
		""));
	 }
	 public void testGetStoreAlias() throws IOException {
		 override.remove(""STORE"");
		 parser.override(""STORE output INTO '/path'"");
		 Assert.assertEquals(""output"", override.get(""LAST_STORE_ALIAS""));
	 }
	 public void testChangeRootDirectory() throws Exception {
		 Assert.assertEquals( ""A = LOAD 'input.txt';
		"", parser.override(""A = LOAD 'input.txt';
		""));
		 System.setProperty(""pigunit.filesystem.prefix"", ""/tmp/pigunit/"");
		 Assert.assertEquals( ""A = LOAD '/tmp/pigunit/input.txt';
		"", parser.override(""A = LOAD 'input.txt';
		""));
		 System.clearProperty(""pigunit.filesystem.prefix"");
		 Assert.assertEquals( ""A = LOAD 'input.txt';
		"", parser.override(""A = LOAD 'input.txt';
		""));
	 }
}",1,0,0,0
"class GlyphPainter2 extends GlyphView.GlyphPainter {
	 public GlyphPainter2(TextLayout layout) {
		 this.layout = layout;
	 }
	 public GlyphView.GlyphPainter getPainter(GlyphView v, int p0, int p1) {
		 return null;
	 }
	 public float getSpan(GlyphView v, int p0, int p1, TabExpander e, float x) {
		 if ((p0 == v.getStartOffset()) && (p1 == v.getEndOffset())) {
			 return layout.getAdvance();
		 }
		 int p = v.getStartOffset();
		 int index0 = p0 - p;
		 int index1 = p1 - p;
		 TextHitInfo hit0 = TextHitInfo.afterOffset(index0);
		 TextHitInfo hit1 = TextHitInfo.beforeOffset(index1);
		 float[] locs = layout.getCaretInfo(hit0);
		 float x0 = locs[0];
		 locs = layout.getCaretInfo(hit1);
		 float x1 = locs[0];
		 return (x1 > x0) ? x1 - x0 : x0 - x1;
	 }
	 public float getHeight(GlyphView v) {
		 return layout.getAscent() + layout.getDescent() + layout.getLeading();
	 }
	 public float getAscent(GlyphView v) {
		 return layout.getAscent();
	 }
	 public float getDescent(GlyphView v) {
		 return layout.getDescent();
	 }
	 public void paint(GlyphView v, Graphics g, Shape a, int p0, int p1) {
		 if (g instanceof Graphics2D) {
			 Rectangle2D alloc = a.getBounds2D();
			 Graphics2D g2d = (Graphics2D)g;
			 float y = (float) alloc.getY() + layout.getAscent() + layout.getLeading();
			 float x = (float) alloc.getX();
			 if( p0 > v.getStartOffset() || p1 < v.getEndOffset() ) {
				 try {
					 Shape s = v.modelToView(p0, Position.Bias.Forward, p1, Position.Bias.Backward, a);
					 Shape savedClip = g.getClip();
					 g2d.clip(s);
					 layout.draw(g2d, x, y);
					 g.setClip(savedClip);
				 }
				 catch (BadLocationException e) {
				}
			 }
			 else {
				 layout.draw(g2d, x, y);
			 }
		 }
	 }
	 public Shape modelToView(GlyphView v, int pos, Position.Bias bias, Shape a) throws BadLocationException {
		 int offs = pos - v.getStartOffset();
		 Rectangle2D alloc = a.getBounds2D();
		 TextHitInfo hit = (bias == Position.Bias.Forward) ? TextHitInfo.afterOffset(offs) : TextHitInfo.beforeOffset(offs);
		 float[] locs = layout.getCaretInfo(hit);
		 Rectangle2D rect = new Rectangle2D.Float();
		 rect.setRect(alloc.getX() + locs[0], alloc.getY(), 1, alloc.getHeight());
		 return rect;
	 }
	 public int viewToModel(GlyphView v, float x, float y, Shape a, Position.Bias[] biasReturn) {
		 Rectangle2D alloc = (a instanceof Rectangle2D) ? (Rectangle2D)a : a.getBounds2D();
		 TextHitInfo hit = layout.hitTestChar(x - (float)alloc.getX(), 0);
		 int pos = hit.getInsertionIndex();
		 if (pos == v.getEndOffset()) {
			 pos--;
		 }
		 biasReturn[0] = hit.isLeadingEdge() ? Position.Bias.Forward : Position.Bias.Backward;
		 return pos + v.getStartOffset();
	 }
	 public int getBoundedPosition(GlyphView v, int p0, float x, float len) {
		 if( len < 0 ) throw new IllegalArgumentException(""Length must be >= 0."");
		 TextHitInfo hit;
		 if (layout.isLeftToRight()) {
			 hit = layout.hitTestChar(len, 0);
		 }
		 else {
			 hit = layout.hitTestChar(layout.getAdvance() - len, 0);
		 }
		 return v.getStartOffset() + hit.getCharIndex();
	 }
	 public int getNextVisualPositionFrom(GlyphView v, int pos, Position.Bias b, Shape a, int direction, Position.Bias[] biasRet) throws BadLocationException {
		 Document doc = v.getDocument();
		 int startOffset = v.getStartOffset();
		 int endOffset = v.getEndOffset();
		 Segment text;
		 boolean viewIsLeftToRight;
		 TextHitInfo currentHit, nextHit;
		 switch (direction) {
			 case View.NORTH: break;
			 case View.SOUTH: break;
			 case View.EAST: viewIsLeftToRight = AbstractDocument.isLeftToRight(doc, startOffset, endOffset);
			 if(startOffset == doc.getLength()) {
				 if(pos == -1) {
					 biasRet[0] = Position.Bias.Forward;
					 return startOffset;
				 }
				 return -1;
			 }
			 if(pos == -1) {
				 if( viewIsLeftToRight ) {
					 biasRet[0] = Position.Bias.Forward;
					 return startOffset;
				 }
				 else {
					 text = v.getText(endOffset - 1, endOffset);
					 char c = text.array[text.offset];
					 SegmentCache.releaseSharedSegment(text);
					 if(c == '\n') {
						 biasRet[0] = Position.Bias.Forward;
						 return endOffset-1;
					 }
					 biasRet[0] = Position.Bias.Backward;
					 return endOffset;
				 }
			 }
			 if( b==Position.Bias.Forward ) currentHit = TextHitInfo.afterOffset(pos-startOffset);
			 else currentHit = TextHitInfo.beforeOffset(pos-startOffset);
			 nextHit = layout.getNextRightHit(currentHit);
			 if( nextHit == null ) {
				 return -1;
			 }
			 if( viewIsLeftToRight != layout.isLeftToRight() ) {
				 nextHit = layout.getVisualOtherHit(nextHit);
			 }
			 pos = nextHit.getInsertionIndex() + startOffset;
			 if(pos == endOffset) {
				 text = v.getText(endOffset - 1, endOffset);
				 char c = text.array[text.offset];
				 SegmentCache.releaseSharedSegment(text);
				 if(c == '\n') {
					 return -1;
				 }
				 biasRet[0] = Position.Bias.Backward;
			 }
			 else {
				 biasRet[0] = Position.Bias.Forward;
			 }
			 return pos;
			 case View.WEST: viewIsLeftToRight = AbstractDocument.isLeftToRight(doc, startOffset, endOffset);
			 if(startOffset == doc.getLength()) {
				 if(pos == -1) {
					 biasRet[0] = Position.Bias.Forward;
					 return startOffset;
				 }
				 return -1;
			 }
			 if(pos == -1) {
				 if( viewIsLeftToRight ) {
					 text = v.getText(endOffset - 1, endOffset);
					 char c = text.array[text.offset];
					 SegmentCache.releaseSharedSegment(text);
					 if ((c == '\n') || Character.isSpaceChar(c)) {
						 biasRet[0] = Position.Bias.Forward;
						 return endOffset - 1;
					 }
					 biasRet[0] = Position.Bias.Backward;
					 return endOffset;
				 }
				 else {
					 biasRet[0] = Position.Bias.Forward;
					 return startOffset;
				 }
			 }
			 if( b==Position.Bias.Forward ) currentHit = TextHitInfo.afterOffset(pos-startOffset);
			 else currentHit = TextHitInfo.beforeOffset(pos-startOffset);
			 nextHit = layout.getNextLeftHit(currentHit);
			 if( nextHit == null ) {
				 return -1;
			 }
			 if( viewIsLeftToRight != layout.isLeftToRight() ) {
				 nextHit = layout.getVisualOtherHit(nextHit);
			 }
			 pos = nextHit.getInsertionIndex() + startOffset;
			 if(pos == endOffset) {
				 text = v.getText(endOffset - 1, endOffset);
				 char c = text.array[text.offset];
				 SegmentCache.releaseSharedSegment(text);
				 if(c == '\n') {
					 return -1;
				 }
				 biasRet[0] = Position.Bias.Backward;
			 }
			 else {
				 biasRet[0] = Position.Bias.Forward;
			 }
			 return pos;
			 default: throw new IllegalArgumentException(""Bad direction: "" + direction);
		 }
		 return pos;
	 }
	 TextLayout layout;
}",1,0,0,0
"public void reduce(Text key, Iterator<MetaWrapper> values, OutputCollector<Text, MetaWrapper> output, Reporter reporter) throws IOException {
	 CrawlDatum lastG = null;
	 CrawlDatum lastF = null;
	 CrawlDatum lastSig = null;
	 Content lastC = null;
	 ParseData lastPD = null;
	 ParseText lastPT = null;
	 String lastGname = null;
	 String lastFname = null;
	 String lastSigname = null;
	 String lastCname = null;
	 String lastPDname = null;
	 String lastPTname = null;
	 TreeMap<String, ArrayList<CrawlDatum>> linked = new TreeMap<String, ArrayList<CrawlDatum>>();
	 while (values.hasNext()) {
		 MetaWrapper wrapper = values.next();
		 Object o = wrapper.get();
		 String spString = wrapper.getMeta(SEGMENT_PART_KEY);
		 if (spString == null) {
			 throw new IOException(""Null segment part, key="" + key);
		 }
		 SegmentPart sp = SegmentPart.parse(spString);
		 if (o instanceof CrawlDatum) {
			 CrawlDatum val = (CrawlDatum)o;
			 if (sp.partName.equals(CrawlDatum.GENERATE_DIR_NAME)) {
				 if (lastG == null) {
					 lastG = val;
					 lastGname = sp.segmentName;
				 }
				 else {
					 if (lastGname.compareTo(sp.segmentName) < 0) {
						 lastG = val;
						 lastGname = sp.segmentName;
					 }
				 }
			 }
			 else if (sp.partName.equals(CrawlDatum.FETCH_DIR_NAME)) {
				 if (lastF == null) {
					 lastF = val;
					 lastFname = sp.segmentName;
				 }
				 else {
					 if (lastFname.compareTo(sp.segmentName) < 0) {
						 lastF = val;
						 lastFname = sp.segmentName;
					 }
				 }
			 }
			 else if (sp.partName.equals(CrawlDatum.PARSE_DIR_NAME)) {
				 if (val.getStatus() == CrawlDatum.STATUS_SIGNATURE) {
					 if (lastSig == null) {
						 lastSig = val;
						 lastSigname = sp.segmentName;
					 }
					 else {
						 if (lastSigname.compareTo(sp.segmentName) < 0) {
							 lastSig = val;
							 lastSigname = sp.segmentName;
						 }
					 }
					 continue;
				 }
				 ArrayList<CrawlDatum> segLinked = linked.get(sp.segmentName);
				 if (segLinked == null) {
					 segLinked = new ArrayList<CrawlDatum>();
					 linked.put(sp.segmentName, segLinked);
				 }
				 segLinked.add(val);
			 }
			 else {
				 throw new IOException(""Cannot determine segment part: "" + sp.partName);
			 }
		 }
		 else if (o instanceof Content) {
			 if (lastC == null) {
				 lastC = (Content)o;
				 lastCname = sp.segmentName;
			 }
			 else {
				 if (lastCname.compareTo(sp.segmentName) < 0) {
					 lastC = (Content)o;
					 lastCname = sp.segmentName;
				 }
			 }
		 }
		 else if (o instanceof ParseData) {
			 if (lastPD == null) {
				 lastPD = (ParseData)o;
				 lastPDname = sp.segmentName;
			 }
			 else {
				 if (lastPDname.compareTo(sp.segmentName) < 0) {
					 lastPD = (ParseData)o;
					 lastPDname = sp.segmentName;
				 }
			 }
		 }
		 else if (o instanceof ParseText) {
			 if (lastPT == null) {
				 lastPT = (ParseText)o;
				 lastPTname = sp.segmentName;
			 }
			 else {
				 if (lastPTname.compareTo(sp.segmentName) < 0) {
					 lastPT = (ParseText)o;
					 lastPTname = sp.segmentName;
				 }
			 }
		 }
	 }
	 if (mergeFilters != null && !mergeFilters.filter(key, lastG, lastF, lastSig, lastC, lastPD, lastPT, linked.isEmpty() ? null : linked.lastEntry().getValue())){
		 return;
	 }
	 curCount++;
	 String sliceName = null;
	 MetaWrapper wrapper = new MetaWrapper();
	 if (sliceSize > 0) {
		 sliceName = String.valueOf(curCount / sliceSize);
		 wrapper.setMeta(SEGMENT_SLICE_KEY, sliceName);
	 }
	 SegmentPart sp = new SegmentPart();
	 if (lastG != null) {
		 wrapper.set(lastG);
		 sp.partName = CrawlDatum.GENERATE_DIR_NAME;
		 sp.segmentName = lastGname;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 output.collect(key, wrapper);
	 }
	 if (lastF != null) {
		 wrapper.set(lastF);
		 sp.partName = CrawlDatum.FETCH_DIR_NAME;
		 sp.segmentName = lastFname;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 output.collect(key, wrapper);
	 }
	 if (lastSig != null) {
		 wrapper.set(lastSig);
		 sp.partName = CrawlDatum.PARSE_DIR_NAME;
		 sp.segmentName = lastSigname;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 output.collect(key, wrapper);
	 }
	 if (lastC != null) {
		 wrapper.set(lastC);
		 sp.partName = Content.DIR_NAME;
		 sp.segmentName = lastCname;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 output.collect(key, wrapper);
	 }
	 if (lastPD != null) {
		 wrapper.set(lastPD);
		 sp.partName = ParseData.DIR_NAME;
		 sp.segmentName = lastPDname;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 output.collect(key, wrapper);
	 }
	 if (lastPT != null) {
		 wrapper.set(lastPT);
		 sp.partName = ParseText.DIR_NAME;
		 sp.segmentName = lastPTname;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 output.collect(key, wrapper);
	 }
	 if (linked.size() > 0) {
		 String name = linked.lastKey();
		 sp.partName = CrawlDatum.PARSE_DIR_NAME;
		 sp.segmentName = name;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 ArrayList<CrawlDatum> segLinked = linked.get(name);
		 for (int i = 0;
		 i < segLinked.size();
		 i++) {
			 CrawlDatum link = segLinked.get(i);
			 wrapper.set(link);
			 output.collect(key, wrapper);
		 }
	 }
 }",0,0,1,0
"public class FailureDetector implements IFailureDetector, FailureDetectorMBean{
	 public static final String MBEAN_NAME = ""org.apache.cassandra.net:type=FailureDetector"";
	 public static final IFailureDetector instance = new FailureDetector();
	 private static Logger logger_ = LoggerFactory.getLogger(FailureDetector.class);
	 private static final int sampleSize_ = 1000;
	 private static int phiConvictThreshold_;
	 private Map<InetAddress, ArrivalWindow> arrivalSamples_ = new Hashtable<InetAddress, ArrivalWindow>();
	 private List<IFailureDetectionEventListener> fdEvntListeners_ = new CopyOnWriteArrayList<IFailureDetectionEventListener>();
	 public FailureDetector() {
		 phiConvictThreshold_ = DatabaseDescriptor.getPhiConvictThreshold();
		 try {
			 MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
			 mbs.registerMBean(this, new ObjectName(MBEAN_NAME));
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e);
		 }
	 }
	 public String getAllEndpointStates() {
		 StringBuilder sb = new StringBuilder();
		 for (Map.Entry<InetAddress, EndpointState> entry : Gossiper.instance.endpointStateMap.entrySet()) {
			 sb.append(entry.getKey()).append(""\n"");
			 appendEndpointState(sb, entry.getValue());
		 }
		 return sb.toString();
	 }
	 public Map<String, String> getSimpleStates() {
		 Map<String, String> nodesStatus = new HashMap<String, String>(Gossiper.instance.endpointStateMap.size());
		 for (Map.Entry<InetAddress, EndpointState> entry : Gossiper.instance.endpointStateMap.entrySet()) {
			 if (entry.getValue().isAlive()) nodesStatus.put(entry.getKey().toString(), ""UP"");
			 else nodesStatus.put(entry.getKey().toString(), ""DOWN"");
		 }
		 return nodesStatus;
	 }
	 public String getEndpointState(String address) throws UnknownHostException {
		 StringBuilder sb = new StringBuilder();
		 EndpointState endpointState = Gossiper.instance.getEndpointStateForEndpoint(InetAddress.getByName(address));
		 appendEndpointState(sb, endpointState);
		 return sb.toString();
	 }
	 private void appendEndpointState(StringBuilder sb, EndpointState endpointState) {
		 for (Map.Entry<ApplicationState, VersionedValue> state : endpointState.applicationState.entrySet()) sb.append("" "").append(state.getKey()).append("":"").append(state.getValue().value).append(""\n"");
	 }
	 public void dumpInterArrivalTimes() {
		 OutputStream os = null;
		 try {
			 File file = File.createTempFile(""failuredetector-"", "".dat"");
			 os = new BufferedOutputStream(new FileOutputStream(file, true));
			 os.write(toString().getBytes());
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
		 finally {
			 FileUtils.closeQuietly(os);
		 }
	 }
	 public void setPhiConvictThreshold(int phi) {
		 phiConvictThreshold_ = phi;
	 }
	 public int getPhiConvictThreshold() {
		 return phiConvictThreshold_;
	 }
	 public boolean isAlive(InetAddress ep) {
		 if (ep.equals(FBUtilities.getBroadcastAddress())) return true;
		 EndpointState epState = Gossiper.instance.getEndpointStateForEndpoint(ep);
		 if (epState == null) logger_.error(""unknown endpoint "" + ep);
		 return epState != null && epState.isAlive();
	 }
	 public void clear(InetAddress ep) {
		 ArrivalWindow heartbeatWindow = arrivalSamples_.get(ep);
		 if (heartbeatWindow != null) heartbeatWindow.clear();
	 }
	 public void report(InetAddress ep) {
		 if (logger_.isTraceEnabled()) logger_.trace(""reporting {
		}
		"", ep);
		 long now = System.currentTimeMillis();
		 ArrivalWindow heartbeatWindow = arrivalSamples_.get(ep);
		 if ( heartbeatWindow == null ) {
			 heartbeatWindow = new ArrivalWindow(sampleSize_);
			 arrivalSamples_.put(ep, heartbeatWindow);
		 }
		 heartbeatWindow.add(now);
	 }
	 public void interpret(InetAddress ep) {
		 ArrivalWindow hbWnd = arrivalSamples_.get(ep);
		 if ( hbWnd == null ) {
			 return;
		 }
		 long now = System.currentTimeMillis();
		 double phi = hbWnd.phi(now);
		 if (logger_.isTraceEnabled()) logger_.trace(""PHI for "" + ep + "" : "" + phi);
		 if ( phi > phiConvictThreshold_ ) {
			 logger_.trace(""notifying listeners that {
			}
			 is down"", ep);
			 logger_.trace(""intervals: {
			}
			 mean: {
			}
			"", hbWnd, hbWnd.mean());
			 for ( IFailureDetectionEventListener listener : fdEvntListeners_ ) {
				 listener.convict(ep, phi);
			 }
		 }
	 }
	 public void remove(InetAddress ep) {
		 arrivalSamples_.remove(ep);
	 }
	 public void registerFailureDetectionEventListener(IFailureDetectionEventListener listener) {
		 fdEvntListeners_.add(listener);
	 }
	 public void unregisterFailureDetectionEventListener(IFailureDetectionEventListener listener) {
		 fdEvntListeners_.remove(listener);
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder();
		 Set<InetAddress> eps = arrivalSamples_.keySet();
		 sb.append(""-----------------------------------------------------------------------"");
		 for ( InetAddress ep : eps ) {
			 ArrivalWindow hWnd = arrivalSamples_.get(ep);
			 sb.append(ep + "" : "");
			 sb.append(hWnd.toString());
			 sb.append( System.getProperty(""line.separator"") );
		 }
		 sb.append(""-----------------------------------------------------------------------"");
		 return sb.toString();
	 }
	 public static void main(String[] args) throws Throwable {
	 }
}
class ArrivalWindow{
	 private static Logger logger_ = LoggerFactory.getLogger(ArrivalWindow.class);
	 private double tLast_ = 0L;
	 private BoundedStatsDeque arrivalIntervals_;
	 private final double PHI_FACTOR = 1.0 / Math.log(10.0);
	 private final double MAX_INTERVAL_IN_MS = DatabaseDescriptor.getRpcTimeout();
	 ArrivalWindow(int size) {
		 arrivalIntervals_ = new BoundedStatsDeque(size);
	 }
	 synchronized void add(double value) {
		 double interArrivalTime;
		 if ( tLast_ > 0L ) {
			 interArrivalTime = (value - tLast_);
		 }
		 else {
			 interArrivalTime = Gossiper.intervalInMillis / 2;
		 }
		 if (interArrivalTime <= MAX_INTERVAL_IN_MS) arrivalIntervals_.add(interArrivalTime);
		 else logger_.debug(""Ignoring interval time of {
		}
		"", interArrivalTime);
		 tLast_ = value;
	 }
	 synchronized double sum() {
		 return arrivalIntervals_.sum();
	 }
	 synchronized double sumOfDeviations() {
		 return arrivalIntervals_.sumOfDeviations();
	 }
	 synchronized double mean() {
		 return arrivalIntervals_.mean();
	 }
	 synchronized double variance() {
		 return arrivalIntervals_.variance();
	 }
	 double stdev() {
		 return arrivalIntervals_.stdev();
	 }
	 void clear() {
		 arrivalIntervals_.clear();
	 }
	 synchronized double phi(long tnow) {
		 int size = arrivalIntervals_.size();
		 double t = tnow - tLast_;
		 return (size > 0) ? PHI_FACTOR * t / mean() : 0.0;
	 }
	 public String toString() {
		 return StringUtils.join(arrivalIntervals_.iterator(), "" "");
	 }
}",0,0,0,0
"public class CliUserHelp{
	 public String banner;
	 public String help;
	 public List<CliCommandHelp> commands;
}",0,0,0,0
"public interface ColumnPreparedStatement {
	 ColumnPreparedStatement bind(String name, Object value);
	 List<ColumnEntity> getResultList();
	 Optional<ColumnEntity> getSingleResult();
}",0,0,0,0
"public final class CommandShelvesets extends Command {
	 private static final String SHELVESETS_ELEMENT_NAME = ""shelvesets"";
	 private final DateFormat defaultFormat = SimpleDateFormat.getDateTimeInstance();
	 public CommandShelvesets() {
		 super();
	 }
	 public void run() throws ArgumentException, MalformedURLException, CLCException, LicenseException, InputValidationException {
		 if (getFreeArguments().length > 1) {
			 final String messageFormat = Messages.getString(""CommandShelvesets.CommandRequiresZeroOrOneShelvesetNamesFormat"");
			 final String message = MessageFormat.format(messageFormat, getCanonicalName());
			 throw new InvalidFreeArgumentException(message);
		 }
		 String ownerArg = null;
		 String format = OptionFormat.BRIEF;
		 Option o = null;
		 if ((o = findOptionType(OptionFormat.class)) != null) {
			 format = ((OptionFormat) o).getValue();
		 }
		 if ((o = findOptionType(OptionOwner.class)) != null) {
			 ownerArg = ((OptionOwner) o).getValue();
		 }
		 final TFSTeamProjectCollection connection = createConnection(new String[0]);
		 final VersionControlClient client = connection.getVersionControlClient();
		 initializeClient(client);
		 final Workspace workspace = realizeCachedWorkspace(determineCachedWorkspace(new String[0]), client);
		 Check.notNull(workspace, ""workspace"");
		 String shelvesetName = null;
		 String shelvesetOwner = null;
		 if (getFreeArguments().length == 1) {
			 final WorkspaceSpec spec = WorkspaceSpec.parse(getFreeArguments()[0], VersionControlConstants.AUTHENTICATED_USER);
			 shelvesetName = spec.getName();
			 shelvesetOwner = spec.getOwner();
			 if (shelvesetName.equalsIgnoreCase(""*"")) {
				 shelvesetName = null;
			 }
		 }
		 if (ownerArg != null) {
			 shelvesetOwner = ownerArg;
		 }
		 if (shelvesetOwner == null) {
			 shelvesetOwner = VersionControlConstants.AUTHENTICATED_USER;
		 }
		 else if (shelvesetOwner.equalsIgnoreCase(""*"")) {
			 shelvesetOwner = null;
		 }
		 final Shelveset[] shelvesets = client.queryShelvesets(shelvesetName, shelvesetOwner, null);
		 if (shelvesets.length == 0) {
			 final String displayOwner = (shelvesetOwner != null && shelvesetOwner.equals(VersionControlConstants.AUTHENTICATED_USER)) ? connection.getAuthorizedIdentity().getDisplayName() : ((shelvesetOwner == null) ? ""*"" : shelvesetOwner);
			 final String displayShelvesetName = (shelvesetName == null) ? ""*"" : shelvesetName;
			 final String shelvesetPattern = new WorkspaceSpec(displayShelvesetName, displayOwner).toString();
			 final String messageFormat = Messages.getString(""CommandShelvesets.NoShelvesetsFoundMatchingFormat"");
			 final String message = MessageFormat.format(messageFormat, shelvesetPattern);
			 if (shelvesetName == null) {
				 getDisplay().printLine(message);
				 setExitCode(ExitCode.PARTIAL_SUCCESS);
				 return;
			 }
			 throw new InvalidFreeArgumentException(message);
		 }
		 Arrays.sort(shelvesets, ShelvesetComparator.INSTANCE);
		 if (OptionFormat.DETAILED.equalsIgnoreCase(format)) {
			 ShelvesetPrinter.printDetailedShelvesets( shelvesets, defaultFormat, getDisplay(), connection.getWorkItemClient());
		 }
		 else if (OptionFormat.BRIEF.equalsIgnoreCase(format)) {
			 ShelvesetPrinter.printBriefShelvesets(shelvesets, getDisplay());
		 }
		 else if (OptionFormat.XML.equalsIgnoreCase(format)) {
			 ShelvesetPrinter.printXMLShelvesets(shelvesets, SHELVESETS_ELEMENT_NAME, getDisplay());
		 }
		 else {
			 final String messageFormat = Messages.getString(""CommandShelvesets.UnsupportedOutputFormat"");
			 final String message = MessageFormat.format(messageFormat, format);
			 throw new RuntimeException(message);
		 }
	 }
	 public AcceptedOptionSet[] getSupportedOptionSets() {
		 final AcceptedOptionSet[] optionSets = new AcceptedOptionSet[1];
		 optionSets[0] = new AcceptedOptionSet(new Class[] {
		 OptionOwner.class, OptionFormat.class }
		, ""[<shelvesetName>]"");
		 return optionSets;
	 }
	 public String[] getCommandHelpText() {
		 return new String[] {
		 Messages.getString(""CommandShelvesets.HelpText1"") }
		;
	 }
}",1,0,0,0
"public final int getIndex(){
	return index;
}",0,0,0,0
"private void ensureAuthenticated() throws IOException, SMTPException,CommandCancelledException {
	String username;
	char[] password = new char[0];
	boolean savePassword;
	fromAddress = identity.getAddress().getMailAddress();
	SpecialFoldersItem specialFoldersItem = accountItem.getSpecialFoldersItem();
	Integer i = new Integer(specialFoldersItem.get(""sent""));
	int sentFolder = i.intValue();
	usingSSL = smtpItem.getBoolean(""enable_ssl"");
	int authMethod = getLoginMethod();
	boolean authenticated = (authMethod == AuthenticationManager.NONE);
	if (authMethod == AuthenticationManager.POP_BEFORE_SMTP) {
		try {
			pop3Authentification();
		}
		 catch (POP3Exception e) {
			throw new SMTPException(e);
		}
		authenticated = true;
	}
	ensureConnected();
	if (!authenticated) {
		username = smtpItem.get(""user"");
		password = Blowfish.decrypt(smtpItem.getRoot().getAttribute(""password"", """"));
		savePassword = smtpItem.getBoolean(""save_password"");
		if (username.length() == 0) {
			if (accountItem.isPopAccount()) {
				PopItem pop3Item = accountItem.getPopItem();
				username = pop3Item.get(""user"");
			}
			 else {
				ImapItem imapItem = accountItem.getImapItem();
				username = imapItem.get(""user"");
			}
		}
		PasswordDialog passDialog = new PasswordDialog();
		if (password.length == 0) {
			passDialog.showDialog(MessageFormat.format(MailResourceLoader.getString(""dialog"", ""password"", ""enter_password""),new Object[] {
			 username,smtpItem.get(""host"") }
			),new String(password), savePassword);
			if (passDialog.success()) {
				password = passDialog.getPassword();
				savePassword = passDialog.getSave();
			}
			 else {
				throw new CommandCancelledException();
			}
		}
		while (!authenticated) {
			try {
				try {
					protocol.auth(AuthenticationManager.getSaslName(authMethod), username, password);
					authenticated = true;
				}
				 catch (AuthenticationException e) {
					if (e.getCause() instanceof SMTPException) {
						int errorCode = ((SMTPException) e.getCause()).getCode();
						if( errorCode == 504 ) {
							JOptionPane.showMessageDialog(FrameManager.getInstance().getActiveFrame(),new MultiLineLabel(MailResourceLoader.getString(""dialog"",""error"",""authentication_not_supported"")),MailResourceLoader.getString(""dialog"",""error"",""authentication_process_error""),JOptionPane.INFORMATION_MESSAGE);
							smtpItem.setString(""login_method"", Integer.toString(AuthenticationManager.NONE));
							return;
						}
					}
					 else {
						throw (SMTPException) e.getCause();
					}
					 int result = JOptionPane.showConfirmDialog(FrameManager.getInstance().getActiveFrame(),new MultiLineLabel(e.getMessage()+ ""\n""+ MailResourceLoader.getString(""dialog"",""error"",""authentication_fallback_to_default"")),MailResourceLoader.getString(""dialog"",""error"",""authentication_process_error""),JOptionPane.OK_CANCEL_OPTION);
					if (result == JOptionPane.OK_OPTION) {
						authMethod = AuthenticationManager.SASL_PLAIN;
						smtpItem.setString(""login_method"", Integer.toString(authMethod));
					}
					 else {
						throw new CommandCancelledException();
					}
				}
			}
			 catch (SMTPException e) {
				passDialog.showDialog(MessageFormat.format(MailResourceLoader.getString(""dialog"", ""password"",""enter_password""), new Object[] {
				 username,smtpItem.get(""host"") }
				), new String(password), savePassword);
				if (!passDialog.success()) {
					throw new CommandCancelledException();
				}
				 else {
					password = passDialog.getPassword();
					savePassword = passDialog.getSave();
				}
			}
		}
		smtpItem.setString(""user"", username);
		smtpItem.setBoolean(""save_password"", savePassword);
		if (savePassword) {
			smtpItem.setString(""password"", Blowfish.encrypt(password));
		}
	}
}",0,0,1,0
"public static String getTimestampedSnapshotName(String clientSuppliedName) {
	 String snapshotName = Long.toString(System.currentTimeMillis());
	 if (clientSuppliedName != null && !clientSuppliedName.equals("""")) {
		 snapshotName = snapshotName + ""-"" + clientSuppliedName;
	 }
	 return snapshotName;
 }",0,0,0,0
"public int execute(CompactionExecutorStatsCollector collector) throws IOException {
	 assert sstables != null;
	 Set<SSTableReader> toCompact = new HashSet<SSTableReader>(sstables);
	 if (!isCompactionInteresting(toCompact)) return 0;
	 File compactionFileLocation = cfs.directories.getDirectoryForNewSSTables(cfs.getExpectedCompactedFileSize(toCompact), ensureFreeSpace());
	 if (compactionFileLocation == null && partialCompactionsAcceptable()) {
		 while (compactionFileLocation == null && toCompact.size() > 1) {
			 logger.warn(""insufficient space to compact all requested files "" + StringUtils.join(toCompact, "", ""));
			 toCompact.remove(cfs.getMaxSizeFile(toCompact));
			 compactionFileLocation = cfs.directories.getDirectoryForNewSSTables(cfs.getExpectedCompactedFileSize(toCompact), ensureFreeSpace());
		 }
	 }
	 if (compactionFileLocation == null) {
		 logger.warn(""insufficient space to compact even the two smallest files, aborting"");
		 return 0;
	 }
	 assert compactionFileLocation != null;
	 if (DatabaseDescriptor.isSnapshotBeforeCompaction()) cfs.snapshotWithoutFlush(System.currentTimeMillis() + ""-"" + ""compact-"" + cfs.columnFamily);
	 for (SSTableReader sstable : toCompact) assert sstable.descriptor.cfname.equals(cfs.columnFamily);
	 CompactionController controller = new CompactionController(cfs, toCompact, gcBefore, isUserDefined);
	 logger.info(""Compacting {
	}
	"", toCompact);
	 long startTime = System.currentTimeMillis();
	 long totalkeysWritten = 0;
	 long estimatedTotalKeys = Math.max(DatabaseDescriptor.getIndexInterval(), SSTableReader.getApproximateKeyCount(toCompact));
	 long estimatedSSTables = Math.max(1, SSTable.getTotalBytes(toCompact) / cfs.getCompactionStrategy().getMaxSSTableSize());
	 long keysPerSSTable = (long) Math.ceil((double) estimatedTotalKeys / estimatedSSTables);
	 if (logger.isDebugEnabled()) logger.debug(""Expected bloom filter size : "" + keysPerSSTable);
	 AbstractCompactionIterable ci = DatabaseDescriptor.isMultithreadedCompaction() ? new ParallelCompactionIterable(compactionType, toCompact, controller) : new CompactionIterable(compactionType, toCompact, controller);
	 CloseableIterator<AbstractCompactedRow> iter = ci.iterator();
	 Iterator<AbstractCompactedRow> nni = Iterators.filter(iter, Predicates.notNull());
	 Map<DecoratedKey, Long> cachedKeys = new HashMap<DecoratedKey, Long>();
	 Map<SSTableReader, Map<DecoratedKey, Long>> cachedKeyMap = new HashMap<SSTableReader, Map<DecoratedKey, Long>>();
	 Collection<SSTableReader> sstables = new ArrayList<SSTableReader>();
	 Collection<SSTableWriter> writers = new ArrayList<SSTableWriter>();
	 if (collector != null) collector.beginCompaction(ci);
	 try {
		 if (!nni.hasNext()) {
			 cfs.markCompacted(toCompact, compactionType);
			 return 0;
		 }
		 SSTableWriter writer = cfs.createCompactionWriter(keysPerSSTable, compactionFileLocation, toCompact);
		 writers.add(writer);
		 while (nni.hasNext()) {
			 if (ci.isStopped()) throw new CompactionInterruptedException(ci.getCompactionInfo());
			 AbstractCompactedRow row = nni.next();
			 if (row.isEmpty()) continue;
			 long position = writer.append(row);
			 totalkeysWritten++;
			 if (DatabaseDescriptor.getPreheatKeyCache()) {
				 for (SSTableReader sstable : toCompact) {
					 if (sstable.getCachedPosition(row.key, false) != null) {
						 cachedKeys.put(row.key, position);
						 break;
					 }
				 }
			 }
			 if (!nni.hasNext() || newSSTableSegmentThresholdReached(writer, position)) {
				 SSTableReader toIndex = writer.closeAndOpenReader(getMaxDataAge(toCompact));
				 cachedKeyMap.put(toIndex, cachedKeys);
				 sstables.add(toIndex);
				 if (nni.hasNext()) {
					 writer = cfs.createCompactionWriter(keysPerSSTable, compactionFileLocation, toCompact);
					 writers.add(writer);
					 cachedKeys = new HashMap<DecoratedKey, Long>();
				 }
			 }
		 }
	 }
	 catch (Exception e) {
		 for (SSTableWriter writer : writers) writer.abort();
		 throw FBUtilities.unchecked(e);
	 }
	 finally {
		 iter.close();
		 if (collector != null) collector.finishCompaction(ci);
	 }
	 cfs.replaceCompactedSSTables(toCompact, sstables, compactionType);
	 for (Entry<SSTableReader, Map<DecoratedKey, Long>> ssTableReaderMapEntry : cachedKeyMap.entrySet()) {
		 SSTableReader key = ssTableReaderMapEntry.getKey();
		 for (Entry<DecoratedKey, Long> entry : ssTableReaderMapEntry.getValue().entrySet()) key.cacheKey(entry.getKey(), entry.getValue());
	 }
	 long dTime = System.currentTimeMillis() - startTime;
	 long startsize = SSTable.getTotalBytes(toCompact);
	 long endsize = SSTable.getTotalBytes(sstables);
	 double ratio = (double)endsize / (double)startsize;
	 StringBuilder builder = new StringBuilder();
	 builder.append(""["");
	 for (SSTableReader reader : sstables) builder.append(reader.getFilename()).append("","");
	 builder.append(""]"");
	 double mbps = dTime > 0 ? (double)endsize/(1024*1024)/((double)dTime/1000) : 0;
	 logger.info(String.format(""Compacted to %s. %,d to %,d (~%d%% of original) bytes for %,d keys at %fMB/s. Time: %,dms."", builder.toString(), startsize, endsize, (int) (ratio * 100), totalkeysWritten, mbps, dTime));
	 logger.debug(String.format(""CF Total Bytes Compacted: %,d"", CompactionTask.addToTotalBytesCompacted(endsize)));
	 return toCompact.size();
 }",0,0,1,0
"public class FileSystemSpoolOutTarget implements SpoolOutTarget{
	 private final Path basePath;
	 public FileSystemSpoolOutTarget ( final Path basePath ) {
		 this.basePath = basePath;
	 }
	 public void spoolOut ( final String fileName, final String mimeType, final IOConsumer<OutputStream> streamConsumer ) throws IOException {
		 final Path path = this.basePath.resolve ( fileName );
		 Files.createDirectories ( path.getParent () );
		 try ( OutputStream stream = new BufferedOutputStream ( Files.newOutputStream ( path ) ) ) {
			 streamConsumer.accept ( stream );
		 }
	 }
}",0,0,0,0
"private static List<Row> fetchRows(List<ReadCommand> commands, ConsistencyLevel consistency_level) throws IOException, UnavailableException, TimeoutException {
	 List<ReadCallback<Row>> readCallbacks = new ArrayList<ReadCallback<Row>>();
	 List<Row> rows = new ArrayList<Row>();
	 for (ReadCommand command: commands) {
		 assert !command.isDigestQuery();
		 logger.debug(""Command/ConsistencyLevel is {
		}
		/{
		}
		"", command, consistency_level);
		 List<InetAddress> endpoints = StorageService.instance.getLiveNaturalEndpoints(command.table, command.key);
		 DatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getLocalAddress(), endpoints);
		 RowDigestResolver resolver = new RowDigestResolver(command.table, command.key);
		 ReadCallback<Row> handler = getReadCallback(resolver, command, consistency_level, endpoints);
		 handler.assureSufficientLiveNodes();
		 assert !handler.endpoints.isEmpty();
		 ReadCommand digestCommand = null;
		 if (handler.endpoints.size() > 1) {
			 digestCommand = command.copy();
			 digestCommand.setDigestQuery(true);
		 }
		 InetAddress dataPoint = handler.endpoints.get(0);
		 if (dataPoint.equals(FBUtilities.getLocalAddress())) {
			 if (logger.isDebugEnabled()) logger.debug(""reading data locally"");
			 StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(command, handler));
		 }
		 else {
			 Message message = command.makeReadMessage();
			 if (logger.isDebugEnabled()) logger.debug(""reading data from "" + dataPoint);
			 MessagingService.instance().sendRR(message, dataPoint, handler);
		 }
		 Message digestMessage = null;
		 for (InetAddress digestPoint : handler.endpoints.subList(1, handler.endpoints.size())) {
			 if (digestPoint.equals(FBUtilities.getLocalAddress())) {
				 if (logger.isDebugEnabled()) logger.debug(""reading digest locally"");
				 StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(digestCommand, handler));
			 }
			 else {
				 if (digestMessage == null) digestMessage = digestCommand.makeReadMessage();
				 if (logger.isDebugEnabled()) logger.debug(""reading digest for from "" + digestPoint);
				 MessagingService.instance().sendRR(digestMessage, digestPoint, handler);
			 }
		 }
		 readCallbacks.add(handler);
	 }
	 List<RepairCallback<Row>> repairResponseHandlers = null;
	 for (int i = 0;
	 i < commands.size();
	 i++) {
		 ReadCallback<Row> handler = readCallbacks.get(i);
		 Row row;
		 ReadCommand command = commands.get(i);
		 try {
			 long startTime2 = System.currentTimeMillis();
			 row = handler.get();
			 if (row != null) rows.add(row);
			 if (logger.isDebugEnabled()) logger.debug(""Read: "" + (System.currentTimeMillis() - startTime2) + "" ms."");
		 }
		 catch (DigestMismatchException ex) {
			 if (logger.isDebugEnabled()) logger.debug(""Digest mismatch:"", ex);
			 RowRepairResolver resolver = new RowRepairResolver(command.table, command.key);
			 RepairCallback<Row> repairHandler = new RepairCallback<Row>(resolver, handler.endpoints);
			 Message messageRepair = command.makeReadMessage();
			 for (InetAddress endpoint : handler.endpoints) MessagingService.instance().sendRR(messageRepair, endpoint, repairHandler);
			 if (repairResponseHandlers == null) repairResponseHandlers = new ArrayList<RepairCallback<Row>>();
			 repairResponseHandlers.add(repairHandler);
		 }
	 }
	 if (repairResponseHandlers != null) {
		 for (RepairCallback<Row> handler : repairResponseHandlers) {
			 try {
				 Row row = handler.get();
				 if (row != null) rows.add(row);
			 }
			 catch (DigestMismatchException e) {
				 throw new AssertionError(e);
			 }
		 }
	 }
	 return rows;
 }",0,0,1,0
"public void setSeriesVisible(Boolean visible, boolean notify);",0,0,0,0
"public static class getAllApplicationInterfaceNames_args implements org.apache.thrift.TBase<getAllApplicationInterfaceNames_args, getAllApplicationInterfaceNames_args._Fields>, java.io.Serializable, Cloneable, Comparable<getAllApplicationInterfaceNames_args> {
	 private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct(""getAllApplicationInterfaceNames_args"");
	 private static final org.apache.thrift.protocol.TField GATEWAY_ID_FIELD_DESC = new org.apache.thrift.protocol.TField(""gatewayId"", org.apache.thrift.protocol.TType.STRING, (short)1);
	 private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
	 static {
		 schemes.put(StandardScheme.class, new getAllApplicationInterfaceNames_argsStandardSchemeFactory());
		 schemes.put(TupleScheme.class, new getAllApplicationInterfaceNames_argsTupleSchemeFactory());
	 }
	 public String gatewayId;
	 public enum _Fields implements org.apache.thrift.TFieldIdEnum {
		 GATEWAY_ID((short)1, ""gatewayId"");
		 private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
		 static {
			 for (_Fields field : EnumSet.allOf(_Fields.class)) {
				 byName.put(field.getFieldName(), field);
			 }
		 }
		 public static _Fields findByThriftId(int fieldId) {
			 switch(fieldId) {
				 case 1: return GATEWAY_ID;
				 default: return null;
			 }
		 }
		 public static _Fields findByThriftIdOrThrow(int fieldId) {
			 _Fields fields = findByThriftId(fieldId);
			 if (fields == null) throw new IllegalArgumentException(""Field "" + fieldId + "" doesn't exist!"");
			 return fields;
		 }
		 public static _Fields findByName(String name) {
			 return byName.get(name);
		 }
		 private final short _thriftId;
		 private final String _fieldName;
		 _Fields(short thriftId, String fieldName) {
			 _thriftId = thriftId;
			 _fieldName = fieldName;
		 }
		 public short getThriftFieldId() {
			 return _thriftId;
		 }
		 public String getFieldName() {
			 return _fieldName;
		 }
	 }
	 public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
	 static {
		 Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
		 tmpMap.put(_Fields.GATEWAY_ID, new org.apache.thrift.meta_data.FieldMetaData(""gatewayId"", org.apache.thrift.TFieldRequirementType.REQUIRED, new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
		 metaDataMap = Collections.unmodifiableMap(tmpMap);
		 org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(getAllApplicationInterfaceNames_args.class, metaDataMap);
	 }
	 public getAllApplicationInterfaceNames_args() {
	 }
	 public getAllApplicationInterfaceNames_args( String gatewayId) {
		 this();
		 this.gatewayId = gatewayId;
	 }
	 public getAllApplicationInterfaceNames_args(getAllApplicationInterfaceNames_args other) {
		 if (other.isSetGatewayId()) {
			 this.gatewayId = other.gatewayId;
		 }
	 }
	 public getAllApplicationInterfaceNames_args deepCopy() {
		 return new getAllApplicationInterfaceNames_args(this);
	 }
	 public void clear() {
		 this.gatewayId = null;
	 }
	 public String getGatewayId() {
		 return this.gatewayId;
	 }
	 public getAllApplicationInterfaceNames_args setGatewayId(String gatewayId) {
		 this.gatewayId = gatewayId;
		 return this;
	 }
	 public void unsetGatewayId() {
		 this.gatewayId = null;
	 }
	 public boolean isSetGatewayId() {
		 return this.gatewayId != null;
	 }
	 public void setGatewayIdIsSet(boolean value) {
		 if (!value) {
			 this.gatewayId = null;
		 }
	 }
	 public void setFieldValue(_Fields field, Object value) {
		 switch (field) {
			 case GATEWAY_ID: if (value == null) {
				 unsetGatewayId();
			 }
			 else {
				 setGatewayId((String)value);
			 }
			 break;
		 }
	 }
	 public Object getFieldValue(_Fields field) {
		 switch (field) {
			 case GATEWAY_ID: return getGatewayId();
		 }
		 throw new IllegalStateException();
	 }
	 public boolean isSet(_Fields field) {
		 if (field == null) {
			 throw new IllegalArgumentException();
		 }
		 switch (field) {
			 case GATEWAY_ID: return isSetGatewayId();
		 }
		 throw new IllegalStateException();
	 }
	 public boolean equals(Object that) {
		 if (that == null) return false;
		 if (that instanceof getAllApplicationInterfaceNames_args) return this.equals((getAllApplicationInterfaceNames_args)that);
		 return false;
	 }
	 public boolean equals(getAllApplicationInterfaceNames_args that) {
		 if (that == null) return false;
		 boolean this_present_gatewayId = true && this.isSetGatewayId();
		 boolean that_present_gatewayId = true && that.isSetGatewayId();
		 if (this_present_gatewayId || that_present_gatewayId) {
			 if (!(this_present_gatewayId && that_present_gatewayId)) return false;
			 if (!this.gatewayId.equals(that.gatewayId)) return false;
		 }
		 return true;
	 }
	 public int hashCode() {
		 List<Object> list = new ArrayList<Object>();
		 boolean present_gatewayId = true && (isSetGatewayId());
		 list.add(present_gatewayId);
		 if (present_gatewayId) list.add(gatewayId);
		 return list.hashCode();
	 }
	 public int compareTo(getAllApplicationInterfaceNames_args other) {
		 if (!getClass().equals(other.getClass())) {
			 return getClass().getName().compareTo(other.getClass().getName());
		 }
		 int lastComparison = 0;
		 lastComparison = Boolean.valueOf(isSetGatewayId()).compareTo(other.isSetGatewayId());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (isSetGatewayId()) {
			 lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.gatewayId, other.gatewayId);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 return 0;
	 }
	 public _Fields fieldForId(int fieldId) {
		 return _Fields.findByThriftId(fieldId);
	 }
	 public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
		 schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
	 }
	 public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
		 schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder(""getAllApplicationInterfaceNames_args("");
		 boolean first = true;
		 sb.append(""gatewayId:"");
		 if (this.gatewayId == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.gatewayId);
		 }
		 first = false;
		 sb.append("")"");
		 return sb.toString();
	 }
	 public void validate() throws org.apache.thrift.TException {
		 if (gatewayId == null) {
			 throw new org.apache.thrift.protocol.TProtocolException(""Required field 'gatewayId' was not present! Struct: "" + toString());
		 }
	 }
	 private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
		 try {
			 write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
		 }
		 catch (org.apache.thrift.TException te) {
			 throw new java.io.IOException(te);
		 }
	 }
	 private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
		 try {
			 read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
		 }
		 catch (org.apache.thrift.TException te) {
			 throw new java.io.IOException(te);
		 }
	 }
	 private static class getAllApplicationInterfaceNames_argsStandardSchemeFactory implements SchemeFactory {
		 public getAllApplicationInterfaceNames_argsStandardScheme getScheme() {
			 return new getAllApplicationInterfaceNames_argsStandardScheme();
		 }
	 }
	 private static class getAllApplicationInterfaceNames_argsStandardScheme extends StandardScheme<getAllApplicationInterfaceNames_args> {
		 public void read(org.apache.thrift.protocol.TProtocol iprot, getAllApplicationInterfaceNames_args struct) throws org.apache.thrift.TException {
			 org.apache.thrift.protocol.TField schemeField;
			 iprot.readStructBegin();
			 while (true) {
				 schemeField = iprot.readFieldBegin();
				 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
					 break;
				 }
				 switch (schemeField.id) {
					 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
						 struct.gatewayId = iprot.readString();
						 struct.setGatewayIdIsSet(true);
					 }
					 else {
						 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 iprot.readFieldEnd();
			 }
			 iprot.readStructEnd();
			 struct.validate();
		 }
		 public void write(org.apache.thrift.protocol.TProtocol oprot, getAllApplicationInterfaceNames_args struct) throws org.apache.thrift.TException {
			 struct.validate();
			 oprot.writeStructBegin(STRUCT_DESC);
			 if (struct.gatewayId != null) {
				 oprot.writeFieldBegin(GATEWAY_ID_FIELD_DESC);
				 oprot.writeString(struct.gatewayId);
				 oprot.writeFieldEnd();
			 }
			 oprot.writeFieldStop();
			 oprot.writeStructEnd();
		 }
	 }
	 private static class getAllApplicationInterfaceNames_argsTupleSchemeFactory implements SchemeFactory {
		 public getAllApplicationInterfaceNames_argsTupleScheme getScheme() {
			 return new getAllApplicationInterfaceNames_argsTupleScheme();
		 }
	 }
	 private static class getAllApplicationInterfaceNames_argsTupleScheme extends TupleScheme<getAllApplicationInterfaceNames_args> {
		 public void write(org.apache.thrift.protocol.TProtocol prot, getAllApplicationInterfaceNames_args struct) throws org.apache.thrift.TException {
			 TTupleProtocol oprot = (TTupleProtocol) prot;
			 oprot.writeString(struct.gatewayId);
		 }
		 public void read(org.apache.thrift.protocol.TProtocol prot, getAllApplicationInterfaceNames_args struct) throws org.apache.thrift.TException {
			 TTupleProtocol iprot = (TTupleProtocol) prot;
			 struct.gatewayId = iprot.readString();
			 struct.setGatewayIdIsSet(true);
		 }
	 }
 }",1,1,0,0
"public final class AArch64FloatConvertOp extends AArch64LIRInstruction {
	 private static final LIRInstructionClass<AArch64FloatConvertOp> TYPE = LIRInstructionClass.create(AArch64FloatConvertOp.class);
	 private final FloatConvert op;
	 protected AllocatableValue resultValue;
	 protected AllocatableValue inputValue;
	 protected AArch64FloatConvertOp(FloatConvert op, AllocatableValue resultValue, AllocatableValue inputValue) {
		 super(TYPE);
		 this.op = op;
		 this.resultValue = resultValue;
		 this.inputValue = inputValue;
	 }
	 public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
		 int fromSize = inputValue.getPlatformKind().getSizeInBytes() * Byte.SIZE;
		 int toSize = resultValue.getPlatformKind().getSizeInBytes() * Byte.SIZE;
		 Register result = asRegister(resultValue);
		 Register input = asRegister(inputValue);
		 switch (op) {
			 case F2I: case D2I: case F2L: case D2L: masm.fcvtzs(toSize, fromSize, result, input);
			 break;
			 case I2F: case I2D: case L2F: case L2D: masm.scvtf(toSize, fromSize, result, input);
			 break;
			 case D2F: case F2D: masm.fcvt(fromSize, result, input);
			 break;
			 default: throw GraalError.shouldNotReachHere();
		 }
	 }
}",0,0,0,0
"public class NetAgent extends Agent {
	 ConnectionRequestInterface connectionRequest_;
	 StatementRequestInterface statementRequest_;
	 ResultSetRequestInterface resultSetRequest_;
	 ConnectionReply connectionReply_;
	 private ConnectionReply packageReply_;
	 StatementReply statementReply_;
	 ResultSetReply resultSetReply_;
	 NetConnection netConnection_;
	 private Request request_;
	 NetConnectionRequest netConnectionRequest_;
	 private NetPackageRequest netPackageRequest_;
	 private NetStatementRequest netStatementRequest_;
	 private NetResultSetRequest netResultSetRequest_;
	 private Reply reply_;
	 NetConnectionReply netConnectionReply_;
	 private NetPackageReply netPackageReply_;
	 private NetStatementReply netStatementReply_;
	 private NetResultSetReply netResultSetReply_;
	 Socket socket_;
	 private InputStream rawSocketInputStream_;
	 private OutputStream rawSocketOutputStream_;
	 String server_;
	 int port_;
	 private int clientSSLMode_;
	 private EbcdicCcsidManager ebcdicCcsidManager_;
	 private Utf8CcsidManager utf8CcsidManager_;
	 private CcsidManager currentCcsidManager_;
	 Typdef typdef_;
	 Typdef targetTypdef_;
	 Typdef originalTargetTypdef_;
	 private int svrcod_;
	 int orignalTargetSqlam_ = NetConfiguration.MGRLVL_7;
	 int targetSqlam_ = orignalTargetSqlam_;
	 SqlException exceptionOpeningSocket_ = null;
	 SqlException exceptionConvertingRdbnam = null;
	 private boolean writeChainIsDirty_ = false;
	 public NetAgent(NetConnection netConnection, LogWriter logWriter) throws SqlException {
		 super(netConnection, logWriter);
		 this.netConnection_ = netConnection;
	 }
	 NetAgent(NetConnection netConnection, LogWriter netLogWriter, int loginTimeout, String server, int port, int clientSSLMode) throws SqlException {
		 super(netConnection, netLogWriter);
		 server_ = server;
		 port_ = port;
		 netConnection_ = netConnection;
		 clientSSLMode_ = clientSSLMode;
		 if (server_ == null) {
			 throw new DisconnectException(this, new ClientMessageId(SQLState.CONNECT_REQUIRED_PROPERTY_NOT_SET), ""serverName"");
		 }
		 try {
			 socket_ = (Socket)AccessController.doPrivileged( new OpenSocketAction(server, port, clientSSLMode_));
		 }
		 catch (PrivilegedActionException e) {
			 throw new DisconnectException(this, new ClientMessageId(SQLState.CONNECT_UNABLE_TO_CONNECT_TO_SERVER), e.getException(), e.getException().getClass().getName(), server, port, e.getException().getMessage());
		 }
		 try {
			 if (exceptionOpeningSocket_ == null) {
				 socket_.setTcpNoDelay(true);
				 socket_.setKeepAlive(true);
				 socket_.setSoTimeout(loginTimeout * 1000);
			 }
		 }
		 catch (SocketException e) {
			 try {
				 socket_.close();
			 }
			 catch (IOException doNothing) {
			 }
			 exceptionOpeningSocket_ = new DisconnectException(this, new ClientMessageId(SQLState.CONNECT_SOCKET_EXCEPTION), e, e.getMessage());
		 }
		 try {
			 if (exceptionOpeningSocket_ == null) {
				 rawSocketOutputStream_ = socket_.getOutputStream();
				 rawSocketInputStream_ = socket_.getInputStream();
			 }
		 }
		 catch (IOException e) {
			 try {
				 socket_.close();
			 }
			 catch (IOException doNothing) {
			 }
			 exceptionOpeningSocket_ = new DisconnectException(this, new ClientMessageId(SQLState.CONNECT_UNABLE_TO_OPEN_SOCKET_STREAM), e, e.getMessage());
		 }
		 ebcdicCcsidManager_ = new EbcdicCcsidManager();
		 utf8CcsidManager_ = new Utf8CcsidManager();
		 currentCcsidManager_ = ebcdicCcsidManager_;
		 if (netConnection_.isXAConnection()) {
			 NetXAConnectionReply netXAConnectionReply_ = new NetXAConnectionReply(this, netConnection_.commBufferSize_);
			 netResultSetReply_ = (NetResultSetReply) netXAConnectionReply_;
			 netStatementReply_ = (NetStatementReply) netResultSetReply_;
			 netPackageReply_ = (NetPackageReply) netStatementReply_;
			 netConnectionReply_ = (NetConnectionReply) netPackageReply_;
			 reply_ = (Reply) netConnectionReply_;
			 resultSetReply_ = new ResultSetReply(this, netResultSetReply_, netStatementReply_, netConnectionReply_);
			 statementReply_ = (StatementReply) resultSetReply_;
			 packageReply_ = (ConnectionReply) statementReply_;
			 connectionReply_ = (ConnectionReply) packageReply_;
			 NetXAConnectionRequest netXAConnectionRequest_ = new NetXAConnectionRequest(this, netConnection_.commBufferSize_);
			 netResultSetRequest_ = (NetResultSetRequest) netXAConnectionRequest_;
			 netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;
			 netPackageRequest_ = (NetPackageRequest) netStatementRequest_;
			 netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;
			 request_ = (Request) netConnectionRequest_;
			 resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;
			 statementRequest_ = (StatementRequestInterface) netStatementRequest_;
			 connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;
		 }
		 else {
			 netResultSetReply_ = new NetResultSetReply(this, netConnection_.commBufferSize_);
			 netStatementReply_ = (NetStatementReply) netResultSetReply_;
			 netPackageReply_ = (NetPackageReply) netStatementReply_;
			 netConnectionReply_ = (NetConnectionReply) netPackageReply_;
			 reply_ = (Reply) netConnectionReply_;
			 resultSetReply_ = new ResultSetReply(this, netResultSetReply_, netStatementReply_, netConnectionReply_);
			 statementReply_ = (StatementReply) resultSetReply_;
			 packageReply_ = (ConnectionReply) statementReply_;
			 connectionReply_ = (ConnectionReply) packageReply_;
			 netResultSetRequest_ = new NetResultSetRequest(this, netConnection_.commBufferSize_);
			 netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;
			 netPackageRequest_ = (NetPackageRequest) netStatementRequest_;
			 netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;
			 request_ = (Request) netConnectionRequest_;
			 resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;
			 statementRequest_ = (StatementRequestInterface) netStatementRequest_;
			 connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;
		 }
	 }
	 protected void resetAgent_(LogWriter netLogWriter, int loginTimeout, String server, int port) throws SqlException {
		 exceptionConvertingRdbnam = null;
		 targetTypdef_ = originalTargetTypdef_;
		 svrcod_ = 0;
		 try {
			 socket_.setSoTimeout(loginTimeout * 1000);
		 }
		 catch (SocketException e) {
			 try {
				 socket_.close();
			 }
			 catch (IOException doNothing) {
			 }
			 throw new SqlException(logWriter_, new ClientMessageId(SQLState.SOCKET_EXCEPTION), e, e.getMessage());
		 }
	 }
	 void setSvrcod(int svrcod) {
		 if (svrcod > svrcod_) {
			 svrcod_ = svrcod;
		 }
	 }
	 void clearSvrcod() {
		 svrcod_ = CodePoint.SVRCOD_INFO;
	 }
	 private int getSvrcod() {
		 return svrcod_;
	 }
	 public void flush_() throws DisconnectException {
		 sendRequest();
		 reply_.initialize();
	 }
	 public void close_() throws SqlException {
		 SqlException accumulatedExceptions = null;
		 if (rawSocketInputStream_ != null) {
			 try {
				 rawSocketInputStream_.close();
			 }
			 catch (IOException e) {
				 accumulatedExceptions = new SqlException(logWriter_, new ClientMessageId(SQLState.COMMUNICATION_ERROR), e, e.getMessage());
			 }
			 finally {
				 rawSocketInputStream_ = null;
			 }
		 }
		 if (rawSocketOutputStream_ != null) {
			 try {
				 rawSocketOutputStream_.close();
			 }
			 catch (IOException e) {
				 SqlException latestException = new SqlException(logWriter_, new ClientMessageId(SQLState.COMMUNICATION_ERROR), e, e.getMessage());
				 accumulatedExceptions = Utils.accumulateSQLException(latestException, accumulatedExceptions);
			 }
			 finally {
				 rawSocketOutputStream_ = null;
			 }
		 }
		 if (socket_ != null) {
			 try {
				 socket_.close();
			 }
			 catch (IOException e) {
				 SqlException latestException = new SqlException(logWriter_, new ClientMessageId(SQLState.COMMUNICATION_ERROR), e, e.getMessage());
				 accumulatedExceptions = Utils.accumulateSQLException(latestException, accumulatedExceptions);
			 }
			 finally {
				 socket_ = null;
			 }
		 }
		 if (accumulatedExceptions != null) {
			 throw accumulatedExceptions;
		 }
	 }
	 protected void setTimeout(int timeout) {
		 try {
			 socket_.setSoTimeout(timeout * 1000);
		 }
		 catch (SocketException se) {
			 if (SanityManager.DEBUG) {
				 System.out.println(""NetAgent.setTimeout: ignoring exception: "" + se);
			 }
		 }
	 }
	 protected int getTimeout() {
		 int timeout = 0;
		 try {
			 timeout = socket_.getSoTimeout();
		 }
		 catch (SocketException se) {
			 if (SanityManager.DEBUG) {
				 System.out.println(""NetAgent.getTimeout: ignoring exception: "" + se);
			 }
		 }
		 timeout = timeout / 1000;
		 return timeout;
	 }
	 private void sendRequest() throws DisconnectException {
		 try {
			 request_.flush(rawSocketOutputStream_);
		 }
		 catch (IOException e) {
			 throwCommunicationsFailure(e);
		 }
	 }
	 public InputStream getInputStream() {
		 return rawSocketInputStream_;
	 }
	 public CcsidManager getCurrentCcsidManager() {
		 return currentCcsidManager_;
	 }
	 public OutputStream getOutputStream() {
		 return rawSocketOutputStream_;
	 }
	 void setInputStream(InputStream inputStream) {
		 rawSocketInputStream_ = inputStream;
	 }
	 void setOutputStream(OutputStream outputStream) {
		 rawSocketOutputStream_ = outputStream;
	 }
	 void throwCommunicationsFailure(Throwable cause) throws DisconnectException {
		 accumulateChainBreakingReadExceptionAndThrow( new DisconnectException(this, new ClientMessageId(SQLState.COMMUNICATION_ERROR), cause, cause.getMessage()));
	 }
	 protected void markChainBreakingException_() {
		 setSvrcod(CodePoint.SVRCOD_ERROR);
	 }
	 public void checkForChainBreakingException_() throws SqlException {
		 int svrcod = getSvrcod();
		 clearSvrcod();
		 if (svrcod > CodePoint.SVRCOD_WARNING) {
			 super.checkForExceptions();
		 }
	 }
	 private void writeDeferredResetConnection() throws SqlException {
		 if (!netConnection_.resetConnectionAtFirstSql_) {
			 return;
		 }
		 try {
			 netConnection_.writeDeferredReset();
		 }
		 catch (SqlException sqle) {
			 DisconnectException de = new DisconnectException(this, new ClientMessageId(SQLState.CONNECTION_FAILED_ON_DEFERRED_RESET));
			 de.setNextException(sqle);
			 throw de;
		 }
	 }
	 void markWriteChainAsDirty() {
		 writeChainIsDirty_ = true;
	 }
	 private void verifyWriteChainIsClean() throws DisconnectException {
		 if (writeChainIsDirty_) {
			 throw new DisconnectException(this, new ClientMessageId(SQLState.NET_WRITE_CHAIN_IS_DIRTY));
		 }
	 }
	 public void beginWriteChainOutsideUOW() throws SqlException {
		 verifyWriteChainIsClean();
		 request_.initialize();
		 writeDeferredResetConnection();
	 }
	 public void beginWriteChain(ClientStatement statement) throws SqlException {
		 verifyWriteChainIsClean();
		 request_.initialize();
		 writeDeferredResetConnection();
		 super.beginWriteChain(statement);
	 }
	 protected void endWriteChain() {
	}
	 private void readDeferredResetConnection() throws SqlException {
		 if (!netConnection_.resetConnectionAtFirstSql_) {
			 return;
		 }
		 try {
			 netConnection_.readDeferredReset();
			 checkForExceptions();
		 }
		 catch (SqlException sqle) {
			 DisconnectException de = new DisconnectException(this, new ClientMessageId(SQLState.CONNECTION_FAILED_ON_DEFERRED_RESET));
			 de.setNextException(sqle);
			 throw de;
		 }
	 }
	 protected void beginReadChain(ClientStatement statement) throws SqlException {
		 writeChainIsDirty_ = false;
		 readDeferredResetConnection();
		 super.beginReadChain(statement);
	 }
	 protected void beginReadChainOutsideUOW() throws SqlException {
		 writeChainIsDirty_ = false;
		 readDeferredResetConnection();
		 super.beginReadChainOutsideUOW();
	 }
	 void switchToUtf8CcsidMgr() {
		 currentCcsidManager_ = utf8CcsidManager_;
	 }
	 void switchToEbcdicMgr() {
		 currentCcsidManager_ = ebcdicCcsidManager_;
	 }
}",1,0,0,0
"public void executeCLIStatement(String statement) {
	 Tree tree = CliCompiler.compileQuery(statement);
	 try {
		 switch (tree.getType()) {
			 case CliParser.NODE_EXIT: cleanupAndExit();
			 break;
			 case CliParser.NODE_THRIFT_GET: executeGet(tree);
			 break;
			 case CliParser.NODE_THRIFT_GET_WITH_CONDITIONS: executeGetWithConditions(tree);
			 break;
			 case CliParser.NODE_HELP: executeHelp(tree);
			 break;
			 case CliParser.NODE_THRIFT_SET: executeSet(tree);
			 break;
			 case CliParser.NODE_THRIFT_DEL: executeDelete(tree);
			 break;
			 case CliParser.NODE_THRIFT_COUNT: executeCount(tree);
			 break;
			 case CliParser.NODE_ADD_KEYSPACE: executeAddKeySpace(tree.getChild(0));
			 break;
			 case CliParser.NODE_ADD_COLUMN_FAMILY: executeAddColumnFamily(tree.getChild(0));
			 break;
			 case CliParser.NODE_UPDATE_KEYSPACE: executeUpdateKeySpace(tree.getChild(0));
			 break;
			 case CliParser.NODE_UPDATE_COLUMN_FAMILY: executeUpdateColumnFamily(tree.getChild(0));
			 break;
			 case CliParser.NODE_DEL_COLUMN_FAMILY: executeDelColumnFamily(tree);
			 break;
			 case CliParser.NODE_DEL_KEYSPACE: executeDelKeySpace(tree);
			 break;
			 case CliParser.NODE_SHOW_CLUSTER_NAME: executeShowClusterName();
			 break;
			 case CliParser.NODE_SHOW_VERSION: executeShowVersion();
			 break;
			 case CliParser.NODE_SHOW_KEYSPACES: executeShowKeySpaces();
			 break;
			 case CliParser.NODE_DESCRIBE_TABLE: executeDescribeKeySpace(tree);
			 break;
			 case CliParser.NODE_DESCRIBE_CLUSTER: executeDescribeCluster();
			 break;
			 case CliParser.NODE_USE_TABLE: executeUseKeySpace(tree);
			 break;
			 case CliParser.NODE_CONNECT: executeConnect(tree);
			 break;
			 case CliParser.NODE_LIST: executeList(tree);
			 break;
			 case CliParser.NODE_TRUNCATE: executeTruncate(tree.getChild(0).getText());
			 break;
			 case CliParser.NODE_ASSUME: executeAssumeStatement(tree);
			 break;
			 case CliParser.NODE_CONSISTENCY_LEVEL: executeConsistencyLevelStatement(tree);
			 break;
			 case CliParser.NODE_THRIFT_INCR: executeIncr(tree, 1L);
			 break;
			 case CliParser.NODE_THRIFT_DECR: executeIncr(tree, -1L);
			 break;
			 case CliParser.NODE_DROP_INDEX: executeDropIndex(tree);
			 break;
			 case CliParser.NODE_NO_OP: break;
			 default: sessionState.err.println(""Invalid Statement (Type: "" + tree.getType() + "")"");
			 if (sessionState.batch) System.exit(2);
			 break;
		 }
	 }
	 catch (InvalidRequestException e) {
		 RuntimeException rtEx = new RuntimeException(e.getWhy());
		 rtEx.initCause(e);
		 throw rtEx;
	 }
	 catch (SchemaDisagreementException e) {
		 RuntimeException rtEx = new RuntimeException(""schema does not match across nodes, (try again later)."");
		 rtEx.initCause(e);
		 throw new RuntimeException();
	 }
	 catch (Exception e) {
		 RuntimeException rtEx = new RuntimeException(e.getMessage());
		 rtEx.initCause(e);
		 throw rtEx;
	 }
 }",0,0,1,0
"public String getDisplayName() {
	 return displayName;
 }
 public String getDisplayName() {
	 return displayName;
 }",0,0,0,0
"public class ListChoice<T> extends DropDownChoice<T>{
	private static final long serialVersionUID = 1L;
	private static int defaultMaxRows = 8;
	private int maxRows;
	protected static int getDefaultMaxRows(){
		return defaultMaxRows;
	}
	protected static void setDefaultMaxRows(final int defaultMaxRows){
		ListChoice.defaultMaxRows = defaultMaxRows;
	}
	public ListChoice(final String id){
		this(id, null, (List<? extends T>)null, null, defaultMaxRows);
	}
	public ListChoice(final String id, final List<? extends T> choices){
		this(id, null, choices, null, defaultMaxRows);
	}
	public ListChoice(final String id, final List<? extends T> choices,final IChoiceRenderer<? super T> renderer){
		this(id, null, choices, renderer, defaultMaxRows);
	}
	public ListChoice(final String id, final IModel<T> model, final List<? extends T> choices){
		this(id, model, choices, null, defaultMaxRows);
	}
	public ListChoice(final String id, final IModel<T> model, final List<? extends T> choices,final int maxRows){
		this(id, model, choices, null, maxRows);
	}
	public ListChoice(final String id, final IModel<T> model, final List<? extends T> choices,final IChoiceRenderer<? super T> renderer){
		this(id, model, choices, renderer, defaultMaxRows);
	}
	public ListChoice(final String id, final IModel<T> model, final List<? extends T> choices,final IChoiceRenderer<? super T> renderer, final int maxRows){
		super(id, model, choices, renderer);
		this.maxRows = maxRows;
	}
	public ListChoice(String id, IModel<? extends List<? extends T>> choices){
		this(id, null, choices, null, defaultMaxRows);
	}
	public ListChoice(String id, IModel<T> model, IModel<? extends List<? extends T>> choices){
		this(id, model, choices, null, defaultMaxRows);
	}
	public ListChoice(String id, IModel<? extends List<? extends T>> choices,IChoiceRenderer<? super T> renderer){
		this(id, null, choices, renderer, defaultMaxRows);
	}
	public ListChoice(String id, IModel<T> model, IModel<? extends List<? extends T>> choices,IChoiceRenderer<? super T> renderer){
		this(id, model, choices, renderer, defaultMaxRows);
	}
	public ListChoice(String id, IModel<T> model, IModel<? extends List<? extends T>> choices,IChoiceRenderer<? super T> renderer, int maxRows){
		super(id, model, choices, renderer);
		this.maxRows = maxRows;
	}
	public final int getMaxRows(){
		return maxRows;
	}
	public final ListChoice<T> setMaxRows(int maxRows){
		this.maxRows = maxRows;
		return this;
	}
	protected void onComponentTag(final ComponentTag tag){
		super.onComponentTag(tag);
		if (!tag.getAttributes().containsKey(""size"")){
			tag.put(""size"", maxRows);
		}
	}
	protected final boolean supportsPersistence(){
		return true;
	}
}",0,0,0,0
"public Enumeration<String> getHeaderNames(){
	return Collections.enumeration(headers.keySet());
}",0,0,0,0
"public class VmEvent extends EventObject {
	 public VmEvent(MonitoredVm vm) {
		 super(vm);
	 }
	 public MonitoredVm getMonitoredVm() {
		 return (MonitoredVm)source;
	 }
}",0,0,0,0
"public class Parser{
	 final static int CLEAR_TI_MASK = 0xFFFF, TI_AFTER_EOL = 1 << 16, TI_CHECK_LABEL = 1 << 17;
	 CompilerEnvirons compilerEnv;
	 private ErrorReporter errorReporter;
	 private String sourceURI;
	 boolean calledByCompileFunction;
	 private TokenStream ts;
	 private int currentFlaggedToken;
	 private int syntaxErrorCount;
	 private IRFactory nf;
	 private int nestingOfFunction;
	 private Decompiler decompiler;
	 private String encodedSource;
	 ScriptOrFnNode currentScriptOrFn;
	 private int nestingOfWith;
	 private Hashtable labelSet;
	 private ObjArray loopSet;
	 private ObjArray loopAndSwitchSet;
	 private static class ParserException extends RuntimeException {
		 static final long serialVersionUID = 5882582646773765630L;
	 }
	 public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter) {
		 this.compilerEnv = compilerEnv;
		 this.errorReporter = errorReporter;
	 }
	 protected Decompiler createDecompiler(CompilerEnvirons compilerEnv) {
		 return new Decompiler();
	 }
	 void addWarning(String messageId, String messageArg) {
		 String message = ScriptRuntime.getMessage1(messageId, messageArg);
		 errorReporter.warning(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());
	 }
	 void addError(String messageId) {
		 ++syntaxErrorCount;
		 String message = ScriptRuntime.getMessage0(messageId);
		 errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());
	 }
	 RuntimeException reportError(String messageId) {
		 addError(messageId);
		 throw new ParserException();
	 }
	 private int peekToken() throws IOException {
		 int tt = currentFlaggedToken;
		 if (tt == Token.EOF) {
			 tt = ts.getToken();
			 if (tt == Token.EOL) {
				 do {
					 tt = ts.getToken();
				 }
				 while (tt == Token.EOL);
				 tt |= TI_AFTER_EOL;
			 }
			 currentFlaggedToken = tt;
		 }
		 return tt & CLEAR_TI_MASK;
	 }
	 private int peekFlaggedToken() throws IOException {
		 peekToken();
		 return currentFlaggedToken;
	 }
	 private void consumeToken() {
		 currentFlaggedToken = Token.EOF;
	 }
	 private int nextToken() throws IOException {
		 int tt = peekToken();
		 consumeToken();
		 return tt;
	 }
	 private int nextFlaggedToken() throws IOException {
		 peekToken();
		 int ttFlagged = currentFlaggedToken;
		 consumeToken();
		 return ttFlagged;
	 }
	 private boolean matchToken(int toMatch) throws IOException {
		 int tt = peekToken();
		 if (tt != toMatch) {
			 return false;
		 }
		 consumeToken();
		 return true;
	 }
	 private int peekTokenOrEOL() throws IOException {
		 int tt = peekToken();
		 if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {
			 tt = Token.EOL;
		 }
		 return tt;
	 }
	 private void setCheckForLabel() {
		 if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME) throw Kit.codeBug();
		 currentFlaggedToken |= TI_CHECK_LABEL;
	 }
	 private void mustMatchToken(int toMatch, String messageId) throws IOException, ParserException {
		 if (!matchToken(toMatch)) {
			 reportError(messageId);
		 }
	 }
	 private void mustHaveXML() {
		 if (!compilerEnv.isXmlAvailable()) {
			 reportError(""msg.XML.not.available"");
		 }
	 }
	 public String getEncodedSource() {
		 return encodedSource;
	 }
	 public boolean eof() {
		 return ts.eof();
	 }
	 boolean insideFunction() {
		 return nestingOfFunction != 0;
	 }
	 private Node enterLoop(Node loopLabel) {
		 Node loop = nf.createLoopNode(loopLabel, ts.getLineno());
		 if (loopSet == null) {
			 loopSet = new ObjArray();
			 if (loopAndSwitchSet == null) {
				 loopAndSwitchSet = new ObjArray();
			 }
		 }
		 loopSet.push(loop);
		 loopAndSwitchSet.push(loop);
		 return loop;
	 }
	 private void exitLoop() {
		 loopSet.pop();
		 loopAndSwitchSet.pop();
	 }
	 private Node enterSwitch(Node switchSelector, int lineno, Node switchLabel) {
		 Node switchNode = nf.createSwitch(switchSelector, lineno);
		 if (loopAndSwitchSet == null) {
			 loopAndSwitchSet = new ObjArray();
		 }
		 loopAndSwitchSet.push(switchNode);
		 return switchNode;
	 }
	 private void exitSwitch() {
		 loopAndSwitchSet.pop();
	 }
	 public ScriptOrFnNode parse(String sourceString, String sourceURI, int lineno) {
		 this.sourceURI = sourceURI;
		 this.ts = new TokenStream(this, null, sourceString, lineno);
		 try {
			 return parse();
		 }
		 catch (IOException ex) {
			 throw new IllegalStateException();
		 }
	 }
	 public ScriptOrFnNode parse(Reader sourceReader, String sourceURI, int lineno) throws IOException {
		 this.sourceURI = sourceURI;
		 this.ts = new TokenStream(this, sourceReader, null, lineno);
		 return parse();
	 }
	 private ScriptOrFnNode parse() throws IOException {
		 this.decompiler = createDecompiler(compilerEnv);
		 this.nf = new IRFactory(this);
		 currentScriptOrFn = nf.createScript();
		 int sourceStartOffset = decompiler.getCurrentOffset();
		 this.encodedSource = null;
		 decompiler.addToken(Token.SCRIPT);
		 this.currentFlaggedToken = Token.EOF;
		 this.syntaxErrorCount = 0;
		 int baseLineno = ts.getLineno();
		 Node pn = nf.createLeaf(Token.BLOCK);
		 try {
			 for (;
			;
			) {
				 int tt = peekToken();
				 if (tt <= Token.EOF) {
					 break;
				 }
				 Node n;
				 if (tt == Token.FUNCTION) {
					 consumeToken();
					 try {
						 n = function(calledByCompileFunction ? FunctionNode.FUNCTION_EXPRESSION : FunctionNode.FUNCTION_STATEMENT);
					 }
					 catch (ParserException e) {
						 break;
					 }
				 }
				 else {
					 n = statement();
				 }
				 nf.addChildToBack(pn, n);
			 }
		 }
		 catch (StackOverflowError ex) {
			 String msg = ScriptRuntime.getMessage0( ""mag.too.deep.parser.recursion"");
			 throw Context.reportRuntimeError(msg, sourceURI, ts.getLineno(), null, 0);
		 }
		 if (this.syntaxErrorCount != 0) {
			 String msg = String.valueOf(this.syntaxErrorCount);
			 msg = ScriptRuntime.getMessage1(""msg.got.syntax.errors"", msg);
			 throw errorReporter.runtimeError(msg, sourceURI, baseLineno, null, 0);
		 }
		 currentScriptOrFn.setSourceName(sourceURI);
		 currentScriptOrFn.setBaseLineno(baseLineno);
		 currentScriptOrFn.setEndLineno(ts.getLineno());
		 int sourceEndOffset = decompiler.getCurrentOffset();
		 currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset, sourceEndOffset);
		 nf.initScript(currentScriptOrFn, pn);
		 if (compilerEnv.isGeneratingSource()) {
			 encodedSource = decompiler.getEncodedSource();
		 }
		 this.decompiler = null;
		 return currentScriptOrFn;
	 }
	 private Node parseFunctionBody() throws IOException {
		 ++nestingOfFunction;
		 Node pn = nf.createBlock(ts.getLineno());
		 try {
			 bodyLoop: for (;
			;
			) {
				 Node n;
				 int tt = peekToken();
				 switch (tt) {
					 case Token.ERROR: case Token.EOF: case Token.RC: break bodyLoop;
					 case Token.FUNCTION: consumeToken();
					 n = function(FunctionNode.FUNCTION_STATEMENT);
					 break;
					 default: n = statement();
					 break;
				 }
				 nf.addChildToBack(pn, n);
			 }
		 }
		 catch (ParserException e) {
		 }
		 finally {
			 --nestingOfFunction;
		 }
		 return pn;
	 }
	 private Node function(int functionType) throws IOException, ParserException {
		 int syntheticType = functionType;
		 int baseLineno = ts.getLineno();
		 int functionSourceStart = decompiler.markFunctionStart(functionType);
		 String name;
		 Node memberExprNode = null;
		 if (matchToken(Token.NAME)) {
			 name = ts.getString();
			 decompiler.addName(name);
			 if (!matchToken(Token.LP)) {
				 if (compilerEnv.isAllowMemberExprAsFunctionName()) {
					 Node memberExprHead = nf.createName(name);
					 name = """";
					 memberExprNode = memberExprTail(false, memberExprHead);
				 }
				 mustMatchToken(Token.LP, ""msg.no.paren.parms"");
			 }
		 }
		 else if (matchToken(Token.LP)) {
			 name = """";
		 }
		 else {
			 name = """";
			 if (compilerEnv.isAllowMemberExprAsFunctionName()) {
				 memberExprNode = memberExpr(false);
			 }
			 mustMatchToken(Token.LP, ""msg.no.paren.parms"");
		 }
		 if (memberExprNode != null) {
			 syntheticType = FunctionNode.FUNCTION_EXPRESSION;
		 }
		 boolean nested = insideFunction();
		 FunctionNode fnNode = nf.createFunction(name);
		 if (nested || nestingOfWith > 0) {
			 fnNode.itsIgnoreDynamicScope = true;
		 }
		 int functionIndex = currentScriptOrFn.addFunction(fnNode);
		 int functionSourceEnd;
		 ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;
		 currentScriptOrFn = fnNode;
		 int savedNestingOfWith = nestingOfWith;
		 nestingOfWith = 0;
		 Hashtable savedLabelSet = labelSet;
		 labelSet = null;
		 ObjArray savedLoopSet = loopSet;
		 loopSet = null;
		 ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;
		 loopAndSwitchSet = null;
		 Node body;
		 String source;
		 try {
			 decompiler.addToken(Token.LP);
			 if (!matchToken(Token.RP)) {
				 boolean first = true;
				 do {
					 if (!first) decompiler.addToken(Token.COMMA);
					 first = false;
					 mustMatchToken(Token.NAME, ""msg.no.parm"");
					 String s = ts.getString();
					 if (fnNode.hasParamOrVar(s)) {
						 addWarning(""msg.dup.parms"", s);
					 }
					 fnNode.addParam(s);
					 decompiler.addName(s);
				 }
				 while (matchToken(Token.COMMA));
				 mustMatchToken(Token.RP, ""msg.no.paren.after.parms"");
			 }
			 decompiler.addToken(Token.RP);
			 mustMatchToken(Token.LC, ""msg.no.brace.body"");
			 decompiler.addEOL(Token.LC);
			 body = parseFunctionBody();
			 mustMatchToken(Token.RC, ""msg.no.brace.after.body"");
			 decompiler.addToken(Token.RC);
			 functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);
			 if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
				 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {
					 int tt = peekTokenOrEOL();
					 if (tt == Token.FUNCTION) {
						 reportError(""msg.no.semi.stmt"");
					 }
				 }
				 decompiler.addToken(Token.EOL);
			 }
		 }
		 finally {
			 loopAndSwitchSet = savedLoopAndSwitchSet;
			 loopSet = savedLoopSet;
			 labelSet = savedLabelSet;
			 nestingOfWith = savedNestingOfWith;
			 currentScriptOrFn = savedScriptOrFn;
		 }
		 fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);
		 fnNode.setSourceName(sourceURI);
		 fnNode.setBaseLineno(baseLineno);
		 fnNode.setEndLineno(ts.getLineno());
		 Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);
		 if (memberExprNode != null) {
			 pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);
			 if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
				 pn = nf.createExprStatementNoReturn(pn, baseLineno);
			 }
		 }
		 return pn;
	 }
	 private Node statements() throws IOException {
		 Node pn = nf.createBlock(ts.getLineno());
		 int tt;
		 while((tt = peekToken()) > Token.EOF && tt != Token.RC) {
			 nf.addChildToBack(pn, statement());
		 }
		 return pn;
	 }
	 private Node condition() throws IOException, ParserException {
		 Node pn;
		 mustMatchToken(Token.LP, ""msg.no.paren.cond"");
		 decompiler.addToken(Token.LP);
		 pn = expr(false);
		 mustMatchToken(Token.RP, ""msg.no.paren.after.cond"");
		 decompiler.addToken(Token.RP);
		 return pn;
	 }
	 private Node matchJumpLabelName() throws IOException, ParserException {
		 Node label = null;
		 int tt = peekTokenOrEOL();
		 if (tt == Token.NAME) {
			 consumeToken();
			 String name = ts.getString();
			 decompiler.addName(name);
			 if (labelSet != null) {
				 label = (Node)labelSet.get(name);
			 }
			 if (label == null) {
				 reportError(""msg.undef.label"");
			 }
		 }
		 return label;
	 }
	 private Node statement() throws IOException {
		 try {
			 Node pn = statementHelper(null);
			 if (pn != null) {
				 return pn;
			 }
		 }
		 catch (ParserException e) {
		 }
		 int lineno = ts.getLineno();
		 guessingStatementEnd: for (;
		;
		) {
			 int tt = peekTokenOrEOL();
			 consumeToken();
			 switch (tt) {
				 case Token.ERROR: case Token.EOF: case Token.EOL: case Token.SEMI: break guessingStatementEnd;
			 }
		 }
		 return nf.createExprStatement(nf.createName(""error""), lineno);
	 }
	 private Node statementHelper(Node statementLabel) throws IOException, ParserException {
		 Node pn = null;
		 int tt;
		 tt = peekToken();
		 switch(tt) {
			 case Token.IF: {
				 consumeToken();
				 decompiler.addToken(Token.IF);
				 int lineno = ts.getLineno();
				 Node cond = condition();
				 decompiler.addEOL(Token.LC);
				 Node ifTrue = statement();
				 Node ifFalse = null;
				 if (matchToken(Token.ELSE)) {
					 decompiler.addToken(Token.RC);
					 decompiler.addToken(Token.ELSE);
					 decompiler.addEOL(Token.LC);
					 ifFalse = statement();
				 }
				 decompiler.addEOL(Token.RC);
				 pn = nf.createIf(cond, ifTrue, ifFalse, lineno);
				 return pn;
			 }
			 case Token.SWITCH: {
				 consumeToken();
				 decompiler.addToken(Token.SWITCH);
				 int lineno = ts.getLineno();
				 mustMatchToken(Token.LP, ""msg.no.paren.switch"");
				 decompiler.addToken(Token.LP);
				 pn = enterSwitch(expr(false), lineno, statementLabel);
				 try {
					 mustMatchToken(Token.RP, ""msg.no.paren.after.switch"");
					 decompiler.addToken(Token.RP);
					 mustMatchToken(Token.LC, ""msg.no.brace.switch"");
					 decompiler.addEOL(Token.LC);
					 boolean hasDefault = false;
					 switchLoop: for (;
					;
					) {
						 tt = nextToken();
						 Node caseExpression;
						 switch (tt) {
							 case Token.RC: break switchLoop;
							 case Token.CASE: decompiler.addToken(Token.CASE);
							 caseExpression = expr(false);
							 mustMatchToken(Token.COLON, ""msg.no.colon.case"");
							 decompiler.addEOL(Token.COLON);
							 break;
							 case Token.DEFAULT: if (hasDefault) {
								 reportError(""msg.double.switch.default"");
							 }
							 decompiler.addToken(Token.DEFAULT);
							 hasDefault = true;
							 caseExpression = null;
							 mustMatchToken(Token.COLON, ""msg.no.colon.case"");
							 decompiler.addEOL(Token.COLON);
							 break;
							 default: reportError(""msg.bad.switch"");
							 break switchLoop;
						 }
						 Node block = nf.createLeaf(Token.BLOCK);
						 while ((tt = peekToken()) != Token.RC && tt != Token.CASE && tt != Token.DEFAULT && tt != Token.EOF) {
							 nf.addChildToBack(block, statement());
						 }
						 nf.addSwitchCase(pn, caseExpression, block);
					 }
					 decompiler.addEOL(Token.RC);
					 nf.closeSwitch(pn);
				 }
				 finally {
					 exitSwitch();
				 }
				 return pn;
			 }
			 case Token.WHILE: {
				 consumeToken();
				 decompiler.addToken(Token.WHILE);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node cond = condition();
					 decompiler.addEOL(Token.LC);
					 Node body = statement();
					 decompiler.addEOL(Token.RC);
					 pn = nf.createWhile(loop, cond, body);
				 }
				 finally {
					 exitLoop();
				 }
				 return pn;
			 }
			 case Token.DO: {
				 consumeToken();
				 decompiler.addToken(Token.DO);
				 decompiler.addEOL(Token.LC);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node body = statement();
					 decompiler.addToken(Token.RC);
					 mustMatchToken(Token.WHILE, ""msg.no.while.do"");
					 decompiler.addToken(Token.WHILE);
					 Node cond = condition();
					 pn = nf.createDoWhile(loop, body, cond);
				 }
				 finally {
					 exitLoop();
				 }
				 matchToken(Token.SEMI);
				 decompiler.addEOL(Token.SEMI);
				 return pn;
			 }
			 case Token.FOR: {
				 consumeToken();
				 boolean isForEach = false;
				 decompiler.addToken(Token.FOR);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node init;
					 Node cond;
					 Node incr = null;
					 Node body;
					 if (matchToken(Token.NAME)) {
						 decompiler.addName(ts.getString());
						 if (ts.getString().equals(""each"")) {
							 isForEach = true;
						 }
						 else {
							 reportError(""msg.no.paren.for"");
						 }
					 }
					 mustMatchToken(Token.LP, ""msg.no.paren.for"");
					 decompiler.addToken(Token.LP);
					 tt = peekToken();
					 if (tt == Token.SEMI) {
						 init = nf.createLeaf(Token.EMPTY);
					 }
					 else {
						 if (tt == Token.VAR) {
							 consumeToken();
							 init = variables(true);
						 }
						 else {
							 init = expr(true);
						 }
					 }
					 if (matchToken(Token.IN)) {
						 decompiler.addToken(Token.IN);
						 cond = expr(false);
					 }
					 else {
						 mustMatchToken(Token.SEMI, ""msg.no.semi.for"");
						 decompiler.addToken(Token.SEMI);
						 if (peekToken() == Token.SEMI) {
							 cond = nf.createLeaf(Token.EMPTY);
						 }
						 else {
							 cond = expr(false);
						 }
						 mustMatchToken(Token.SEMI, ""msg.no.semi.for.cond"");
						 decompiler.addToken(Token.SEMI);
						 if (peekToken() == Token.RP) {
							 incr = nf.createLeaf(Token.EMPTY);
						 }
						 else {
							 incr = expr(false);
						 }
					 }
					 mustMatchToken(Token.RP, ""msg.no.paren.for.ctrl"");
					 decompiler.addToken(Token.RP);
					 decompiler.addEOL(Token.LC);
					 body = statement();
					 decompiler.addEOL(Token.RC);
					 if (incr == null) {
						 pn = nf.createForIn(loop, init, cond, body, isForEach);
					 }
					 else {
						 pn = nf.createFor(loop, init, cond, incr, body);
					 }
				 }
				 finally {
					 exitLoop();
				 }
				 return pn;
			 }
			 case Token.TRY: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 Node tryblock;
				 Node catchblocks = null;
				 Node finallyblock = null;
				 decompiler.addToken(Token.TRY);
				 decompiler.addEOL(Token.LC);
				 tryblock = statement();
				 decompiler.addEOL(Token.RC);
				 catchblocks = nf.createLeaf(Token.BLOCK);
				 boolean sawDefaultCatch = false;
				 int peek = peekToken();
				 if (peek == Token.CATCH) {
					 while (matchToken(Token.CATCH)) {
						 if (sawDefaultCatch) {
							 reportError(""msg.catch.unreachable"");
						 }
						 decompiler.addToken(Token.CATCH);
						 mustMatchToken(Token.LP, ""msg.no.paren.catch"");
						 decompiler.addToken(Token.LP);
						 mustMatchToken(Token.NAME, ""msg.bad.catchcond"");
						 String varName = ts.getString();
						 decompiler.addName(varName);
						 Node catchCond = null;
						 if (matchToken(Token.IF)) {
							 decompiler.addToken(Token.IF);
							 catchCond = expr(false);
						 }
						 else {
							 sawDefaultCatch = true;
						 }
						 mustMatchToken(Token.RP, ""msg.bad.catchcond"");
						 decompiler.addToken(Token.RP);
						 mustMatchToken(Token.LC, ""msg.no.brace.catchblock"");
						 decompiler.addEOL(Token.LC);
						 nf.addChildToBack(catchblocks, nf.createCatch(varName, catchCond, statements(), ts.getLineno()));
						 mustMatchToken(Token.RC, ""msg.no.brace.after.body"");
						 decompiler.addEOL(Token.RC);
					 }
				 }
				 else if (peek != Token.FINALLY) {
					 mustMatchToken(Token.FINALLY, ""msg.try.no.catchfinally"");
				 }
				 if (matchToken(Token.FINALLY)) {
					 decompiler.addToken(Token.FINALLY);
					 decompiler.addEOL(Token.LC);
					 finallyblock = statement();
					 decompiler.addEOL(Token.RC);
				 }
				 pn = nf.createTryCatchFinally(tryblock, catchblocks, finallyblock, lineno);
				 return pn;
			 }
			 case Token.THROW: {
				 consumeToken();
				 if (peekTokenOrEOL() == Token.EOL) {
					 reportError(""msg.bad.throw.eol"");
				 }
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.THROW);
				 pn = nf.createThrow(expr(false), lineno);
				 break;
			 }
			 case Token.BREAK: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.BREAK);
				 Node breakStatement = matchJumpLabelName();
				 if (breakStatement == null) {
					 if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {
						 reportError(""msg.bad.break"");
						 return null;
					 }
					 breakStatement = (Node)loopAndSwitchSet.peek();
				 }
				 pn = nf.createBreak(breakStatement, lineno);
				 break;
			 }
			 case Token.CONTINUE: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.CONTINUE);
				 Node loop;
				 Node label = matchJumpLabelName();
				 if (label == null) {
					 if (loopSet == null || loopSet.size() == 0) {
						 reportError(""msg.continue.outside"");
						 return null;
					 }
					 loop = (Node)loopSet.peek();
				 }
				 else {
					 loop = nf.getLabelLoop(label);
					 if (loop == null) {
						 reportError(""msg.continue.nonloop"");
						 return null;
					 }
				 }
				 pn = nf.createContinue(loop, lineno);
				 break;
			 }
			 case Token.WITH: {
				 consumeToken();
				 decompiler.addToken(Token.WITH);
				 int lineno = ts.getLineno();
				 mustMatchToken(Token.LP, ""msg.no.paren.with"");
				 decompiler.addToken(Token.LP);
				 Node obj = expr(false);
				 mustMatchToken(Token.RP, ""msg.no.paren.after.with"");
				 decompiler.addToken(Token.RP);
				 decompiler.addEOL(Token.LC);
				 ++nestingOfWith;
				 Node body;
				 try {
					 body = statement();
				 }
				 finally {
					 --nestingOfWith;
				 }
				 decompiler.addEOL(Token.RC);
				 pn = nf.createWith(obj, body, lineno);
				 return pn;
			 }
			 case Token.VAR: {
				 consumeToken();
				 pn = variables(false);
				 break;
			 }
			 case Token.RETURN: {
				 if (!insideFunction()) {
					 reportError(""msg.bad.return"");
				 }
				 consumeToken();
				 decompiler.addToken(Token.RETURN);
				 int lineno = ts.getLineno();
				 Node retExpr;
				 tt = peekTokenOrEOL();
				 switch (tt) {
					 case Token.SEMI: case Token.RC: case Token.EOF: case Token.EOL: case Token.ERROR: retExpr = null;
					 break;
					 default: retExpr = expr(false);
				 }
				 pn = nf.createReturn(retExpr, lineno);
				 break;
			 }
			 case Token.LC: consumeToken();
			 if (statementLabel != null) {
				 decompiler.addToken(Token.LC);
			 }
			 pn = statements();
			 mustMatchToken(Token.RC, ""msg.no.brace.block"");
			 if (statementLabel != null) {
				 decompiler.addEOL(Token.RC);
			 }
			 return pn;
			 case Token.ERROR: case Token.SEMI: consumeToken();
			 pn = nf.createLeaf(Token.EMPTY);
			 return pn;
			 case Token.FUNCTION: {
				 consumeToken();
				 pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);
				 return pn;
			 }
			 case Token.DEFAULT : consumeToken();
			 mustHaveXML();
			 decompiler.addToken(Token.DEFAULT);
			 int nsLine = ts.getLineno();
			 if (!(matchToken(Token.NAME) && ts.getString().equals(""xml""))) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addName(ts.getString());
			 if (!(matchToken(Token.NAME) && ts.getString().equals(""namespace""))) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addName(ts.getString());
			 if (!matchToken(Token.ASSIGN)) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addToken(Token.ASSIGN);
			 Node expr = expr(false);
			 pn = nf.createDefaultNamespace(expr, nsLine);
			 break;
			 case Token.NAME: {
				 int lineno = ts.getLineno();
				 String name = ts.getString();
				 setCheckForLabel();
				 pn = expr(false);
				 if (pn.getType() != Token.LABEL) {
					 pn = nf.createExprStatement(pn, lineno);
				 }
				 else {
					 if (peekToken() != Token.COLON) Kit.codeBug();
					 consumeToken();
					 decompiler.addName(name);
					 decompiler.addEOL(Token.COLON);
					 if (labelSet == null) {
						 labelSet = new Hashtable();
					 }
					 else if (labelSet.containsKey(name)) {
						 reportError(""msg.dup.label"");
					 }
					 boolean firstLabel;
					 if (statementLabel == null) {
						 firstLabel = true;
						 statementLabel = pn;
					 }
					 else {
						 firstLabel = false;
					 }
					 labelSet.put(name, statementLabel);
					 try {
						 pn = statementHelper(statementLabel);
					 }
					 finally {
						 labelSet.remove(name);
					 }
					 if (firstLabel) {
						 pn = nf.createLabeledStatement(statementLabel, pn);
					 }
					 return pn;
				 }
				 break;
			 }
			 default: {
				 int lineno = ts.getLineno();
				 pn = expr(false);
				 pn = nf.createExprStatement(pn, lineno);
				 break;
			 }
		 }
		 int ttFlagged = peekFlaggedToken();
		 switch (ttFlagged & CLEAR_TI_MASK) {
			 case Token.SEMI: consumeToken();
			 break;
			 case Token.ERROR: case Token.EOF: case Token.RC: break;
			 default: if ((ttFlagged & TI_AFTER_EOL) == 0) {
				 reportError(""msg.no.semi.stmt"");
			 }
			 break;
		 }
		 decompiler.addEOL(Token.SEMI);
		 return pn;
	 }
	 private Node variables(boolean inForInit) throws IOException, ParserException {
		 Node pn = nf.createVariables(ts.getLineno());
		 boolean first = true;
		 decompiler.addToken(Token.VAR);
		 for (;
		;
		) {
			 Node name;
			 Node init;
			 mustMatchToken(Token.NAME, ""msg.bad.var"");
			 String s = ts.getString();
			 if (!first) decompiler.addToken(Token.COMMA);
			 first = false;
			 decompiler.addName(s);
			 currentScriptOrFn.addVar(s);
			 name = nf.createName(s);
			 if (matchToken(Token.ASSIGN)) {
				 decompiler.addToken(Token.ASSIGN);
				 init = assignExpr(inForInit);
				 nf.addChildToBack(name, init);
			 }
			 nf.addChildToBack(pn, name);
			 if (!matchToken(Token.COMMA)) break;
		 }
		 return pn;
	 }
	 private Node expr(boolean inForInit) throws IOException, ParserException {
		 Node pn = assignExpr(inForInit);
		 while (matchToken(Token.COMMA)) {
			 decompiler.addToken(Token.COMMA);
			 pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node assignExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = condExpr(inForInit);
		 int tt = peekToken();
		 if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {
			 consumeToken();
			 decompiler.addToken(tt);
			 pn = nf.createAssignment(tt, pn, assignExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node condExpr(boolean inForInit) throws IOException, ParserException {
		 Node ifTrue;
		 Node ifFalse;
		 Node pn = orExpr(inForInit);
		 if (matchToken(Token.HOOK)) {
			 decompiler.addToken(Token.HOOK);
			 ifTrue = assignExpr(false);
			 mustMatchToken(Token.COLON, ""msg.no.colon.cond"");
			 decompiler.addToken(Token.COLON);
			 ifFalse = assignExpr(inForInit);
			 return nf.createCondExpr(pn, ifTrue, ifFalse);
		 }
		 return pn;
	 }
	 private Node orExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = andExpr(inForInit);
		 if (matchToken(Token.OR)) {
			 decompiler.addToken(Token.OR);
			 pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node andExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitOrExpr(inForInit);
		 if (matchToken(Token.AND)) {
			 decompiler.addToken(Token.AND);
			 pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitOrExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitXorExpr(inForInit);
		 while (matchToken(Token.BITOR)) {
			 decompiler.addToken(Token.BITOR);
			 pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitXorExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitAndExpr(inForInit);
		 while (matchToken(Token.BITXOR)) {
			 decompiler.addToken(Token.BITXOR);
			 pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitAndExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = eqExpr(inForInit);
		 while (matchToken(Token.BITAND)) {
			 decompiler.addToken(Token.BITAND);
			 pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node eqExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = relExpr(inForInit);
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: consumeToken();
				 int decompilerToken = tt;
				 int parseToken = tt;
				 if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {
					 switch (tt) {
						 case Token.EQ: parseToken = Token.SHEQ;
						 break;
						 case Token.NE: parseToken = Token.SHNE;
						 break;
						 case Token.SHEQ: decompilerToken = Token.EQ;
						 break;
						 case Token.SHNE: decompilerToken = Token.NE;
						 break;
					 }
				 }
				 decompiler.addToken(decompilerToken);
				 pn = nf.createBinary(parseToken, pn, relExpr(inForInit));
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node relExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = shiftExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.IN: if (inForInit) break;
				 case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, shiftExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node shiftExpr() throws IOException, ParserException {
		 Node pn = addExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.LSH: case Token.URSH: case Token.RSH: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, addExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node addExpr() throws IOException, ParserException {
		 Node pn = mulExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 if (tt == Token.ADD || tt == Token.SUB) {
				 consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, mulExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node mulExpr() throws IOException, ParserException {
		 Node pn = unaryExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.MUL: case Token.DIV: case Token.MOD: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, unaryExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node unaryExpr() throws IOException, ParserException {
		 int tt;
		 tt = peekToken();
		 switch(tt) {
			 case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.TYPEOF: consumeToken();
			 decompiler.addToken(tt);
			 return nf.createUnary(tt, unaryExpr());
			 case Token.ADD: consumeToken();
			 decompiler.addToken(Token.POS);
			 return nf.createUnary(Token.POS, unaryExpr());
			 case Token.SUB: consumeToken();
			 decompiler.addToken(Token.NEG);
			 return nf.createUnary(Token.NEG, unaryExpr());
			 case Token.INC: case Token.DEC: consumeToken();
			 decompiler.addToken(tt);
			 return nf.createIncDec(tt, false, memberExpr(true));
			 case Token.DELPROP: consumeToken();
			 decompiler.addToken(Token.DELPROP);
			 return nf.createUnary(Token.DELPROP, unaryExpr());
			 case Token.ERROR: consumeToken();
			 break;
			 case Token.LT: if (compilerEnv.isXmlAvailable()) {
				 consumeToken();
				 Node pn = xmlInitializer();
				 return memberExprTail(true, pn);
			 }
			 default: Node pn = memberExpr(true);
			 tt = peekTokenOrEOL();
			 if (tt == Token.INC || tt == Token.DEC) {
				 consumeToken();
				 decompiler.addToken(tt);
				 return nf.createIncDec(tt, true, pn);
			 }
			 return pn;
		 }
		 return nf.createName(""err"");
	 }
	 private Node xmlInitializer() throws IOException {
		 int tt = ts.getFirstXMLToken();
		 if (tt != Token.XML && tt != Token.XMLEND) {
			 reportError(""msg.syntax"");
			 return null;
		 }
		 Node pnXML = nf.createLeaf(Token.NEW);
		 String xml = ts.getString();
		 boolean fAnonymous = xml.trim().startsWith(""<>"");
		 Node pn = nf.createName(fAnonymous ? ""XMLList"" : ""XML"");
		 nf.addChildToBack(pnXML, pn);
		 pn = null;
		 Node expr;
		 for (;
		;
		tt = ts.getNextXMLToken()) {
			 switch (tt) {
				 case Token.XML: xml = ts.getString();
				 decompiler.addName(xml);
				 mustMatchToken(Token.LC, ""msg.syntax"");
				 decompiler.addToken(Token.LC);
				 expr = (peekToken() == Token.RC) ? nf.createString("""") : expr(false);
				 mustMatchToken(Token.RC, ""msg.syntax"");
				 decompiler.addToken(Token.RC);
				 if (pn == null) {
					 pn = nf.createString(xml);
				 }
				 else {
					 pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));
				 }
				 int nodeType;
				 if (ts.isXMLAttribute()) {
					 nodeType = Token.ESCXMLATTR;
				 }
				 else {
					 nodeType = Token.ESCXMLTEXT;
				 }
				 expr = nf.createUnary(nodeType, expr);
				 pn = nf.createBinary(Token.ADD, pn, expr);
				 break;
				 case Token.XMLEND: xml = ts.getString();
				 decompiler.addName(xml);
				 if (pn == null) {
					 pn = nf.createString(xml);
				 }
				 else {
					 pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));
				 }
				 nf.addChildToBack(pnXML, pn);
				 return pnXML;
				 default: reportError(""msg.syntax"");
				 return null;
			 }
		 }
	 }
	 private void argumentList(Node listNode) throws IOException, ParserException {
		 boolean matched;
		 matched = matchToken(Token.RP);
		 if (!matched) {
			 boolean first = true;
			 do {
				 if (!first) decompiler.addToken(Token.COMMA);
				 first = false;
				 nf.addChildToBack(listNode, assignExpr(false));
			 }
			 while (matchToken(Token.COMMA));
			 mustMatchToken(Token.RP, ""msg.no.paren.arg"");
		 }
		 decompiler.addToken(Token.RP);
	 }
	 private Node memberExpr(boolean allowCallSyntax) throws IOException, ParserException {
		 int tt;
		 Node pn;
		 tt = peekToken();
		 if (tt == Token.NEW) {
			 consumeToken();
			 decompiler.addToken(Token.NEW);
			 pn = nf.createCallOrNew(Token.NEW, memberExpr(false));
			 if (matchToken(Token.LP)) {
				 decompiler.addToken(Token.LP);
				 argumentList(pn);
			 }
			 tt = peekToken();
			 if (tt == Token.LC) {
				 nf.addChildToBack(pn, primaryExpr());
			 }
		 }
		 else {
			 pn = primaryExpr();
		 }
		 return memberExprTail(allowCallSyntax, pn);
	 }
	 private Node memberExprTail(boolean allowCallSyntax, Node pn) throws IOException, ParserException {
		 tailLoop: for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.DOT: case Token.DOTDOT: {
					 int memberTypeFlags;
					 String s;
					 consumeToken();
					 decompiler.addToken(tt);
					 memberTypeFlags = 0;
					 if (tt == Token.DOTDOT) {
						 mustHaveXML();
						 memberTypeFlags = Node.DESCENDANTS_FLAG;
					 }
					 if (!compilerEnv.isXmlAvailable()) {
						 mustMatchToken(Token.NAME, ""msg.no.name.after.dot"");
						 s = ts.getString();
						 decompiler.addName(s);
						 pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);
						 break;
					 }
					 tt = nextToken();
					 switch (tt) {
						 case Token.NAME: s = ts.getString();
						 decompiler.addName(s);
						 pn = propertyName(pn, s, memberTypeFlags);
						 break;
						 case Token.MUL: decompiler.addName(""*"");
						 pn = propertyName(pn, ""*"", memberTypeFlags);
						 break;
						 case Token.XMLATTR: decompiler.addToken(Token.XMLATTR);
						 pn = attributeAccess(pn, memberTypeFlags);
						 break;
						 default: reportError(""msg.no.name.after.dot"");
					 }
				 }
				 break;
				 case Token.DOTQUERY: consumeToken();
				 mustHaveXML();
				 decompiler.addToken(Token.DOTQUERY);
				 pn = nf.createDotQuery(pn, expr(false), ts.getLineno());
				 mustMatchToken(Token.RP, ""msg.no.paren"");
				 decompiler.addToken(Token.RP);
				 break;
				 case Token.LB: consumeToken();
				 decompiler.addToken(Token.LB);
				 pn = nf.createElementGet(pn, null, expr(false), 0);
				 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
				 decompiler.addToken(Token.RB);
				 break;
				 case Token.LP: if (!allowCallSyntax) {
					 break tailLoop;
				 }
				 consumeToken();
				 decompiler.addToken(Token.LP);
				 pn = nf.createCallOrNew(Token.CALL, pn);
				 argumentList(pn);
				 break;
				 default: break tailLoop;
			 }
		 }
		 return pn;
	 }
	 private Node attributeAccess(Node pn, int memberTypeFlags) throws IOException {
		 memberTypeFlags |= Node.ATTRIBUTE_FLAG;
		 int tt = nextToken();
		 switch (tt) {
			 case Token.NAME: {
				 String s = ts.getString();
				 decompiler.addName(s);
				 pn = propertyName(pn, s, memberTypeFlags);
			 }
			 break;
			 case Token.MUL: decompiler.addName(""*"");
			 pn = propertyName(pn, ""*"", memberTypeFlags);
			 break;
			 case Token.LB: decompiler.addToken(Token.LB);
			 pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);
			 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
			 decompiler.addToken(Token.RB);
			 break;
			 default: reportError(""msg.no.name.after.xmlAttr"");
			 pn = nf.createPropertyGet(pn, null, ""?"", memberTypeFlags);
			 break;
		 }
		 return pn;
	 }
	 private Node propertyName(Node pn, String name, int memberTypeFlags) throws IOException, ParserException {
		 String namespace = null;
		 if (matchToken(Token.COLONCOLON)) {
			 decompiler.addToken(Token.COLONCOLON);
			 namespace = name;
			 int tt = nextToken();
			 switch (tt) {
				 case Token.NAME: name = ts.getString();
				 decompiler.addName(name);
				 break;
				 case Token.MUL: decompiler.addName(""*"");
				 name = ""*"";
				 break;
				 case Token.LB: decompiler.addToken(Token.LB);
				 pn = nf.createElementGet(pn, namespace, expr(false), memberTypeFlags);
				 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
				 decompiler.addToken(Token.RB);
				 return pn;
				 default: reportError(""msg.no.name.after.coloncolon"");
				 name = ""?"";
			 }
		 }
		 pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);
		 return pn;
	 }
	 private Node primaryExpr() throws IOException, ParserException {
		 Node pn;
		 int ttFlagged = nextFlaggedToken();
		 int tt = ttFlagged & CLEAR_TI_MASK;
		 switch(tt) {
			 case Token.FUNCTION: return function(FunctionNode.FUNCTION_EXPRESSION);
			 case Token.LB: {
				 ObjArray elems = new ObjArray();
				 int skipCount = 0;
				 decompiler.addToken(Token.LB);
				 boolean after_lb_or_comma = true;
				 for (;
				;
				) {
					 tt = peekToken();
					 if (tt == Token.COMMA) {
						 consumeToken();
						 decompiler.addToken(Token.COMMA);
						 if (!after_lb_or_comma) {
							 after_lb_or_comma = true;
						 }
						 else {
							 elems.add(null);
							 ++skipCount;
						 }
					 }
					 else if (tt == Token.RB) {
						 consumeToken();
						 decompiler.addToken(Token.RB);
						 break;
					 }
					 else {
						 if (!after_lb_or_comma) {
							 reportError(""msg.no.bracket.arg"");
						 }
						 elems.add(assignExpr(false));
						 after_lb_or_comma = false;
					 }
				 }
				 return nf.createArrayLiteral(elems, skipCount);
			 }
			 case Token.LC: {
				 ObjArray elems = new ObjArray();
				 decompiler.addToken(Token.LC);
				 if (!matchToken(Token.RC)) {
					 boolean first = true;
					 commaloop: do {
						 Object property;
						 if (!first) decompiler.addToken(Token.COMMA);
						 else first = false;
						 tt = peekToken();
						 switch(tt) {
							 case Token.NAME: case Token.STRING: consumeToken();
							 String s = ts.getString();
							 if (tt == Token.NAME) {
								 decompiler.addName(s);
							 }
							 else {
								 decompiler.addString(s);
							 }
							 property = ScriptRuntime.getIndexObject(s);
							 break;
							 case Token.NUMBER: consumeToken();
							 double n = ts.getNumber();
							 decompiler.addNumber(n);
							 property = ScriptRuntime.getIndexObject(n);
							 break;
							 case Token.RC: break commaloop;
							 default: reportError(""msg.bad.prop"");
							 break commaloop;
						 }
						 mustMatchToken(Token.COLON, ""msg.no.colon.prop"");
						 decompiler.addToken(Token.OBJECTLIT);
						 elems.add(property);
						 elems.add(assignExpr(false));
					 }
					 while (matchToken(Token.COMMA));
					 mustMatchToken(Token.RC, ""msg.no.brace.prop"");
				 }
				 decompiler.addToken(Token.RC);
				 return nf.createObjectLiteral(elems);
			 }
			 case Token.LP: decompiler.addToken(Token.LP);
			 pn = expr(false);
			 decompiler.addToken(Token.RP);
			 mustMatchToken(Token.RP, ""msg.no.paren"");
			 return pn;
			 case Token.XMLATTR: mustHaveXML();
			 decompiler.addToken(Token.XMLATTR);
			 pn = attributeAccess(null, 0);
			 return pn;
			 case Token.NAME: {
				 String name = ts.getString();
				 if ((ttFlagged & TI_CHECK_LABEL) != 0) {
					 if (peekToken() == Token.COLON) {
						 return nf.createLabel(ts.getLineno());
					 }
				 }
				 decompiler.addName(name);
				 if (compilerEnv.isXmlAvailable()) {
					 pn = propertyName(null, name, 0);
				 }
				 else {
					 pn = nf.createName(name);
				 }
				 return pn;
			 }
			 case Token.NUMBER: {
				 double n = ts.getNumber();
				 decompiler.addNumber(n);
				 return nf.createNumber(n);
			 }
			 case Token.STRING: {
				 String s = ts.getString();
				 decompiler.addString(s);
				 return nf.createString(s);
			 }
			 case Token.DIV: case Token.ASSIGN_DIV: {
				 ts.readRegExp(tt);
				 String flags = ts.regExpFlags;
				 ts.regExpFlags = null;
				 String re = ts.getString();
				 decompiler.addRegexp(re, flags);
				 int index = currentScriptOrFn.addRegexp(re, flags);
				 return nf.createRegExp(index);
			 }
			 case Token.NULL: case Token.THIS: case Token.FALSE: case Token.TRUE: decompiler.addToken(tt);
			 return nf.createLeaf(tt);
			 case Token.RESERVED: reportError(""msg.reserved.id"");
			 break;
			 case Token.ERROR: break;
			 case Token.EOF: reportError(""msg.unexpected.eof"");
			 break;
			 default: reportError(""msg.syntax"");
			 break;
		 }
		 return null;
	 }
}",1,0,0,0
"public String getLoggerLevel(String loggerName) {
	String result = null;
	try {
		Object logger = getLoggerFromName(loggerName);
		if (logger != null) {
			Object level = logger_getLevel.invoke(logger);
			if (level != null) {
				result = (String)level_getName.invoke(level);
			}
			 else {
				result = """";
			 }
		}
	}
	 catch (Exception e) {
		throw handleError(e);
	}
	return result;
}",0,0,1,0
"public class AccumulativeSumBag extends EvalFunc<String> implements Accumulator<String>{
	 StringBuffer sb;
	 public AccumulativeSumBag() {
	 }
	 public void accumulate(Tuple tuple) throws IOException {
		 DataBag databag = (DataBag)tuple.get(0);
		 if(databag == null) return;
		 if (sb == null) {
			 sb = new StringBuffer();
		 }
		 Iterator<Tuple> iterator = databag.iterator();
		 while(iterator.hasNext()) {
			 Tuple t = iterator.next();
			 if (t.size()>1 && t.get(1) == null) {
				 continue;
			 }
			 sb.append(t.toString());
		 }
	 }
	 public String getValue() {
		 if (sb != null && sb.length()>0) {
			 return sb.toString();
		 }
		 return null;
	 }
	 public void cleanup() {
		 sb = null;
	 }
	 public String exec(Tuple tuple) throws IOException {
		 throw new IOException(""exec() should not be called"");
	 }
}",1,0,0,0
"public class RegexpUtil {
	 public static boolean hasFlag(int options, int flag) {
		 return ((options & flag) > 0);
	 }
	 public static int removeFlag(int options, int flag) {
		 return (options & (0xFFFFFFFF - flag));
	 }
	 public static int asOptions(String flags) {
		 int options = RegexpMatcher.MATCH_DEFAULT;
		 if (flags != null) {
			 options = asOptions(flags.indexOf('i') == -1, flags.indexOf('m') != -1, flags.indexOf('s') != -1);
			 if (flags.indexOf('g') != -1) {
				 options |= Regexp.REPLACE_ALL;
			 }
		 }
		 return options;
	 }
	 public static int asOptions(boolean caseSensitive) {
		 return asOptions(caseSensitive, false, false);
	 }
	 public static int asOptions(boolean caseSensitive, boolean multiLine, boolean singleLine) {
		 int options = RegexpMatcher.MATCH_DEFAULT;
		 if (!caseSensitive) {
			 options = options | RegexpMatcher.MATCH_CASE_INSENSITIVE;
		 }
		 if (multiLine) {
			 options = options | RegexpMatcher.MATCH_MULTILINE;
		 }
		 if (singleLine) {
			 options = options | RegexpMatcher.MATCH_SINGLELINE;
		 }
		 return options;
	 }
}",0,0,0,0
"public class InitParameterMap extends AbstractMap{
	 private PortletContext p_context;
	 public InitParameterMap( PortletContext context ) {
		 p_context = context;
	 }
	 protected Object getAttribute( String name ) {
		 return p_context.getInitParameter( name );
	 }
	 protected void setAttribute( String name, Object value ) {
		 throw new UnsupportedOperationException();
	 }
	 protected void removeAttribute( String name ) {
		 throw new UnsupportedOperationException();
	 }
	 protected Enumeration getAttributeNames() {
		 return p_context.getInitParameterNames();
	 }
}",0,1,0,0
"public class BaseDeclProcessor {
	public static void process(ASTOperationContainer qc, String externalBaseURI) throws MalformedQueryException {
		ParsedIRI parsedBaseURI = null;
		ASTBaseDecl baseDecl = qc.getBaseDecl();
		if (baseDecl != null) {
			try {
				parsedBaseURI = new ParsedIRI(baseDecl.getIRI());
			}
			 catch (URISyntaxException e) {
				throw new MalformedQueryException(e);
			}
			if (!parsedBaseURI.isAbsolute()) {
				throw new MalformedQueryException(""BASE IRI is not an absolute IRI: "" + externalBaseURI);
			}
		}
		 else if (externalBaseURI != null) {
			try {
				parsedBaseURI = new ParsedIRI(externalBaseURI);
			}
			 catch (URISyntaxException e) {
				throw new MalformedQueryException(e);
			}
			if (!parsedBaseURI.isAbsolute()) {
				throw new IllegalArgumentException(""Supplied base URI is not an absolute IRI: "" + externalBaseURI);
			}
		}
		 else {
		}
		if (parsedBaseURI != null) {
			ASTUnparsedQuadDataBlock dataBlock = null;
			if (qc.getOperation() instanceof ASTInsertData) {
				ASTInsertData insertData = (ASTInsertData) qc.getOperation();
				dataBlock = insertData.jjtGetChild(ASTUnparsedQuadDataBlock.class);
			}
			 else if (qc.getOperation() instanceof ASTDeleteData) {
				ASTDeleteData deleteData = (ASTDeleteData) qc.getOperation();
				dataBlock = deleteData.jjtGetChild(ASTUnparsedQuadDataBlock.class);
			}
			if (dataBlock != null) {
				final String baseURIDeclaration = ""BASE <"" + parsedBaseURI + ""> \n"";
				dataBlock.setDataBlock(baseURIDeclaration + dataBlock.getDataBlock());
			}
			 else {
				RelativeIRIResolver visitor = new RelativeIRIResolver(parsedBaseURI);
				try {
					qc.jjtAccept(visitor, null);
				}
				 catch (VisitorException e) {
					throw new MalformedQueryException(e);
				}
			}
		}
	}
	private static class RelativeIRIResolver extends AbstractASTVisitor {
		private ParsedIRI parsedBaseURI;
		public RelativeIRIResolver(ParsedURI parsedBaseURI) {
			this(ParsedIRI.create(parsedBaseURI.toString()));
		}
		public RelativeIRIResolver(ParsedIRI parsedBaseURI) {
			this.parsedBaseURI = parsedBaseURI;
		}
		public Object visit(ASTIRI node, Object data) throws VisitorException {
			node.setValue(parsedBaseURI.resolve(node.getValue()));
			return super.visit(node, data);
		}
		public Object visit(ASTIRIFunc node, Object data) throws VisitorException {
			node.setBaseURI(parsedBaseURI.toString());
			return super.visit(node, data);
		}
		public Object visit(ASTServiceGraphPattern node, Object data) throws VisitorException {
			node.setBaseURI(parsedBaseURI.toString());
			return super.visit(node, data);
		}
	}
}",1,0,0,0
"final class NativeError extends IdScriptableObject{
	 static final long serialVersionUID = -5338413581437645187L;
	 private static final Object ERROR_TAG = new Object();
	 static void init(Scriptable scope, boolean sealed) {
		 NativeError obj = new NativeError();
		 ScriptableObject.putProperty(obj, ""name"", ""Error"");
		 ScriptableObject.putProperty(obj, ""message"", """");
		 ScriptableObject.putProperty(obj, ""fileName"", """");
		 ScriptableObject.putProperty(obj, ""lineNumber"", new Integer(0));
		 obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
	 }
	 static NativeError make(Context cx, Scriptable scope, IdFunctionObject ctorObj, Object[] args) {
		 Scriptable proto = (Scriptable)(ctorObj.get(""prototype"", ctorObj));
		 NativeError obj = new NativeError();
		 obj.setPrototype(proto);
		 obj.setParentScope(scope);
		 int arglen = args.length;
		 if (arglen >= 1) {
			 ScriptableObject.putProperty(obj, ""message"", ScriptRuntime.toString(args[0]));
			 if (arglen >= 2) {
				 ScriptableObject.putProperty(obj, ""fileName"", args[1]);
				 if (arglen >= 3) {
					 int line = ScriptRuntime.toInt32(args[2]);
					 ScriptableObject.putProperty(obj, ""lineNumber"", new Integer(line));
				 }
			 }
		 }
		 if(arglen < 3 && cx.hasFeature(Context.FEATURE_LOCATION_INFORMATION_IN_ERROR)) {
			 int[] linep = new int[1];
			 String fileName = Context.getSourcePositionFromStack(linep);
			 ScriptableObject.putProperty(obj, ""lineNumber"", new Integer(linep[0]));
			 if(arglen < 2) {
				 ScriptableObject.putProperty(obj, ""fileName"", fileName);
			 }
		 }
		 return obj;
	 }
	 public String getClassName() {
		 return ""Error"";
	 }
	 public String toString() {
		 return js_toString(this);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_constructor: arity=1;
			 s=""constructor"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(ERROR_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(ERROR_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case Id_constructor: return make(cx, scope, f, args);
			 case Id_toString: return js_toString(thisObj);
			 case Id_toSource: return js_toSource(cx, scope, thisObj);
		 }
		 throw new IllegalArgumentException(String.valueOf(id));
	 }
	 private static String js_toString(Scriptable thisObj) {
		 return getString(thisObj, ""name"")+"": ""+getString(thisObj, ""message"");
	 }
	 private static String js_toSource(Context cx, Scriptable scope, Scriptable thisObj) {
		 Object name = ScriptableObject.getProperty(thisObj, ""name"");
		 Object message = ScriptableObject.getProperty(thisObj, ""message"");
		 Object fileName = ScriptableObject.getProperty(thisObj, ""fileName"");
		 Object lineNumber = ScriptableObject.getProperty(thisObj, ""lineNumber"");
		 StringBuffer sb = new StringBuffer();
		 sb.append(""(new "");
		 if (name == NOT_FOUND) {
			 name = Undefined.instance;
		 }
		 sb.append(ScriptRuntime.toString(name));
		 sb.append(""("");
		 if (message != NOT_FOUND || fileName != NOT_FOUND || lineNumber != NOT_FOUND) {
			 if (message == NOT_FOUND) {
				 message = """";
			 }
			 sb.append(ScriptRuntime.uneval(cx, scope, message));
			 if (fileName != NOT_FOUND || lineNumber != NOT_FOUND) {
				 sb.append("", "");
				 if (fileName == NOT_FOUND) {
					 fileName = """";
				 }
				 sb.append(ScriptRuntime.uneval(cx, scope, fileName));
				 if (lineNumber != NOT_FOUND) {
					 int line = ScriptRuntime.toInt32(lineNumber);
					 if (line != 0) {
						 sb.append("", "");
						 sb.append(ScriptRuntime.toString(line));
					 }
				 }
			 }
		 }
		 sb.append(""))"");
		 return sb.toString();
	 }
	 private static String getString(Scriptable obj, String id) {
		 Object value = ScriptableObject.getProperty(obj, id);
		 if (value == NOT_FOUND) return """";
		 return ScriptRuntime.toString(value);
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 int s_length = s.length();
			 if (s_length==8) {
				 c=s.charAt(3);
				 if (c=='o') {
					 X=""toSource"";
					id=Id_toSource;
				 }
				 else if (c=='t') {
					 X=""toString"";
					id=Id_toString;
				 }
			 }
			 else if (s_length==11) {
				 X=""constructor"";
				id=Id_constructor;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
			 break L0;
		 }
		 return id;
	 }
	 private static final int Id_constructor = 1, Id_toString = 2, Id_toSource = 3, MAX_PROTOTYPE_ID = 3;
}",0,0,0,0
"public class SqlFileScanner implements TokenSource {
	 public static final int YYEOF = -1;
	 private static final int ZZ_BUFFERSIZE = 16384;
	 public static final int SPECIAL = 12;
	 public static final int SQL_DOUBLE_QUOTED = 8;
	 public static final int SQL_SINGLE_QUOTED = 6;
	 public static final int GOBBLE = 10;
	 public static final int RAW = 4;
	 public static final int SQL = 2;
	 public static final int YYINITIAL = 0;
	 public static final int EDIT = 16;
	 public static final int PL = 14;
	 public static final int PROMPT_CHANGE_STATE = 20;
	 public static final int MACRO = 18;
	 private static final int ZZ_LEXSTATE[] = {
	 0, 0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11 }
	;
	 private static final String ZZ_CMAP_PACKED = ""\11\0\1\6\1\2\1\0\1\6\1\1\22\0\1\6\1\0\1\3""+ ""\4\0\1\33\2\0\1\5\2\0\1\7\1\32\1\4\12\0\1\31""+ ""\1\10\5\0\1\20\1\11\1\16\1\26\1\12\1\22\1\13\1\0""+ ""\1\14\2\0\1\27\1\0\1\15\1\24\1\25\1\0\1\17\1\0""+ ""\1\21\1\23\6\0\1\30\4\0\1\20\1\11\1\16\1\26\1\12""+ ""\1\22\1\13\1\0\1\14\2\0\1\27\1\0\1\15\1\24\1\25""+ ""\1\0\1\17\1\0\1\21\1\23\uff8a\0"";
	 private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);
	 private static final int [] ZZ_ACTION = zzUnpackAction();
	 private static final String ZZ_ACTION_PACKED_0 = ""\14\0\1\1\2\2\1\3\1\4\1\5\1\6\1\7""+ ""\1\10\3\1\1\11\1\12\1\13\2\14\1\15\2\13""+ ""\1\16\1\17\2\20\1\13\1\0\2\21\1\0\1\22""+ ""\1\23\1\22\1\24\2\25\1\22\2\26\2\22\2\27""+ ""\2\30\2\31\2\32\7\0\2\33\10\0\2\34\2\35""+ ""\1\0\2\36\1\37\3\0\1\40\1\41\3\0\2\42""+ ""\23\0"";
	 private static int [] zzUnpackAction() {
		 int [] result = new int[114];
		 int offset = 0;
		 offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAction(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
	 private static final String ZZ_ROWMAP_PACKED_0 = ""\0\0\0\34\0\70\0\124\0\160\0\214\0\250\0\304""+ ""\0\340\0\374\0\u0118\0\u0134\0\u0150\0\u016c\0\u0150\0\u0150""+ ""\0\u0188\0\u0150\0\u01a4\0\u01c0\0\u0150\0\u01dc\0\u01f8\0\u0214""+ ""\0\u0150\0\u0150\0\u0150\0\u0230\0\u0150\0\u0150\0\u024c\0\u0268""+ ""\0\u0150\0\u0150\0\u0284\0\u0150\0\u02a0\0\u02bc\0\u02d8\0\u0150""+ ""\0\u02f4\0\u0310\0\u032c\0\u0348\0\u0150\0\u0364\0\u0150\0\u0150""+ ""\0\u0380\0\u0150\0\u039c\0\u03b8\0\u03d4\0\u0150\0\u03f0\0\u0150""+ ""\0\u040c\0\u0150\0\u0428\0\u0150\0\u0444\0\u0460\0\u047c\0\u0498""+ ""\0\u04b4\0\u04d0\0\u02a0\0\u04ec\0\u0150\0\u0508\0\u0524\0\u0540""+ ""\0\u055c\0\u0578\0\u0594\0\u05b0\0\u05cc\0\u05e8\0\u0150\0\u0604""+ ""\0\u0150\0\u0620\0\u063c\0\u0150\0\u0150\0\u0658\0\u0674\0\u0690""+ ""\0\u0150\0\u0150\0\u06ac\0\u06c8\0\u06e4\0\u0700\0\u0150\0\u071c""+ ""\0\u0738\0\u0754\0\u0770\0\u078c\0\u07a8\0\u07c4\0\u07e0\0\u07fc""+ ""\0\u0818\0\u0834\0\u0850\0\u086c\0\u0888\0\u08a4\0\u08c0\0\u08dc""+ ""\0\u08f8\0\u0914"";
	 private static int [] zzUnpackRowMap() {
		 int [] result = new int[114];
		 int offset = 0;
		 offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackRowMap(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int high = packed.charAt(i++) << 16;
			 result[j++] = high | packed.charAt(i++);
		 }
		 return j;
	 }
	 private static final int [] ZZ_TRANS = zzUnpackTrans();
	 private static final String ZZ_TRANS_PACKED_0 = ""\1\15\1\16\1\17\1\20\1\21\1\22\1\23\1\24""+ ""\1\25\1\26\4\15\1\27\7\15\1\30\1\15\1\31""+ ""\1\32\1\15\1\20\1\33\1\34\1\35\1\36\1\37""+ ""\2\33\1\40\1\41\22\33\1\42\1\33\1\43\1\44""+ ""\1\36\1\37\1\33\1\45\1\40\1\41\22\33\1\42""+ ""\1\46\1\47\1\50\3\46\1\4\23\46\1\51\1\46""+ ""\33\52\1\53\3\54\1\55\30\54\1\7\1\56\1\57""+ ""\31\7\1\60\1\61\1\62\1\60\1\63\2\60\1\64""+ ""\25\60\1\65\1\66\1\60\1\63\2\60\1\64\25\60""+ ""\1\67\1\70\32\60\1\71\1\72\1\60\1\63\2\60""+ ""\1\64\24\60\1\0\1\73\1\74\67\0\1\17\36\0""+ ""\1\75\34\0\1\23\25\0\1\24\2\0\31\24\12\0""+ ""\1\76\40\0\1\77\26\0\1\100\23\0\1\35\36\0""+ ""\1\101\35\0\1\102\26\0\1\44\32\0\1\43\1\44""+ ""\3\0\1\103\25\0\1\46\1\47\1\50\31\46\2\0""+ ""\1\50\31\0\1\46\1\104\1\105\3\46\1\51\1\46""+ ""\1\106\23\46\33\52\34\0\1\60\3\54\1\0\30\54""+ ""\2\0\1\57\33\0\1\62\36\0\1\107\35\0\1\110""+ ""\26\0\1\66\33\0\1\70\33\0\1\72\33\0\1\74""+ ""\31\0\5\75\1\111\26\75\13\0\1\112\32\0\1\113""+ ""\37\0\1\114\15\0\5\101\1\115\26\101\1\102\1\116""+ ""\1\117\31\102\2\0\1\105\31\0\1\46\1\120\1\121""+ ""\3\46\1\106\25\46\5\107\1\122\26\107\1\110\1\123""+ ""\1\124\31\110\4\75\1\125\1\111\26\75\14\0\1\126""+ ""\37\0\1\127\42\0\1\130\4\0\4\101\1\131\1\115""+ ""\26\101\2\0\1\117\33\0\1\121\31\0\4\107\1\132""+ ""\1\122\26\107\2\0\1\124\46\0\1\133\37\0\1\134""+ ""\32\0\1\135\14\0\1\136\1\137\3\0\1\133\37\0""+ ""\1\140\40\0\1\141\16\0\1\137\37\0\1\142\37\0""+ ""\1\133\27\0\1\142\13\0\1\143\2\0\1\144\31\0""+ ""\1\145\27\0\1\146\31\0\1\147\42\0\1\150\25\0""+ ""\1\151\33\0\1\152\36\0\1\153\24\0\1\154\35\0""+ ""\1\155\45\0\1\156\31\0\1\157\32\0\1\160\25\0""+ ""\1\161\35\0\1\162\14\0\1\161\1\136\1\137\31\161""+ ""\12\0\1\161\21\0"";
	 private static int [] zzUnpackTrans() {
		 int [] result = new int[2352];
		 int offset = 0;
		 offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackTrans(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 value--;
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int ZZ_UNKNOWN_ERROR = 0;
	 private static final int ZZ_NO_MATCH = 1;
	 private static final int ZZ_PUSHBACK_2BIG = 2;
	 private static final String ZZ_ERROR_MSG[] = {
	 ""Unkown internal scanner error"", ""Error: could not match input"", ""Error: pushback value was too large"" }
	;
	 private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
	 private static final String ZZ_ATTRIBUTE_PACKED_0 = ""\14\0\1\11\1\1\2\11\1\1\1\11\2\1\1\11""+ ""\3\1\3\11\1\1\2\11\2\1\2\11\1\1\1\11""+ ""\1\1\1\0\1\1\1\11\1\0\3\1\1\11\1\1""+ ""\2\11\1\1\1\11\3\1\1\11\1\1\1\11\1\1""+ ""\1\11\1\1\1\11\7\0\1\1\1\11\10\0\1\1""+ ""\1\11\1\1\1\11\1\0\1\1\2\11\3\0\2\11""+ ""\3\0\1\1\1\11\23\0"";
	 private static int [] zzUnpackAttribute() {
		 int [] result = new int[114];
		 int offset = 0;
		 offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAttribute(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private java.io.Reader zzReader;
	 private int zzState;
	 private int zzLexicalState = YYINITIAL;
	 private char zzBuffer[] = new char[ZZ_BUFFERSIZE];
	 private int zzMarkedPos;
	 private int zzPushbackPos;
	 private int zzCurrentPos;
	 private int zzStartRead;
	 private int zzEndRead;
	 private int yyline;
	 private int yychar;
	 private int yycolumn;
	 private boolean zzAtBOL = true;
	 private boolean zzAtEOF;
	 private boolean zzEOFDone;
	 static private FrameworkLogger logger = FrameworkLogger.getLog(SqlFileScanner.class);
	 private StringBuffer commandBuffer = new StringBuffer();
	 private boolean interactive;
	 private PrintStream psStd = System.out;
	 private String magicPrefix;
	 private int requestedState = YYINITIAL;
	 private String rawLeadinPrompt;
	 private boolean specialAppendState;
	 public void setRequestedState(int requestedState) {
		 this.requestedState = requestedState;
	 }
	 public void setRawLeadinPrompt(String rawLeadinPrompt) {
		 this.rawLeadinPrompt = rawLeadinPrompt;
	 }
	 private void rawLeadinPrompt() {
		 if (!interactive) {
			 return;
		 }
		 if (rawLeadinPrompt == null) {
			 throw new RuntimeException(""Internal assertion failed. "" + ""Scanner's message Resource Bundle not initialized properly"");
		 }
		 psStd.println(rawLeadinPrompt);
	 }
	 private void trimBuffer() {
		 int len = commandBuffer.length();
		 commandBuffer.setLength(len - ((len > 1 && commandBuffer.charAt(len - 2) == '\r') ? 2 : 1));
	 }
	 public void setCommandBuffer(String s) {
		 commandBuffer.setLength(0);
		 commandBuffer.append(s);
	 }
	 public void setInteractive(boolean interactive) {
		 this.interactive = interactive;
	 }
	 public void setMagicPrefix(String magicPrefix) {
		 this.magicPrefix = magicPrefix;
	 }
	 public void setStdPrintStream(PrintStream psStd) {
		 this.psStd = psStd;
	 }
	 private String sqlPrompt = null;
	 public void setSqlPrompt(String sqlPrompt) {
		 this.sqlPrompt = sqlPrompt;
	 }
	 public String getSqlPrompt() {
		 return sqlPrompt;
	 }
	 private String sqltoolPrompt = null;
	 public void setSqltoolPrompt(String sqltoolPrompt) {
		 this.sqltoolPrompt = sqltoolPrompt;
	 }
	 public String getSqltoolPrompt() {
		 return sqltoolPrompt;
	 }
	 private String rawPrompt = null;
	 public void setRawPrompt(String rawPrompt) {
		 this.rawPrompt = rawPrompt;
	 }
	 public String getRawPrompt() {
		 return rawPrompt;
	 }
	 private void debug(String id, String msg) {
		 logger.finest(id + "": ["" + msg + ']');
	 }
	 public String strippedYytext() {
		 String lineString = yytext();
		 int len = lineString.length();
		 len = len - ((len > 1 && lineString.charAt(len - 2) == '\r') ? 2 : 1);
		 return (lineString.substring(0, len));
	 }
	 public void pushbackTrim() {
		 String lineString = yytext();
		 int len = lineString.length();
		 yypushback((len > 1 && lineString.charAt(len - 2) == '\r') ? 2 : 1);
	 }
	 private void prompt(String s) {
		 if (!interactive) return;
		 psStd.print(s);
	 }
	 public void prompt() {
		 if (sqltoolPrompt != null) prompt(sqltoolPrompt);
		 specialAppendState = (interactive && magicPrefix != null);
		 if (interactive && magicPrefix != null) {
			 psStd.print(magicPrefix);
			 magicPrefix = null;
		 }
	 }
	 public SqlFileScanner(java.io.Reader in) {
		 this.zzReader = in;
	 }
	 public SqlFileScanner(java.io.InputStream in) {
		 this(new java.io.InputStreamReader(in));
	 }
	 private static char [] zzUnpackCMap(String packed) {
		 char [] map = new char[0x10000];
		 int i = 0;
		 int j = 0;
		 while (i < 132) {
			 int count = packed.charAt(i++);
			 char value = packed.charAt(i++);
			 do map[j++] = value;
			 while (--count > 0);
		 }
		 return map;
	 }
	 private boolean zzRefill() throws java.io.IOException {
		 if (zzStartRead > 0) {
			 System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead-zzStartRead);
			 zzEndRead-= zzStartRead;
			 zzCurrentPos-= zzStartRead;
			 zzMarkedPos-= zzStartRead;
			 zzPushbackPos-= zzStartRead;
			 zzStartRead = 0;
		 }
		 if (zzCurrentPos >= zzBuffer.length) {
			 char newBuffer[] = new char[zzCurrentPos*2];
			 System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
			 zzBuffer = newBuffer;
		 }
		 int numRead = zzReader.read(zzBuffer, zzEndRead, zzBuffer.length-zzEndRead);
		 if (numRead < 0) {
			 return true;
		 }
		 else {
			 zzEndRead+= numRead;
			 return false;
		 }
	 }
	 public final void yyclose() throws java.io.IOException {
		 zzAtEOF = true;
		 zzEndRead = zzStartRead;
		 if (zzReader != null) zzReader.close();
	 }
	 public final void yyreset(java.io.Reader reader) {
		 zzReader = reader;
		 zzAtBOL = true;
		 zzAtEOF = false;
		 zzEndRead = zzStartRead = 0;
		 zzCurrentPos = zzMarkedPos = zzPushbackPos = 0;
		 yyline = yychar = yycolumn = 0;
		 zzLexicalState = YYINITIAL;
	 }
	 public final int yystate() {
		 return zzLexicalState;
	 }
	 public final void yybegin(int newState) {
		 zzLexicalState = newState;
	 }
	 public final String yytext() {
		 return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
	 }
	 public final char yycharat(int pos) {
		 return zzBuffer[zzStartRead+pos];
	 }
	 public final int yylength() {
		 return zzMarkedPos-zzStartRead;
	 }
	 private void zzScanError(int errorCode) {
		 String message;
		 try {
			 message = ZZ_ERROR_MSG[errorCode];
		 }
		 catch (ArrayIndexOutOfBoundsException e) {
			 message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
		 }
		 throw new Error(message);
	 }
	 public void yypushback(int number) {
		 if ( number > yylength() ) zzScanError(ZZ_PUSHBACK_2BIG);
		 zzMarkedPos -= number;
	 }
	 private void zzDoEOF() throws java.io.IOException {
		 if (!zzEOFDone) {
			 zzEOFDone = true;
			 yyclose();
		 }
	 }
	 public Token yylex() throws java.io.IOException {
		 int zzInput;
		 int zzAction;
		 int zzCurrentPosL;
		 int zzMarkedPosL;
		 int zzEndReadL = zzEndRead;
		 char [] zzBufferL = zzBuffer;
		 char [] zzCMapL = ZZ_CMAP;
		 int [] zzTransL = ZZ_TRANS;
		 int [] zzRowMapL = ZZ_ROWMAP;
		 int [] zzAttrL = ZZ_ATTRIBUTE;
		 while (true) {
			 zzMarkedPosL = zzMarkedPos;
			 boolean zzR = false;
			 for (zzCurrentPosL = zzStartRead;
			 zzCurrentPosL < zzMarkedPosL;
			 zzCurrentPosL++) {
				 switch (zzBufferL[zzCurrentPosL]) {
					 case '\u000B': case '\u000C': case '\u0085': case '\u2028': case '\u2029': yyline++;
					 yycolumn = 0;
					 zzR = false;
					 break;
					 case '\r': yyline++;
					 yycolumn = 0;
					 zzR = true;
					 break;
					 case '\n': if (zzR) zzR = false;
					 else {
						 yyline++;
						 yycolumn = 0;
					 }
					 break;
					 default: zzR = false;
					 yycolumn++;
				 }
			 }
			 if (zzR) {
				 boolean zzPeek;
				 if (zzMarkedPosL < zzEndReadL) zzPeek = zzBufferL[zzMarkedPosL] == '\n';
				 else if (zzAtEOF) zzPeek = false;
				 else {
					 boolean eof = zzRefill();
					 zzEndReadL = zzEndRead;
					 zzMarkedPosL = zzMarkedPos;
					 zzBufferL = zzBuffer;
					 if (eof) zzPeek = false;
					 else zzPeek = zzBufferL[zzMarkedPosL] == '\n';
				 }
				 if (zzPeek) yyline--;
			 }
			 if (zzMarkedPosL > zzStartRead) {
				 switch (zzBufferL[zzMarkedPosL-1]) {
					 case '\n': case '\u000B': case '\u000C': case '\u0085': case '\u2028': case '\u2029': zzAtBOL = true;
					 break;
					 case '\r': if (zzMarkedPosL < zzEndReadL) zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
					 else if (zzAtEOF) zzAtBOL = false;
					 else {
						 boolean eof = zzRefill();
						 zzMarkedPosL = zzMarkedPos;
						 zzEndReadL = zzEndRead;
						 zzBufferL = zzBuffer;
						 if (eof) zzAtBOL = false;
						 else zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
					 }
					 break;
					 default: zzAtBOL = false;
				 }
			 }
			 zzAction = -1;
			 zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
			 if (zzAtBOL) zzState = ZZ_LEXSTATE[zzLexicalState+1];
			 else zzState = ZZ_LEXSTATE[zzLexicalState];
			 zzForAction: {
				 while (true) {
					 if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++];
					 else if (zzAtEOF) {
						 zzInput = YYEOF;
						 break zzForAction;
					 }
					 else {
						 zzCurrentPos = zzCurrentPosL;
						 zzMarkedPos = zzMarkedPosL;
						 boolean eof = zzRefill();
						 zzCurrentPosL = zzCurrentPos;
						 zzMarkedPosL = zzMarkedPos;
						 zzBufferL = zzBuffer;
						 zzEndReadL = zzEndRead;
						 if (eof) {
							 zzInput = YYEOF;
							 break zzForAction;
						 }
						 else {
							 zzInput = zzBufferL[zzCurrentPosL++];
						 }
					 }
					 int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
					 if (zzNext == -1) break zzForAction;
					 zzState = zzNext;
					 int zzAttributes = zzAttrL[zzState];
					 if ( (zzAttributes & 1) == 1 ) {
						 zzAction = zzState;
						 zzMarkedPosL = zzCurrentPosL;
						 if ( (zzAttributes & 8) == 8 ) break zzForAction;
					 }
				 }
			 }
			 zzMarkedPos = zzMarkedPosL;
			 switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
				 case 19: {
					 commandBuffer.append(yytext());
					 debug(""SQL '"", yytext());
					 yybegin(SQL);
				 }
				 case 35: break;
				 case 9: {
					 commandBuffer.setLength(0);
					 yybegin(SPECIAL);
				 }
				 case 36: break;
				 case 30: {
					 pushbackTrim();
					 debug(""Spl. -- Comment"", yytext());
				 }
				 case 37: break;
				 case 10: {
					 commandBuffer.setLength(0);
					 yybegin(EDIT);
				 }
				 case 38: break;
				 case 21: {
					 yybegin(YYINITIAL);
					 debug(""Gobbled"", yytext());
					 prompt();
				 }
				 case 39: break;
				 case 31: {
					 debug ("" Comment"", yytext());
				 }
				 case 40: break;
				 case 8: {
					 return new Token(Token.SQL_TYPE, yyline);
				 }
				 case 41: break;
				 case 2: {
					 prompt();
				 }
				 case 42: break;
				 case 22: {
					 if (commandBuffer.toString().trim().equals(""."")) {
						 commandBuffer.setLength(0);
						 yybegin(RAW);
						 rawLeadinPrompt();
						 if (rawPrompt != null) prompt(rawPrompt);
					 }
					 else {
						 requestedState = YYINITIAL;
						 yybegin(PROMPT_CHANGE_STATE);
						 pushbackTrim();
						 return new Token(Token.SPECIAL_TYPE, commandBuffer, yyline);
					 }
				 }
				 case 43: break;
				 case 28: {
					 specialAppendState = false;
					 commandBuffer.append(yytext());
					 debug(""SQL -- Comment"", yytext());
				 }
				 case 44: break;
				 case 17: {
					 if (commandBuffer.length() > 0) commandBuffer.append('\n');
					 commandBuffer.append(strippedYytext());
					 if (rawPrompt != null) prompt(rawPrompt);
				 }
				 case 45: break;
				 case 26: {
					 yybegin(requestedState);
					 prompt();
				 }
				 case 46: break;
				 case 4: {
					 commandBuffer.setLength(0);
					 yybegin(MACRO);
				 }
				 case 47: break;
				 case 6: {
					 debug(""Whitespace"", yytext());
				 }
				 case 48: break;
				 case 18: {
					 commandBuffer.append(yytext());
				 }
				 case 49: break;
				 case 11: {
					 specialAppendState = false;
					 commandBuffer.append(yytext());
				 }
				 case 50: break;
				 case 25: {
					 requestedState = YYINITIAL;
					 yybegin(PROMPT_CHANGE_STATE);
					 pushbackTrim();
					 return new Token(Token.MACRO_TYPE, commandBuffer, yyline);
				 }
				 case 51: break;
				 case 16: {
					 if (interactive && !specialAppendState) {
						 requestedState = YYINITIAL;
						 yybegin(PROMPT_CHANGE_STATE);
						 pushbackTrim();
						 trimBuffer();
						 return new Token(Token.BUFFER_TYPE, commandBuffer, yyline);
					 }
					 specialAppendState = false;
					 commandBuffer.append(yytext());
				 }
				 case 52: break;
				 case 29: {
					 yybegin(YYINITIAL);
					 prompt();
					 return new Token(Token.RAWEXEC_TYPE, commandBuffer, yyline);
				 }
				 case 53: break;
				 case 27: {
					 yybegin(YYINITIAL);
					 prompt();
					 return new Token(Token.RAW_TYPE, commandBuffer, yyline);
				 }
				 case 54: break;
				 case 14: {
					 specialAppendState = false;
					 yybegin(YYINITIAL);
					 return new Token(Token.SQL_TYPE, commandBuffer, yyline);
				 }
				 case 55: break;
				 case 33: {
					 debug(""Spl. Comment"", yytext());
				 }
				 case 56: break;
				 case 3: {
					 yybegin(GOBBLE);
					 return new Token(Token.SYNTAX_ERR_TYPE, yytext(), yyline);
				 }
				 case 57: break;
				 case 20: {
					 commandBuffer.append(yytext());
					 yybegin(SQL);
					 debug(""SQL \"""", yytext());
				 }
				 case 58: break;
				 case 1: {
					 setCommandBuffer(yytext());
					 yybegin(SQL);
				 }
				 case 59: break;
				 case 23: {
					 requestedState = YYINITIAL;
					 yybegin(PROMPT_CHANGE_STATE);
					 pushbackTrim();
					 return new Token(Token.PL_TYPE, commandBuffer, yyline);
				 }
				 case 60: break;
				 case 12: {
					 specialAppendState = false;
					 commandBuffer.append(yytext());
					 if (sqlPrompt != null) prompt(sqlPrompt);
				 }
				 case 61: break;
				 case 24: {
					 requestedState = YYINITIAL;
					 yybegin(PROMPT_CHANGE_STATE);
					 pushbackTrim();
					 return new Token(Token.EDIT_TYPE, commandBuffer, yyline);
				 }
				 case 62: break;
				 case 7: {
					 debug (""-- Comment"", yytext());
				 }
				 case 63: break;
				 case 15: {
					 specialAppendState = false;
					 commandBuffer.append(yytext());
					 yybegin(SQL_SINGLE_QUOTED);
				 }
				 case 64: break;
				 case 5: {
					 commandBuffer.setLength(0);
					 yybegin(PL);
				 }
				 case 65: break;
				 case 34: {
					 setCommandBuffer(strippedYytext());
					 yybegin(RAW);
					 rawLeadinPrompt();
					 if (rawPrompt != null) prompt(rawPrompt);
				 }
				 case 66: break;
				 case 32: {
					 specialAppendState = false;
					 commandBuffer.append(yytext());
					 debug(""SQL Comment"", yytext());
				 }
				 case 67: break;
				 case 13: {
					 specialAppendState = false;
					 commandBuffer.append(yytext());
					 yybegin(SQL_DOUBLE_QUOTED);
				 }
				 case 68: break;
				 default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
					 zzAtEOF = true;
					 zzDoEOF();
					 switch (zzLexicalState) {
						 case SPECIAL: {
							 yybegin(YYINITIAL);
							 return new Token(Token.UNTERM_TYPE, commandBuffer, yyline);
						 }
						 case 115: break;
						 case SQL_DOUBLE_QUOTED: {
							 yybegin(YYINITIAL);
							 return new Token(Token.UNTERM_TYPE, commandBuffer, yyline);
						 }
						 case 116: break;
						 case SQL_SINGLE_QUOTED: {
							 yybegin(YYINITIAL);
							 return new Token(Token.UNTERM_TYPE, commandBuffer, yyline);
						 }
						 case 117: break;
						 case SQL: {
							 yybegin(YYINITIAL);
							 return new Token(Token.UNTERM_TYPE, commandBuffer, yyline);
						 }
						 case 118: break;
						 case EDIT: {
							 yybegin(YYINITIAL);
							 return new Token(Token.UNTERM_TYPE, commandBuffer, yyline);
						 }
						 case 119: break;
						 case PL: {
							 yybegin(YYINITIAL);
							 return new Token(Token.UNTERM_TYPE, commandBuffer, yyline);
						 }
						 case 120: break;
						 case MACRO: {
							 yybegin(YYINITIAL);
							 return new Token(Token.UNTERM_TYPE, commandBuffer, yyline);
						 }
						 case 121: break;
						 default: return null;
					 }
				 }
				 else {
					 zzScanError(ZZ_NO_MATCH);
				 }
			 }
		 }
	 }
}",1,0,0,0
"public class VisualizationModel extends Model {
	private String writerName;
	private String readerName;
	private String outputName;
	 private String exportString;
	private IIOService ioService;
	 private IReader reader;
	 private IWriter writer;
	public VisualizationModel() {
		this(null);
	}
	public VisualizationModel(IProject project) {
		super(project);
	}
	protected void setupItemInfo() {
		setName(""Visualization Model"");
		setDescription(""Specify information about Visualization"");
		writerName = ""VisualizationDefaultWriterName"";
		readerName = ""VisualizationDefaultReaderName"";
		 outputName = ""VisualizationDefaultOutputName"";
		 exportString = ""Export to Visualization input format"";
		allowedActions.add(0, exportString);
	}
	public void setupForm() {
		form = new Form();
		ioService = getIOService();
	}
	protected FormStatus reviewEntries(Form preparedForm) {
		FormStatus retStatus = FormStatus.ReadyToProcess;
		return retStatus;
	}
	public FormStatus process(String actionName) {
		FormStatus retStatus = FormStatus.ReadyToProcess;
		if (actionName == exportString) {
			IFile outputFile = project.getFile(outputName);
			writer = ioService.getWriter(writerName);
			retStatus = FormStatus.Processing;
			writer.write(form, outputFile);
			refreshProjectSpace();
			retStatus = FormStatus.Processed;
		}
		 else {
			retStatus = super.process(actionName);
		}
		return retStatus;
	}
	public void loadInput(String fileName) {
		IFile inputFile = project.getFile(fileName);
		reader = ioService.getReader(readerName);
		form = reader.read(inputFile);
		form.setName(getName());
		form.setDescription(getDescription());
		form.setId(getId());
		form.setItemID(getId());
	}
}",1,0,0,0
"public class ContentProviderController<T extends ContentProvider> {
	 private T contentProvider;
	 private ContentProviderController(T contentProvider) {
		 this.contentProvider = contentProvider;
	 }
	 public static <T extends ContentProvider> ContentProviderController<T> of(T contentProvider) {
		 return new ContentProviderController<>(contentProvider);
	 }
	 public ContentProviderController<T> create() {
		 Context baseContext = RuntimeEnvironment.application.getBaseContext();
		 ComponentName componentName = createRelative(baseContext.getPackageName(), contentProvider.getClass().getName());
		 ProviderInfo providerInfo = null;
		 try {
			 providerInfo = baseContext .getPackageManager() .getProviderInfo(componentName, PackageManager.MATCH_DISABLED_COMPONENTS);
		 }
		 catch (PackageManager.NameNotFoundException e) {
			 Logger.strict(""Unable to find provider info for "" + componentName, e);
		 }
		 return create(providerInfo);
	 }
	 public ContentProviderController<T> create(String authority) {
		 ProviderInfo providerInfo = new ProviderInfo();
		 providerInfo.authority = authority;
		 return create(providerInfo);
	 }
	 public ContentProviderController<T> create(ProviderInfo providerInfo) {
		 Context baseContext = RuntimeEnvironment.application.getBaseContext();
		 ComponentName componentName = createRelative(baseContext.getPackageName(), contentProvider.getClass().getName());
		 baseContext .getPackageManager() .setComponentEnabledSetting( componentName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, 0);
		 contentProvider.attachInfo(baseContext, providerInfo);
		 if (providerInfo != null) {
			 ShadowContentResolver.registerProviderInternal(providerInfo.authority, contentProvider);
		 }
		 return this;
	 }
	 public T get() {
		 return contentProvider;
	 }
	 public ContentProviderController<T> shutdown() {
		 contentProvider.shutdown();
		 return this;
	 }
	 private static ComponentName createRelative(String pkg, String cls) {
		 final String fullName;
		 if (cls.charAt(0) == '.') {
			 fullName = pkg + cls;
		 }
		 else {
			 fullName = cls;
		 }
		 return new ComponentName(pkg, fullName);
	 }
}",0,0,0,0
"protected GraphicsNode createImageGraphicsNode( BridgeContext ctx, Element imageElement, ParsedURL purl) {
	 AbstractFOPBridgeContext bridgeCtx = (AbstractFOPBridgeContext)ctx;
	 ImageManager manager = bridgeCtx.getImageManager();
	 ImageSessionContext sessionContext = bridgeCtx.getImageSessionContext();
	 try {
		 ImageInfo info = manager.getImageInfo(purl.toString(), sessionContext);
		 ImageFlavor[] supportedFlavors = getSupportedFlavours();
		 Image image = manager.getImage(info, supportedFlavors, sessionContext);
		 AbstractGraphicsNode specializedNode = null;
		 if (image instanceof ImageXMLDOM) {
			 ImageXMLDOM xmlImage = (ImageXMLDOM)image;
			 if (xmlImage.getDocument() instanceof SVGDocument) {
				 SVGDocument clonedDoc = (SVGDocument)BatikUtil.cloneSVGDocument( xmlImage.getDocument());
				 return createSVGImageNode(ctx, imageElement, clonedDoc);
			 }
			 else {
				 image = manager.convertImage(xmlImage, new ImageFlavor[] {
				ImageFlavor.GRAPHICS2D}
				);
			 }
		 }
		 if (image instanceof ImageRawJPEG) {
			 specializedNode = createLoaderImageNode(image, ctx, imageElement, purl);
		 }
		 else if (image instanceof ImageRawCCITTFax) {
			 specializedNode = createLoaderImageNode(image, ctx, imageElement, purl);
		 }
		 else if (image instanceof ImageGraphics2D) {
			 ImageGraphics2D g2dImage = (ImageGraphics2D)image;
			 specializedNode = new Graphics2DNode(g2dImage);
		 }
		 else {
			 ctx.getUserAgent().displayError( new ImageException(""Cannot convert an image to a usable format: "" + purl));
		 }
		 if (specializedNode != null) {
			 Rectangle2D imgBounds = getImageBounds(ctx, imageElement);
			 Rectangle2D bounds = specializedNode.getPrimitiveBounds();
			 float [] vb = new float[4];
			 vb[0] = 0;
			 vb[1] = 0;
			 vb[2] = (float) bounds.getWidth();
			 vb[3] = (float) bounds.getHeight();
			 initializeViewport(ctx, imageElement, specializedNode, vb, imgBounds);
			 return specializedNode;
		 }
	 }
	 catch (Exception e) {
		 ctx.getUserAgent().displayError(e);
	 }
	 return superCreateGraphicsNode(ctx, imageElement, purl);
 }",0,0,1,0
"public class CloudOperationsImpl implements CloudOperations {
	 private List<CloudProvider> providers = new ArrayList<CloudProvider>();
	 private List<CloudProviderId> providersId = null;
	 private ProjectOperations projectOperations;
	 public boolean isSetupCommandAvailable() {
		 return projectOperations.isProjectAvailable(projectOperations.getFocusedModuleName());
	 }
	 public void installProvider(CloudProviderId prov, String configuration) {
		 CloudProvider provider = null;
		 for (CloudProvider tmpProvider : providers) {
			 if (prov.is(tmpProvider)) {
				 provider = tmpProvider;
				 break;
			 }
		 }
		 if (provider == null) {
			 throw new RuntimeException(""Provider '"".concat(prov.getId()).concat(""' not found'""));
		 }
		 provider.setup(configuration);
	 }
	 public CloudProviderId getProviderIdByName(String name) {
		 CloudProviderId provider = null;
		 for (CloudProvider tmpProvider : providers) {
			 if (tmpProvider.getName().equals(name)) {
				 provider = new CloudProviderId(tmpProvider);
			 }
		 }
		 return provider;
	 }
	 protected void bindProvider(final CloudProvider provider) {
		 providers.add(provider);
	 }
	 protected void unbindProvider(final CloudProvider provider) {
		 providers.remove(provider);
	 }
	 public List<CloudProviderId> getProvidersId() {
		 if (providersId == null) {
			 providersId = new ArrayList<CloudProviderId>();
			 for (CloudProvider tmpProvider : providers) {
				 providersId.add(new CloudProviderId(tmpProvider));
			 }
			 providersId = Collections.unmodifiableList(providersId);
		 }
		 return providersId;
	 }
}",0,0,0,0
"public class ShortConverter extends AbstractIntegerConverter{
	private static final long serialVersionUID = 1L;
	public static final IConverter INSTANCE = new ShortConverter();
	public Short convertToObject(final String value, Locale locale){
		final Number number = parse(value, Short.MIN_VALUE, Short.MAX_VALUE, locale);
		if (number == null){
			return null;
		}
		return new Short(number.shortValue());
	}
	protected Class<Short> getTargetType(){
		return Short.class;
	}
}",0,0,0,0
"public class OgnlTextParser implements TextParser {
	 public Object evaluate(char[] openChars, String expression, TextParseUtil.ParsedValueEvaluator evaluator, int maxLoopCount) {
		 Object result = expression = (expression == null) ? """" : expression;
		 int pos = 0;
		 for (char open : openChars) {
			 int loopCount = 1;
			 final String lookupChars = open + ""{
				"";
				 while (true) {
					 int start = expression.indexOf(lookupChars, pos);
					 if (start == -1) {
						 loopCount++;
						 start = expression.indexOf(lookupChars);
					 }
					 if (loopCount > maxLoopCount) {
						 break;
					 }
					 int length = expression.length();
					 int x = start + 2;
					 int end;
					 char c;
					 int count = 1;
					 while (start != -1 && x < length && count != 0) {
						 c = expression.charAt(x++);
						 if (c == '{
							') {
								 count++;
							 }
						 else if (c == '}
						') {
							 count--;
						 }
					 }
					 end = x - 1;
					 if ((start != -1) && (end != -1) && (count == 0)) {
						 String var = expression.substring(start + 2, end);
						 Object o = evaluator.evaluate(var);
						 String left = expression.substring(0, start);
						 String right = expression.substring(end + 1);
						 String middle = null;
						 if (o != null) {
							 middle = o.toString();
							 if (StringUtils.isEmpty(left)) {
								 result = o;
							 }
							 else {
								 result = left.concat(middle);
							 }
							 if (StringUtils.isNotEmpty(right)) {
								 result = result.toString().concat(right);
							 }
							 expression = left.concat(middle).concat(right);
						 }
						 else {
							 expression = left.concat(right);
							 result = expression;
						 }
						 pos = (left != null && left.length() > 0 ? left.length() - 1: 0) + (middle != null && middle.length() > 0 ? middle.length() - 1: 0) + 1;
						 pos = Math.max(pos, 1);
					 }
					 else {
						 break;
					 }
				 }
			 }
			 return result;
		 }
	}",0,0,0,0
"public static long pop_union(long A[], long B[], int wordOffset, int numWords) {
	 int n = wordOffset+numWords;
	 long tot=0, tot8=0;
	 long ones=0, twos=0, fours=0;
	 int i;
	 for (i = wordOffset;
	 i <= n - 8;
	 i+=8) {
		 long twosA,twosB,foursA,foursB,eights;
		 {
			 long b=(A[i] | B[i]), c=(A[i+1] | B[i+1]);
			 long u=ones ^ b;
			 twosA=(ones & b)|( u & c);
			 ones=u^c;
		 }
		 {
			 long b=(A[i+2] | B[i+2]), c=(A[i+3] | B[i+3]);
			 long u=ones^b;
			 twosB =(ones&b)|(u&c);
			 ones=u^c;
		 }
		 {
			 long u=twos^twosA;
			 foursA=(twos&twosA)|(u&twosB);
			 twos=u^twosB;
		 }
		 {
			 long b=(A[i+4] | B[i+4]), c=(A[i+5] | B[i+5]);
			 long u=ones^b;
			 twosA=(ones&b)|(u&c);
			 ones=u^c;
		 }
		 {
			 long b=(A[i+6] | B[i+6]), c=(A[i+7] | B[i+7]);
			 long u=ones^b;
			 twosB=(ones&b)|(u&c);
			 ones=u^c;
		 }
		 {
			 long u=twos^twosA;
			 foursB=(twos&twosA)|(u&twosB);
			 twos=u^twosB;
		 }
		 {
			 long u=fours^foursA;
			 eights=(fours&foursA)|(u&foursB);
			 fours=u^foursB;
		 }
		 tot8 += pop(eights);
	 }
	 if (i<=n-4) {
		 long twosA, twosB, foursA, eights;
		 {
			 long b=(A[i] | B[i]), c=(A[i+1] | B[i+1]);
			 long u=ones ^ b;
			 twosA=(ones & b)|( u & c);
			 ones=u^c;
		 }
		 {
			 long b=(A[i+2] | B[i+2]), c=(A[i+3] | B[i+3]);
			 long u=ones^b;
			 twosB =(ones&b)|(u&c);
			 ones=u^c;
		 }
		 {
			 long u=twos^twosA;
			 foursA=(twos&twosA)|(u&twosB);
			 twos=u^twosB;
		 }
		 eights=fours&foursA;
		 fours=fours^foursA;
		 tot8 += pop(eights);
		 i+=4;
	 }
	 if (i<=n-2) {
		 long b=(A[i] | B[i]), c=(A[i+1] | B[i+1]);
		 long u=ones ^ b;
		 long twosA=(ones & b)|( u & c);
		 ones=u^c;
		 long foursA=twos&twosA;
		 twos=twos^twosA;
		 long eights=fours&foursA;
		 fours=fours^foursA;
		 tot8 += pop(eights);
		 i+=2;
	 }
	 if (i<n) {
		 tot += pop((A[i] | B[i]));
	 }
	 tot += (pop(fours)<<2) + (pop(twos)<<1) + pop(ones) + (tot8<<3);
	 return tot;
 }",0,0,1,0
"public class BorlandDeploymentTool extends GenericDeploymentTool implements ExecuteStreamHandler {
	 public static final String PUBLICID_BORLAND_EJB = ""- protected static final String DEFAULT_BAS45_EJB11_DTD_LOCATION = ""/com/inprise/j2ee/xml/dtds/ejb-jar.dtd"";
	 protected static final String DEFAULT_BAS_DTD_LOCATION = ""/com/inprise/j2ee/xml/dtds/ejb-inprise.dtd"";
	 protected static final String BAS_DD = ""ejb-inprise.xml"";
	 protected static final String BES_DD = ""ejb-borland.xml"";
	 protected static final String JAVA2IIOP = ""java2iiop"";
	 protected static final String VERIFY = ""com.inprise.ejb.util.Verify"";
	 private String jarSuffix = ""-ejb.jar"";
	 private String borlandDTD;
	 private boolean java2iiopdebug = false;
	 private String java2iioparams = null;
	 private boolean generateclient = false;
	 static final int BES = 5;
	 static final int BAS = 4;
	 private int version = BAS;
	 private boolean verify = true;
	 private String verifyArgs = """";
	 private Hashtable genfiles = new Hashtable();
	 public void setDebug(boolean debug) {
		 this.java2iiopdebug = debug;
	 }
	 public void setVerify(boolean verify) {
		 this.verify = verify;
	 }
	 public void setSuffix(String inString) {
		 this.jarSuffix = inString;
	 }
	 public void setVerifyArgs(String args) {
		 this.verifyArgs = args;
	 }
	 public void setBASdtd(String inString) {
		 this.borlandDTD = inString;
	 }
	 public void setGenerateclient(boolean b) {
		 this.generateclient = b;
	 }
	 public void setVersion(int version) {
		 this.version = version;
	 }
	 public void setJava2iiopParams(String params) {
		 this.java2iioparams = params;
	 }
	 protected DescriptorHandler getBorlandDescriptorHandler(final File srcDir) {
		 DescriptorHandler handler = new DescriptorHandler(getTask(), srcDir) {
			 protected void processElement() {
				 if (currentElement.equals(""type-storage"")) {
					 String fileNameWithMETA = currentText;
					 String fileName = fileNameWithMETA.substring(META_DIR.length(), fileNameWithMETA.length());
					 File descriptorFile = new File(srcDir, fileName);
					 ejbFiles.put(fileNameWithMETA, descriptorFile);
				 }
			 }
		 }
		;
		 handler.registerDTD(PUBLICID_BORLAND_EJB, borlandDTD == null ? DEFAULT_BAS_DTD_LOCATION : borlandDTD);
		 for (Iterator i = getConfig().dtdLocations.iterator();
		 i.hasNext();
		) {
			 EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();
			 handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
		 }
		 return handler;
	 }
	 protected void addVendorFiles(Hashtable ejbFiles, String ddPrefix) {
		 if (!(version == BES || version == BAS)) {
			 throw new BuildException(""version "" + version + "" is not supported"");
		 }
		 String dd = (version == BES ? BES_DD : BAS_DD);
		 log(""vendor file : "" + ddPrefix + dd, Project.MSG_DEBUG);
		 File borlandDD = new File(getConfig().descriptorDir, ddPrefix + dd);
		 if (borlandDD.exists()) {
			 log(""Borland specific file found "" + borlandDD, Project.MSG_VERBOSE);
			 ejbFiles.put(META_DIR + dd , borlandDD);
		 }
		 else {
			 log(""Unable to locate borland deployment descriptor. "" + ""It was expected to be in "" + borlandDD.getPath(), Project.MSG_WARN);
			 return;
		 }
	 }
	 File getVendorOutputJarFile(String baseName) {
		 return new File(getDestDir(), baseName + jarSuffix);
	 }
	 private void verifyBorlandJar(File sourceJar) {
		 if (version == BAS) {
			 verifyBorlandJarV4(sourceJar);
			 return;
		 }
		 if (version == BES) {
			 verifyBorlandJarV5(sourceJar);
			 return;
		 }
		 log(""verify jar skipped because the version is invalid ["" + version + ""]"", Project.MSG_WARN);
	 }
	 private void verifyBorlandJarV5(File sourceJar) {
		 log(""verify BES "" + sourceJar, Project.MSG_INFO);
		 try {
			 ExecTask execTask = null;
			 execTask = new ExecTask(getTask());
			 execTask.setDir(new File("".""));
			 execTask.setExecutable(""iastool"");
			 if (getCombinedClasspath() != null) {
				 execTask.createArg().setValue(""-VBJclasspath"");
				 execTask.createArg().setValue(getCombinedClasspath().toString());
			 }
			 if (java2iiopdebug) {
				 execTask.createArg().setValue(""-debug"");
			 }
			 execTask.createArg().setValue(""-verify"");
			 execTask.createArg().setValue(""-src"");
			 execTask.createArg().setValue(sourceJar.getPath());
			 log(""Calling iastool"", Project.MSG_VERBOSE);
			 execTask.execute();
		 }
		 catch (Exception e) {
			 String msg = ""Exception while calling generateclient Details: "" + e.toString();
			 throw new BuildException(msg, e);
		 }
	 }
	 private void verifyBorlandJarV4(File sourceJar) {
		 org.apache.tools.ant.taskdefs.Java javaTask = null;
		 log(""verify BAS "" + sourceJar, Project.MSG_INFO);
		 try {
			 String args = verifyArgs;
			 args += "" "" + sourceJar.getPath();
			 javaTask = new Java(getTask());
			 javaTask.setTaskName(""verify"");
			 javaTask.setClassname(VERIFY);
			 Commandline.Argument arguments = javaTask.createArg();
			 arguments.setLine(args);
			 Path classpath = getCombinedClasspath();
			 if (classpath != null) {
				 javaTask.setClasspath(classpath);
				 javaTask.setFork(true);
			 }
			 log(""Calling "" + VERIFY + "" for "" + sourceJar.toString(), Project.MSG_VERBOSE);
			 javaTask.execute();
		 }
		 catch (Exception e) {
			 String msg = ""Exception while calling "" + VERIFY + "" Details: "" + e.toString();
			 throw new BuildException(msg, e);
		 }
	 }
	 private void generateClient(File sourceJar) {
		 getTask().getProject().addTaskDefinition(""internal_bas_generateclient"", org.apache.tools.ant.taskdefs.optional.ejb.BorlandGenerateClient.class);
		 org.apache.tools.ant.taskdefs.optional.ejb.BorlandGenerateClient gentask = null;
		 log(""generate client for "" + sourceJar, Project.MSG_INFO);
		 try {
			 Project project = getTask().getProject();
			 gentask = (BorlandGenerateClient) project.createTask(""internal_bas_generateclient"");
			 gentask.setEjbjar(sourceJar);
			 gentask.setDebug(java2iiopdebug);
			 Path classpath = getCombinedClasspath();
			 if (classpath != null) {
				 gentask.setClasspath(classpath);
			 }
			 gentask.setVersion(version);
			 gentask.setTaskName(""generate client"");
			 gentask.execute();
		 }
		 catch (Exception e) {
			 String msg = ""Exception while calling "" + VERIFY + "" Details: "" + e.toString();
			 throw new BuildException(msg, e);
		 }
	 }
	 private void buildBorlandStubs(Iterator ithomes) {
		 Execute execTask = null;
		 execTask = new Execute(this);
		 Project project = getTask().getProject();
		 execTask.setAntRun(project);
		 execTask.setWorkingDirectory(project.getBaseDir());
		 Commandline commandline = new Commandline();
		 commandline.setExecutable(JAVA2IIOP);
		 if (java2iiopdebug) {
			 commandline.createArgument().setValue(""-VBJdebug"");
		 }
		 commandline.createArgument().setValue(""-VBJclasspath"");
		 commandline.createArgument().setPath(getCombinedClasspath());
		 commandline.createArgument().setValue(""-list_files"");
		 commandline.createArgument().setValue(""-no_tie"");
		 if (java2iioparams != null) {
			 log(""additional "" + java2iioparams + "" to java2iiop "", 0);
			 commandline.createArgument().setValue(java2iioparams);
		 }
		 commandline.createArgument().setValue(""-root_dir"");
		 commandline.createArgument().setValue(getConfig().srcDir.getAbsolutePath());
		 commandline.createArgument().setValue(""-compile"");
		 while (ithomes.hasNext()) {
			 commandline.createArgument().setValue(ithomes.next().toString());
		 }
		 try {
			 log(""Calling java2iiop"", Project.MSG_VERBOSE);
			 log(commandline.describeCommand(), Project.MSG_DEBUG);
			 execTask.setCommandline(commandline.getCommandline());
			 int result = execTask.execute();
			 if (Execute.isFailure(result)) {
				 String msg = ""Failed executing java2iiop (ret code is "" + result + "")"";
				 throw new BuildException(msg, getTask().getLocation());
			 }
		 }
		 catch (java.io.IOException e) {
			 log(""java2iiop exception :"" + e.getMessage(), Project.MSG_ERR);
			 throw new BuildException(e, getTask().getLocation());
		 }
	 }
	 protected void writeJar(String baseName, File jarFile, Hashtable files, String publicId) throws BuildException {
		 Vector homes = new Vector();
		 Iterator it = files.keySet().iterator();
		 while (it.hasNext()) {
			 String clazz = (String) it.next();
			 if (clazz.endsWith(""Home.class"")) {
				 String home = toClass(clazz);
				 homes.add(home);
				 log("" Home "" + home, Project.MSG_VERBOSE);
			 }
		 }
		 buildBorlandStubs(homes.iterator());
		 files.putAll(genfiles);
		 super.writeJar(baseName, jarFile, files, publicId);
		 if (verify) {
			 verifyBorlandJar(jarFile);
		 }
		 if (generateclient) {
			 generateClient(jarFile);
		 }
	 }
	 private String toClass(String filename) {
		 String classname = filename.substring(0, filename.lastIndexOf("".class""));
		 classname = classname.replace('\\', '.');
		 return classname;
	 }
	 private String toClassFile(String filename) {
		 String classfile = filename.substring(0, filename.lastIndexOf("".java""));
		 classfile = classfile + "".class"";
		 return classfile;
	 }
	 public void start() throws IOException {
	 }
	 public void stop() {
	 }
	 public void setProcessInputStream(OutputStream param1) throws IOException {
	 }
	 public void setProcessOutputStream(InputStream is) throws IOException {
		 try {
			 BufferedReader reader = new BufferedReader(new InputStreamReader(is));
			 String javafile;
			 while ((javafile = reader.readLine()) != null) {
				 if (javafile.endsWith("".java"")) {
					 String classfile = toClassFile(javafile);
					 String key = classfile.substring( getConfig().srcDir.getAbsolutePath().length() + 1);
					 genfiles.put(key, new File(classfile));
				 }
			 }
			 reader.close();
		 }
		 catch (Exception e) {
			 String msg = ""Exception while parsing java2iiop output. Details: "" + e.toString();
			 throw new BuildException(msg, e);
		 }
	 }
	 public void setProcessErrorStream(InputStream is) throws IOException {
		 BufferedReader reader = new BufferedReader(new InputStreamReader(is));
		 String s = reader.readLine();
		 if (s != null) {
			 log(""[java2iiop] "" + s, Project.MSG_ERR);
		 }
	 }
}",0,0,0,0
"public classTarBuffer extends Object{
	public static final intDEFAULT_RCDSIZE = ( 512 );
	public static final intDEFAULT_BLKSIZE = ( DEFAULT_RCDSIZE * 20 );
	private InputStreaminStream;
	private OutputStreamoutStream;
	private byte[]blockBuffer;
	private intcurrBlkIdx;
	private intcurrRecIdx;
	private intblockSize;
	private intrecordSize;
	private intrecsPerBlock;
	private booleandebug;
	publicTarBuffer( InputStream inStream ){
		this( inStream, TarBuffer.DEFAULT_BLKSIZE );
	}
	publicTarBuffer( InputStream inStream, int blockSize ){
		this( inStream, blockSize, TarBuffer.DEFAULT_RCDSIZE );
	}
	publicTarBuffer( InputStream inStream, int blockSize, int recordSize ){
		this.inStream = inStream;
		this.outStream = null;
		this.initialize( blockSize, recordSize );
	}
	publicTarBuffer( OutputStream outStream ){
		this( outStream, TarBuffer.DEFAULT_BLKSIZE );
	}
	publicTarBuffer( OutputStream outStream, int blockSize ){
		this( outStream, blockSize, TarBuffer.DEFAULT_RCDSIZE );
	}
	publicTarBuffer( OutputStream outStream, int blockSize, int recordSize ){
		this.inStream = null;
		this.outStream = outStream;
		this.initialize( blockSize, recordSize );
	}
	private voidinitialize( int blockSize, int recordSize ){
		this.debug = false;
		this.blockSize = blockSize;
		this.recordSize = recordSize;
		this.recsPerBlock = ( this.blockSize / this.recordSize );
		this.blockBuffer = new byte[ this.blockSize ];
		if ( this.inStream != null ){
			this.currBlkIdx = -1;
			this.currRecIdx = this.recsPerBlock;
		}
		else{
			this.currBlkIdx = 0;
			this.currRecIdx = 0;
		}
	}
	public intgetBlockSize(){
		return this.blockSize;
	}
	public intgetRecordSize(){
		return this.recordSize;
	}
	public voidsetDebug( boolean debug ){
		this.debug = debug;
	}
	public booleanisEOFRecord( byte[] record ){
		for ( int i = 0, sz = this.getRecordSize() ;
		 i < sz ;
		 ++i )if ( record[i] != 0 )return false;
		return true;
	}
	public voidskipRecord()throws IOException{
		if ( this.debug ){
			System.err.println( ""SkipRecord: recIdx = "" + this.currRecIdx+ "" blkIdx = "" + this.currBlkIdx );
		}
		if ( this.inStream == null )throw new IOException( ""reading (via skip) from an output buffer"" );
		if ( this.currRecIdx >= this.recsPerBlock ){
			if ( ! this.readBlock() )return;
		 }
		this.currRecIdx++;
	}
	public byte[]readRecord()throws IOException{
		if ( this.debug ){
			System.err.println( ""ReadRecord: recIdx = "" + this.currRecIdx+ "" blkIdx = "" + this.currBlkIdx );
		}
		if ( this.inStream == null )throw new IOException( ""reading from an output buffer"" );
		if ( this.currRecIdx >= this.recsPerBlock ){
			if ( ! this.readBlock() )return null;
		}
		byte[] result = new byte[ this.recordSize ];
		System.arraycopy(this.blockBuffer, (this.currRecIdx * this.recordSize),result, 0, this.recordSize );
		this.currRecIdx++;
		return result;
	}
	private booleanreadBlock()throws IOException{
		if ( this.debug ){
			System.err.println( ""ReadBlock: blkIdx = "" + this.currBlkIdx );
		}
		if ( this.inStream == null )throw new IOException( ""reading from an output buffer"" );
		this.currRecIdx = 0;
		int offset = 0;
		int bytesNeeded = this.blockSize;
		for ( ;
		 bytesNeeded > 0 ;
		 ){
			long numBytes =this.inStream.read( this.blockBuffer, offset, bytesNeeded );
			if ( numBytes == -1 )break;
			offset += numBytes;
			bytesNeeded -= numBytes;
			if ( numBytes != this.blockSize ){
				if ( this.debug ){
					System.err.println( ""ReadBlock: INCOMPLETE READ "" + numBytes+ "" of "" + this.blockSize + "" bytes read."" );
				}
			}
		}
		this.currBlkIdx++;
		return true;
	}
	public intgetCurrentBlockNum(){
		return this.currBlkIdx;
	}
	public intgetCurrentRecordNum(){
		return this.currRecIdx - 1;
	}
	public voidwriteRecord( byte[] record )throws IOException{
		if ( this.debug ){
			System.err.println( ""WriteRecord: recIdx = "" + this.currRecIdx+ "" blkIdx = "" + this.currBlkIdx );
		}
		if ( this.outStream == null )throw new IOException( ""writing to an input buffer"" );
		if ( record.length != this.recordSize )throw new IOException( ""record to write has length '"" + record.length+ ""' which is not the record size of '""+ this.recordSize + ""'"" );
		if ( this.currRecIdx >= this.recsPerBlock ){
			this.writeBlock();
		}
		System.arraycopy(record, 0,this.blockBuffer, (this.currRecIdx * this.recordSize),this.recordSize );
		this.currRecIdx++;
	}
	public voidwriteRecord( byte[] buf, int offset )throws IOException{
		if ( this.debug ){
			System.err.println( ""WriteRecord: recIdx = "" + this.currRecIdx+ "" blkIdx = "" + this.currBlkIdx );
		}
		if ( this.outStream == null )throw new IOException( ""writing to an input buffer"" );
		if ( (offset + this.recordSize) > buf.length )throw new IOException( ""record has length '"" + buf.length+ ""' with offset '"" + offset+ ""' which is less than the record size of '""+ this.recordSize + ""'"" );
		if ( this.currRecIdx >= this.recsPerBlock ){
			this.writeBlock();
		}
		System.arraycopy(buf, offset,this.blockBuffer, (this.currRecIdx * this.recordSize),this.recordSize );
		this.currRecIdx++;
	}
	private voidwriteBlock()throws IOException{
		if ( this.debug ){
			System.err.println( ""WriteBlock: blkIdx = "" + this.currBlkIdx );
		}
		if ( this.outStream == null )throw new IOException( ""writing to an input buffer"" );
		this.outStream.write( this.blockBuffer, 0, this.blockSize );
		this.outStream.flush();
		this.currRecIdx = 0;
		this.currBlkIdx++;
	}
	private voidflushBlock()throws IOException{
		if ( this.debug ){
			System.err.println( ""TarBuffer.flushBlock() called."" );
		}
		if ( this.outStream == null )throw new IOException( ""writing to an input buffer"" );
		if ( this.currRecIdx > 0 ){
			this.writeBlock();
		}
	}
	public voidclose()throws IOException{
		if ( this.debug ){
			System.err.println( ""TarBuffer.closeBuffer()."" );
		}
		if ( this.outStream != null ){
			this.flushBlock();
			if ( this.outStream != System.out&& this.outStream != System.err ){
				this.outStream.close();
				this.outStream = null;
			}
		}
		else if ( this.inStream != null ){
			if ( this.inStream != System.in ){
				this.inStream.close();
				this.inStream = null;
			}
		}
	}
}",1,0,0,0
"public abstract class DecoratingHeaderResponse implements IHeaderResponse{
	private final IHeaderResponse realResponse;
	public DecoratingHeaderResponse(IHeaderResponse real){
		realResponse = real;
	}
	protected final IHeaderResponse getRealResponse(){
		return realResponse;
	}
	public void renderJavascriptReference(ResourceReference reference){
		realResponse.renderJavascriptReference(reference);
	}
	public void renderJavascriptReference(ResourceReference reference, String id){
		realResponse.renderJavascriptReference(reference, id);
	}
	public void renderJavascriptReference(String url){
		realResponse.renderJavascriptReference(url);
	}
	public void renderJavascriptReference(String url, String id){
		realResponse.renderJavascriptReference(url, id);
	}
	public void renderJavascript(CharSequence javascript, String id){
		realResponse.renderJavascript(javascript, id);
	}
	public void renderCSSReference(ResourceReference reference){
		realResponse.renderCSSReference(reference);
	}
	public void renderCSSReference(String url){
		realResponse.renderCSSReference(url);
	}
	public void renderCSSReference(ResourceReference reference, String media){
		realResponse.renderCSSReference(reference, media);
	}
	public void renderCSSReference(String url, String media){
		realResponse.renderCSSReference(url, media);
	}
	public void renderString(CharSequence string){
		realResponse.renderString(string);
	}
	public void markRendered(Object object){
		realResponse.markRendered(object);
	}
	public boolean wasRendered(Object object){
		return realResponse.wasRendered(object);
	}
	public Response getResponse(){
		return realResponse.getResponse();
	}
	public void renderOnDomReadyJavascript(String javascript){
		realResponse.renderOnDomReadyJavascript(javascript);
	}
	public void renderOnLoadJavascript(String javascript){
		realResponse.renderOnLoadJavascript(javascript);
	}
	public void renderOnEventJavascript(String target, String event, String javascript){
		realResponse.renderOnEventJavascript(target, event, javascript);
	}
	public void close(){
		realResponse.close();
	}
	public boolean isClosed(){
		return realResponse.isClosed();
	}
}",0,0,0,0
"public final class ZipLong implements Cloneable {
	 private static final int WORD = 4;
	 private static final int BYTE_MASK = 0xFF;
	 private static final int BYTE_1 = 1;
	 private static final int BYTE_1_MASK = 0xFF00;
	 private static final int BYTE_1_SHIFT = 8;
	 private static final int BYTE_2 = 2;
	 private static final int BYTE_2_MASK = 0xFF0000;
	 private static final int BYTE_2_SHIFT = 16;
	 private static final int BYTE_3 = 3;
	 private static final long BYTE_3_MASK = 0xFF000000L;
	 private static final int BYTE_3_SHIFT = 24;
	 private long value;
	 public ZipLong(long value) {
		 this.value = value;
	 }
	 public ZipLong (byte[] bytes) {
		 this(bytes, 0);
	 }
	 public ZipLong (byte[] bytes, int offset) {
		 value = ZipLong.getValue(bytes, offset);
	 }
	 public byte[] getBytes() {
		 return ZipLong.getBytes(value);
	 }
	 public long getValue() {
		 return value;
	 }
	 public static byte[] getBytes(long value) {
		 byte[] result = new byte[WORD];
		 result[0] = (byte) ((value & BYTE_MASK));
		 result[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);
		 result[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);
		 result[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);
		 return result;
	 }
	 public static long getValue(byte[] bytes, int offset) {
		 long value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;
		 value += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;
		 value += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;
		 value += (bytes[offset] & BYTE_MASK);
		 return value;
	 }
	 public static long getValue(byte[] bytes) {
		 return getValue(bytes, 0);
	 }
	 public boolean equals(Object o) {
		 if (o == null || !(o instanceof ZipLong)) {
			 return false;
		 }
		 return value == ((ZipLong) o).getValue();
	 }
	 public int hashCode() {
		 return (int) value;
	 }
	 public Object clone() {
		 try {
			 return super.clone();
		 }
		 catch (CloneNotSupportedException cnfe) {
			 throw new RuntimeException(cnfe);
		 }
	 }
}",0,0,0,0
"public ValueEval evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);",0,0,0,0
"protected JRFillDatasetRun(JRBaseFiller filler, JRDatasetRun datasetRun, JRFillDataset dataset);",0,0,0,0
"public class ComponentRenderInfo extends BaseRenderInfo {
	 public static final String LAYOUT_DIFFING_ENABLED = ""layout_diffing_enabled"";
	 public static final String PERSISTENCE_ENABLED = ""is_persistence_enabled"";
	 private final Component mComponent;
	 private final EventHandler<RenderCompleteEvent> mRenderCompleteEventHandler;
	 public static Builder create() {
		 return new Builder();
	 }
	 private ComponentRenderInfo(Builder builder) {
		 super(builder);
		 if (builder.mComponent == null) {
			 throw new IllegalStateException(""Component must be provided."");
		 }
		 mComponent = builder.mComponent;
		 mRenderCompleteEventHandler = builder.mRenderCompleteEventEventHandler;
	 }
	 public static RenderInfo createEmpty() {
		 return create().component(new EmptyComponent()).build();
	 }
	 public Component getComponent() {
		 return mComponent;
	 }
	 public EventHandler<RenderCompleteEvent> getRenderCompleteEventHandler() {
		 return mRenderCompleteEventHandler;
	 }
	 public boolean rendersComponent() {
		 return true;
	 }
	 public String getName() {
		 return mComponent.getSimpleName();
	 }
	 public static class Builder extends BaseRenderInfo.Builder<Builder> {
		 private Component mComponent;
		 private EventHandler<RenderCompleteEvent> mRenderCompleteEventEventHandler;
		 public Builder component(Component component) {
			 this.mComponent = component;
			 return this;
		 }
		 public Builder renderCompleteHandler( EventHandler<RenderCompleteEvent> renderCompleteEventHandler) {
			 this.mRenderCompleteEventEventHandler = renderCompleteEventHandler;
			 return this;
		 }
		 public Builder component(Component.Builder builder) {
			 return component(builder.build());
		 }
		 public ComponentRenderInfo build() {
			 return new ComponentRenderInfo(this);
		 }
	 }
	 private static class EmptyComponent extends Component {
		 protected EmptyComponent() {
			 super(""EmptyComponent"");
		 }
		 protected Component onCreateLayout(ComponentContext c) {
			 return Column.create(c).build();
		 }
		 public boolean isEquivalentTo(Component other) {
			 return EmptyComponent.this == other || (other != null && EmptyComponent.this.getClass() == other.getClass());
		 }
	 }
}",1,1,0,0
"public class WebsphereDeploymentTool extends GenericDeploymentTool {
	 public static final String PUBLICID_EJB11 = ""- public static final String PUBLICID_EJB20 = ""- protected static final String SCHEMA_DIR = ""Schema/"";
	 protected static final String WAS_EXT = ""ibm-ejb-jar-ext.xmi"";
	 protected static final String WAS_BND = ""ibm-ejb-jar-bnd.xmi"";
	 protected static final String WAS_CMP_MAP = ""Map.mapxmi"";
	 protected static final String WAS_CMP_SCHEMA = ""Schema.dbxmi"";
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private String jarSuffix = "".jar"";
	 private String ejb11DTD;
	 private boolean keepGeneric = false;
	 private boolean alwaysRebuild = true;
	 private boolean ejbdeploy = true;
	 private boolean newCMP = false;
	 private Path wasClasspath = null;
	 private String dbVendor;
	 private String dbName;
	 private String dbSchema;
	 private boolean codegen;
	 private boolean quiet = true;
	 private boolean novalidate;
	 private boolean nowarn;
	 private boolean noinform;
	 private boolean trace;
	 private String rmicOptions;
	 private boolean use35MappingRules;
	 private String tempdir = ""_ejbdeploy_temp"";
	 private File websphereHome;
	 public Path createWASClasspath() {
		 if (wasClasspath == null) {
			 wasClasspath = new Path(getTask().getProject());
		 }
		 return wasClasspath.createPath();
	 }
	 public void setWASClasspath(Path wasClasspath) {
		 this.wasClasspath = wasClasspath;
	 }
	 public void setDbvendor(String dbvendor) {
		 this.dbVendor = dbvendor;
	 }
	 public void setDbname(String dbName) {
		 this.dbName = dbName;
	 }
	 public void setDbschema(String dbSchema) {
		 this.dbSchema = dbSchema;
	 }
	 public void setCodegen(boolean codegen) {
		 this.codegen = codegen;
	 }
	 public void setQuiet(boolean quiet) {
		 this.quiet = quiet;
	 }
	 public void setNovalidate(boolean novalidate) {
		 this.novalidate = novalidate;
	 }
	 public void setNowarn(boolean nowarn) {
		 this.nowarn = nowarn;
	 }
	 public void setNoinform(boolean noinform) {
		 this.noinform = noinform;
	 }
	 public void setTrace(boolean trace) {
		 this.trace = trace;
	 }
	 public void setRmicoptions(String options) {
		 this.rmicOptions = options;
	 }
	 public void setUse35(boolean attr) {
		 use35MappingRules = attr;
	 }
	 public void setRebuild(boolean rebuild) {
		 this.alwaysRebuild = rebuild;
	 }
	 public void setSuffix(String inString) {
		 this.jarSuffix = inString;
	 }
	 public void setKeepgeneric(boolean inValue) {
		 this.keepGeneric = inValue;
	 }
	 public void setEjbdeploy(boolean ejbdeploy) {
		 this.ejbdeploy = ejbdeploy;
	 }
	 public void setEJBdtd(String inString) {
		 this.ejb11DTD = inString;
	 }
	 public void setOldCMP(boolean oldCMP) {
		 this.newCMP = !oldCMP;
	 }
	 public void setNewCMP(boolean newCMP) {
		 this.newCMP = newCMP;
	 }
	 public void setTempdir(String tempdir) {
		 this.tempdir = tempdir;
	 }
	 protected DescriptorHandler getDescriptorHandler(File srcDir) {
		 DescriptorHandler handler = new DescriptorHandler(getTask(), srcDir);
		 handler.registerDTD(PUBLICID_EJB11, ejb11DTD);
		 for (Iterator i = getConfig().dtdLocations.iterator();
		 i.hasNext();
		) {
			 EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();
			 handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
		 }
		 return handler;
	 }
	 protected DescriptorHandler getWebsphereDescriptorHandler(final File srcDir) {
		 DescriptorHandler handler = new DescriptorHandler(getTask(), srcDir) {
			 protected void processElement() {
			 }
		 }
		;
		 for (Iterator i = getConfig().dtdLocations.iterator();
		 i.hasNext();
		) {
			 EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();
			 handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
		 }
		 return handler;
	 }
	 protected void addVendorFiles(Hashtable ejbFiles, String baseName) {
		 String ddPrefix = (usingBaseJarName() ? """" : baseName);
		 String dbPrefix = (dbVendor == null) ? """" : dbVendor + ""-"";
		 File websphereEXT = new File(getConfig().descriptorDir, ddPrefix + WAS_EXT);
		 if (websphereEXT.exists()) {
			 ejbFiles.put(META_DIR + WAS_EXT, websphereEXT);
		 }
		 else {
			 log(""Unable to locate websphere extensions. "" + ""It was expected to be in "" + websphereEXT.getPath(), Project.MSG_VERBOSE);
		 }
		 File websphereBND = new File(getConfig().descriptorDir, ddPrefix + WAS_BND);
		 if (websphereBND.exists()) {
			 ejbFiles.put(META_DIR + WAS_BND, websphereBND);
		 }
		 else {
			 log(""Unable to locate websphere bindings. "" + ""It was expected to be in "" + websphereBND.getPath(), Project.MSG_VERBOSE);
		 }
		 if (!newCMP) {
			 log(""The old method for locating CMP files has been DEPRECATED."", Project.MSG_VERBOSE);
			 log(""Please adjust your websphere descriptor and set "" + ""newCMP=\""true\"" to use the new CMP descriptor "" + ""inclusion mechanism. "", Project.MSG_VERBOSE);
		 }
		 else {
			 try {
				 File websphereMAP = new File(getConfig().descriptorDir, ddPrefix + dbPrefix + WAS_CMP_MAP);
				 if (websphereMAP.exists()) {
					 ejbFiles.put(META_DIR + WAS_CMP_MAP, websphereMAP);
				 }
				 else {
					 log(""Unable to locate the websphere Map: "" + websphereMAP.getPath(), Project.MSG_VERBOSE);
				 }
				 File websphereSchema = new File(getConfig().descriptorDir, ddPrefix + dbPrefix + WAS_CMP_SCHEMA);
				 if (websphereSchema.exists()) {
					 ejbFiles.put(META_DIR + SCHEMA_DIR + WAS_CMP_SCHEMA, websphereSchema);
				 }
				 else {
					 log(""Unable to locate the websphere Schema: "" + websphereSchema.getPath(), Project.MSG_VERBOSE);
				 }
			 }
			 catch (Exception e) {
				 String msg = ""Exception while adding Vendor specific files: "" + e.toString();
				 throw new BuildException(msg, e);
			 }
		 }
	 }
	 File getVendorOutputJarFile(String baseName) {
		 return new File(getDestDir(), baseName + jarSuffix);
	 }
	 protected String getOptions() {
		 StringBuffer options = new StringBuffer();
		 if (dbVendor != null) {
			 options.append("" -dbvendor "").append(dbVendor);
		 }
		 if (dbName != null) {
			 options.append("" -dbname \"""").append(dbName).append(""\"""");
		 }
		 if (dbSchema != null) {
			 options.append("" -dbschema \"""").append(dbSchema).append(""\"""");
		 }
		 if (codegen) {
			 options.append("" -codegen"");
		 }
		 if (quiet) {
			 options.append("" -quiet"");
		 }
		 if (novalidate) {
			 options.append("" -novalidate"");
		 }
		 if (nowarn) {
			 options.append("" -nowarn"");
		 }
		 if (noinform) {
			 options.append("" -noinform"");
		 }
		 if (trace) {
			 options.append("" -trace"");
		 }
		 if (use35MappingRules) {
			 options.append("" -35"");
		 }
		 if (rmicOptions != null) {
			 options.append("" -rmic \"""").append(rmicOptions).append(""\"""");
		 }
		 return options.toString();
	 }
	 private void buildWebsphereJar(File sourceJar, File destJar) {
		 try {
			 if (ejbdeploy) {
				 Java javaTask = new Java(getTask());
				 javaTask.createJvmarg().setValue(""-Xms64m"");
				 javaTask.createJvmarg().setValue(""-Xmx128m"");
				 Environment.Variable var = new Environment.Variable();
				 var.setKey(""websphere.lib.dir"");
				 File libdir = new File(websphereHome, ""lib"");
				 var.setValue(libdir.getAbsolutePath());
				 javaTask.addSysproperty(var);
				 javaTask.setDir(websphereHome);
				 javaTask.setTaskName(""ejbdeploy"");
				 javaTask.setClassname(""com.ibm.etools.ejbdeploy.EJBDeploy"");
				 javaTask.createArg().setValue(sourceJar.getPath());
				 javaTask.createArg().setValue(tempdir);
				 javaTask.createArg().setValue(destJar.getPath());
				 javaTask.createArg().setLine(getOptions());
				 if (getCombinedClasspath() != null && getCombinedClasspath().toString().length() > 0) {
					 javaTask.createArg().setValue(""-cp"");
					 javaTask.createArg().setValue(getCombinedClasspath().toString());
				 }
				 Path classpath = wasClasspath;
				 if (classpath == null) {
					 classpath = getCombinedClasspath();
				 }
				 if (classpath != null) {
					 javaTask.setClasspath(classpath);
					 javaTask.setFork(true);
				 }
				 else {
					 javaTask.setFork(true);
				 }
				 log(""Calling websphere.ejbdeploy for "" + sourceJar.toString(), Project.MSG_VERBOSE);
				 javaTask.execute();
			 }
		 }
		 catch (Exception e) {
			 String msg = ""Exception while calling ejbdeploy. Details: "" + e.toString();
			 throw new BuildException(msg, e);
		 }
	 }
	 protected void writeJar(String baseName, File jarFile, Hashtable files, String publicId) throws BuildException {
		 if (ejbdeploy) {
			 File genericJarFile = super.getVendorOutputJarFile(baseName);
			 super.writeJar(baseName, genericJarFile, files, publicId);
			 if (alwaysRebuild || isRebuildRequired(genericJarFile, jarFile)) {
				 buildWebsphereJar(genericJarFile, jarFile);
			 }
			 if (!keepGeneric) {
				 log(""deleting generic jar "" + genericJarFile.toString(), Project.MSG_VERBOSE);
				 genericJarFile.delete();
			 }
		 }
		 else {
			 super.writeJar(baseName, jarFile, files, publicId);
		 }
	 }
	 public void validateConfigured() throws BuildException {
		 super.validateConfigured();
		 if (ejbdeploy) {
			 String home = getTask().getProject().getProperty(""websphere.home"");
			 if (home == null) {
				 throw new BuildException(""The 'websphere.home' property must "" + ""be set when 'ejbdeploy=true'"");
			 }
			 websphereHome = getTask().getProject().resolveFile(home);
		 }
	 }
	 protected boolean isRebuildRequired(File genericJarFile, File websphereJarFile) {
		 boolean rebuild = false;
		 JarFile genericJar = null;
		 JarFile wasJar = null;
		 File newwasJarFile = null;
		 JarOutputStream newJarStream = null;
		 try {
			 log(""Checking if websphere Jar needs to be rebuilt for jar "" + websphereJarFile.getName(), Project.MSG_VERBOSE);
			 if (genericJarFile.exists() && genericJarFile.isFile() && websphereJarFile.exists() && websphereJarFile.isFile()) {
				 genericJar = new JarFile(genericJarFile);
				 wasJar = new JarFile(websphereJarFile);
				 Hashtable genericEntries = new Hashtable();
				 Hashtable wasEntries = new Hashtable();
				 Hashtable replaceEntries = new Hashtable();
				 for (Enumeration e = genericJar.entries();
				 e.hasMoreElements();
				) {
					 JarEntry je = (JarEntry) e.nextElement();
					 genericEntries.put(je.getName().replace('\\', '/'), je);
				 }
				 for (Enumeration e = wasJar.entries();
				 e.hasMoreElements();
				) {
					 JarEntry je = (JarEntry) e.nextElement();
					 wasEntries.put(je.getName(), je);
				 }
				 ClassLoader genericLoader = getClassLoaderFromJar(genericJarFile);
				 for (Enumeration e = genericEntries.keys();
				 e.hasMoreElements();
				) {
					 String filepath = (String) e.nextElement();
					 if (wasEntries.containsKey(filepath)) {
						 JarEntry genericEntry = (JarEntry) genericEntries.get(filepath);
						 JarEntry wasEntry = (JarEntry) wasEntries.get(filepath);
						 if ((genericEntry.getCrc() != wasEntry.getCrc()) || (genericEntry.getSize() != wasEntry.getSize())) {
							 if (genericEntry.getName().endsWith("".class"")) {
								 String classname = genericEntry.getName().replace(File.separatorChar, '.');
								 classname = classname.substring(0, classname.lastIndexOf("".class""));
								 Class genclass = genericLoader.loadClass(classname);
								 if (genclass.isInterface()) {
									 log(""Interface "" + genclass.getName() + "" has changed"", Project.MSG_VERBOSE);
									 rebuild = true;
									 break;
								 }
								 else {
									 replaceEntries.put(filepath, genericEntry);
								 }
							 }
							 else {
								 if (!genericEntry.getName().equals(""META-INF/MANIFEST.MF"")) {
									 log(""Non class file "" + genericEntry.getName() + "" has changed"", Project.MSG_VERBOSE);
									 rebuild = true;
								 }
								 break;
							 }
						 }
					 }
					 else {
						 log(""File "" + filepath + "" not present in websphere jar"", Project.MSG_VERBOSE);
						 rebuild = true;
						 break;
					 }
				 }
				 if (!rebuild) {
					 log(""No rebuild needed - updating jar"", Project.MSG_VERBOSE);
					 newwasJarFile = new File(websphereJarFile.getAbsolutePath() + "".temp"");
					 if (newwasJarFile.exists()) {
						 newwasJarFile.delete();
					 }
					 newJarStream = new JarOutputStream(new FileOutputStream(newwasJarFile));
					 newJarStream.setLevel(0);
					 for (Enumeration e = wasEntries.elements();
					 e.hasMoreElements();
					) {
						 byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
						 int bytesRead;
						 InputStream is;
						 JarEntry je = (JarEntry) e.nextElement();
						 if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) {
							 newJarStream.setLevel(0);
						 }
						 else {
							 newJarStream.setLevel(JAR_COMPRESS_LEVEL);
						 }
						 if (replaceEntries.containsKey(je.getName())) {
							 log(""Updating Bean class from generic Jar "" + je.getName(), Project.MSG_VERBOSE);
							 je = (JarEntry) replaceEntries.get(je.getName());
							 is = genericJar.getInputStream(je);
						 }
						 else {
							 is = wasJar.getInputStream(je);
						 }
						 newJarStream.putNextEntry(new JarEntry(je.getName()));
						 while ((bytesRead = is.read(buffer)) != -1) {
							 newJarStream.write(buffer, 0, bytesRead);
						 }
						 is.close();
					 }
				 }
				 else {
					 log(""websphere Jar rebuild needed due to changed "" + ""interface or XML"", Project.MSG_VERBOSE);
				 }
			 }
			 else {
				 rebuild = true;
			 }
		 }
		 catch (ClassNotFoundException cnfe) {
			 String cnfmsg = ""ClassNotFoundException while processing ejb-jar file"" + "". Details: "" + cnfe.getMessage();
			 throw new BuildException(cnfmsg, cnfe);
		 }
		 catch (IOException ioe) {
			 String msg = ""IOException while processing ejb-jar file "" + "". Details: "" + ioe.getMessage();
			 throw new BuildException(msg, ioe);
		 }
		 finally {
			 if (genericJar != null) {
				 try {
					 genericJar.close();
				 }
				 catch (IOException closeException) {
				 }
			 }
			 if (wasJar != null) {
				 try {
					 wasJar.close();
				 }
				 catch (IOException closeException) {
				 }
			 }
			 if (newJarStream != null) {
				 try {
					 newJarStream.close();
				 }
				 catch (IOException closeException) {
				 }
				 try {
					 FILE_UTILS.rename(newwasJarFile, websphereJarFile);
				 }
				 catch (IOException renameException) {
					 log(renameException.getMessage(), Project.MSG_WARN);
					 rebuild = true;
				 }
			 }
		 }
		 return rebuild;
	 }
	 protected ClassLoader getClassLoaderFromJar(File classjar) throws IOException {
		 Path lookupPath = new Path(getTask().getProject());
		 lookupPath.setLocation(classjar);
		 Path classpath = getCombinedClasspath();
		 if (classpath != null) {
			 lookupPath.append(classpath);
		 }
		 return getTask().getProject().createClassLoader(lookupPath);
	 }
}",0,0,0,0
"public class UPPER extends EvalFunc <String> {
	 public String exec(Tuple input) {
		 final int quotient = 5/0;
		 String str=""hello"";
		 return str;
	 }
}",1,0,0,0
"public class DefaultClassLoader extends URLClassLoader {
	 protected final List includes;
	 protected final List excludes;
	 public DefaultClassLoader(URL[] urls, List includePatterns, List excludePatterns, final ClassLoader parent) {
		 this(urls, includePatterns, excludePatterns, parent, null);
	 }
	 public DefaultClassLoader(final URL[] urls, List includePatterns, List excludePatterns, ClassLoader parent, URLStreamHandlerFactory factory) {
		 super(urls, parent, factory);
		 this.includes = includePatterns;
		 this.excludes = excludePatterns;
	 }
	 protected boolean tryClassHere(String name) {
		 if ( name != null && (name.startsWith(""java."") || name.startsWith(""javax.servlet"") ) ) {
			 return false;
		 }
		 boolean tryHere;
		 if (this.includes == null || this.includes.size() == 0) {
			 tryHere = true;
		 }
		 else {
			 tryHere = false;
			 for (int i = 0;
			 i < this.includes.size();
			 i++) {
				 if (WildcardMatcherHelper.match((String)includes.get(i), name) != null) {
					 tryHere = true;
					 break;
				 }
			 }
		 }
		 if (tryHere && this.excludes != null && this.excludes.size() > 0) {
			 for (int i = 0;
			 i < this.excludes.size();
			 i++) {
				 if (WildcardMatcherHelper.match((String)excludes.get(i), name) != null) {
					 tryHere = false;
					 break;
				 }
			 }
		 }
		 return tryHere;
	 }
	 protected Class getClass(String name) throws ClassNotFoundException {
		 return findClass(name);
	 }
	 public final Class loadClass(String name, boolean resolve) throws ClassNotFoundException {
		 Class clazz = findLoadedClass(name);
		 if (clazz == null) {
			 final ClassLoader parent = getParent();
			 if (tryClassHere(name)) {
				 try {
					 clazz = this.getClass(name);
				 }
				 catch (ClassNotFoundException cnfe) {
					 if (parent == null) {
						 throw cnfe;
					 }
				 }
			 }
			 if (clazz == null) {
				 if (parent == null) {
					 throw new ClassNotFoundException(name);
				 }
				 else {
					 clazz = parent.loadClass(name);
				 }
			 }
		 }
		 if (resolve) {
			 resolveClass(clazz);
		 }
		 return clazz;
	 }
	 public final URL getResource(final String name) {
		 URL resource = findResource(name);
		 ClassLoader parent = this.getParent();
		 if (resource == null && parent != null) {
			 resource = parent.getResource(name);
		 }
		 return resource;
	 }
	 public final void addDirectory(File file) throws IOException {
		 this.addURL(file.getCanonicalFile().toURL());
	 }
	 public void addURL(URL url) {
		 super.addURL(url);
	 }
}",0,0,0,0
"private static boolean resolveGenericRef(GenericRef ref, Class<T> clazz, Type type) {
	 if (type instanceof Class) {
		 if (type == ref.ifaceClass) {
			 ref.setGenericFromType(type,0);
			 return true;
		 }
		 else {
			 return resolveGenericRef(ref,type);
		 }
	 }
	 if (type instanceof ParameterizedType) {
		 ParameterizedType ptype = (ParameterizedType)type;
		 Type rawType = ptype.getRawType();
		 if (rawType == ref.ifaceClass) {
			 ref.setGenericFromType(ptype.getActualTypeArguments()[0],0);
			 return true;
		 }
		 else {
			 return resolveGenericRef(ref,rawType);
		 }
	 }
	 return false;
 }",0,0,1,0
"public class KeystrokeRecord{
	 private int keyCode;
	 private int modifiers;
	 private String name;
	 private String script;
	 public KeystrokeRecord(int keyCode, int modifiers, String name, String script) {
		 this.keyCode = keyCode;
		 this.modifiers = modifiers;
		 this.name = name;
		 this.script = script;
	 }
	 public int getKeyCode() {
		 return keyCode;
	 }
	 public void setKeyCode(int keyCode) {
		 this.keyCode = keyCode;
	 }
	 public int getModifiers() {
		 return modifiers;
	 }
	 public void setModifiers(int modifiers) {
		 this.modifiers = modifiers;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public String getScript() {
		 return script;
	 }
	 public void setScript(String script) {
		 this.script = script;
	 }
	 public KeystrokeRecord duplicate() {
		 return new KeystrokeRecord(keyCode, modifiers, name, script);
	 }
}",0,1,0,0
"public class ClasspathUriUtil {
	 public static final String CLASSPATH_SCHEME = ""classpath"";
	 public static boolean isClasspathUri(URI uri) {
		 if (uri == null) return false;
		 String scheme = uri.scheme();
		 return CLASSPATH_SCHEME.equals(scheme);
	 }
}",0,1,0,0
"public ContextRelationship diff(ByteBuffer left, ByteBuffer right) {
	 ContextRelationship relationship = ContextRelationship.EQUAL;
	 ContextState leftState = new ContextState(left, headerLength(left));
	 ContextState rightState = new ContextState(right, headerLength(right));
	 while (leftState.hasRemaining() && rightState.hasRemaining()) {
		 int compareId = leftState.compareIdTo(rightState);
		 if (compareId == 0) {
			 long leftClock = leftState.getClock();
			 long rightClock = rightState.getClock();
			 leftState.moveToNext();
			 rightState.moveToNext();
			 if (leftClock == rightClock) {
				 continue;
			 }
			 else if ((leftClock >= 0 && rightClock > 0 && leftClock > rightClock) || (leftClock < 0 && (rightClock > 0 || leftClock < rightClock))) {
				 if (relationship == ContextRelationship.EQUAL) {
					 relationship = ContextRelationship.GREATER_THAN;
				 }
				 else if (relationship == ContextRelationship.GREATER_THAN) {
					 continue;
				 }
				 else {
					 return ContextRelationship.DISJOINT;
				 }
			 }
			 else {
				 if (relationship == ContextRelationship.EQUAL) {
					 relationship = ContextRelationship.LESS_THAN;
				 }
				 else if (relationship == ContextRelationship.GREATER_THAN) {
					 return ContextRelationship.DISJOINT;
				 }
				 else {
					 continue;
				 }
			 }
		 }
		 else if (compareId > 0) {
			 rightState.moveToNext();
			 if (relationship == ContextRelationship.EQUAL) {
				 relationship = ContextRelationship.LESS_THAN;
			 }
			 else if (relationship == ContextRelationship.GREATER_THAN) {
				 return ContextRelationship.DISJOINT;
			 }
			 else {
				 continue;
			 }
		 }
		 else {
			 leftState.moveToNext();
			 if (relationship == ContextRelationship.EQUAL) {
				 relationship = ContextRelationship.GREATER_THAN;
			 }
			 else if (relationship == ContextRelationship.GREATER_THAN) {
				 continue;
			 }
			 else {
				 return ContextRelationship.DISJOINT;
			 }
		 }
	 }
	 if (leftState.hasRemaining()) {
		 if (relationship == ContextRelationship.EQUAL) {
			 return ContextRelationship.GREATER_THAN;
		 }
		 else if (relationship == ContextRelationship.LESS_THAN) {
			 return ContextRelationship.DISJOINT;
		 }
	 }
	 else if (rightState.hasRemaining()) {
		 if (relationship == ContextRelationship.EQUAL) {
			 return ContextRelationship.LESS_THAN;
		 }
		 else if (relationship == ContextRelationship.GREATER_THAN) {
			 return ContextRelationship.DISJOINT;
		 }
	 }
	 return relationship;
 }",0,0,1,0
"public void reduce(WritableComparable key, Iterator values, OutputCollector output, Reporter reporter) throws IOException {
	 CrawlDatum lastG = null;
	 CrawlDatum lastF = null;
	 CrawlDatum lastSig = null;
	 Content lastC = null;
	 ParseData lastPD = null;
	 ParseText lastPT = null;
	 String lastGname = null;
	 String lastFname = null;
	 String lastSigname = null;
	 String lastCname = null;
	 String lastPDname = null;
	 String lastPTname = null;
	 TreeMap linked = new TreeMap();
	 while (values.hasNext()) {
		 ObjectWritable wrapper = (ObjectWritable)values.next();
		 Object o = wrapper.get();
		 if (o instanceof CrawlDatum) {
			 CrawlDatum val = (CrawlDatum)o;
			 UTF8 part = (UTF8)val.getMetaData().get(SEGMENT_PART_KEY);
			 if (part == null) throw new IOException(""Null segment part, key="" + key);
			 UTF8 uName = (UTF8)val.getMetaData().get(SEGMENT_NAME_KEY);
			 if (uName == null) throw new IOException(""Null segment name, key="" + key);
			 String name = uName.toString();
			 String partString = part.toString();
			 if (partString.equals(CrawlDatum.GENERATE_DIR_NAME)) {
				 if (lastG == null) {
					 lastG = val;
					 lastGname = name;
				 }
				 else {
					 if (lastGname.compareTo(name) < 0) {
						 lastG = val;
						 lastGname = name;
					 }
				 }
			 }
			 else if (partString.equals(CrawlDatum.FETCH_DIR_NAME)) {
				 if (lastF == null) {
					 lastF = val;
					 lastFname = name;
				 }
				 else {
					 if (lastFname.compareTo(name) < 0) {
						 lastF = val;
						 lastFname = name;
					 }
				 }
			 }
			 else if (partString.equals(CrawlDatum.PARSE_DIR_NAME)) {
				 if (val.getStatus() == CrawlDatum.STATUS_SIGNATURE) {
					 if (lastSig == null) {
						 lastSig = val;
						 lastSigname = name;
					 }
					 else {
						 if (lastSigname.compareTo(name) < 0) {
							 lastSig = val;
							 lastSigname = name;
						 }
					 }
					 continue;
				 }
				 ArrayList segLinked = (ArrayList)linked.get(name);
				 if (segLinked == null) {
					 segLinked = new ArrayList();
					 linked.put(name, segLinked);
				 }
				 segLinked.add(val);
			 }
			 else {
				 throw new IOException(""Cannot determine segment part: "" + partString);
			 }
		 }
		 else if (o instanceof Content) {
			 String name = ((Content)o).getMetadata().get(SEGMENT_NAME_KEY.toString());
			 if (lastC == null) {
				 lastC = (Content)o;
				 lastCname = name;
			 }
			 else {
				 if (lastCname.compareTo(name) < 0) {
					 lastC = (Content)o;
					 lastCname = name;
				 }
			 }
		 }
		 else if (o instanceof ParseData) {
			 String name = ((ParseData)o).getParseMeta().get(SEGMENT_NAME_KEY.toString());
			 if (lastPD == null) {
				 lastPD = (ParseData)o;
				 lastPDname = name;
			 }
			 else {
				 if (lastPDname.compareTo(name) < 0) {
					 lastPD = (ParseData)o;
					 lastPDname = name;
				 }
			 }
		 }
		 else if (o instanceof ParseText) {
			 String text = ((ParseText)o).getText();
			 String name = null;
			 int idx = text.indexOf(nameMarker, nameMarker.length());
			 if (idx != -1) {
				 name = text.substring(nameMarker.length(), idx);
			 }
			 else {
				 throw new IOException(""Missing segment name marker in ParseText, key "" + key + "": "" + text);
			 }
			 if (lastPT == null) {
				 lastPT = (ParseText)o;
				 lastPTname = name;
			 }
			 else {
				 if (lastPTname.compareTo(name) < 0) {
					 lastPT = (ParseText)o;
					 lastPTname = name;
				 }
			 }
		 }
	 }
	 curCount++;
	 UTF8 sliceName = null;
	 ObjectWritable wrapper = new ObjectWritable();
	 if (sliceSize > 0) {
		 sliceName = new UTF8(String.valueOf(curCount / sliceSize));
	 }
	 if (lastG != null) {
		 if (sliceName != null) {
			 lastG.getMetaData().put(SEGMENT_SLICE_KEY, sliceName);
		 }
		 wrapper.set(lastG);
		 output.collect(key, wrapper);
	 }
	 if (lastF != null) {
		 if (sliceName != null) {
			 lastF.getMetaData().put(SEGMENT_SLICE_KEY, sliceName);
		 }
		 wrapper.set(lastF);
		 output.collect(key, wrapper);
	 }
	 if (lastSig != null) {
		 if (sliceName != null) {
			 lastSig.getMetaData().put(SEGMENT_SLICE_KEY, sliceName);
		 }
		 wrapper.set(lastSig);
		 output.collect(key, wrapper);
	 }
	 if (lastC != null) {
		 if (sliceName != null) {
			 lastC.getMetadata().set(sliceMarker, sliceName.toString());
		 }
		 wrapper.set(lastC);
		 output.collect(key, wrapper);
	 }
	 if (lastPD != null) {
		 if (sliceName != null) {
			 lastPD.getParseMeta().set(sliceMarker, sliceName.toString());
		 }
		 wrapper.set(lastPD);
		 output.collect(key, wrapper);
	 }
	 if (lastPT != null) {
		 if (sliceName != null) {
			 lastPT = new ParseText(sliceMarker + sliceName + sliceMarker + lastPT.getText());
		 }
		 wrapper.set(lastPT);
		 output.collect(key, wrapper);
	 }
	 if (linked.size() > 0) {
		 String name = (String)linked.lastKey();
		 ArrayList segLinked = (ArrayList)linked.get(name);
		 for (int i = 0;
		 i < segLinked.size();
		 i++) {
			 CrawlDatum link = (CrawlDatum)segLinked.get(i);
			 if (sliceName != null) {
				 link.getMetaData().put(SEGMENT_SLICE_KEY, sliceName);
			 }
			 wrapper.set(link);
			 output.collect(key, wrapper);
		 }
	 }
 }",0,0,1,0
"public class KeepAliveInputStream extends FilterInputStream {
	 public KeepAliveInputStream(InputStream in) {
		 super(in);
	 }
	 public void close() throws IOException {
	 }
	 public static InputStream wrapSystemIn() {
		 return new KeepAliveInputStream(System.in);
	 }
}",0,0,0,0
"private List<ColumnOrSuperColumn> thriftifySuperColumns(Collection<IColumn> columns, boolean reverseOrder) {
	 ArrayList<ColumnOrSuperColumn> thriftSuperColumns = new ArrayList<ColumnOrSuperColumn>(columns.size());
	 for (IColumn column : columns) {
		 List<Column> subcolumns = thriftifySubColumns(column.getSubColumns());
		 if (subcolumns.isEmpty()) {
			 continue;
		 }
		 SuperColumn superColumn = new SuperColumn(column.name(), subcolumns);
		 thriftSuperColumns.add(new ColumnOrSuperColumn().setSuper_column(superColumn));
	 }
	 if (reverseOrder) Collections.reverse(thriftSuperColumns);
	 return thriftSuperColumns;
 }",0,0,0,0
"public class Shape {
	 private String type;
	 private Map<String, Member> members = Collections.emptyMap();
	 private String documentation;
	 private List<String> required;
	 private List<String> enumValues;
	 private String payload;
	 private boolean flattened;
	 private boolean exception;
	 private boolean streaming;
	 private boolean wrapper;
	 private Member listMember;
	 private Member mapKeyType;
	 private Member mapValueType;
	 private ErrorTrait errorTrait;
	 private long min;
	 private long max;
	 private String pattern;
	 private boolean fault;
	 private boolean deprecated;
	 private boolean isEventStream;
	 private boolean isEvent;
	 private String timestampFormat;
	 private boolean sensitive;
	 public boolean isFault() {
		 return fault;
	 }
	 public void setFault(boolean fault) {
		 this.fault = fault;
	 }
	 public String getPattern() {
		 return pattern;
	 }
	 public void setPattern(String pattern) {
		 this.pattern = pattern;
	 }
	 public String getType() {
		 return type;
	 }
	 public void setType(String type) {
		 this.type = type;
	 }
	 public Map<String, Member> getMembers() {
		 return members;
	 }
	 public void setMembers(Map<String, Member> members) {
		 this.members = members;
	 }
	 public String getDocumentation() {
		 return documentation;
	 }
	 public void setDocumentation(String documentation) {
		 this.documentation = documentation;
	 }
	 public List<String> getRequired() {
		 return required;
	 }
	 public void setRequired(List<String> required) {
		 this.required = required;
	 }
	 public List<String> getEnumValues() {
		 return enumValues;
	 }
	 public void setEnumValues(List<String> enumValues) {
		 this.enumValues = enumValues;
	 }
	 public String getPayload() {
		 return payload;
	 }
	 public void setPayload(String payload) {
		 this.payload = payload;
	 }
	 public boolean isFlattened() {
		 return flattened;
	 }
	 public void setFlattened(boolean flattened) {
		 this.flattened = flattened;
	 }
	 public boolean isException() {
		 return exception;
	 }
	 public void setException(boolean exception) {
		 this.exception = exception;
	 }
	 public Member getMapKeyType() {
		 return mapKeyType;
	 }
	 public void setMapKeyType(Member mapKeyType) {
		 this.mapKeyType = mapKeyType;
	 }
	 public Member getMapValueType() {
		 return mapValueType;
	 }
	 public void setMapValueType(Member mapValueType) {
		 this.mapValueType = mapValueType;
	 }
	 public Member getListMember() {
		 return listMember;
	 }
	 public void setListMember(Member listMember) {
		 this.listMember = listMember;
	 }
	 public long getMin() {
		 return min;
	 }
	 public void setMin(long min) {
		 this.min = min;
	 }
	 public long getMax() {
		 return max;
	 }
	 public void setMax(long max) {
		 this.max = max;
	 }
	 public boolean isStreaming() {
		 return streaming;
	 }
	 public void setStreaming(boolean streaming) {
		 this.streaming = streaming;
	 }
	 public boolean isWrapper() {
		 return wrapper;
	 }
	 public void setWrapper(boolean wrapper) {
		 this.wrapper = wrapper;
	 }
	 public ErrorTrait getErrorTrait() {
		 return errorTrait;
	 }
	 public void setErrorTrait(ErrorTrait errorTrait) {
		 this.errorTrait = errorTrait;
	 }
	 public boolean isDeprecated() {
		 return deprecated;
	 }
	 public void setDeprecated(boolean deprecated) {
		 this.deprecated = deprecated;
	 }
	 public boolean isEventStream() {
		 return isEventStream;
	 }
	 public void setIsEventStream(boolean eventStream) {
		 isEventStream = eventStream;
	 }
	 public boolean isEvent() {
		 return isEvent;
	 }
	 public void setIsEvent(boolean event) {
		 isEvent = event;
	 }
	 public String getTimestampFormat() {
		 return timestampFormat;
	 }
	 public void setTimestampFormat(String timestampFormat) {
		 this.timestampFormat = timestampFormat;
	 }
	 public boolean isSensitive() {
		 return sensitive;
	 }
	 public void setSensitive(boolean sensitive) {
		 this.sensitive = sensitive;
	 }
}",1,1,0,0
"public ParseText getParseText(Text url) throws IOException {
	 synchronized (this) {
		 if (parseText == null) parseText = getReaders(ParseText.DIR_NAME);
	 }
	 return (ParseText)getEntry(parseText, url, new ParseText());
 }
 public ParseText getParseText(HitDetails details) throws IOException {
	 return getSegment(details).getParseText(getUrl(details));
 }",0,0,0,0
"public class LuceneIndexForPartitionedRegion extends LuceneIndexImpl {
	 protected Region fileAndChunkRegion;
	 protected final FileSystemStats fileSystemStats;
	 public static final String FILES_REGION_SUFFIX = "".files"";
	 private final ExecutorService waitingThreadPoolFromDM;
	 public LuceneIndexForPartitionedRegion(String indexName, String regionPath, InternalCache cache) {
		 super(indexName, regionPath, cache);
		 this.waitingThreadPoolFromDM = cache.getDistributionManager().getWaitingThreadPool();
		 final String statsName = indexName + ""-"" + regionPath;
		 this.fileSystemStats = new FileSystemStats(cache.getDistributedSystem(), statsName);
	 }
	 protected RepositoryManager createRepositoryManager(LuceneSerializer luceneSerializer) {
		 LuceneSerializer mapper = luceneSerializer;
		 if (mapper == null) {
			 mapper = new HeterogeneousLuceneSerializer();
		 }
		 PartitionedRepositoryManager partitionedRepositoryManager = new PartitionedRepositoryManager(this, mapper, this.waitingThreadPoolFromDM);
		 return partitionedRepositoryManager;
	 }
	 public boolean isIndexingInProgress() {
		 PartitionedRegion userRegion = (PartitionedRegion) cache.getRegion(this.getRegionPath());
		 Set<Integer> fileRegionPrimaryBucketIds = this.getFileAndChunkRegion().getDataStore().getAllLocalPrimaryBucketIds();
		 for (Integer bucketId : fileRegionPrimaryBucketIds) {
			 BucketRegion userBucket = userRegion.getDataStore().getLocalBucketById(bucketId);
			 if (!userBucket.isEmpty() && !this.isIndexAvailable(bucketId)) {
				 return true;
			 }
		 }
		 return false;
	 }
	 protected void createLuceneListenersAndFileChunkRegions( PartitionedRepositoryManager partitionedRepositoryManager) {
		 partitionedRepositoryManager.setUserRegionForRepositoryManager((PartitionedRegion) dataRegion);
		 RegionShortcut regionShortCut;
		 final boolean withPersistence = withPersistence();
		 RegionAttributes regionAttributes = dataRegion.getAttributes();
		 final boolean withStorage = regionAttributes.getPartitionAttributes().getLocalMaxMemory() > 0;
		 if (!withStorage) {
			 regionShortCut = RegionShortcut.PARTITION_PROXY;
		 }
		 else if (withPersistence) {
			 regionShortCut = RegionShortcut.PARTITION_PERSISTENT;
		 }
		 else {
			 regionShortCut = RegionShortcut.PARTITION;
		 }
		 final String fileRegionName = createFileRegionName();
		 PartitionAttributes partitionAttributes = dataRegion.getPartitionAttributes();
		 DistributionManager dm = this.cache.getInternalDistributedSystem().getDistributionManager();
		 LuceneBucketListener lucenePrimaryBucketListener = new LuceneBucketListener(partitionedRepositoryManager, dm);
		 if (!fileRegionExists(fileRegionName)) {
			 fileAndChunkRegion = createRegion(fileRegionName, regionShortCut, this.regionPath, partitionAttributes, regionAttributes, lucenePrimaryBucketListener);
		 }
		 fileSystemStats .setBytesSupplier(() -> getFileAndChunkRegion().getPrStats().getDataStoreBytesInUse());
	 }
	 public PartitionedRegion getFileAndChunkRegion() {
		 return (PartitionedRegion) fileAndChunkRegion;
	 }
	 public FileSystemStats getFileSystemStats() {
		 return fileSystemStats;
	 }
	 boolean fileRegionExists(String fileRegionName) {
		 return cache.getRegion(fileRegionName) != null;
	 }
	 public String createFileRegionName() {
		 return LuceneServiceImpl.getUniqueIndexRegionName(indexName, regionPath, FILES_REGION_SUFFIX);
	 }
	 private PartitionAttributesFactory configureLuceneRegionAttributesFactory( PartitionAttributesFactory attributesFactory, PartitionAttributes<?, ?> dataRegionAttributes) {
		 attributesFactory.setTotalNumBuckets(dataRegionAttributes.getTotalNumBuckets());
		 attributesFactory.setRedundantCopies(dataRegionAttributes.getRedundantCopies());
		 attributesFactory.setPartitionResolver(getPartitionResolver(dataRegionAttributes));
		 attributesFactory.setRecoveryDelay(dataRegionAttributes.getRecoveryDelay());
		 attributesFactory.setStartupRecoveryDelay(dataRegionAttributes.getStartupRecoveryDelay());
		 return attributesFactory;
	 }
	 private PartitionResolver getPartitionResolver(PartitionAttributes dataRegionAttributes) {
		 if (dataRegionAttributes.getPartitionResolver() instanceof FixedPartitionResolver) {
			 return new BucketTargetingFixedResolver();
		 }
		 else {
			 return new BucketTargetingResolver();
		 }
	 }
	 protected <K, V> Region<K, V> createRegion(final String regionName, final RegionShortcut regionShortCut, final String colocatedWithRegionName, final PartitionAttributes partitionAttributes, final RegionAttributes regionAttributes, PartitionListener lucenePrimaryBucketListener) {
		 PartitionAttributesFactory partitionAttributesFactory = new PartitionAttributesFactory();
		 if (lucenePrimaryBucketListener != null) {
			 partitionAttributesFactory.addPartitionListener(lucenePrimaryBucketListener);
		 }
		 partitionAttributesFactory.setColocatedWith(colocatedWithRegionName);
		 configureLuceneRegionAttributesFactory(partitionAttributesFactory, partitionAttributes);
		 RegionAttributes baseAttributes = this.cache.getRegionAttributes(regionShortCut.toString());
		 AttributesFactory factory = new AttributesFactory(baseAttributes);
		 factory.setPartitionAttributes(partitionAttributesFactory.create());
		 if (regionAttributes.getDataPolicy().withPersistence()) {
			 factory.setDiskStoreName(regionAttributes.getDiskStoreName());
		 }
		 RegionAttributes<K, V> attributes = factory.create();
		 return createRegion(regionName, attributes);
	 }
	 public void close() {
	}
	 public void dumpFiles(final String directory) {
		 ResultCollector results = FunctionService.onRegion(getDataRegion()) .setArguments(new String[] {
		directory, indexName}
		).execute(DumpDirectoryFiles.ID);
		 results.getResult();
	 }
	 public void destroy(boolean initiator) {
		 if (logger.isDebugEnabled()) {
			 logger.debug(""Destroying index regionPath="" + regionPath + "";
			 indexName="" + indexName + "";
			 initiator="" + initiator);
		 }
		 super.destroy(initiator);
		 if (initiator) {
			 destroyOnRemoteMembers();
		 }
		 if (initiator) {
			 try {
				 fileAndChunkRegion.destroyRegion();
				 if (logger.isDebugEnabled()) {
					 logger.debug(""Destroyed fileAndChunkRegion="" + fileAndChunkRegion.getName());
				 }
			 }
			 catch (RegionDestroyedException e) {
				 if (logger.isDebugEnabled()) {
					 logger.debug(""Already destroyed fileAndChunkRegion="" + fileAndChunkRegion.getName());
				 }
			 }
		 }
		 if (logger.isDebugEnabled()) {
			 logger.debug(""Destroyed index regionPath="" + regionPath + "";
			 indexName="" + indexName + "";
			 initiator="" + initiator);
		 }
	 }
	 public boolean isIndexAvailable(int id) {
		 PartitionedRegion fileAndChunkRegion = getFileAndChunkRegion();
		 return (fileAndChunkRegion.get(IndexRepositoryFactory.APACHE_GEODE_INDEX_COMPLETE, id) != null || !LuceneServiceImpl.LUCENE_REINDEX);
	 }
	 private void destroyOnRemoteMembers() {
		 DistributionManager dm = getDataRegion().getDistributionManager();
		 Set<InternalDistributedMember> recipients = dm.getOtherNormalDistributionManagerIds();
		 if (!recipients.isEmpty()) {
			 if (logger.isDebugEnabled()) {
				 logger.debug(""LuceneIndexForPartitionedRegion: About to send destroy message recipients="" + recipients);
			 }
			 ReplyProcessor21 processor = new ReplyProcessor21(dm, recipients);
			 DestroyLuceneIndexMessage message = new DestroyLuceneIndexMessage(recipients, processor.getProcessorId(), regionPath, indexName);
			 dm.putOutgoing(message);
			 if (logger.isDebugEnabled()) {
				 logger.debug(""LuceneIndexForPartitionedRegion: Sent message recipients="" + recipients);
			 }
			 try {
				 processor.waitForReplies();
			 }
			 catch (ReplyException e) {
				 Throwable cause = e.getCause();
				 if (cause instanceof IllegalArgumentException) {
					 String fullRegionPath = regionPath.startsWith(Region.SEPARATOR) ? regionPath : Region.SEPARATOR + regionPath;
					 String indexNotFoundMessage = String.format(""Lucene index %s was not found in region %s"", indexName, fullRegionPath);
					 if (!cause.getLocalizedMessage().equals(indexNotFoundMessage)) {
						 throw e;
					 }
				 }
				 else if (!(cause instanceof CancelException)) {
					 throw e;
				 }
			 }
			 catch (InterruptedException e) {
				 dm.getCancelCriterion().checkCancelInProgress(e);
				 Thread.currentThread().interrupt();
			 }
		 }
	 }
}",1,1,0,0
"public class CliCompiler{
	 public static class ANTLRNoCaseStringStream extends ANTLRStringStream {
		 public ANTLRNoCaseStringStream(String input) {
			 super(input);
		 }
		 public int LA(int i) {
			 int returnChar = super.LA(i);
			 if (returnChar == CharStream.EOF) {
				 return returnChar;
			 }
			 else if (returnChar == 0) {
				 return returnChar;
			 }
			 return Character.toUpperCase((char)returnChar);
		 }
	 }
	 public static Tree compileQuery(String query) {
		 Tree queryTree;
		 try {
			 ANTLRStringStream input = new ANTLRNoCaseStringStream(query);
			 CliLexer lexer = new CliLexer(input);
			 CommonTokenStream tokens = new CommonTokenStream(lexer);
			 CliParser parser = new CliParser(tokens);
			 queryTree = (Tree)(parser.root().getTree());
		 }
		 catch(Exception e) {
			 throw new RuntimeException(e.getMessage(), e);
		 }
		 return queryTree;
	 }
	 public static String getColumnFamily(Tree astNode, List<CfDef> cfDefs) {
		 return getColumnFamily(CliUtils.unescapeSQLString(astNode.getChild(0).getText()), cfDefs);
	 }
	 public static String getColumnFamily(String cfName, List<CfDef> cfDefs) {
		 int matches = 0;
		 String lastMatchedName = """";
		 for (CfDef cfDef : cfDefs) {
			 if (cfDef.name.equals(cfName)) {
				 return cfName;
			 }
			 else if (cfDef.name.toUpperCase().equals(cfName.toUpperCase())) {
				 lastMatchedName = cfDef.name;
				 matches++;
			 }
		 }
		 if (matches > 1 || matches == 0) throw new RuntimeException(cfName + "" not found in current keyspace."");
		 return lastMatchedName;
	 }
	 public static String getKeySpace(Tree statement, List<KsDef> keyspaces) {
		 return getKeySpace(CliUtils.unescapeSQLString(statement.getChild(0).getText()), keyspaces);
	 }
	 public static String getKeySpace(String ksName, List<KsDef> keyspaces) {
		 int matches = 0;
		 String lastMatchedName = """";
		 for (KsDef ksDef : keyspaces) {
			 if (ksDef.name.equals(ksName)) {
				 return ksName;
			 }
			 else if (ksDef.name.toUpperCase().equals(ksName.toUpperCase())) {
				 lastMatchedName = ksDef.name;
				 matches++;
			 }
		 }
		 if (matches > 1 || matches == 0) throw new RuntimeException(""Keyspace '"" + ksName + ""' not found."");
		 return lastMatchedName;
	 }
	 public static String getKey(Tree astNode) {
		 return CliUtils.unescapeSQLString(astNode.getChild(1).getText());
	 }
	 public static int numColumnSpecifiers(Tree astNode) {
		 return astNode.getChildCount() - 2;
	 }
	 public static String getColumn(Tree astNode, int pos) {
		 return CliUtils.unescapeSQLString(astNode.getChild(pos + 2).getText());
	 }
}",0,0,0,0
"public ParserRule getRule() {
	 return rule;
 }",0,0,0,0
"public String getExtraOptions() {
	 return this.extraOptions;
 }",0,0,0,0
"public class ResourceServerConfiguration extends WebSecurityConfigurerAdapter implements Ordered {
	private int order = 3;
	private TokenStore tokenStore;
	private AuthenticationEventPublisher eventPublisher;
	private Map<String, ResourceServerTokenServices> tokenServices;
	private ApplicationContext context;
	private List<ResourceServerConfigurer> configurers = Collections.emptyList();
	private AuthorizationServerEndpointsConfiguration endpoints;
	public int getOrder() {
		return order;
	}
	public void setOrder(int order) {
		this.order = order;
	}
	public void setConfigurers(List<ResourceServerConfigurer> configurers) {
		this.configurers = configurers;
	}
	private static class NotOAuthRequestMatcher implements RequestMatcher {
		private FrameworkEndpointHandlerMapping mapping;
		public NotOAuthRequestMatcher(FrameworkEndpointHandlerMapping mapping) {
			this.mapping = mapping;
		}
		public boolean matches(HttpServletRequest request) {
			String requestPath = getRequestPath(request);
			for (String path : mapping.getPaths()) {
				if (requestPath.startsWith(mapping.getPath(path))) {
					return false;
				}
			}
			return true;
		}
		private String getRequestPath(HttpServletRequest request) {
			String url = request.getServletPath();
			if (request.getPathInfo() != null) {
				url += request.getPathInfo();
			}
			return url;
		}
	}
	protected void configure(HttpSecurity http) throws Exception {
		ResourceServerSecurityConfigurer resources = new ResourceServerSecurityConfigurer();
		ResourceServerTokenServices services = resolveTokenServices();
		if (services != null) {
			resources.tokenServices(services);
		}
		else {
			if (tokenStore != null) {
				resources.tokenStore(tokenStore);
			}
			else if (endpoints != null) {
				resources.tokenStore(endpoints.getEndpointsConfigurer().getTokenStore());
			}
		}
		if (eventPublisher != null) {
			resources.eventPublisher(eventPublisher);
		}
		for (ResourceServerConfigurer configurer : configurers) {
			configurer.configure(resources);
		}
		http.authenticationProvider(new AnonymousAuthenticationProvider(""default"")).exceptionHandling().accessDeniedHandler(resources.getAccessDeniedHandler()).and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and().csrf().disable();
		http.apply(resources);
		if (endpoints != null) {
			http.requestMatcher(new NotOAuthRequestMatcher(endpoints.oauth2EndpointHandlerMapping()));
		}
		for (ResourceServerConfigurer configurer : configurers) {
			configurer.configure(http);
		}
		if (configurers.isEmpty()) {
			http.authorizeRequests().anyRequest().authenticated();
		}
	}
	private ResourceServerTokenServices resolveTokenServices() {
		if (tokenServices == null || tokenServices.size() == 0) {
			return null;
		}
		if (tokenServices.size() == 1) {
			return tokenServices.values().iterator().next();
		}
		if (tokenServices.size() == 2) {
			Iterator<ResourceServerTokenServices> iter = tokenServices.values().iterator();
			ResourceServerTokenServices one = iter.next();
			ResourceServerTokenServices two = iter.next();
			if (elementsEqual(one, two)) {
				return one;
			}
		}
		return context.getBean(ResourceServerTokenServices.class);
	}
	private boolean elementsEqual(Object one, Object two) {
		if (one == two) {
			return true;
		}
		Object targetOne = findTarget(one);
		Object targetTwo = findTarget(two);
		return targetOne == targetTwo;
	}
	private Object findTarget(Object item) {
		Object current = item;
		while (current instanceof Advised) {
			try {
				current = ((Advised) current).getTargetSource().getTarget();
			}
			catch (Exception e) {
				ReflectionUtils.rethrowRuntimeException(e);
			}
		}
		return current;
	}
}",0,0,0,0
"protected void executeScript(String execName) {
	 getRunner().executeScript(execName);
 }",0,0,0,0
"public abstract class FilterOperator extends BaseOperator{
	 public final transient DefaultInputPort<Object> in = new DefaultInputPort<Object>() {
		 public void process(Object tuple) {
			 if (satisfiesFilter(tuple)) {
				 out.emit(tuple);
			 }
		 }
	 }
	;
	 public final transient DefaultOutputPort<Object> out = new DefaultOutputPort<Object>();
	 public abstract boolean satisfiesFilter(Object tuple);
}",0,0,0,0
"public class LeadPipeInputStream extends PipedInputStream {
	 private static final int BYTE_MASK = 0xFF;
	 private ProjectComponent managingPc;
	 public LeadPipeInputStream() {
		 super();
	 }
	 public LeadPipeInputStream(int size) {
		 super();
		 setBufferSize(size);
	 }
	 public LeadPipeInputStream(PipedOutputStream src) throws IOException {
		 super(src);
	 }
	 public LeadPipeInputStream(PipedOutputStream src, int size) throws IOException {
		 super(src);
		 setBufferSize(size);
	 }
	 public synchronized int read() throws IOException {
		 int result = -1;
		 try {
			 result = super.read();
		 }
		 catch (IOException eyeOhEx) {
			 String msg = eyeOhEx.getMessage();
			 if (""write end dead"".equalsIgnoreCase(msg) || ""pipe broken"".equalsIgnoreCase(msg)) {
				 if (super.in > 0 && super.out < super.buffer.length && super.out > super.in) {
					 result = super.buffer[super.out++] & BYTE_MASK;
				 }
			 }
			 else {
				 log(""error at LeadPipeInputStream.read(): "" + msg, Project.MSG_INFO);
			 }
		 }
		 return result;
	 }
	 public synchronized void setBufferSize(int size) {
		 if (size > buffer.length) {
			 byte[] newBuffer = new byte[size];
			 if (in >= 0) {
				 if (in > out) {
					 System.arraycopy(buffer, out, newBuffer, out, in - out);
				 }
				 else {
					 int outlen = buffer.length - out;
					 System.arraycopy(buffer, out, newBuffer, 0, outlen);
					 System.arraycopy(buffer, 0, newBuffer, outlen, in);
					 in += outlen;
					 out = 0;
				 }
			 }
			 buffer = newBuffer;
		 }
	 }
	 public void setManagingTask(Task task) {
		 setManagingComponent(task);
	 }
	 public void setManagingComponent(ProjectComponent pc) {
		 this.managingPc = pc;
	 }
	 public void log(String message, int loglevel) {
		 if (managingPc != null) {
			 managingPc.log(message, loglevel);
		 }
		 else {
			 if (loglevel > Project.MSG_WARN) {
				 System.out.println(message);
			 }
			 else {
				 System.err.println(message);
			 }
		 }
	 }
}",0,0,0,0
"static short encode(int major, int minor, int micro);",0,0,0,1
"public String sendMessage(final Map<String, String> headers, final int type, final String body, boolean durable, final String user, final String password) throws Exception {
	 if (AuditLogger.isEnabled()) {
		 AuditLogger.sendMessage(this, null, headers, type, body, durable, user, ""****"");
	 }
	 try {
		 return sendMessage(addressInfo.getName(), server, headers, type, body, durable, user, password);
	 }
	 catch (Exception e) {
		 e.printStackTrace();
		 throw new IllegalStateException(e.getMessage());
	 }
 }",0,0,1,0
"public static boolean isStoringContent(Configuration conf) {
	 return conf.getBoolean(""fetcher.store.content"", true);
 }",0,0,0,0
"class ResourceMethodConfigImpl implements ResourceMethodConfig{
	 private final ConfigValue<Long> _timeoutMs;
	 ResourceMethodConfigImpl(ConfigValue<Long> timeoutMs) {
		 _timeoutMs = timeoutMs;
	 }
	 public ConfigValue<Long> getTimeoutMs() {
		 return _timeoutMs;
	 }
	 public String toString() {
		 return ""ResourceMethodConfigImpl{
		"" + ""_timeoutMs="" + _timeoutMs + '}
		';
	 }
	 public boolean equals(Object o) {
		 if (this == o) return true;
		 if (o == null || getClass() != o.getClass()) return false;
		 ResourceMethodConfigImpl that = (ResourceMethodConfigImpl) o;
		 return Objects.equals(_timeoutMs, that._timeoutMs);
	 }
	 public int hashCode() {
		 return Objects.hash(_timeoutMs);
	 }
}",0,1,0,0
"private void parseDoc(Document doc, String surl) throws XPathExpressionException {
	if (xpath == null) {
		initXPath();
	}
	baseUrl = xpath.evaluate(""/ns:manifest/ns:baseURL"", doc);
	if (StringUtils.isNullOrEmptyOrBlank(baseUrl)) {
		try {
			URL url = new URL(surl);
			StringBuilder sb = new StringBuilder();
			sb.append(url.getProtocol());
			sb.append("":sb.append(url.getHost());
			int port = url.getPort();
			if (port < 1) {
				port = url.getDefaultPort();
			}
			sb.append(port == 80 ? """" : port);
			String path = url.getPath();
			String[] arr = path.split(""/"");
			for (int i = 0;
			 i < arr.length - 1;
			 i++) {
				if (arr[i].length() > 0) {
					sb.append(""/"" + arr[i]);
				}
			}
			baseUrl = sb.toString();
			System.out.println(""*** URL: "" + baseUrl);
		}
		 catch (Exception e) {
		}
	}
	pv = xpath.evaluate(""/ns:manifest/ns:pv-2.0"", doc);
	NodeList mediaNodeList = (NodeList) xpath.evaluate(""/ns:manifest/ns:media"", doc, XPathConstants.NODESET);
	F4MMedia media = null;
	for (int i = 0;
	 i < mediaNodeList.getLength();
	 i++) {
		Node mediaNode = mediaNodeList.item(i);
		NamedNodeMap attrMap = mediaNode.getAttributes();
		Node bitRateAttr = attrMap.getNamedItem(""bitrate"");
		long bitRate = 0;
		if (bitRateAttr != null) {
			bitRate = Long.parseLong(bitRateAttr.getNodeValue());
		}
		boolean mediaFound = false;
		if (this.selectedBitRate > 0) {
			if (this.selectedBitRate == bitRate) {
				mediaFound = true;
			}
		}
		 else {
			mediaFound = true;
		}
		if (mediaFound) {
			media = new F4MMedia();
			media.setBaseUrl(baseUrl);
			media.setBitRate(bitRate);
			media.setUrl(attrMap.getNamedItem(""url"").getNodeValue());
			Node bootstrapInfoIdNode = attrMap.getNamedItem(""bootstrapInfoId"");
			String bootstrapInfoStr = null;
			if (bootstrapInfoIdNode != null) {
				String bootstrapInfoId = bootstrapInfoIdNode.getNodeValue();
				bootstrapInfoStr = xpath.evaluate(""/ns:manifest/ns:bootstrapInfo[='"" + bootstrapInfoId + ""']"",doc);
			}
			 else {
				bootstrapInfoStr = xpath.evaluate(""/ns:manifest/ns:bootstrapInfo"", doc);
			}
			media.setBootstrap(Base64.decode(bootstrapInfoStr));
			break;
		}
	}
	if (media == null) {
		Logger.log(""Could not find media"");
		return;
	}
	int pos = 0;
	BufferPointer ptr = new BufferPointer();
	ptr.setBuf(media.getBootstrap());
	ptr.setPos(pos);
	BoxInfo boxInfo = readBoxHeader(ptr);
	pos = ptr.getPos();
	long boxSize = boxInfo.getBoxSize();
	String boxType = boxInfo.getBoxType();
	if (boxType.equals(""abst""))parseBootstrapBox(media.bootstrap, pos);
	if (fragsPerSeg == 0)fragsPerSeg = fragCount;
	if (live) {
		fromTimestamp = -1;
		Logger.log(""F4M Parser: [Live stream]"");
	}
	 else {
		Logger.log(""F4M Parser: [Not Live stream]"");
	}
	Logger.log(""F4M Parser: Start- "" + start);
	selectedMedia = media;
}",0,0,1,0
"public class HelperEvalFuncUtils {
	 public static class AlgCOUNT extends AlgFunc<Long> {
		 public AlgCOUNT() {
			 super(new COUNT());
		 }
	 }
	 public static class AccCOUNT extends AccFunc<Long> {
		 public AccCOUNT() {
			 super(new COUNT());
		 }
	 }
	 public static class BasicCOUNT extends BasicFunc<Long> {
		 public BasicCOUNT() {
			 super(new COUNT());
		 }
	 }
	 public static class AlgSUM extends AlgFunc<Long> {
		 public AlgSUM() {
			 super(new LongSum());
		 }
	 }
	 public static class AccSUM extends AccFunc<Long> {
		 public AccSUM() {
			 super(new LongSum());
		 }
	 }
	 public static class BasicSUM extends BasicFunc<Long> {
		 public BasicSUM() {
			 super(new LongSum());
		 }
	 }
	 public static class AlgFunc<T> extends AlgebraicEvalFunc<T> {
		 Algebraic f;
		 public AlgFunc(Algebraic f) {
			 this.f=f;
		 }
		 public String getInitial() {
			 if (f==null) {
				 return LongSum.Initial.class.getName();
			 }
			 return f.getInitial();
		 }
		 public String getIntermed() {
			 if (f==null) {
				 return LongSum.Intermediate.class.getName();
			 }
			 return f.getIntermed();
		 }
		 public String getFinal() {
			 if (f==null) {
				 return LongSum.Final.class.getName();
			 }
			 return f.getFinal();
		 }
	 }
	 public static class AccFunc<T> extends AccumulatorEvalFunc<T> {
		 Accumulator<T> f;
		 public AccFunc(Accumulator<T> f) {
			 this.f=f;
		 }
		 public T getValue() {
			 return f.getValue();
		 }
		 public void accumulate(Tuple input) throws IOException {
			 f.accumulate(input);
		 }
		 public void cleanup() {
			 f.cleanup();
		 }
	 }
	 public static class BasicFunc<T> extends EvalFunc<T> {
		 EvalFunc<T> f;
		 public BasicFunc(EvalFunc<T> f) {
			 this.f=f;
		 }
		 public T exec(Tuple input) throws IOException {
			 return f.exec(input);
		 }
	 }
	 public static class AccLongCountWithConstructor extends AccFunc<Long> {
		 public AccLongCountWithConstructor(String mult) {
			 super(new AlgLongCountWithConstructor(mult));
		 }
	 }
	 public static class BasicLongCountWithConstructor extends BasicFunc<Long> {
		 public BasicLongCountWithConstructor(String mult) {
			 super(new AlgLongCountWithConstructor(mult));
		 }
	 }
	 public static class AlgLongCountWithConstructor extends AlgebraicEvalFunc<Long> {
		 public AlgLongCountWithConstructor(String mult) {
			 super(mult);
		 }
		 public static class Initial extends COUNT.Initial {
			 long mult=1;
			 public Initial() {
			}
			 public Initial(String mult) {
				 this.mult = Long.parseLong(mult);
			 }
			 public Tuple exec(Tuple input) throws IOException {
				 Tuple t = super.exec(input);
				 t.set(0,((Long)t.get(0))*mult);
				 return t;
			 }
		 }
		 public static class Intermed extends COUNT.Intermediate {
			 public Intermed() {
			}
			 public Intermed(String mult) {
			}
		 }
		 public static class Final extends COUNT.Final {
			 public Final() {
			}
			 public Final(String mult) {
			}
		 }
		 public String getInitial() {
			 return Initial.class.getName();
		 }
		 public String getIntermed() {
			 return Intermed.class.getName();
		 }
		 public String getFinal() {
			 return Final.class.getName();
		 }
	 }
}",1,0,0,0
"public class NumUtil {
	 public static boolean isShiftCount(int x) {
		 return 0 <= x && x < 32;
	 }
	 public static boolean isUByte(int x) {
		 return (x & 0xff) == x;
	 }
	 public static boolean isByte(int x) {
		 return (byte) x == x;
	 }
	 public static boolean isUByte(long x) {
		 return (x & 0xffL) == x;
	 }
	 public static boolean isByte(long l) {
		 return (byte) l == l;
	 }
	 public static boolean isUInt(long x) {
		 return (x & 0xffffffffL) == x;
	 }
	 public static boolean isInt(long l) {
		 return (int) l == l;
	 }
	 public static boolean isShort(int x) {
		 return (short) x == x;
	 }
	 public static boolean isShort(long x) {
		 return (short) x == x;
	 }
	 public static boolean isUShort(int s) {
		 return s == (s & 0xFFFF);
	 }
	 public static boolean isUShort(long s) {
		 return s == (s & 0xFFFF);
	 }
	 public static boolean is32bit(long x) {
		 return -0x80000000L <= x && x < 0x80000000L;
	 }
	 public static short safeToShort(int v) {
		 assert isShort(v);
		 return (short) v;
	 }
	 public static int safeToInt(long v) {
		 assert isInt(v);
		 return (int) v;
	 }
	 public static int roundUp(int number, int mod) {
		 return ((number + mod - 1) / mod) * mod;
	 }
	 public static long roundUp(long number, long mod) {
		 return ((number + mod - 1L) / mod) * mod;
	 }
	 public static int roundDown(int number, int mod) {
		 return number / mod * mod;
	 }
	 public static long roundDown(long number, long mod) {
		 return number / mod * mod;
	 }
	 public static int log2Ceil(int val) {
		 int x = 1;
		 int log2 = 0;
		 while (x < val) {
			 log2++;
			 x *= 2;
		 }
		 return log2;
	 }
	 public static boolean isUnsignedNbit(int n, int value) {
		 assert n > 0 && n < 32;
		 return 32 - Integer.numberOfLeadingZeros(value) <= n;
	 }
	 public static boolean isUnsignedNbit(int n, long value) {
		 assert n > 0 && n < 64;
		 return 64 - Long.numberOfLeadingZeros(value) <= n;
	 }
	 public static boolean isSignedNbit(int n, int value) {
		 assert n > 0 && n < 32;
		 int min = -(1 << (n - 1));
		 int max = (1 << (n - 1)) - 1;
		 return value >= min && value <= max;
	 }
	 public static boolean isSignedNbit(int n, long value) {
		 assert n > 0 && n < 64;
		 long min = -(1L << (n - 1));
		 long max = (1L << (n - 1)) - 1;
		 return value >= min && value <= max;
	 }
	 public static int getNbitNumberInt(int n) {
		 assert n >= 0 && n <= 32 : ""0 <= n <= 32;
		 instead: "" + n;
		 if (n < 32) {
			 return (1 << n) - 1;
		 }
		 else {
			 return 0xFFFFFFFF;
		 }
	 }
	 public static long getNbitNumberLong(int n) {
		 assert n >= 0 && n <= 64;
		 if (n < 64) {
			 return (1L << n) - 1;
		 }
		 else {
			 return 0xFFFFFFFFFFFFFFFFL;
		 }
	 }
	 public static long minValue(int bits) {
		 return CodeUtil.minValue(bits);
	 }
	 public static long maxValue(int bits) {
		 return CodeUtil.maxValue(bits);
	 }
	 public static long maxValueUnsigned(int bits) {
		 return getNbitNumberLong(bits);
	 }
	 public static long maxUnsigned(long a, long b) {
		 if (Long.compareUnsigned(a, b) < 0) {
			 return b;
		 }
		 return a;
	 }
	 public static long minUnsigned(long a, long b) {
		 if (Long.compareUnsigned(a, b) < 0) {
			 return a;
		 }
		 return b;
	 }
	 public static boolean sameSign(long a, long b) {
		 return a < 0 == b < 0;
	 }
}",0,0,0,0
"public void genCppCode(FileWriter hh, FileWriter cc) throws IOException {
	 String[] ns = getCppNameSpace().split(""::"");
	 for (int i = 0;
	 i < ns.length;
	 i++) {
		 hh.write(""namespace ""+ns[i]+"" {
			\n"");
		 }
		 hh.write(""class ""+getName()+"" : public ::hadoop::Record {
			\n"");
			 hh.write(""private:\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			) {
				 JField jf = (JField) i.next();
				 hh.write(jf.genCppDecl());
			 }
			 hh.write("" std::bitset<""+mFields.size()+""> bs_;
			\n"");
			 hh.write(""public:\n"");
			 hh.write("" virtual void serialize(::hadoop::OArchive& a_, const char* tag);
			\n"");
			 hh.write("" virtual void deserialize(::hadoop::IArchive& a_, const char* tag);
			\n"");
			 hh.write("" virtual const ::std::string& type() const;
			\n"");
			 hh.write("" virtual const ::std::string& signature() const;
			\n"");
			 hh.write("" virtual bool validate() const;
			\n"");
			 hh.write("" virtual bool operator<(const ""+getName()+""& peer_);
			\n"");
			 hh.write("" virtual bool operator==(const ""+getName()+""& peer_);
			\n"");
			 hh.write("" virtual ~""+getName()+""() {
			}
			;
			\n"");
			 int fIdx = 0;
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 hh.write(jf.genCppGetSet(fIdx));
			 }
		 hh.write(""}
		;
		 for (int i=0;
		 i<ns.length;
		 i++) {
		 hh.write(""}
	 }
	 cc.write(""void ""+getCppFQName()+""::serialize(::hadoop::OArchive& a_, const char* tag) {
		\n"");
		 cc.write("" if (!validate()) throw new ::hadoop::IOException(\""All fields not set.\"");
		\n"");
		 cc.write("" a_.startRecord(*this,tag);
		\n"");
		 fIdx = 0;
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 String name = jf.getName();
			 if (jf.getType() instanceof JBuffer) {
				 cc.write("" a_.serialize(""+name+"",""+name+"".length(),\""""+jf.getTag()+""\"");
				\n"");
			 }
			 else {
				 cc.write("" a_.serialize(""+name+"",\""""+jf.getTag()+""\"");
				\n"");
			 }
			 cc.write("" bs_.reset(""+fIdx+"");
			\n"");
		 }
		 cc.write("" a_.endRecord(*this,tag);
		\n"");
		 cc.write("" return;
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""void ""+getCppFQName()+""::deserialize(::hadoop::IArchive& a_, const char* tag) {
		\n"");
		 cc.write("" a_.startRecord(*this,tag);
		\n"");
		 fIdx = 0;
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 String name = jf.getName();
			 if (jf.getType() instanceof JBuffer) {
				 cc.write("" {
					 size_t len=0;
					 a_.deserialize(""+name+"",len,\""""+jf.getTag()+""\"");
				}
				\n"");
			 }
			 else {
				 cc.write("" a_.deserialize(""+name+"",\""""+jf.getTag()+""\"");
				\n"");
			 }
			 cc.write("" bs_.set(""+fIdx+"");
			\n"");
		 }
		 cc.write("" a_.endRecord(*this,tag);
		\n"");
		 cc.write("" return;
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""bool ""+getCppFQName()+""::validate() const {
		\n"");
		 cc.write("" if (bs_.size() != bs_.count()) return false;
		\n"");
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 JType type = jf.getType();
			 if (type instanceof JRecord) {
				 cc.write("" if (!""+jf.getName()+"".validate()) return false;
				\n"");
			 }
		 }
		 cc.write("" return true;
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""bool ""+getCppFQName()+""::operator< (const ""+getCppFQName()+""& peer_) {
		\n"");
		 cc.write("" return (1\n"");
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		) {
			 JField jf = (JField) i.next();
			 String name = jf.getName();
			 cc.write("" && (""+name+"" < peer_.""+name+"")\n"");
		 }
		 cc.write("" );
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""bool ""+getCppFQName()+""::operator== (const ""+getCppFQName()+""& peer_) {
		\n"");
		 cc.write("" return (1\n"");
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		) {
			 JField jf = (JField) i.next();
			 String name = jf.getName();
			 cc.write("" && (""+name+"" == peer_.""+name+"")\n"");
		 }
		 cc.write("" );
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""const ::std::string&""+getCppFQName()+""::type() const {
		\n"");
		 cc.write("" static const ::std::string type_(\""""+mName+""\"");
		\n"");
		 cc.write("" return type_;
		\n"");
	 cc.write(""}
	\n"");
	 cc.write(""const ::std::string&""+getCppFQName()+""::signature() const {
		\n"");
		 cc.write("" static const ::std::string sig_(\""""+getSignature()+""\"");
		\n"");
		 cc.write("" return sig_;
		\n"");
	 cc.write(""}
	\n"");
 }",0,0,1,0
"public class UnicodeCommentExtraField extends AbstractUnicodeExtraField {
	 public static final ZipShort UCOM_ID = new ZipShort(0x6375);
	 public UnicodeCommentExtraField () {
	 }
	 public UnicodeCommentExtraField(String text, byte[] bytes, int off, int len) {
		 super(text, bytes, off, len);
	 }
	 public UnicodeCommentExtraField(String comment, byte[] bytes) {
		 super(comment, bytes);
	 }
	 public ZipShort getHeaderId() {
		 return UCOM_ID;
	 }
}",0,0,0,0
"public class SphericalLens implements CameraLens {
	 public boolean update(ParameterList pl, SunflowAPI api) {
		 return true;
	 }
	 public Ray getRay(float x, float y, int imageWidth, int imageHeight, double lensX, double lensY, double time) {
		 double theta = 2 * Math.PI * x / imageWidth + Math.PI / 2;
		 double phi = Math.PI * (imageHeight - 1 - y) / imageHeight;
		 return new Ray(0, 0, 0, (float) (Math.cos(theta) * Math.sin(phi)), (float) (Math.cos(phi)), (float) (Math.sin(theta) * Math.sin(phi)));
	 }
}",0,0,0,0
"protected SQLBuffer toBulkOperation(ClassMapping mapping, Select sel, JDBCStore store, Object[] params, Map updateParams) {
	 SQLBuffer sql = new SQLBuffer(this);
	 if (updateParams == null) {
		 if (requiresTargetForDelete) {
			 sql.append(""DELETE "");
			 SQLBuffer deleteTargets = getDeleteTargets(sel);
			 sql.append(deleteTargets);
			 sql.append("" FROM "");
		 }
		 else {
			 sql.append(""DELETE FROM "");
		 }
	 }
	 else sql.append(""UPDATE "");
	 sel.addJoinClassConditions();
	 Collection<String> selectedTables = getSelectTableAliases(sel);
	 if (selectedTables.size() == 1 && supportsSubselect && allowsAliasInBulkClause) {
		 SQLBuffer from;
		 if (sel.getFromSelect() != null) from = getFromSelect(sel, false);
		 else from = getFrom(sel, false);
		 sql.append(from);
		 appendUpdates(sel, store, sql, params, updateParams, allowsAliasInBulkClause);
		 SQLBuffer where = sel.getWhere();
		 if (where != null && !where.isEmpty()) {
			 sql.append("" WHERE "");
			 sql.append(where);
		 }
		 return sql;
	 }
	 Table table = mapping.getTable();
	 String tableName = getFullName(table, false);
	 if (sel.getWhere() == null || sel.getWhere().isEmpty()) {
		 sql.append(tableName);
		 appendUpdates(sel, store, sql, params, updateParams, false);
		 return sql;
	 }
	 if (!supportsSubselect || !supportsCorrelatedSubselect) return null;
	 Column[] pks = mapping.getPrimaryKeyColumns();
	 sel.clearSelects();
	 sel.setDistinct(true);
	 if (pks.length == 1) {
		 sel.select(pks[0]);
		 sql.append(tableName);
		 appendUpdates(sel, store, sql, params, updateParams, false);
		 sql.append("" WHERE ""). append(pks[0]).append("" IN (""). append(sel.toSelect(false, null)).append("")"");
	 }
	 else {
		 sel.clearSelects();
		 sel.setDistinct(false);
		 sel.select(""1"", null);
		 Column[] cols = table.getPrimaryKey().getColumns();
		 SQLBuffer buf = new SQLBuffer(this);
		 buf.append(""("");
		 for (int i = 0;
		 i < cols.length;
		 i++) {
			 if (i > 0) buf.append("" AND "");
			 buf.append(sel.getColumnAlias(cols[i])).append("" = ""). append(table).append(catalogSeparator).append(cols[i]);
		 }
		 buf.append("")"");
		 sel.where(buf, null);
		 sql.append(tableName);
		 appendUpdates(sel, store, sql, params, updateParams, false);
		 sql.append("" WHERE EXISTS (""). append(sel.toSelect(false, null)).append("")"");
	 }
	 return sql;
 }",0,0,1,0
"public class StandardComponentInitializer {
	 public static final String NAVIGATE_TO_FILE = ""navigateToFile"";
	 public static final String FULL_TEXT_SEARCH = ""fullTextSearch"";
	 public static final String PREVIEW_IMAGE = ""previewImage"";
	 public static final String FIND_ACTION = ""findAction"";
	 public static final String FORMAT = ""format"";
	 public static final String SAVE = ""save"";
	 public static final String COPY = ""copy"";
	 public static final String CUT = ""cut"";
	 public static final String PASTE = ""paste"";
	 public static final String UNDO = ""undo"";
	 public static final String REDO = ""redo"";
	 public static final String SWITCH_LEFT_TAB = ""switchLeftTab"";
	 public static final String SWITCH_RIGHT_TAB = ""switchRightTab"";
	 public static final String OPEN_RECENT_FILES = ""openRecentFiles"";
	 public static final String DELETE_ITEM = ""deleteItem"";
	 public static final String NEW_FILE = ""newFile"";
	 public static final String CREATE_PROJECT = ""createProject"";
	 public static final String IMPORT_PROJECT = ""importProject"";
	 public static final String CLOSE_ACTIVE_EDITOR = ""closeActiveEditor"";
	 public static final String SIGNATURE_HELP = ""signatureHelp"";
	 public static final String SOFT_WRAP = ""softWrap"";
	 public static final String RENAME = ""renameResource"";
	 public static final String SHOW_REFERENCE = ""showReference"";
	 public static final String SHOW_COMMANDS_PALETTE = ""showCommandsPalette"";
	 public static final String NEW_TERMINAL = ""newTerminal"";
	 public static final String OPEN_IN_TERMINAL = ""openInTerminal"";
	 public static final String PROJECT_EXPLORER_DISPLAYING_MODE = ""projectExplorerDisplayingMode"";
	 public static final String COMMAND_EXPLORER_DISPLAYING_MODE = ""commandExplorerDisplayingMode"";
	 public static final String FIND_RESULT_DISPLAYING_MODE = ""findResultDisplayingMode"";
	 public static final String EVENT_LOGS_DISPLAYING_MODE = ""eventLogsDisplayingMode"";
	 public static final String EDITOR_DISPLAYING_MODE = ""editorDisplayingMode"";
	 public static final String TERMINAL_DISPLAYING_MODE = ""terminalDisplayingMode"";
	 public static final String REVEAL_RESOURCE = ""revealResourceInProjectTree"";
	 public static final String COLLAPSE_ALL = ""collapseAll"";
	 public interface ParserResource extends ClientBundle {
		 SVGResource samplesCategoryBlank();
	 }
	 private EditorRegistry editorRegistry;
	 private FileTypeRegistry fileTypeRegistry;
	 private Resources resources;
	 private KeyBindingAgent keyBinding;
	 private ActionManager actionManager;
	 private SaveAction saveAction;
	 private SaveAllAction saveAllAction;
	 private ShowPreferencesAction showPreferencesAction;
	 private PreviewImageAction previewImageAction;
	 private FindActionAction findActionAction;
	 private NavigateToFileAction navigateToFileAction;
	 private ToolbarPresenter toolbarPresenter;
	 private CutResourceAction cutResourceAction;
	 private CopyResourceAction copyResourceAction;
	 private PasteResourceAction pasteResourceAction;
	 private DeleteResourceAction deleteResourceAction;
	 private RenameItemAction renameItemAction;
	 private SplitVerticallyAction splitVerticallyAction;
	 private SplitHorizontallyAction splitHorizontallyAction;
	 private CloseAction closeAction;
	 private CloseAllAction closeAllAction;
	 private CloseOtherAction closeOtherAction;
	 private CloseAllExceptPinnedAction closeAllExceptPinnedAction;
	 private ReopenClosedFileAction reopenClosedFileAction;
	 private PinEditorTabAction pinEditorTabAction;
	 private GoIntoAction goIntoAction;
	 private EditFileAction editFileAction;
	 private OpenFileAction openFileAction;
	 private ShowHiddenFilesAction showHiddenFilesAction;
	 private FormatterAction formatterAction;
	 private UndoAction undoAction;
	 private RedoAction redoAction;
	 private UploadFileAction uploadFileAction;
	 private UploadFolderAction uploadFolderAction;
	 private DownloadProjectAction downloadProjectAction;
	 private DownloadWsAction downloadWsAction;
	 private DownloadResourceAction downloadResourceAction;
	 private ImportProjectAction importProjectAction;
	 private CreateProjectAction createProjectAction;
	 private ConvertFolderToProjectAction convertFolderToProjectAction;
	 private FullTextSearchAction fullTextSearchAction;
	 private NewFolderAction newFolderAction;
	 private NewFileAction newFileAction;
	 private NewXmlFileAction newXmlFileAction;
	 private ImageViewerProvider imageViewerProvider;
	 private ProjectConfigurationAction projectConfigurationAction;
	 private ExpandEditorAction expandEditorAction;
	 private CompleteAction completeAction;
	 private SwitchPreviousEditorAction switchPreviousEditorAction;
	 private SwitchNextEditorAction switchNextEditorAction;
	 private HotKeysListAction hotKeysListAction;
	 private OpenRecentFilesAction openRecentFilesAction;
	 private ClearRecentListAction clearRecentFilesAction;
	 private CloseActiveEditorAction closeActiveEditorAction;
	 private MessageLoaderResources messageLoaderResources;
	 private EditorResources editorResources;
	 private PopupResources popupResources;
	 private ShowReferenceAction showReferenceAction;
	 private RevealResourceAction revealResourceAction;
	 private RefreshPathAction refreshPathAction;
	 private LinkWithEditorAction linkWithEditorAction;
	 private ShowToolbarAction showToolbarAction;
	 private SignatureHelpAction signatureHelpAction;
	 private MaximizePartAction maximizePartAction;
	 private HidePartAction hidePartAction;
	 private RestorePartAction restorePartAction;
	 private ShowCommandsPaletteAction showCommandsPaletteAction;
	 private SoftWrapAction softWrapAction;
	 private StartWorkspaceAction startWorkspaceAction;
	 private StopWorkspaceAction stopWorkspaceAction;
	 private ShowWorkspaceStatusAction showWorkspaceStatusAction;
	 private ShowRuntimeInfoAction showRuntimeInfoAction;
	 private RunCommandAction runCommandAction;
	 private NewTerminalAction newTerminalAction;
	 private ReRunProcessAction reRunProcessAction;
	 private StopProcessAction stopProcessAction;
	 private CloseConsoleAction closeConsoleAction;
	 private DisplayMachineOutputAction displayMachineOutputAction;
	 private PreviewSSHAction previewSSHAction;
	 private ShowConsoleTreeAction showConsoleTreeAction;
	 private AddToFileWatcherExcludesAction addToFileWatcherExcludesAction;
	 private RemoveFromFileWatcherExcludesAction removeFromFileWatcherExcludesAction;
	 private DevModeSetUpAction devModeSetUpAction;
	 private DevModeOffAction devModeOffAction;
	 private CollapseAllAction collapseAllAction;
	 private PerspectiveManager perspectiveManager;
	 private CommandsExplorerDisplayingModeAction commandsExplorerDisplayingModeAction;
	 private ProjectExplorerDisplayingModeAction projectExplorerDisplayingModeAction;
	 private EventLogsDisplayingModeAction eventLogsDisplayingModeAction;
	 private FindResultDisplayingModeAction findResultDisplayingModeAction;
	 private EditorDisplayingModeAction editorDisplayingModeAction;
	 private TerminalDisplayingModeAction terminalDisplayingModeAction;
	 private RenameCommandAction renameCommandAction;
	 private MoveCommandAction moveCommandAction;
	 private OpenInTerminalAction openInTerminalAction;
	 private FreeDiskSpaceStatusBarAction freeDiskSpaceStatusBarAction;
	 private FileType xmlFile;
	 private FileType txtFile;
	 private FileType jsonFile;
	 private FileType mdFile;
	 private FileType pngFile;
	 private FileType bmpFile;
	 private FileType gifFile;
	 private FileType iconFile;
	 private FileType svgFile;
	 private FileType jpeFile;
	 private FileType jpegFile;
	 private FileType jpgFile;
	 private CommandEditorProvider commandEditorProvider;
	 private FileType commandFileType;
	 private ProjectConfigSynchronized projectConfigSynchronized;
	 private TreeResourceRevealer treeResourceRevealer;
	 private TerminalInitializer terminalInitializer;
	 public StandardComponentInitializer( IconRegistry iconRegistry, MachineResources machineResources, StandardComponentInitializer.ParserResource parserResource) {
		 iconRegistry.registerIcon( new Icon(BLANK_CATEGORY + "".samples.category.icon"", parserResource.samplesCategoryBlank()));
		 iconRegistry.registerIcon(new Icon(""che.machine.icon"", machineResources.devMachine()));
		 machineResources.getCss().ensureInjected();
	 }
	 public void initialize() {
		 messageLoaderResources.Css().ensureInjected();
		 editorResources.editorCss().ensureInjected();
		 popupResources.popupStyle().ensureInjected();
		 fileTypeRegistry.registerFileType(xmlFile);
		 fileTypeRegistry.registerFileType(txtFile);
		 fileTypeRegistry.registerFileType(jsonFile);
		 fileTypeRegistry.registerFileType(mdFile);
		 fileTypeRegistry.registerFileType(pngFile);
		 editorRegistry.registerDefaultEditor(pngFile, imageViewerProvider);
		 fileTypeRegistry.registerFileType(bmpFile);
		 editorRegistry.registerDefaultEditor(bmpFile, imageViewerProvider);
		 fileTypeRegistry.registerFileType(gifFile);
		 editorRegistry.registerDefaultEditor(gifFile, imageViewerProvider);
		 fileTypeRegistry.registerFileType(iconFile);
		 editorRegistry.registerDefaultEditor(iconFile, imageViewerProvider);
		 fileTypeRegistry.registerFileType(svgFile);
		 editorRegistry.registerDefaultEditor(svgFile, imageViewerProvider);
		 fileTypeRegistry.registerFileType(jpeFile);
		 editorRegistry.registerDefaultEditor(jpeFile, imageViewerProvider);
		 fileTypeRegistry.registerFileType(jpegFile);
		 editorRegistry.registerDefaultEditor(jpegFile, imageViewerProvider);
		 fileTypeRegistry.registerFileType(jpgFile);
		 editorRegistry.registerDefaultEditor(jpgFile, imageViewerProvider);
		 fileTypeRegistry.registerFileType(commandFileType);
		 editorRegistry.registerDefaultEditor(commandFileType, commandEditorProvider);
		 DefaultActionGroup workspaceGroup = (DefaultActionGroup) actionManager.getAction(GROUP_WORKSPACE);
		 actionManager.registerAction(IMPORT_PROJECT, importProjectAction);
		 workspaceGroup.add(importProjectAction);
		 actionManager.registerAction(CREATE_PROJECT, createProjectAction);
		 workspaceGroup.add(createProjectAction);
		 actionManager.registerAction(""downloadWsAsZipAction"", downloadWsAction);
		 workspaceGroup.add(downloadWsAction);
		 workspaceGroup.addSeparator();
		 workspaceGroup.add(startWorkspaceAction);
		 workspaceGroup.add(stopWorkspaceAction);
		 workspaceGroup.add(showWorkspaceStatusAction);
		 DefaultActionGroup projectGroup = (DefaultActionGroup) actionManager.getAction(GROUP_PROJECT);
		 DefaultActionGroup newGroup = new DefaultActionGroup(""New"", true, actionManager);
		 newGroup.getTemplatePresentation().setDescription(""Create..."");
		 newGroup .getTemplatePresentation() .setImageElement(new SVGImage(resources.newResource()).getElement());
		 actionManager.registerAction(GROUP_FILE_NEW, newGroup);
		 projectGroup.add(newGroup);
		 newGroup.addSeparator();
		 actionManager.registerAction(NEW_FILE, newFileAction);
		 newGroup.addAction(newFileAction, Constraints.FIRST);
		 actionManager.registerAction(""newFolder"", newFolderAction);
		 newGroup.addAction(newFolderAction, new Constraints(AFTER, NEW_FILE));
		 newGroup.addSeparator();
		 actionManager.registerAction(""newXmlFile"", newXmlFileAction);
		 newXmlFileAction .getTemplatePresentation() .setImageElement(new SVGImage(xmlFile.getImage()).getElement());
		 newGroup.addAction(newXmlFileAction);
		 actionManager.registerAction(""uploadFile"", uploadFileAction);
		 projectGroup.add(uploadFileAction);
		 actionManager.registerAction(""uploadFolder"", uploadFolderAction);
		 projectGroup.add(uploadFolderAction);
		 actionManager.registerAction(""convertFolderToProject"", convertFolderToProjectAction);
		 projectGroup.add(convertFolderToProjectAction);
		 actionManager.registerAction(""downloadAsZipAction"", downloadProjectAction);
		 projectGroup.add(downloadProjectAction);
		 actionManager.registerAction(""showHideHiddenFiles"", showHiddenFilesAction);
		 projectGroup.add(showHiddenFilesAction);
		 projectGroup.addSeparator();
		 actionManager.registerAction(""projectConfiguration"", projectConfigurationAction);
		 projectGroup.add(projectConfigurationAction);
		 DefaultActionGroup saveGroup = new DefaultActionGroup(actionManager);
		 actionManager.registerAction(""saveGroup"", saveGroup);
		 actionManager.registerAction(SAVE, saveAction);
		 saveGroup.addSeparator();
		 saveGroup.add(saveAction);
		 DefaultActionGroup editGroup = (DefaultActionGroup) actionManager.getAction(GROUP_EDIT);
		 DefaultActionGroup recentGroup = new DefaultActionGroup(RECENT_GROUP_ID, true, actionManager);
		 actionManager.registerAction(GROUP_RECENT_FILES, recentGroup);
		 actionManager.registerAction(""clearRecentList"", clearRecentFilesAction);
		 recentGroup.addSeparator();
		 recentGroup.add(clearRecentFilesAction, LAST);
		 editGroup.add(recentGroup);
		 actionManager.registerAction(OPEN_RECENT_FILES, openRecentFilesAction);
		 editGroup.add(openRecentFilesAction);
		 actionManager.registerAction(CLOSE_ACTIVE_EDITOR, closeActiveEditorAction);
		 editGroup.add(closeActiveEditorAction);
		 actionManager.registerAction(FORMAT, formatterAction);
		 editGroup.add(formatterAction);
		 editGroup.add(saveAction);
		 actionManager.registerAction(UNDO, undoAction);
		 editGroup.add(undoAction);
		 actionManager.registerAction(REDO, redoAction);
		 editGroup.add(redoAction);
		 actionManager.registerAction(SOFT_WRAP, softWrapAction);
		 editGroup.add(softWrapAction);
		 actionManager.registerAction(CUT, cutResourceAction);
		 editGroup.add(cutResourceAction);
		 actionManager.registerAction(COPY, copyResourceAction);
		 editGroup.add(copyResourceAction);
		 actionManager.registerAction(PASTE, pasteResourceAction);
		 editGroup.add(pasteResourceAction);
		 actionManager.registerAction(RENAME, renameItemAction);
		 editGroup.add(renameItemAction);
		 actionManager.registerAction(DELETE_ITEM, deleteResourceAction);
		 editGroup.add(deleteResourceAction);
		 actionManager.registerAction(FULL_TEXT_SEARCH, fullTextSearchAction);
		 editGroup.add(fullTextSearchAction);
		 editGroup.addSeparator();
		 editGroup.add(switchPreviousEditorAction);
		 editGroup.add(switchNextEditorAction);
		 DefaultActionGroup assistantGroup = (DefaultActionGroup) actionManager.getAction(GROUP_ASSISTANT);
		 actionManager.registerAction(PREVIEW_IMAGE, previewImageAction);
		 assistantGroup.add(previewImageAction);
		 actionManager.registerAction(FIND_ACTION, findActionAction);
		 assistantGroup.add(findActionAction);
		 actionManager.registerAction(""hotKeysList"", hotKeysListAction);
		 assistantGroup.add(hotKeysListAction);
		 assistantGroup.addSeparator();
		 DefaultActionGroup toolWindowsGroup = new DefaultActionGroup(""Tool Windows"", true, actionManager);
		 actionManager.registerAction(TOOL_WINDOWS_GROUP, toolWindowsGroup);
		 actionManager.registerAction( PROJECT_EXPLORER_DISPLAYING_MODE, projectExplorerDisplayingModeAction);
		 actionManager.registerAction(FIND_RESULT_DISPLAYING_MODE, findResultDisplayingModeAction);
		 actionManager.registerAction(EVENT_LOGS_DISPLAYING_MODE, eventLogsDisplayingModeAction);
		 actionManager.registerAction( COMMAND_EXPLORER_DISPLAYING_MODE, commandsExplorerDisplayingModeAction);
		 actionManager.registerAction(EDITOR_DISPLAYING_MODE, editorDisplayingModeAction);
		 actionManager.registerAction(TERMINAL_DISPLAYING_MODE, terminalDisplayingModeAction);
		 toolWindowsGroup.add(projectExplorerDisplayingModeAction, FIRST);
		 toolWindowsGroup.add( eventLogsDisplayingModeAction, new Constraints(AFTER, PROJECT_EXPLORER_DISPLAYING_MODE));
		 toolWindowsGroup.add( findResultDisplayingModeAction, new Constraints(AFTER, EVENT_LOGS_DISPLAYING_MODE));
		 toolWindowsGroup.add( commandsExplorerDisplayingModeAction, new Constraints(AFTER, FIND_RESULT_DISPLAYING_MODE));
		 toolWindowsGroup.add(editorDisplayingModeAction);
		 toolWindowsGroup.add(terminalDisplayingModeAction);
		 assistantGroup.add(toolWindowsGroup);
		 assistantGroup.addSeparator();
		 actionManager.registerAction(""callCompletion"", completeAction);
		 assistantGroup.add(completeAction);
		 actionManager.registerAction(""downloadItemAction"", downloadResourceAction);
		 actionManager.registerAction(NAVIGATE_TO_FILE, navigateToFileAction);
		 assistantGroup.add(navigateToFileAction);
		 assistantGroup.addSeparator();
		 actionManager.registerAction(""devModeSetUpAction"", devModeSetUpAction);
		 actionManager.registerAction(""devModeOffAction"", devModeOffAction);
		 assistantGroup.add(devModeSetUpAction);
		 assistantGroup.add(devModeOffAction);
		 DefaultActionGroup profileGroup = (DefaultActionGroup) actionManager.getAction(GROUP_PROFILE);
		 actionManager.registerAction(""showPreferences"", showPreferencesAction);
		 profileGroup.add(showPreferencesAction);
		 DefaultActionGroup helpGroup = (DefaultActionGroup) actionManager.getAction(GROUP_HELP);
		 helpGroup.addSeparator();
		 actionManager.registerAction(""startWorkspace"", startWorkspaceAction);
		 actionManager.registerAction(""stopWorkspace"", stopWorkspaceAction);
		 actionManager.registerAction(""showWorkspaceStatus"", showWorkspaceStatusAction);
		 actionManager.registerAction(""runCommand"", runCommandAction);
		 actionManager.registerAction(""newTerminal"", newTerminalAction);
		 DefaultActionGroup resourceOperation = new DefaultActionGroup(actionManager);
		 actionManager.registerAction(""resourceOperation"", resourceOperation);
		 actionManager.registerAction(""refreshPathAction"", refreshPathAction);
		 actionManager.registerAction(""linkWithEditor"", linkWithEditorAction);
		 actionManager.registerAction(""showToolbar"", showToolbarAction);
		 resourceOperation.addSeparator();
		 resourceOperation.add(previewImageAction);
		 resourceOperation.add(showReferenceAction);
		 resourceOperation.add(goIntoAction);
		 resourceOperation.add(editFileAction);
		 resourceOperation.add(saveAction);
		 resourceOperation.add(cutResourceAction);
		 resourceOperation.add(copyResourceAction);
		 resourceOperation.add(pasteResourceAction);
		 resourceOperation.add(renameItemAction);
		 resourceOperation.add(deleteResourceAction);
		 resourceOperation.addSeparator();
		 resourceOperation.add(downloadResourceAction);
		 resourceOperation.add(refreshPathAction);
		 resourceOperation.add(linkWithEditorAction);
		 resourceOperation.add(collapseAllAction);
		 resourceOperation.addSeparator();
		 resourceOperation.add(convertFolderToProjectAction);
		 resourceOperation.addSeparator();
		 resourceOperation.addSeparator();
		 resourceOperation.add(addToFileWatcherExcludesAction);
		 resourceOperation.add(removeFromFileWatcherExcludesAction);
		 resourceOperation.addSeparator();
		 DefaultActionGroup mainContextMenuGroup = (DefaultActionGroup) actionManager.getAction(GROUP_MAIN_CONTEXT_MENU);
		 mainContextMenuGroup.add(newGroup, FIRST);
		 mainContextMenuGroup.addSeparator();
		 mainContextMenuGroup.add(resourceOperation);
		 mainContextMenuGroup.add(openInTerminalAction);
		 actionManager.registerAction(OPEN_IN_TERMINAL, openInTerminalAction);
		 DefaultActionGroup partMenuGroup = (DefaultActionGroup) actionManager.getAction(GROUP_PART_MENU);
		 partMenuGroup.add(maximizePartAction);
		 partMenuGroup.add(hidePartAction);
		 partMenuGroup.add(restorePartAction);
		 partMenuGroup.add(showConsoleTreeAction);
		 partMenuGroup.add(revealResourceAction);
		 partMenuGroup.add(collapseAllAction);
		 partMenuGroup.add(refreshPathAction);
		 partMenuGroup.add(linkWithEditorAction);
		 DefaultActionGroup toolbarControllerGroup = (DefaultActionGroup) actionManager.getAction(GROUP_TOOLBAR_CONTROLLER);
		 toolbarControllerGroup.add(showToolbarAction);
		 actionManager.registerAction(""expandEditor"", expandEditorAction);
		 DefaultActionGroup rightMenuGroup = (DefaultActionGroup) actionManager.getAction(GROUP_RIGHT_MAIN_MENU);
		 rightMenuGroup.add(expandEditorAction, FIRST);
		 DefaultActionGroup changeResourceGroup = new DefaultActionGroup(actionManager);
		 actionManager.registerAction(""changeResourceGroup"", changeResourceGroup);
		 actionManager.registerAction(""editFile"", editFileAction);
		 actionManager.registerAction(""goInto"", goIntoAction);
		 actionManager.registerAction(SHOW_REFERENCE, showReferenceAction);
		 actionManager.registerAction(REVEAL_RESOURCE, revealResourceAction);
		 actionManager.registerAction(COLLAPSE_ALL, collapseAllAction);
		 actionManager.registerAction(""openFile"", openFileAction);
		 actionManager.registerAction(SWITCH_LEFT_TAB, switchPreviousEditorAction);
		 actionManager.registerAction(SWITCH_RIGHT_TAB, switchNextEditorAction);
		 changeResourceGroup.add(cutResourceAction);
		 changeResourceGroup.add(copyResourceAction);
		 changeResourceGroup.add(pasteResourceAction);
		 changeResourceGroup.add(deleteResourceAction);
		 DefaultActionGroup mainToolbarGroup = (DefaultActionGroup) actionManager.getAction(GROUP_MAIN_TOOLBAR);
		 mainToolbarGroup.add(newGroup);
		 mainToolbarGroup.add(saveGroup);
		 mainToolbarGroup.add(changeResourceGroup);
		 toolbarPresenter.bindMainGroup(mainToolbarGroup);
		 DefaultActionGroup centerToolbarGroup = (DefaultActionGroup) actionManager.getAction(GROUP_CENTER_TOOLBAR);
		 toolbarPresenter.bindCenterGroup(centerToolbarGroup);
		 DefaultActionGroup rightToolbarGroup = (DefaultActionGroup) actionManager.getAction(GROUP_RIGHT_TOOLBAR);
		 toolbarPresenter.bindRightGroup(rightToolbarGroup);
		 actionManager.registerAction(""showServers"", showRuntimeInfoAction);
		 DefaultActionGroup consolesTreeContextMenu = (DefaultActionGroup) actionManager.getAction(GROUP_CONSOLES_TREE_CONTEXT_MENU);
		 consolesTreeContextMenu.add(showRuntimeInfoAction);
		 consolesTreeContextMenu.add(newTerminalAction);
		 consolesTreeContextMenu.add(reRunProcessAction);
		 consolesTreeContextMenu.add(stopProcessAction);
		 consolesTreeContextMenu.add(closeConsoleAction);
		 actionManager.registerAction(""displayMachineOutput"", displayMachineOutputAction);
		 consolesTreeContextMenu.add(displayMachineOutputAction);
		 actionManager.registerAction(""previewSSH"", previewSSHAction);
		 consolesTreeContextMenu.add(previewSSHAction);
		 DefaultActionGroup editorTabContextMenu = (DefaultActionGroup) actionManager.getAction(GROUP_EDITOR_TAB_CONTEXT_MENU);
		 editorTabContextMenu.add(closeAction);
		 actionManager.registerAction(CLOSE, closeAction);
		 editorTabContextMenu.add(closeAllAction);
		 actionManager.registerAction(CLOSE_ALL, closeAllAction);
		 editorTabContextMenu.add(closeOtherAction);
		 actionManager.registerAction(CLOSE_OTHER, closeOtherAction);
		 editorTabContextMenu.add(closeAllExceptPinnedAction);
		 actionManager.registerAction(CLOSE_ALL_EXCEPT_PINNED, closeAllExceptPinnedAction);
		 editorTabContextMenu.addSeparator();
		 editorTabContextMenu.add(reopenClosedFileAction);
		 actionManager.registerAction(REOPEN_CLOSED, reopenClosedFileAction);
		 editorTabContextMenu.add(pinEditorTabAction);
		 actionManager.registerAction(PIN_TAB, pinEditorTabAction);
		 editorTabContextMenu.addSeparator();
		 actionManager.registerAction(SPLIT_HORIZONTALLY, splitHorizontallyAction);
		 editorTabContextMenu.add(splitHorizontallyAction);
		 actionManager.registerAction(SPLIT_VERTICALLY, splitVerticallyAction);
		 editorTabContextMenu.add(splitVerticallyAction);
		 actionManager.registerAction(SIGNATURE_HELP, signatureHelpAction);
		 actionManager.registerAction(SHOW_COMMANDS_PALETTE, showCommandsPaletteAction);
		 DefaultActionGroup runGroup = (DefaultActionGroup) actionManager.getAction(IdeActions.GROUP_RUN);
		 runGroup.add(showCommandsPaletteAction);
		 runGroup.add(newTerminalAction, FIRST);
		 runGroup.addSeparator();
		 DefaultActionGroup editorContextMenuGroup = new DefaultActionGroup(actionManager);
		 actionManager.registerAction(GROUP_EDITOR_CONTEXT_MENU, editorContextMenuGroup);
		 editorContextMenuGroup.add(saveAction);
		 editorContextMenuGroup.add(undoAction);
		 editorContextMenuGroup.add(redoAction);
		 editorContextMenuGroup.addSeparator();
		 editorContextMenuGroup.add(formatterAction);
		 editorContextMenuGroup.add(softWrapAction);
		 editorContextMenuGroup.addSeparator();
		 editorContextMenuGroup.add(fullTextSearchAction);
		 editorContextMenuGroup.add(closeActiveEditorAction);
		 editorContextMenuGroup.addSeparator();
		 editorContextMenuGroup.add(revealResourceAction);
		 DefaultActionGroup commandExplorerMenuGroup = new DefaultActionGroup(actionManager);
		 actionManager.registerAction(GROUP_COMMAND_EXPLORER_CONTEXT_MENU, commandExplorerMenuGroup);
		 actionManager.registerAction(""renameCommand"", renameCommandAction);
		 commandExplorerMenuGroup.add(renameCommandAction);
		 actionManager.registerAction(""moveCommand"", moveCommandAction);
		 commandExplorerMenuGroup.add(moveCommandAction);
		 DefaultActionGroup rightStatusPanelGroup = (DefaultActionGroup) actionManager.getAction(GROUP_RIGHT_STATUS_PANEL);
		 rightStatusPanelGroup.add(freeDiskSpaceStatusBarAction);
		 keyBinding .getGlobal() .addKey(new KeyBuilder().action().alt().charCode('n').build(), NAVIGATE_TO_FILE);
		 keyBinding .getGlobal() .addKey(new KeyBuilder().action().charCode('F').build(), FULL_TEXT_SEARCH);
		 keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('A').build(), FIND_ACTION);
		 keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('L').build(), FORMAT);
		 keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('c').build(), COPY);
		 keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('x').build(), CUT);
		 keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('v').build(), PASTE);
		 keyBinding.getGlobal().addKey(new KeyBuilder().shift().charCode(KeyCodeMap.F6).build(), RENAME);
		 keyBinding .getGlobal() .addKey(new KeyBuilder().shift().charCode(KeyCodeMap.F7).build(), SHOW_REFERENCE);
		 keyBinding .getGlobal() .addKey(new KeyBuilder().alt().charCode(KeyCodeMap.ARROW_LEFT).build(), SWITCH_LEFT_TAB);
		 keyBinding .getGlobal() .addKey(new KeyBuilder().alt().charCode(KeyCodeMap.ARROW_RIGHT).build(), SWITCH_RIGHT_TAB);
		 keyBinding .getGlobal() .addKey(new KeyBuilder().action().charCode('e').build(), OPEN_RECENT_FILES);
		 keyBinding .getGlobal() .addKey(new KeyBuilder().charCode(KeyCodeMap.DELETE).build(), DELETE_ITEM);
		 keyBinding.getGlobal().addKey(new KeyBuilder().action().alt().charCode('w').build(), SOFT_WRAP);
		 keyBinding .getGlobal() .addKey(new KeyBuilder().alt().charCode(KeyCodeMap.F12).build(), NEW_TERMINAL);
		 keyBinding .getGlobal() .addKey(new KeyBuilder().alt().shift().charCode(KeyCodeMap.F12).build(), OPEN_IN_TERMINAL);
		 keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('N').build(), NEW_FILE);
		 keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('x').build(), CREATE_PROJECT);
		 keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('A').build(), IMPORT_PROJECT);
		 keyBinding .getGlobal() .addKey(new KeyBuilder().shift().charCode(KeyCodeMap.F10).build(), SHOW_COMMANDS_PALETTE);
		 keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('s').build(), SAVE);
		 keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('z').build(), UNDO);
		 keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('y').build(), REDO);
		 if (UserAgent.isMac()) {
			 keyBinding .getGlobal() .addKey( new KeyBuilder().action().control().charCode('1').build(), PROJECT_EXPLORER_DISPLAYING_MODE);
			 keyBinding .getGlobal() .addKey( new KeyBuilder().action().control().charCode('2').build(), EVENT_LOGS_DISPLAYING_MODE);
			 keyBinding .getGlobal() .addKey( new KeyBuilder().action().control().charCode('3').build(), FIND_RESULT_DISPLAYING_MODE);
			 keyBinding .getGlobal() .addKey( new KeyBuilder().action().control().charCode('4').build(), COMMAND_EXPLORER_DISPLAYING_MODE);
			 keyBinding .getGlobal() .addKey(new KeyBuilder().action().charCode('E').build(), EDITOR_DISPLAYING_MODE);
			 keyBinding .getGlobal() .addKey(new KeyBuilder().action().charCode('T').build(), TERMINAL_DISPLAYING_MODE);
		 }
		 else {
			 keyBinding .getGlobal() .addKey( new KeyBuilder().action().alt().charCode('1').build(), PROJECT_EXPLORER_DISPLAYING_MODE);
			 keyBinding .getGlobal() .addKey( new KeyBuilder().action().alt().charCode('2').build(), EVENT_LOGS_DISPLAYING_MODE);
			 keyBinding .getGlobal() .addKey( new KeyBuilder().action().alt().charCode('3').build(), FIND_RESULT_DISPLAYING_MODE);
			 keyBinding .getGlobal() .addKey( new KeyBuilder().action().alt().charCode('4').build(), COMMAND_EXPLORER_DISPLAYING_MODE);
			 keyBinding .getGlobal() .addKey(new KeyBuilder().alt().charCode('E').build(), EDITOR_DISPLAYING_MODE);
			 keyBinding .getGlobal() .addKey(new KeyBuilder().alt().charCode('T').build(), TERMINAL_DISPLAYING_MODE);
		 }
		 keyBinding .getGlobal() .addKey(new KeyBuilder().action().charCode(ARROW_DOWN).build(), REVEAL_RESOURCE);
		 keyBinding .getGlobal() .addKey(new KeyBuilder().action().charCode(ARROW_UP).build(), COLLAPSE_ALL);
		 if (UserAgent.isMac()) {
			 keyBinding .getGlobal() .addKey(new KeyBuilder().control().charCode('w').build(), CLOSE_ACTIVE_EDITOR);
			 keyBinding .getGlobal() .addKey(new KeyBuilder().control().charCode('p').build(), SIGNATURE_HELP);
		 }
		 else {
			 keyBinding .getGlobal() .addKey(new KeyBuilder().alt().charCode('w').build(), CLOSE_ACTIVE_EDITOR);
			 keyBinding .getGlobal() .addKey(new KeyBuilder().action().charCode('p').build(), SIGNATURE_HELP);
		 }
		 final Map<String, Perspective> perspectives = perspectiveManager.getPerspectives();
		 if (perspectives.size() > 1) {
			 final DefaultActionGroup windowMenu = new DefaultActionGroup(""Window"", true, actionManager);
			 actionManager.registerAction(""Window"", windowMenu);
			 final DefaultActionGroup mainMenu = (DefaultActionGroup) actionManager.getAction(GROUP_MAIN_MENU);
			 mainMenu.add(windowMenu);
			 for (Perspective perspective : perspectives.values()) {
				 final BaseAction action = new BaseAction(perspective.getPerspectiveName()) {
					 public void actionPerformed(ActionEvent e) {
						 perspectiveManager.setPerspectiveId(perspective.getPerspectiveId());
					 }
				 }
				;
				 actionManager.registerAction(perspective.getPerspectiveId(), action);
				 windowMenu.add(action);
			 }
		 }
	 }
}",1,1,0,0
"public void checkNoForwardReferences(XExpression fieldInitializer) {
	JvmIdentifiableElement container = logicalContainerProvider.getLogicalContainer(fieldInitializer);
	if (container instanceof JvmField) {
		JvmField field = (JvmField) container;
		boolean staticField = field.isStatic();
		JvmDeclaredType declaredType = field.getDeclaringType();
		if (declaredType == null) {
			return;
		}
		Collection<JvmField> illegalFields = Sets.newHashSet();
		for(int i = declaredType.getMembers().size() - 1;
		 i>=0;
		 i--) {
			JvmMember member = declaredType.getMembers().get(i);
			if (member instanceof JvmField) {
				if (((JvmField) member).isStatic() == staticField) {
					illegalFields.add((JvmField) member);
				}
			}
			if (member == field)break;
		}
		TreeIterator<EObject> iterator = EcoreUtil2.eAll(fieldInitializer);
		while(iterator.hasNext()) {
			EObject object = iterator.next();
			if (object instanceof XFeatureCall) {
				JvmIdentifiableElement feature = ((XFeatureCall) object).getFeature();
				if (illegalFields.contains(((XFeatureCall) object).getFeature())) {
					error(""Cannot reference the field '"" + feature.getSimpleName() + ""' before it is defined"", object, null, INSIGNIFICANT_INDEX, ILLEGAL_FORWARD_REFERENCE);
				}
			}
			 else if (isLocalClassSemantics(object)) {
				iterator.prune();
			}
		}
	}
}",0,0,1,0
"private void doScrub(ColumnFamilyStore cfs) throws IOException {
	 assert !cfs.isIndex();
	 for (final SSTableReader sstable : cfs.getSSTables()) {
		 logger.info(""Scrubbing "" + sstable);
		 String compactionFileLocation = cfs.table.getDataFileLocation(sstable.length());
		 if (compactionFileLocation == null) throw new IOException(""disk full"");
		 int expectedBloomFilterSize = Math.max(DatabaseDescriptor.getIndexInterval(), (int)(SSTableReader.getApproximateKeyCount(Arrays.asList(sstable))));
		 final BufferedRandomAccessFile dataFile = BufferedRandomAccessFile.getUncachingReader(sstable.getFilename());
		 String indexFilename = sstable.descriptor.filenameFor(Component.PRIMARY_INDEX);
		 BufferedRandomAccessFile indexFile = BufferedRandomAccessFile.getUncachingReader(indexFilename);
		 ByteBuffer nextIndexKey = ByteBufferUtil.readWithShortLength(indexFile);
		 {
			 long firstRowPositionFromIndex = indexFile.readLong();
			 assert firstRowPositionFromIndex == 0 : firstRowPositionFromIndex;
		 }
		 SSTableWriter writer = maybeCreateWriter(cfs, compactionFileLocation, expectedBloomFilterSize, null);
		 executor.beginCompaction(cfs.columnFamily, new ScrubInfo(dataFile, sstable));
		 int goodRows = 0, badRows = 0;
		 while (!dataFile.isEOF()) {
			 long rowStart = dataFile.getFilePointer();
			 if (logger.isDebugEnabled()) logger.debug(""Reading row at "" + rowStart);
			 DecoratedKey key = null;
			 long dataSize = -1;
			 try {
				 key = SSTableReader.decodeKey(sstable.partitioner, sstable.descriptor, ByteBufferUtil.readWithShortLength(dataFile));
				 dataSize = sstable.descriptor.hasIntRowSize ? dataFile.readInt() : dataFile.readLong();
				 if (logger.isDebugEnabled()) logger.debug(String.format(""row %s is %s bytes"", ByteBufferUtil.bytesToHex(key.key), dataSize));
			 }
			 catch (Throwable th) {
				 throwIfFatal(th);
			 }
			 ByteBuffer currentIndexKey = nextIndexKey;
			 long nextRowPositionFromIndex;
			 try {
				 nextIndexKey = indexFile.isEOF() ? null : ByteBufferUtil.readWithShortLength(indexFile);
				 nextRowPositionFromIndex = indexFile.isEOF() ? dataFile.length() : indexFile.readLong();
			 }
			 catch (Throwable th) {
				 logger.warn(""Error reading index file"", th);
				 nextIndexKey = null;
				 nextRowPositionFromIndex = dataFile.length();
			 }
			 long dataStart = dataFile.getFilePointer();
			 long dataStartFromIndex = currentIndexKey == null ? -1 : rowStart + 2 + currentIndexKey.remaining() + (sstable.descriptor.hasIntRowSize ? 4 : 8);
			 long dataSizeFromIndex = nextRowPositionFromIndex - dataStartFromIndex;
			 assert currentIndexKey != null || indexFile.isEOF();
			 if (logger.isDebugEnabled() && currentIndexKey != null) logger.debug(String.format(""Index doublecheck: row %s is %s bytes"", ByteBufferUtil.bytesToHex(currentIndexKey), dataSizeFromIndex));
			 writer.mark();
			 try {
				 if (key == null) throw new IOError(new IOException(""Unable to read row key from data file""));
				 if (dataSize > dataFile.length()) throw new IOError(new IOException(""Impossible row size "" + dataSize));
				 SSTableIdentityIterator row = new SSTableIdentityIterator(sstable, dataFile, key, dataStart, dataSize, true);
				 writer.append(getCompactedRow(row, cfs, sstable.descriptor, true));
				 goodRows++;
				 if (!key.key.equals(currentIndexKey) || dataStart != dataStartFromIndex) logger.warn(""Row scrubbed successfully but index file contains a different key or row size;
			 consider rebuilding the index as described in http: }
			 catch (Throwable th) {
				 throwIfFatal(th);
				 logger.warn(""Non-fatal error reading row (stacktrace follows)"", th);
				 writer.reset();
				 if (currentIndexKey != null && (key == null || !key.key.equals(currentIndexKey) || dataStart != dataStartFromIndex || dataSize != dataSizeFromIndex)) {
					 logger.info(String.format(""Retrying from row index;
					 data is %s bytes starting at %s"", dataSizeFromIndex, dataStartFromIndex));
					 key = SSTableReader.decodeKey(sstable.partitioner, sstable.descriptor, currentIndexKey);
					 try {
						 SSTableIdentityIterator row = new SSTableIdentityIterator(sstable, dataFile, key, dataStartFromIndex, dataSizeFromIndex, true);
						 writer.append(getCompactedRow(row, cfs, sstable.descriptor, true));
						 goodRows++;
					 }
					 catch (Throwable th2) {
						 throwIfFatal(th2);
						 logger.warn(""Retry failed too. Skipping to next row (retry's stacktrace follows)"", th2);
						 writer.reset();
						 dataFile.seek(nextRowPositionFromIndex);
						 badRows++;
					 }
				 }
				 else {
					 logger.warn(""Row is unreadable;
					 skipping to next"");
					 if (currentIndexKey != null) dataFile.seek(nextRowPositionFromIndex);
					 badRows++;
				 }
			 }
		 }
		 if (writer.getFilePointer() > 0) {
			 SSTableReader newSstable = writer.closeAndOpenReader(sstable.maxDataAge);
			 cfs.replaceCompactedSSTables(Arrays.asList(sstable), Arrays.asList(newSstable));
			 logger.info(""Scrub of "" + sstable + "" complete: "" + goodRows + "" rows in new sstable"");
			 if (badRows > 0) logger.warn(""Unable to recover "" + badRows + "" that were skipped. You can attempt manual recovery from the pre-scrub snapshot. You can also run nodetool repair to transfer the data from a healthy replica, if any"");
		 }
		 else {
			 cfs.markCompacted(Arrays.asList(sstable));
			 logger.warn(""No valid rows found while scrubbing "" + sstable + "";
			 it is marked for deletion now. If you want to attempt manual recovery, you can find a copy in the pre-scrub snapshot"");
		 }
	 }
 }",0,0,1,0
"public class InfinispanAsyncLocalEventListener extends InfinispanSyncLocalEventListener {
	 public InfinispanAsyncLocalEventListener(InfinispanConsumer consumer, Set<String> eventTypes) {
		 super(consumer, eventTypes);
	 }
}",0,1,0,0
"public <T extends Object> List<NamedSerializationContexts<T>> getNamedContexts(final SerializationContextMap<T> map) {
	 final ArrayList<NamedSerializationContexts<T>> result = CollectionLiterals.<NamedSerializationContexts<T>>newArrayList();
	 final HashMap<String, Integer> names = CollectionLiterals.<String, Integer>newHashMap();
	 List<SerializationContextMap.Entry<T>> _values = map.values();
	 for (final SerializationContextMap.Entry<T> e : _values) {
		 Set<EClass> _types = e.getTypes();
		 for (final EClass t : _types) {
			 {
				 final List<ISerializationContext> ctx = e.getContexts(t);
				 String _xifexpression = null;
				 if ((t == null)) {
					 _xifexpression = """";
				 }
				 else {
					 _xifexpression = t.getName();
				 }
				 String _plus = (_xifexpression + ""_"");
				 String _significantGrammarElement = this.getSignificantGrammarElement(ctx);
				 final String name = (_plus + _significantGrammarElement);
				 final Integer dup = names.get(name);
				 String _xifexpression_1 = null;
				 if ((dup == null)) {
					 String _xblockexpression = null;
					 {
						 names.put(name, Integer.valueOf(1));
						 _xblockexpression = name;
					 }
					 _xifexpression_1 = _xblockexpression;
				 }
				 else {
					 String _xblockexpression_1 = null;
					 {
						 names.put(name, Integer.valueOf(((dup).intValue() + 1)));
						 _xblockexpression_1 = ((name + ""_"") + dup);
					 }
					 _xifexpression_1 = _xblockexpression_1;
				 }
				 final String unique = _xifexpression_1;
				 T _value = e.getValue();
				 NamedSerializationContexts<T> _namedSerializationContexts = new NamedSerializationContexts<T>(unique, t, ctx, _value);
				 result.add(_namedSerializationContexts);
			 }
		 }
	 }
	 return result;
 }",0,0,1,0
"final class AvlNode<T extends Comparable<T>>{
	 AvlNode<T> parent = null;
	 AvlNode<T> left = null;
	 AvlNode<T> right = null;
	 int height = 0;
	 int balance = 0;
	 T value = null;
	 AvlNode( AvlNode<T> parent, T value ) {
		 this.parent = parent;
		 this.value = value;
	 }
	 public AvlNode<T> reset( AvlNode<T> parent, T value ) {
		 this.parent = parent;
		 left = null;
		 right = null;
		 height = 0;
		 this.value = value;
		 return this;
	 }
}",0,1,0,0
"public final String getRawInput(){
	return NO_RAW_INPUT.equals(rawInput) ? null : rawInput;
}",0,0,0,0
"private void lock(int idx) throws IOException {
	 RandomAccessFile file = (RandomAccessFile) storageFiles.get(idx);
	 FileLock lock = file.getChannel().tryLock();
	 if (lock == null) {
		 LOG.warn(""Cannot lock storage file in directory ""+origDirs[idx].getName());
		 storageFiles.add(idx, null);
		 file.close();
	 }
	 storageLocks.add(idx, lock);
 }",0,0,0,0
"public Void remove(ByteBuffer key, ColumnPath columnPath, long timestamp, ConsistencyLevel consistencyLevel) throws AvroRemoteException, InvalidRequestException, UnavailableException, TimedOutException {
	 if (logger.isDebugEnabled()) logger.debug(""remove"");
	 AvroValidation.validateKey(key);
	 AvroValidation.validateColumnPath(state().getKeyspace(), columnPath);
	 RowMutation rm = new RowMutation(state().getKeyspace(), key);
	 rm.delete(new QueryPath(columnPath.column_family.toString(), columnPath.super_column), timestamp);
	 doInsert(consistencyLevel, rm);
	 return null;
 }",0,0,0,0
"public interface SSTableFlushObserver{
	 void begin();
	 void startPartition(DecoratedKey key, long indexPosition);
	 void nextUnfilteredCluster(Unfiltered unfilteredCluster);
	 void complete();
}",0,0,0,0
"public class PasswordPolicyDetailsPage implements IDetailsPage{
	 private PasswordPoliciesMasterDetailsBlock masterDetailsBlock;
	 private IManagedForm mform;
	 private PasswordPolicyBean passwordPolicy;
	 private Button enabledCheckbox;
	 private Text idText;
	 private Text descriptionText;
	 private ComboViewer checkQualityComboViewer;
	 private Text validatorText;
	 private Button minimumLengthCheckbox;
	 private Text minimumLengthText;
	 private Button maximumLengthCheckbox;
	 private Text maximumLengthText;
	 private Text minimumAgeText;
	 private Text maximumAgeText;
	 private Button expireWarningCheckbox;
	 private Text expireWarningText;
	 private Button graceAuthenticationLimitCheckbox;
	 private Text graceAuthenticationLimitText;
	 private Button graceExpireCheckbox;
	 private Text graceExpireText;
	 private Button mustChangeCheckbox;
	 private Button allowUserChangeCheckbox;
	 private Button safeModifyCheckbox;
	 private Button lockoutCheckbox;
	 private Text lockoutDurationText;
	 private Text maxFailureText;
	 private Text failureCountIntervalText;
	 private Button inHistoryCheckbox;
	 private Text inHistoryText;
	 private Button maxIdleCheckbox;
	 private Text maxIdleText;
	 private Text minimumDelayText;
	 private Text maximumDelayText;
	 private ModifyListener textModifyListener = new ModifyListener() {
		 public void modifyText( ModifyEvent e ) {
			 commit( true );
			 masterDetailsBlock.setEditorDirty();
		 }
	 }
	;
	 private SelectionListener buttonSelectionListener = new SelectionAdapter() {
		 public void widgetSelected( SelectionEvent e ) {
			 commit( true );
			 masterDetailsBlock.setEditorDirty();
		 }
	 }
	;
	 private ISelectionChangedListener viewerSelectionChangedListener = new ISelectionChangedListener() {
		 public void selectionChanged( SelectionChangedEvent event ) {
			 commit( true );
			 masterDetailsBlock.setEditorDirty();
		 }
	 }
	;
	 private VerifyListener integerVerifyListener = new VerifyListener() {
		 public void verifyText( VerifyEvent e ) {
			 if ( !e.text.matches( ""[0-9]*"" ) ) {
				 e.doit = false;
			 }
		 }
	 }
	;
	 private ISelectionChangedListener checkQualityComboViewerSelectionChangedListener = new ISelectionChangedListener() {
		 public void selectionChanged( SelectionChangedEvent event ) {
			 StructuredSelection selection = ( StructuredSelection ) checkQualityComboViewer.getSelection();
			 if ( !selection.isEmpty() ) {
				 CheckQuality checkQuality = ( CheckQuality ) selection.getFirstElement();
				 if ( checkQuality == CheckQuality.DISABLED ) {
					 minimumLengthCheckbox.setEnabled( false );
					 minimumLengthText.setEnabled( false );
					 maximumLengthCheckbox.setEnabled( false );
					 maximumLengthText.setEnabled( false );
				 }
				 else {
					 int minimumLength = 0;
					 int maximumLength = 0;
					 try {
						 minimumLength = Integer.parseInt( minimumLengthText.getText() );
					 }
					 catch ( NumberFormatException e ) {
					 }
					 try {
						 maximumLength = Integer.parseInt( maximumLengthText.getText() );
					 }
					 catch ( NumberFormatException e ) {
					 }
					 minimumLengthCheckbox.setEnabled( true );
					 minimumLengthText.setEnabled( minimumLength != 0 );
					 maximumLengthCheckbox.setEnabled( true );
					 maximumLengthText.setEnabled( maximumLength != 0 );
				 }
			 }
		 }
	 }
	;
	 private SelectionListener minimumLengthCheckboxSelectionListener = new SelectionAdapter() {
		 public void widgetSelected( SelectionEvent e ) {
			 minimumLengthText.setEnabled( minimumLengthCheckbox.getSelection() );
		 }
	 }
	;
	 private SelectionListener maximumLengthCheckboxSelectionListener = new SelectionAdapter() {
		 public void widgetSelected( SelectionEvent e ) {
			 maximumLengthText.setEnabled( maximumLengthCheckbox.getSelection() );
		 }
	 }
	;
	 private SelectionListener expireWarningCheckboxSelectionListener = new SelectionAdapter() {
		 public void widgetSelected( SelectionEvent e ) {
			 expireWarningText.setEnabled( expireWarningCheckbox.getSelection() );
		 }
	 }
	;
	 private SelectionListener graceAuthenticationLimitCheckboxSelectionListener = new SelectionAdapter() {
		 public void widgetSelected( SelectionEvent e ) {
			 graceAuthenticationLimitText.setEnabled( graceAuthenticationLimitCheckbox.getSelection() );
		 }
	 }
	;
	 private SelectionListener graceExpireCheckboxSelectionListener = new SelectionAdapter() {
		 public void widgetSelected( SelectionEvent e ) {
			 graceExpireText.setEnabled( graceExpireCheckbox.getSelection() );
		 }
	 }
	;
	 private SelectionListener maxIdleCheckboxSelectionListener = new SelectionAdapter() {
		 public void widgetSelected( SelectionEvent e ) {
			 maxIdleText.setEnabled( maxIdleCheckbox.getSelection() );
		 }
	 }
	;
	 private SelectionListener inHistoryCheckboxSelectionListener = new SelectionAdapter() {
		 public void widgetSelected( SelectionEvent e ) {
			 inHistoryText.setEnabled( inHistoryCheckbox.getSelection() );
		 }
	 }
	;
	 public PasswordPolicyDetailsPage( PasswordPoliciesMasterDetailsBlock pmdb ) {
		 masterDetailsBlock = pmdb;
	 }
	 public void createContents( Composite parent ) {
		 FormToolkit toolkit = mform.getToolkit();
		 TableWrapLayout layout = new TableWrapLayout();
		 layout.topMargin = 5;
		 layout.leftMargin = 5;
		 layout.rightMargin = 2;
		 layout.bottomMargin = 2;
		 parent.setLayout( layout );
		 createDetailsSection( toolkit, parent );
		 createQualitySection( toolkit, parent );
		 createExpirationSection( toolkit, parent );
		 createOptionsSection( toolkit, parent );
		 createLockoutSection( toolkit, parent );
	 }
	 private void createDetailsSection( FormToolkit toolkit, Composite parent ) {
		 Section section = toolkit.createSection( parent, Section.DESCRIPTION | Section.TITLE_BAR );
		 section.marginWidth = 10;
		 section.setText( ""Password Policy Details"" );
		 section.setDescription( ""Set the properties of the password policy."" );
		 TableWrapData td = new TableWrapData( TableWrapData.FILL, TableWrapData.TOP );
		 td.grabHorizontal = true;
		 section.setLayoutData( td );
		 Composite client = toolkit.createComposite( section );
		 toolkit.paintBordersFor( client );
		 GridLayout glayout = new GridLayout( 2, false );
		 client.setLayout( glayout );
		 section.setClient( client );
		 enabledCheckbox = toolkit.createButton( client, ""Enabled"", SWT.CHECK );
		 enabledCheckbox.setLayoutData( new GridData( SWT.FILL, SWT.NONE, true, false, 2, 1 ) );
		 toolkit.createLabel( client, ""ID:"" );
		 idText = toolkit.createText( client, """" );
		 idText.setLayoutData( new GridData( SWT.FILL, SWT.NONE, true, false ) );
		 toolkit.createLabel( client, ""Description:"" );
		 descriptionText = toolkit.createText( client, """" );
		 descriptionText.setLayoutData( new GridData( SWT.FILL, SWT.NONE, true, false ) );
	 }
	 private void createQualitySection( FormToolkit toolkit, Composite parent ) {
		 Section section = toolkit.createSection( parent, Section.TITLE_BAR );
		 section.marginWidth = 10;
		 section.setText( ""Quality"" );
		 TableWrapData td = new TableWrapData( TableWrapData.FILL, TableWrapData.TOP );
		 td.grabHorizontal = true;
		 section.setLayoutData( td );
		 Composite composite = toolkit.createComposite( section );
		 toolkit.paintBordersFor( composite );
		 GridLayout gridLayout = new GridLayout( 2, false );
		 gridLayout.marginHeight = gridLayout.marginWidth = 0;
		 composite.setLayout( gridLayout );
		 section.setClient( composite );
		 toolkit.createLabel( composite, ""Check Quality:"" );
		 checkQualityComboViewer = new ComboViewer( composite );
		 checkQualityComboViewer.setContentProvider( new ArrayContentProvider() );
		 checkQualityComboViewer.setInput( new CheckQuality[] {
		 CheckQuality.DISABLED, CheckQuality.RELAXED, CheckQuality.STRICT }
		 );
		 checkQualityComboViewer.getControl().setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
		 toolkit.createLabel( composite, ""Validator:"" );
		 validatorText = toolkit.createText( composite, """" );
		 validatorText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
		 minimumLengthCheckbox = toolkit.createButton( composite, ""Enable Mimimum Length"", SWT.CHECK );
		 minimumLengthCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );
		 Composite mimimumLengthRadioIndentComposite = createRadioIndentComposite( toolkit, composite, ""Number of characters:"" );
		 minimumLengthText = toolkit.createText( mimimumLengthRadioIndentComposite, """" );
		 minimumLengthText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
		 maximumLengthCheckbox = toolkit.createButton( composite, ""Enable Maximum Length"", SWT.CHECK );
		 maximumLengthCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );
		 Composite maximumLengthRadioIndentComposite = createRadioIndentComposite( toolkit, composite, ""Number of characters:"" );
		 maximumLengthText = toolkit.createText( maximumLengthRadioIndentComposite, """" );
		 maximumLengthText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
	 }
	 private void createExpirationSection( FormToolkit toolkit, Composite parent ) {
		 Section section = toolkit.createSection( parent, Section.TITLE_BAR );
		 section.marginWidth = 10;
		 section.setText( ""Expiration"" );
		 TableWrapData td = new TableWrapData( TableWrapData.FILL, TableWrapData.TOP );
		 td.grabHorizontal = true;
		 section.setLayoutData( td );
		 Composite composite = toolkit.createComposite( section );
		 toolkit.paintBordersFor( composite );
		 GridLayout gridLayout = new GridLayout( 2, false );
		 gridLayout.marginHeight = gridLayout.marginWidth = 0;
		 composite.setLayout( gridLayout );
		 section.setClient( composite );
		 toolkit.createLabel( composite, ""Mimimum Age (seconds):"" );
		 minimumAgeText = toolkit.createText( composite, """" );
		 minimumAgeText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
		 toolkit.createLabel( composite, ""Maximum Age (seconds):"" );
		 maximumAgeText = toolkit.createText( composite, """" );
		 maximumAgeText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
		 expireWarningCheckbox = toolkit.createButton( composite, ""Enable Expire Warning"", SWT.CHECK );
		 expireWarningCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 3, 1 ) );
		 Composite expireWarningRadioIndentComposite = createRadioIndentComposite( toolkit, composite, ""Number of seconds:"" );
		 expireWarningText = toolkit.createText( expireWarningRadioIndentComposite, """" );
		 expireWarningText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
		 graceAuthenticationLimitCheckbox = toolkit.createButton( composite, ""Enable Grace Authentication Limit"", SWT.CHECK );
		 graceAuthenticationLimitCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 3, 1 ) );
		 Composite graceAuthenticationLimitRadioIndentComposite = createRadioIndentComposite( toolkit, composite, ""Number of times:"" );
		 graceAuthenticationLimitText = toolkit.createText( graceAuthenticationLimitRadioIndentComposite, """" );
		 graceAuthenticationLimitText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
		 graceExpireCheckbox = toolkit.createButton( composite, ""Enable Grace Expire"", SWT.CHECK );
		 graceExpireCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 3, 1 ) );
		 Composite graceExpireRadioIndentComposite = createRadioIndentComposite( toolkit, composite, ""Interval (seconds):"" );
		 graceExpireText = toolkit.createText( graceExpireRadioIndentComposite, """" );
		 graceExpireText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
	 }
	 private void createOptionsSection( FormToolkit toolkit, Composite parent ) {
		 Section section = toolkit.createSection( parent, Section.TITLE_BAR );
		 section.marginWidth = 10;
		 section.setText( ""Options"" );
		 TableWrapData td = new TableWrapData( TableWrapData.FILL, TableWrapData.TOP );
		 td.grabHorizontal = true;
		 section.setLayoutData( td );
		 Composite composite = toolkit.createComposite( section );
		 toolkit.paintBordersFor( composite );
		 GridLayout gridLayout = new GridLayout( 2, false );
		 gridLayout.marginHeight = gridLayout.marginWidth = 0;
		 composite.setLayout( gridLayout );
		 section.setClient( composite );
		 mustChangeCheckbox = toolkit.createButton( composite, ""Enable Must Change"", SWT.CHECK );
		 mustChangeCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );
		 allowUserChangeCheckbox = toolkit.createButton( composite, ""Enable Allow User Change"", SWT.CHECK );
		 allowUserChangeCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );
		 safeModifyCheckbox = toolkit.createButton( composite, ""Enable Safe Modify"", SWT.CHECK );
		 safeModifyCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );
	 }
	 private void createLockoutSection( FormToolkit toolkit, Composite parent ) {
		 Section section = toolkit.createSection( parent, Section.TITLE_BAR );
		 section.marginWidth = 10;
		 section.setText( ""Lockout"" );
		 TableWrapData td = new TableWrapData( TableWrapData.FILL, TableWrapData.TOP );
		 td.grabHorizontal = true;
		 section.setLayoutData( td );
		 Composite composite = toolkit.createComposite( section );
		 toolkit.paintBordersFor( composite );
		 GridLayout gridLayout = new GridLayout( 2, false );
		 gridLayout.marginHeight = gridLayout.marginWidth = 0;
		 composite.setLayout( gridLayout );
		 section.setClient( composite );
		 lockoutCheckbox = toolkit.createButton( composite, ""Enable Lockout"", SWT.CHECK );
		 lockoutCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );
		 toolkit.createLabel( composite, ""Lockout Duration (seconds):"" );
		 lockoutDurationText = toolkit.createText( composite, """" );
		 lockoutDurationText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
		 toolkit.createLabel( composite, ""Maximum Consecutive Failures (count):"" );
		 maxFailureText = toolkit.createText( composite, """" );
		 maxFailureText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
		 toolkit.createLabel( composite, ""Failure Count Interval (seconds):"" );
		 failureCountIntervalText = toolkit.createText( composite, """" );
		 failureCountIntervalText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
		 maxIdleCheckbox = toolkit.createButton( composite, ""Enable Maximum Idle"", SWT.CHECK );
		 maxIdleCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 3, 1 ) );
		 Composite maxIdleCheckboxRadioIndentComposite = createRadioIndentComposite( toolkit, composite, ""Interval (seconds):"" );
		 maxIdleText = toolkit.createText( maxIdleCheckboxRadioIndentComposite, """" );
		 maxIdleText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
		 inHistoryCheckbox = toolkit.createButton( composite, ""Enable In History"", SWT.CHECK );
		 inHistoryCheckbox.setLayoutData( new GridData( SWT.BEGINNING, SWT.CENTER, false, false, 2, 1 ) );
		 Composite inHistoryRadioIndentComposite = createRadioIndentComposite( toolkit, composite, ""Used passwords stored in history:"" );
		 inHistoryText = toolkit.createText( inHistoryRadioIndentComposite, """" );
		 inHistoryText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
		 toolkit.createLabel( composite, ""Mimimum Delay (seconds):"" );
		 minimumDelayText = toolkit.createText( composite, """" );
		 minimumDelayText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
		 toolkit.createLabel( composite, ""Maximum Delay (seconds):"" );
		 maximumDelayText = toolkit.createText( composite, """" );
		 maximumDelayText.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false ) );
	 }
	 private Composite createRadioIndentComposite( FormToolkit toolkit, Composite parent, String text ) {
		 Composite composite = toolkit.createComposite( parent );
		 GridLayout gridLayout = new GridLayout( 3, false );
		 gridLayout.marginHeight = gridLayout.marginWidth = 0;
		 composite.setLayout( gridLayout );
		 composite.setLayoutData( new GridData( SWT.FILL, SWT.CENTER, true, false, 2, 1 ) );
		 toolkit.createLabel( composite, "" "" );
		 toolkit.createLabel( composite, text );
		 return composite;
	 }
	 private void addListeners() {
		 enabledCheckbox.addSelectionListener( buttonSelectionListener );
		 idText.addModifyListener( textModifyListener );
		 descriptionText.addModifyListener( textModifyListener );
		 checkQualityComboViewer.addSelectionChangedListener( viewerSelectionChangedListener );
		 checkQualityComboViewer.addSelectionChangedListener( checkQualityComboViewerSelectionChangedListener );
		 validatorText.addModifyListener( textModifyListener );
		 minimumLengthCheckbox.addSelectionListener( buttonSelectionListener );
		 minimumLengthCheckbox.addSelectionListener( minimumLengthCheckboxSelectionListener );
		 minimumLengthText.addModifyListener( textModifyListener );
		 minimumLengthText.addVerifyListener( integerVerifyListener );
		 maximumLengthCheckbox.addSelectionListener( buttonSelectionListener );
		 maximumLengthCheckbox.addSelectionListener( maximumLengthCheckboxSelectionListener );
		 maximumLengthText.addModifyListener( textModifyListener );
		 maximumLengthText.addVerifyListener( integerVerifyListener );
		 minimumAgeText.addModifyListener( textModifyListener );
		 minimumAgeText.addVerifyListener( integerVerifyListener );
		 maximumAgeText.addModifyListener( textModifyListener );
		 maximumAgeText.addVerifyListener( integerVerifyListener );
		 expireWarningCheckbox.addSelectionListener( buttonSelectionListener );
		 expireWarningCheckbox.addSelectionListener( expireWarningCheckboxSelectionListener );
		 expireWarningText.addModifyListener( textModifyListener );
		 expireWarningText.addVerifyListener( integerVerifyListener );
		 graceAuthenticationLimitCheckbox.addSelectionListener( buttonSelectionListener );
		 graceAuthenticationLimitCheckbox.addSelectionListener( graceAuthenticationLimitCheckboxSelectionListener );
		 graceAuthenticationLimitText.addModifyListener( textModifyListener );
		 graceAuthenticationLimitText.addVerifyListener( integerVerifyListener );
		 graceExpireCheckbox.addSelectionListener( buttonSelectionListener );
		 graceExpireCheckbox.addSelectionListener( graceExpireCheckboxSelectionListener );
		 graceExpireText.addModifyListener( textModifyListener );
		 graceExpireText.addVerifyListener( integerVerifyListener );
		 mustChangeCheckbox.addSelectionListener( buttonSelectionListener );
		 allowUserChangeCheckbox.addSelectionListener( buttonSelectionListener );
		 safeModifyCheckbox.addSelectionListener( buttonSelectionListener );
		 lockoutCheckbox.addSelectionListener( buttonSelectionListener );
		 lockoutDurationText.addModifyListener( textModifyListener );
		 lockoutDurationText.addVerifyListener( integerVerifyListener );
		 maxFailureText.addModifyListener( textModifyListener );
		 maxFailureText.addVerifyListener( integerVerifyListener );
		 failureCountIntervalText.addModifyListener( textModifyListener );
		 failureCountIntervalText.addVerifyListener( integerVerifyListener );
		 maxIdleCheckbox.addSelectionListener( buttonSelectionListener );
		 maxIdleCheckbox.addSelectionListener( maxIdleCheckboxSelectionListener );
		 maxIdleText.addModifyListener( textModifyListener );
		 maxIdleText.addVerifyListener( integerVerifyListener );
		 inHistoryCheckbox.addSelectionListener( buttonSelectionListener );
		 inHistoryCheckbox.addSelectionListener( inHistoryCheckboxSelectionListener );
		 inHistoryText.addModifyListener( textModifyListener );
		 inHistoryText.addVerifyListener( integerVerifyListener );
		 minimumDelayText.addModifyListener( textModifyListener );
		 minimumDelayText.addVerifyListener( integerVerifyListener );
		 maximumDelayText.addModifyListener( textModifyListener );
		 maximumDelayText.addVerifyListener( integerVerifyListener );
	 }
	 private void removeListeners() {
		 enabledCheckbox.removeSelectionListener( buttonSelectionListener );
		 idText.removeModifyListener( textModifyListener );
		 descriptionText.removeModifyListener( textModifyListener );
		 checkQualityComboViewer.removeSelectionChangedListener( viewerSelectionChangedListener );
		 checkQualityComboViewer.removeSelectionChangedListener( checkQualityComboViewerSelectionChangedListener );
		 validatorText.removeModifyListener( textModifyListener );
		 minimumLengthCheckbox.removeSelectionListener( buttonSelectionListener );
		 minimumLengthCheckbox.removeSelectionListener( minimumLengthCheckboxSelectionListener );
		 minimumLengthText.removeModifyListener( textModifyListener );
		 minimumLengthText.removeVerifyListener( integerVerifyListener );
		 maximumLengthCheckbox.removeSelectionListener( buttonSelectionListener );
		 maximumLengthCheckbox.removeSelectionListener( maximumLengthCheckboxSelectionListener );
		 maximumLengthText.removeModifyListener( textModifyListener );
		 maximumLengthText.removeVerifyListener( integerVerifyListener );
		 minimumAgeText.removeModifyListener( textModifyListener );
		 minimumAgeText.removeVerifyListener( integerVerifyListener );
		 maximumAgeText.removeModifyListener( textModifyListener );
		 maximumAgeText.removeVerifyListener( integerVerifyListener );
		 expireWarningCheckbox.removeSelectionListener( buttonSelectionListener );
		 expireWarningCheckbox.removeSelectionListener( expireWarningCheckboxSelectionListener );
		 expireWarningText.removeModifyListener( textModifyListener );
		 expireWarningText.removeVerifyListener( integerVerifyListener );
		 graceAuthenticationLimitCheckbox.removeSelectionListener( buttonSelectionListener );
		 graceAuthenticationLimitCheckbox.removeSelectionListener( graceAuthenticationLimitCheckboxSelectionListener );
		 graceAuthenticationLimitText.removeModifyListener( textModifyListener );
		 graceAuthenticationLimitText.removeVerifyListener( integerVerifyListener );
		 graceExpireCheckbox.removeSelectionListener( buttonSelectionListener );
		 graceExpireCheckbox.removeSelectionListener( graceExpireCheckboxSelectionListener );
		 graceExpireText.removeModifyListener( textModifyListener );
		 graceExpireText.removeVerifyListener( integerVerifyListener );
		 mustChangeCheckbox.removeSelectionListener( buttonSelectionListener );
		 allowUserChangeCheckbox.removeSelectionListener( buttonSelectionListener );
		 safeModifyCheckbox.removeSelectionListener( buttonSelectionListener );
		 lockoutCheckbox.removeSelectionListener( buttonSelectionListener );
		 lockoutDurationText.removeModifyListener( textModifyListener );
		 lockoutDurationText.removeVerifyListener( integerVerifyListener );
		 maxFailureText.removeModifyListener( textModifyListener );
		 maxFailureText.removeVerifyListener( integerVerifyListener );
		 failureCountIntervalText.removeModifyListener( textModifyListener );
		 failureCountIntervalText.removeVerifyListener( integerVerifyListener );
		 maxIdleCheckbox.removeSelectionListener( buttonSelectionListener );
		 maxIdleCheckbox.removeSelectionListener( maxIdleCheckboxSelectionListener );
		 maxIdleText.removeModifyListener( textModifyListener );
		 maxIdleText.removeVerifyListener( integerVerifyListener );
		 inHistoryCheckbox.removeSelectionListener( buttonSelectionListener );
		 inHistoryCheckbox.removeSelectionListener( inHistoryCheckboxSelectionListener );
		 inHistoryText.removeModifyListener( textModifyListener );
		 inHistoryText.removeVerifyListener( integerVerifyListener );
		 minimumDelayText.removeModifyListener( textModifyListener );
		 minimumDelayText.removeVerifyListener( integerVerifyListener );
		 maximumDelayText.removeModifyListener( textModifyListener );
		 maximumDelayText.removeVerifyListener( integerVerifyListener );
	 }
	 public void selectionChanged( IFormPart part, ISelection selection ) {
		 IStructuredSelection ssel = ( IStructuredSelection ) selection;
		 if ( ssel.size() == 1 ) {
			 passwordPolicy = ( PasswordPolicyBean ) ssel.getFirstElement();
		 }
		 else {
			 passwordPolicy = null;
		 }
		 refresh();
	 }
	 public void commit( boolean onSave ) {
		 if ( passwordPolicy != null ) {
			 passwordPolicy.setEnabled( enabledCheckbox.getSelection() );
			 passwordPolicy.setPwdId( ServerConfigurationEditorUtils.checkEmptyString( idText.getText() ) );
			 passwordPolicy .setDescription( ServerConfigurationEditorUtils.checkEmptyString( descriptionText.getText() ) );
			 passwordPolicy.setPwdCheckQuality( getPwdCheckQuality() );
			 passwordPolicy .setPwdValidator( ServerConfigurationEditorUtils.checkEmptyString( validatorText.getText() ) );
			 if ( minimumLengthCheckbox.getSelection() ) {
				 try {
					 passwordPolicy.setPwdMinLength( Integer.parseInt( minimumLengthText.getText() ) );
				 }
				 catch ( NumberFormatException e ) {
					 passwordPolicy.setPwdMinLength( 0 );
				 }
			 }
			 else {
				 passwordPolicy.setPwdMinLength( 0 );
			 }
			 if ( maximumLengthCheckbox.getSelection() ) {
				 try {
					 passwordPolicy.setPwdMaxLength( Integer.parseInt( maximumLengthText.getText() ) );
				 }
				 catch ( NumberFormatException e ) {
					 passwordPolicy.setPwdMaxLength( 0 );
				 }
			 }
			 else {
				 passwordPolicy.setPwdMaxLength( 0 );
			 }
			 try {
				 passwordPolicy.setPwdMinAge( Integer.parseInt( minimumAgeText.getText() ) );
			 }
			 catch ( NumberFormatException e ) {
				 passwordPolicy.setPwdMinAge( 0 );
			 }
			 try {
				 passwordPolicy.setPwdMaxAge( Integer.parseInt( maximumAgeText.getText() ) );
			 }
			 catch ( NumberFormatException e ) {
				 passwordPolicy.setPwdMaxAge( 0 );
			 }
			 if ( expireWarningCheckbox.getSelection() ) {
				 try {
					 passwordPolicy.setPwdExpireWarning( Integer.parseInt( expireWarningText.getText() ) );
				 }
				 catch ( NumberFormatException e ) {
					 passwordPolicy.setPwdExpireWarning( 0 );
				 }
			 }
			 else {
				 passwordPolicy.setPwdExpireWarning( 0 );
			 }
			 if ( graceAuthenticationLimitCheckbox.getSelection() ) {
				 try {
					 passwordPolicy.setPwdGraceAuthNLimit( Integer.parseInt( graceAuthenticationLimitText.getText() ) );
				 }
				 catch ( NumberFormatException e ) {
					 passwordPolicy.setPwdGraceAuthNLimit( 0 );
				 }
			 }
			 else {
				 passwordPolicy.setPwdGraceAuthNLimit( 0 );
			 }
			 if ( graceExpireCheckbox.getSelection() ) {
				 try {
					 passwordPolicy.setPwdGraceExpire( Integer.parseInt( graceExpireText.getText() ) );
				 }
				 catch ( NumberFormatException e ) {
					 passwordPolicy.setPwdGraceExpire( 0 );
				 }
			 }
			 else {
				 passwordPolicy.setPwdGraceExpire( 0 );
			 }
			 passwordPolicy.setPwdMustChange( mustChangeCheckbox.getSelection() );
			 passwordPolicy.setPwdAllowUserChange( allowUserChangeCheckbox.getSelection() );
			 passwordPolicy.setPwdSafeModify( safeModifyCheckbox.getSelection() );
			 passwordPolicy.setPwdLockout( lockoutCheckbox.getSelection() );
			 try {
				 passwordPolicy.setPwdLockoutDuration( Integer.parseInt( lockoutDurationText.getText() ) );
			 }
			 catch ( NumberFormatException e ) {
				 passwordPolicy.setPwdLockoutDuration( 0 );
			 }
			 try {
				 passwordPolicy.setPwdMaxFailure( Integer.parseInt( maxFailureText.getText() ) );
			 }
			 catch ( NumberFormatException e ) {
				 passwordPolicy.setPwdMaxFailure( 0 );
			 }
			 try {
				 passwordPolicy.setPwdFailureCountInterval( Integer.parseInt( failureCountIntervalText.getText() ) );
			 }
			 catch ( NumberFormatException e ) {
				 passwordPolicy.setPwdFailureCountInterval( 0 );
			 }
			 if ( maxIdleCheckbox.getSelection() ) {
				 try {
					 passwordPolicy.setPwdMaxIdle( Integer.parseInt( maxIdleText.getText() ) );
				 }
				 catch ( NumberFormatException e ) {
					 passwordPolicy.setPwdMaxIdle( 0 );
				 }
			 }
			 else {
				 passwordPolicy.setPwdMaxIdle( 0 );
			 }
			 if ( inHistoryCheckbox.getSelection() ) {
				 try {
					 passwordPolicy.setPwdInHistory( Integer.parseInt( inHistoryText.getText() ) );
				 }
				 catch ( NumberFormatException e ) {
					 passwordPolicy.setPwdInHistory( 0 );
				 }
			 }
			 else {
				 passwordPolicy.setPwdInHistory( 0 );
			 }
			 try {
				 passwordPolicy.setPwdMinDelay( Integer.parseInt( minimumDelayText.getText() ) );
			 }
			 catch ( NumberFormatException e ) {
				 passwordPolicy.setPwdMinDelay( 0 );
			 }
			 try {
				 passwordPolicy.setPwdMaxDelay( Integer.parseInt( maximumDelayText.getText() ) );
			 }
			 catch ( NumberFormatException e ) {
				 passwordPolicy.setPwdMaxDelay( 0 );
			 }
		 }
	 }
	 private int getPwdCheckQuality() {
		 IStructuredSelection selection = ( StructuredSelection ) checkQualityComboViewer.getSelection();
		 if ( !selection.isEmpty() ) {
			 CheckQuality checkQuality = ( CheckQuality ) selection.getFirstElement();
			 return checkQuality.getValue();
		 }
		 return CheckQuality.DISABLED.getValue();
	 }
	 public void dispose() {
	 }
	 public void initialize( IManagedForm form ) {
		 this.mform = form;
	 }
	 public boolean isDirty() {
		 return false;
	 }
	 public boolean isStale() {
		 return false;
	 }
	 public void refresh() {
		 removeListeners();
		 if ( passwordPolicy != null ) {
			 boolean isDefaultPasswordPolicy = PasswordPoliciesPage.isDefaultPasswordPolicy( passwordPolicy );
			 enabledCheckbox.setSelection( passwordPolicy.isEnabled() );
			 idText.setText( ServerConfigurationEditorUtils.checkNull( passwordPolicy.getPwdId() ) );
			 idText.setEnabled( !isDefaultPasswordPolicy );
			 descriptionText.setText( ServerConfigurationEditorUtils.checkNull( passwordPolicy.getDescription() ) );
			 descriptionText.setEnabled( !isDefaultPasswordPolicy );
			 checkQualityComboViewer.setSelection( new StructuredSelection( CheckQuality.valueOf( passwordPolicy .getPwdCheckQuality() ) ) );
			 validatorText.setText( ServerConfigurationEditorUtils.checkNull( passwordPolicy.getPwdValidator() ) );
			 int minimumLength = passwordPolicy.getPwdMinLength();
			 minimumLengthCheckbox.setSelection( minimumLength != 0 );
			 minimumLengthText.setText( """" + minimumLength );
			 int maximumLength = passwordPolicy.getPwdMaxLength();
			 maximumLengthCheckbox.setSelection( maximumLength != 0 );
			 maximumLengthText.setText( """" + maximumLength );
			 if ( getPwdCheckQuality() == 0 ) {
				 minimumLengthCheckbox.setEnabled( false );
				 minimumLengthText.setEnabled( false );
				 maximumLengthCheckbox.setEnabled( false );
				 maximumLengthText.setEnabled( false );
			 }
			 else {
				 minimumLengthCheckbox.setEnabled( true );
				 minimumLengthText.setEnabled( minimumLength != 0 );
				 maximumLengthCheckbox.setEnabled( true );
				 maximumLengthText.setEnabled( maximumLength != 0 );
			 }
			 minimumAgeText.setText( """" + passwordPolicy.getPwdMinAge() );
			 maximumAgeText.setText( """" + passwordPolicy.getPwdMaxAge() );
			 int expireWarning = passwordPolicy.getPwdExpireWarning();
			 expireWarningCheckbox.setSelection( expireWarning != 0 );
			 expireWarningText.setText( """" + expireWarning );
			 expireWarningText.setEnabled( expireWarning != 0 );
			 int graceAuthenticationLimit = passwordPolicy.getPwdGraceAuthNLimit();
			 graceAuthenticationLimitCheckbox.setSelection( graceAuthenticationLimit != 0 );
			 graceAuthenticationLimitText.setText( """" + graceAuthenticationLimit );
			 graceAuthenticationLimitText.setEnabled( graceAuthenticationLimit != 0 );
			 int graceExpire = passwordPolicy.getPwdGraceExpire();
			 graceExpireCheckbox.setSelection( graceExpire != 0 );
			 graceExpireText.setText( """" + graceExpire );
			 graceExpireText.setEnabled( graceExpire != 0 );
			 mustChangeCheckbox.setSelection( passwordPolicy.isPwdMustChange() );
			 allowUserChangeCheckbox.setSelection( passwordPolicy.isPwdAllowUserChange() );
			 safeModifyCheckbox.setSelection( passwordPolicy.isPwdSafeModify() );
			 lockoutCheckbox.setSelection( passwordPolicy.isPwdLockout() );
			 lockoutDurationText.setText( """" + passwordPolicy.getPwdLockoutDuration() );
			 maxFailureText.setText( """" + passwordPolicy.getPwdMaxFailure() );
			 failureCountIntervalText.setText( """" + passwordPolicy.getPwdFailureCountInterval() );
			 int maxIdle = passwordPolicy.getPwdMaxIdle();
			 maxIdleCheckbox.setSelection( maxIdle != 0 );
			 maxIdleText.setText( """" + maxIdle );
			 maxIdleText.setEnabled( maxIdle != 0 );
			 int inHistory = passwordPolicy.getPwdInHistory();
			 inHistoryCheckbox.setSelection( inHistory != 0 );
			 inHistoryText.setText( """" + inHistory );
			 inHistoryText.setEnabled( inHistory != 0 );
			 minimumDelayText.setText( """" + passwordPolicy.getPwdMinDelay() );
			 maximumDelayText.setText( """" + passwordPolicy.getPwdMaxDelay() );
		 }
		 addListeners();
	 }
	 public void setFocus() {
	 }
	 public boolean setFormInput( Object input ) {
		 return false;
	 }
	 private enum CheckQuality {
		 DISABLED(0), RELAXED(1), STRICT(2);
		 private int value;
		 private CheckQuality( int value ) {
			 this.value = value;
		 }
		 public int getValue() {
			 return value;
		 }
		 public static CheckQuality valueOf( int value ) {
			 for ( CheckQuality checkQuality : CheckQuality.class.getEnumConstants() ) {
				 if ( checkQuality.getValue() == value ) {
					 return checkQuality;
				 }
			 }
			 throw new IllegalArgumentException( ""There is no CheckQuality value for :"" + value );
		 }
		 public String toString() {
			 switch ( this ) {
				 case DISABLED: return ""Disabled"";
				 case RELAXED: return ""Relaxed"";
				 case STRICT: return ""Strict"";
			 }
			 return super.toString();
		 }
	 }
}",1,1,0,0
"public synchronized Object[] pendingTransfers(DatanodeID srcNode, int xmitsInProgress) {
	 if( isInSafeMode() ) return null;
	 synchronized (neededReplications) {
		 Object results[] = null;
		 int scheduledXfers = 0;
		 if (neededReplications.size() > 0) {
			 List<Block> replicateBlocks = new ArrayList<Block>();
			 List<DatanodeDescriptor[]> replicateTargetSets;
			 replicateTargetSets = new ArrayList<DatanodeDescriptor[]>();
			 for (Iterator<Block> it = neededReplications.iterator();
			 it.hasNext();
			) {
				 if (scheduledXfers >= this.maxReplicationStreams - xmitsInProgress) {
					 break;
				 }
				 Block block = it.next();
				 long blockSize = block.getNumBytes();
				 FSDirectory.INode fileINode = dir.getFileByBlock(block);
				 if (fileINode == null) {
					 it.remove();
				 }
				 else {
					 Collection<DatanodeDescriptor> containingNodes = blocksMap.get(block);
					 Collection<Block> excessBlocks = excessReplicateMap.get( srcNode.getStorageID() );
					 if (containingNodes != null && containingNodes.contains(srcNode) && (excessBlocks == null || ! excessBlocks.contains(block))) {
						 DatanodeDescriptor targets[] = chooseTargets( Math.min( fileINode.getReplication() - containingNodes.size(), this.maxReplicationStreams - xmitsInProgress), containingNodes, null, blockSize);
						 if (targets.length > 0) {
							 replicateBlocks.add(block);
							 replicateTargetSets.add(targets);
							 scheduledXfers += targets.length;
						 }
					 }
				 }
			 }
			 if (replicateBlocks.size() > 0) {
				 int i = 0;
				 for (Iterator<Block> it = replicateBlocks.iterator();
				 it.hasNext();
				 i++) {
					 Block block = it.next();
					 DatanodeDescriptor targets[] = (DatanodeDescriptor[]) replicateTargetSets.get(i);
					 Collection<DatanodeDescriptor> containingNodes = blocksMap.get(block);
					 if (containingNodes.size() + targets.length >= dir.getFileByBlock( block).getReplication() ) {
						 neededReplications.remove(block);
						 pendingReplications.add(block);
						 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.pendingTransfer: "" + block.getBlockName() + "" is removed from neededReplications to pendingReplications"");
					 }
					 if (NameNode.stateChangeLog.isInfoEnabled()) {
						 StringBuffer targetList = new StringBuffer(""datanode(s)"");
						 for (int k = 0;
						 k < targets.length;
						 k++) {
							 targetList.append(' ');
							 targetList.append(targets[k].getName());
						 }
						 NameNode.stateChangeLog.info( ""BLOCK* NameSystem.pendingTransfer: "" + ""ask "" + srcNode.getName() + "" to replicate "" + block.getBlockName() + "" to "" + targetList);
						 NameNode.stateChangeLog.debug( ""BLOCK* neededReplications = "" + neededReplications.size() + "" pendingReplications = "" + pendingReplications.size() );
					 }
				 }
				 DatanodeDescriptor targetMatrix[][] = new DatanodeDescriptor[replicateTargetSets.size()][];
				 for (i = 0;
				 i < targetMatrix.length;
				 i++) {
					 targetMatrix[i] = replicateTargetSets.get(i);
				 }
				 results = new Object[2];
				 results[0] = replicateBlocks.toArray(new Block[replicateBlocks.size()]);
				 results[1] = targetMatrix;
			 }
		 }
		 return results;
	 }
 }",0,0,1,0
"public class Capability implements IConvertible {
	 private String virtualCores;
	 private String memorySize;
	 private String memory;
	 public String getVirtualCores() {
		 return virtualCores;
	 }
	 public void setVirtualCores(String virtualCores) {
		 this.virtualCores = virtualCores;
	 }
	 public String getMemorySize() {
		 return memorySize;
	 }
	 public void setMemorySize(String memorySize) {
		 this.memorySize = memorySize;
	 }
	 public String getMemory() {
		 return memory;
	 }
	 public void setMemory(String memory) {
		 this.memory = memory;
	 }
}",0,1,0,0
"public final class CitrixOvsSetTagAndFlowCommandWrapper extends CommandWrapper<OvsSetTagAndFlowCommand, Answer, CitrixResourceBase> {
	 private static final Logger s_logger = Logger.getLogger(CitrixOvsSetTagAndFlowCommandWrapper.class);
	 public Answer execute(final OvsSetTagAndFlowCommand command, final CitrixResourceBase citrixResourceBase) {
		 citrixResourceBase.setIsOvs(true);
		 final Connection conn = citrixResourceBase.getConnection();
		 try {
			 final Network nw = citrixResourceBase.setupvSwitchNetwork(conn);
			 final String bridge = nw.getBridge(conn);
			 final String result = citrixResourceBase.callHostPlugin(conn, ""ovsgre"", ""ovs_set_tag_and_flow"", ""bridge"", bridge, ""vmName"", command.getVmName(), ""tag"", command.getTag(), ""vlans"", command.getVlans(), ""seqno"", command.getSeqNo());
			 s_logger.debug(""set flow for "" + command.getVmName() + "" "" + result);
			 if (result != null && result.equalsIgnoreCase(""SUCCESS"")) {
				 return new OvsSetTagAndFlowAnswer(command, true, result);
			 }
			 else {
				 return new OvsSetTagAndFlowAnswer(command, false, result);
			 }
		 }
		 catch (final BadServerResponse e) {
			 s_logger.error(""Failed to set tag and flow"", e);
		 }
		 catch (final XenAPIException e) {
			 s_logger.error(""Failed to set tag and flow"", e);
		 }
		 catch (final XmlRpcException e) {
			 s_logger.error(""Failed to set tag and flow"", e);
		 }
		 return new OvsSetTagAndFlowAnswer(command, false, ""EXCEPTION"");
	 }
}",0,0,0,0
"void loadFSImage( Configuration conf ) throws IOException {
	 FSNamesystem fsNamesys = FSNamesystem.getFSNamesystem();
	 FSDirectory fsDir = fsNamesys.dir;
	 for (int idx = 0;
	 idx < imageDirs.length;
	 idx++) {
		 File curFile = new File(imageDirs[idx], FS_IMAGE);
		 File newFile = new File(imageDirs[idx], NEW_FS_IMAGE);
		 File oldFile = new File(imageDirs[idx], OLD_FS_IMAGE);
		 if (oldFile.exists() && curFile.exists()) {
			 oldFile.delete();
			 if (editLog.exists()) {
				 editLog.deleteAll();
			 }
		 }
		 else if (oldFile.exists() && newFile.exists()) {
			 newFile.renameTo(curFile);
			 oldFile.delete();
		 }
		 else if (curFile.exists() && newFile.exists()) {
			 newFile.delete();
		 }
	 }
	 File curFile = null;
	 long maxTimeStamp = Long.MIN_VALUE;
	 for (int idx = 0;
	 idx < imageDirs.length;
	 idx++) {
		 File file = new File(imageDirs[idx], FS_IMAGE);
		 if (file.exists()) {
			 long timeStamp = 0;
			 File timeFile = new File(imageDirs[idx], FS_TIME);
			 if (timeFile.exists() && timeFile.canRead()) {
				 DataInputStream in = new DataInputStream( new FileInputStream(timeFile));
				 try {
					 timeStamp = in.readLong();
				 }
				 finally {
					 in.close();
				 }
			 }
			 if (maxTimeStamp < timeStamp) {
				 maxTimeStamp = timeStamp;
				 curFile = file;
			 }
		 }
	 }
	 boolean needToSave = true;
	 int imgVersion = FSConstants.DFS_CURRENT_VERSION;
	 if (curFile != null) {
		 DataInputStream in = new DataInputStream( new BufferedInputStream( new FileInputStream(curFile)));
		 try {
			 imgVersion = in.readInt();
			 if( imgVersion <= -2 ) fsDir.namespaceID = in.readInt();
			 int numFiles = 0;
			 if( imgVersion >= 0 ) {
				 numFiles = imgVersion;
				 imgVersion = 0;
			 }
			 else numFiles = in.readInt();
			 needToSave = ( imgVersion != FSConstants.DFS_CURRENT_VERSION );
			 if( imgVersion < FSConstants.DFS_CURRENT_VERSION ) throw new IncorrectVersionException(imgVersion, ""file system image"");
			 short replication = (short)conf.getInt(""dfs.replication"", 3);
			 for (int i = 0;
			 i < numFiles;
			 i++) {
				 UTF8 name = new UTF8();
				 name.readFields(in);
				 if( !(imgVersion >= 0) ) {
					 replication = in.readShort();
					 replication = FSEditLog.adjustReplication( replication, conf );
				 }
				 int numBlocks = in.readInt();
				 Block blocks[] = null;
				 if (numBlocks > 0) {
					 blocks = new Block[numBlocks];
					 for (int j = 0;
					 j < numBlocks;
					 j++) {
						 blocks[j] = new Block();
						 blocks[j].readFields(in);
					 }
				 }
				 fsDir.unprotectedAddFile(name, blocks, replication );
			 }
			 this.loadDatanodes( imgVersion, in );
		 }
		 finally {
			 in.close();
		 }
	 }
	 if( fsDir.namespaceID == 0 ) fsDir.namespaceID = newNamespaceID();
	 needToSave |= ( editLog.exists() && editLog.loadFSEdits(conf) > 0 );
	 if( needToSave ) saveFSImage();
 }",0,0,1,0
"public BufferedImage processImage(BufferedImage image) {
	 originalImage = image;
	 int width = image.getWidth();
	 int height = image.getHeight();
	 filteredImage = new BufferedImage(width, height, image.getType());
	 treshold = 0.1;
	 generateSobelOperators();
	 double [][] Gx = new double[width][height];
	 double [][] Gy = new double[width][height];
	 double [][] G = new double[width][height];
	 double max = 0;
	 for (int i = 1;
	 i < width-1;
	 i++) {
		 for (int j = 1;
		 j < height-1;
		 j++) {
			 Gx[i][j] = calculateGradient(i, j, sobelX);
			 Gy[i][j] = calculateGradient(i, j, sobelY);
			 G[i][j] = Math.abs(Gx[i][j]) + Math.abs(Gy[i][j]);
			 if (G[i][j] > max) max = G[i][j];
		 }
	 }
	 treshold = treshold*max;
	 for (int i = 0;
	 i < width;
	 i++) {
		 for (int j = 0;
		 j < height;
		 j++) {
			 int newColor;
			 int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
			 if (G[i][j] > treshold) newColor = 0;
			 else newColor = 255;
			 int rgb = ImageUtilities.colorToRGB(alpha, newColor, newColor, newColor);
			 filteredImage.setRGB(i, j, rgb);
		 }
	 }
	 return filteredImage;
 }",0,0,1,0
"public class ArrayWritable implements Writable {
	 private Class valueClass;
	 private Writable[] values;
	 public ArrayWritable() {
		 this.valueClass = null;
	 }
	 public ArrayWritable(Class valueClass) {
		 this.valueClass = valueClass;
	 }
	 public ArrayWritable(Class valueClass, Writable[] values) {
		 this(valueClass);
		 this.values = values;
	 }
	 public ArrayWritable(String[] strings) {
		 this(UTF8.class, new Writable[strings.length]);
		 for (int i = 0;
		 i < strings.length;
		 i++) {
			 values[i] = new UTF8(strings[i]);
		 }
	 }
	 public void setValueClass(Class valueClass) {
		 if (valueClass != this.valueClass) {
			 this.valueClass = valueClass;
			 this.values = null;
		 }
	 }
	 public Class getValueClass() {
		 return valueClass;
	 }
	 public String[] toStrings() {
		 String[] strings = new String[values.length];
		 for (int i = 0;
		 i < values.length;
		 i++) {
			 strings[i] = values[i].toString();
		 }
		 return strings;
	 }
	 public Object toArray() {
		 Object result = Array.newInstance(valueClass, values.length);
		 for (int i = 0;
		 i < values.length;
		 i++) {
			 Array.set(result, i, values[i]);
		 }
		 return result;
	 }
	 public void set(Writable[] values) {
		 this.values = values;
	 }
	 public Writable[] get() {
		 return values;
	 }
	 public void readFields(DataInput in) throws IOException {
		 values = new Writable[in.readInt()];
		 for (int i = 0;
		 i < values.length;
		 i++) {
			 Writable value = WritableFactories.newInstance(valueClass);
			 value.readFields(in);
			 values[i] = value;
		 }
	 }
	 public void write(DataOutput out) throws IOException {
		 out.writeInt(values.length);
		 for (int i = 0;
		 i < values.length;
		 i++) {
			 values[i].write(out);
		 }
	 }
}",0,0,0,0
"public Draw(String props, boolean no_channel, boolean jmx, boolean use_state, long state_timeout, boolean use_blocking, boolean use_unicasts, String name) throws Exception;",0,0,0,1
"public class DeleteIndexAction implements ExpirationAction {
	 private static final Logger logger = LoggerFactory.getLogger(DeleteIndexAction.class);
	 private final PersistentProvenanceRepository repository;
	 private final IndexConfiguration indexConfiguration;
	 private final IndexManager indexManager;
	 public DeleteIndexAction(final PersistentProvenanceRepository repo, final IndexConfiguration indexConfiguration, final IndexManager indexManager) {
		 this.repository = repo;
		 this.indexConfiguration = indexConfiguration;
		 this.indexManager = indexManager;
	 }
	 public File execute(final File expiredFile) throws IOException {
		 final long numDeleted = 0;
		 long maxEventId = -1L;
		 try (final RecordReader reader = RecordReaders.newRecordReader(expiredFile, repository.getAllLogFiles(), Integer.MAX_VALUE)) {
			 maxEventId = reader.getMaxEventId();
		 }
		 catch (final IOException ioe) {
			 logger.warn(""Failed to obtain max ID present in journal file {
			}
			"", expiredFile.getAbsolutePath());
		 }
		 final List<File> indexDirs = indexConfiguration.getIndexDirectories(expiredFile);
		 for (final File indexingDirectory : indexDirs) {
			 final Term term = new Term(FieldNames.STORAGE_FILENAME, LuceneUtil.substringBefore(expiredFile.getName(), "".""));
			 boolean deleteDir = false;
			 final EventIndexWriter writer = indexManager.borrowIndexWriter(indexingDirectory);
			 try {
				 final IndexWriter indexWriter = writer.getIndexWriter();
				 indexWriter.deleteDocuments(term);
				 indexWriter.commit();
				 final int docsLeft = indexWriter.numDocs();
				 deleteDir = docsLeft <= 0;
				 logger.debug(""After expiring {
				}
				, there are {
				}
				 docs left for index {
				}
				"", expiredFile, docsLeft, indexingDirectory);
			 }
			 finally {
				 indexManager.returnIndexWriter(writer);
			 }
			 if (deleteDir) {
				 indexManager.removeIndex(indexingDirectory);
				 indexConfiguration.removeIndexDirectory(indexingDirectory);
				 deleteDirectory(indexingDirectory);
				 logger.info(""Removed empty index directory {
				}
				"", indexingDirectory);
			 }
		 }
		 if (maxEventId > -1L) {
			 indexConfiguration.setMinIdIndexed(maxEventId + 1L);
		 }
		 logger.info(""Deleted Indices for Expired Provenance File {
		}
		 from {
		}
		 index files;
		 {
		}
		 documents removed"", expiredFile, indexDirs.size(), numDeleted);
		 return expiredFile;
	 }
	 private void deleteDirectory(final File dir) {
		 if (dir == null || !dir.exists()) {
			 return;
		 }
		 final File[] children = dir.listFiles();
		 if (children == null) {
			 return;
		 }
		 for (final File child : children) {
			 if (child.isDirectory()) {
				 deleteDirectory(child);
			 }
			 else if (!child.delete()) {
				 logger.warn(""Unable to remove index directory {
				}
				;
				 this directory should be cleaned up manually"", child.getAbsolutePath());
			 }
		 }
		 if (!dir.delete()) {
			 logger.warn(""Unable to remove index directory {
			}
			;
			 this directory should be cleaned up manually"", dir);
		 }
	 }
	 public boolean hasBeenPerformed(final File expiredFile) throws IOException {
		 return false;
	 }
}",1,0,0,0
"public static IPartitioner getPartitioner(Configuration conf) {
	 try {
		 return FBUtilities.newPartitioner(conf.get(PARTITIONER_CONFIG));
	 }
	 catch (ConfigurationException e) {
		 throw new RuntimeException(e);
	 }
 }",0,0,0,0
"public class ConsoleProxyClientParam {
	 private String clientHostAddress;
	 private int clientHostPort;
	 private String clientHostPassword;
	 private String clientTag;
	 private String ticket;
	 private String locale;
	 private String clientTunnelUrl;
	 private String clientTunnelSession;
	 private String hypervHost;
	 private String ajaxSessionId;
	 private String username;
	 private String password;
	 public ConsoleProxyClientParam() {
		 clientHostPort = 0;
	 }
	 public String getClientHostAddress() {
		 return clientHostAddress;
	 }
	 public void setClientHostAddress(String clientHostAddress) {
		 this.clientHostAddress = clientHostAddress;
	 }
	 public int getClientHostPort() {
		 return clientHostPort;
	 }
	 public void setClientHostPort(int clientHostPort) {
		 this.clientHostPort = clientHostPort;
	 }
	 public String getClientHostPassword() {
		 return clientHostPassword;
	 }
	 public void setClientHostPassword(String clientHostPassword) {
		 this.clientHostPassword = clientHostPassword;
	 }
	 public String getClientTag() {
		 return clientTag;
	 }
	 public void setClientTag(String clientTag) {
		 this.clientTag = clientTag;
	 }
	 public String getTicket() {
		 return ticket;
	 }
	 public void setTicket(String ticket) {
		 this.ticket = ticket;
	 }
	 public String getClientTunnelUrl() {
		 return clientTunnelUrl;
	 }
	 public void setClientTunnelUrl(String clientTunnelUrl) {
		 this.clientTunnelUrl = clientTunnelUrl;
	 }
	 public String getClientTunnelSession() {
		 return clientTunnelSession;
	 }
	 public void setClientTunnelSession(String clientTunnelSession) {
		 this.clientTunnelSession = clientTunnelSession;
	 }
	 public String getAjaxSessionId() {
		 return ajaxSessionId;
	 }
	 public void setAjaxSessionId(String ajaxSessionId) {
		 this.ajaxSessionId = ajaxSessionId;
	 }
	 public String getLocale() {
		 return locale;
	 }
	 public void setLocale(String locale) {
		 this.locale = locale;
	 }
	 public String getClientMapKey() {
		 if (clientTag != null && !clientTag.isEmpty()) return clientTag;
		 return clientHostAddress + "":"" + clientHostPort;
	 }
	 public void setHypervHost(String host) {
		 hypervHost = host;
	 }
	 public String getHypervHost() {
		 return hypervHost;
	 }
	 public void setUsername(String username) {
		 this.username = username;
	 }
	 public String getUsername() {
		 return username;
	 }
	 public void setPassword(String password) {
		 this.password = password;
	 }
	 public String getPassword() {
		 return password;
	 }
}",1,1,0,0
"public class HttpTool {
	 private static final Logger LOG = LoggerFactory.getLogger(HttpTool.class);
	 static final ExecutorService executor = Executors.newCachedThreadPool();
	 public static URLConnection connectToUrl(String u) throws Exception {
		 final URL url = new URL(u);
		 final AtomicReference<Exception> exception = new AtomicReference<Exception>();
		 Future<URLConnection> f = executor.submit(new Callable<URLConnection>() {
			 public URLConnection call() {
				 try {
					 HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
						 public boolean verify(String s, SSLSession sslSession) {
							 return true;
						 }
					 }
					);
					 URLConnection connection = url.openConnection();
					 TrustingSslSocketFactory.configure(connection);
					 connection.connect();
					 connection.getContentLength();
					 return connection;
				 }
				 catch (Exception e) {
					 exception.set(e);
					 LOG.debug(""Error connecting to url ""+url+"" (propagating): ""+e, e);
				 }
				 return null;
			 }
		 }
		);
		 try {
			 URLConnection result = null;
			 try {
				 result = f.get(60, TimeUnit.SECONDS);
			 }
			 catch (InterruptedException e) {
				 throw e;
			 }
			 catch (Exception e) {
				 LOG.debug(""Error connecting to url ""+url+"", probably timed out (rethrowing): ""+e);
				 throw new IllegalStateException(""Connect to URL not complete within 60 seconds, for url ""+url+"": ""+e);
			 }
			 if (exception.get() != null) {
				 LOG.debug(""Error connecting to url ""+url+"", thread caller of ""+exception, new Throwable(""source of rethrown error ""+exception));
				 throw exception.get();
			 }
			 else {
				 return result;
			 }
		 }
		 finally {
			 f.cancel(true);
		 }
	 }
	 public static int getHttpStatusCode(String url) throws Exception {
		 URLConnection connection = connectToUrl(url);
		 long startTime = System.currentTimeMillis();
		 int status = ((HttpURLConnection) connection).getResponseCode();
		 consumeAndCloseQuietly((HttpURLConnection) connection);
		 if (LOG.isDebugEnabled()) LOG.debug(""connection to {
		}
		 ({
		}
		ms) gives {
		}
		"", new Object[] {
		 url, (System.currentTimeMillis()-startTime), status }
		);
		 return status;
	 }
	 public static String getContent(String url) {
		 try {
			 return Streams.readFullyString(SslTrustUtils.trustAll(new URL(url).openConnection()).getInputStream());
		 }
		 catch (Exception e) {
			 throw Throwables.propagate(e);
		 }
	 }
	 public static String getErrorContent(String url) {
		 try {
			 HttpURLConnection connection = (HttpURLConnection) connectToUrl(url);
			 long startTime = System.currentTimeMillis();
			 String err;
			 int status;
			 try {
				 InputStream errStream = connection.getErrorStream();
				 err = Streams.readFullyString(errStream);
				 status = connection.getResponseCode();
			 }
			 finally {
				 closeQuietly(connection);
			 }
			 if (LOG.isDebugEnabled()) LOG.debug(""read of err {
			}
			 ({
			}
			ms) complete;
			 http code {
			}
			"", new Object[] {
			 url, Time.makeTimeStringRounded(System.currentTimeMillis() - startTime), status}
			);
			 return err;
		 }
		 catch (Exception e) {
			 throw Exceptions.propagate(e);
		 }
	 }
	 public static void consumeAndCloseQuietly(HttpURLConnection connection) {
		 try {
			 Streams.readFully(connection.getInputStream());
		 }
		 catch (Exception e) {
		}
		 closeQuietly(connection);
	 }
	 public static void closeQuietly(HttpURLConnection connection) {
		 try {
			 connection.disconnect();
		 }
		 catch (Exception e) {
		}
		 try {
			 connection.getInputStream().close();
		 }
		 catch (Exception e) {
		}
		 try {
			 connection.getOutputStream().close();
		 }
		 catch (Exception e) {
		}
		 try {
			 connection.getErrorStream().close();
		 }
		 catch (Exception e) {
		}
	 }
	 public static class TrustAllStrategy implements TrustStrategy {
		 public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {
			 return true;
		 }
	 }
	 public static HttpClientBuilder httpClientBuilder() {
		 return new HttpClientBuilder();
	 }
	 public static class HttpClientBuilder {
		 private ClientConnectionManager clientConnectionManager;
		 private HttpParams httpParams;
		 private URI uri;
		 private Integer port;
		 private Credentials credentials;
		 private boolean laxRedirect;
		 private Boolean https;
		 private SchemeSocketFactory socketFactory;
		 private ConnectionReuseStrategy reuseStrategy;
		 private boolean trustAll;
		 private boolean trustSelfSigned;
		 public HttpClientBuilder clientConnectionManager(ClientConnectionManager val) {
			 this.clientConnectionManager = checkNotNull(val, ""clientConnectionManager"");
			 return this;
		 }
		 public HttpClientBuilder httpParams(HttpParams val) {
			 checkState(httpParams == null, ""Must not call httpParams multiple times, or after other methods like connectionTimeout"");
			 this.httpParams = checkNotNull(val, ""httpParams"");
			 return this;
		 }
		 public HttpClientBuilder connectionTimeout(Duration val) {
			 if (httpParams == null) httpParams = new BasicHttpParams();
			 long millis = checkNotNull(val, ""connectionTimeout"").toMilliseconds();
			 if (millis > Integer.MAX_VALUE) throw new IllegalStateException(""HttpClient only accepts upto max-int millis for connectionTimeout, but given ""+val);
			 HttpConnectionParams.setConnectionTimeout(httpParams, (int) millis);
			 return this;
		 }
		 public HttpClientBuilder socketTimeout(Duration val) {
			 if (httpParams == null) httpParams = new BasicHttpParams();
			 long millis = checkNotNull(val, ""socketTimeout"").toMilliseconds();
			 if (millis > Integer.MAX_VALUE) throw new IllegalStateException(""HttpClient only accepts upto max-int millis for socketTimeout, but given ""+val);
			 HttpConnectionParams.setSoTimeout(httpParams, (int) millis);
			 return this;
		 }
		 public HttpClientBuilder reuseStrategy(ConnectionReuseStrategy val) {
			 this.reuseStrategy = checkNotNull(val, ""reuseStrategy"");
			 return this;
		 }
		 public HttpClientBuilder uri(String val) {
			 return uri(URI.create(checkNotNull(val, ""uri"")));
		 }
		 public HttpClientBuilder uri(URI val) {
			 this.uri = checkNotNull(val, ""uri"");
			 if (https == null) https = (""https"".equalsIgnoreCase(uri.getScheme()));
			 return this;
		 }
		 public HttpClientBuilder port(int val) {
			 this.port = val;
			 return this;
		 }
		 public HttpClientBuilder credentials(Credentials val) {
			 this.credentials = checkNotNull(val, ""credentials"");
			 return this;
		 }
		 public void credential(Optional<Credentials> val) {
			 if (val.isPresent()) credentials = val.get();
		 }
		 public HttpClientBuilder laxRedirect(boolean val) {
			 this.laxRedirect = val;
			 return this;
		 }
		 public HttpClientBuilder https(boolean val) {
			 this.https = val;
			 return this;
		 }
		 public HttpClientBuilder socketFactory(SchemeSocketFactory val) {
			 this.socketFactory = checkNotNull(val, ""socketFactory"");
			 return this;
		 }
		 public HttpClientBuilder trustAll() {
			 this.trustAll = true;
			 return this;
		 }
		 public HttpClientBuilder trustSelfSigned() {
			 this.trustSelfSigned = true;
			 return this;
		 }
		 public HttpClient build() {
			 final DefaultHttpClient httpClient = new DefaultHttpClient(clientConnectionManager);
			 httpClient.setParams(httpParams);
			 if (laxRedirect) {
				 httpClient.setRedirectStrategy(new LaxRedirectStrategy());
			 }
			 if (reuseStrategy != null) {
				 httpClient.setReuseStrategy(reuseStrategy);
			 }
			 if (https == Boolean.TRUE || (uri!=null && uri.toString().startsWith(""https:""))) {
				 try {
					 if (port == null) {
						 port = (uri != null && uri.getPort() >= 0) ? uri.getPort() : 443;
					 }
					 if (socketFactory == null) {
						 if (trustAll) {
							 TrustStrategy trustStrategy = new TrustAllStrategy();
							 X509HostnameVerifier hostnameVerifier = SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;
							 socketFactory = new SSLSocketFactory(trustStrategy, hostnameVerifier);
						 }
						 else if (trustSelfSigned) {
							 TrustStrategy trustStrategy = new TrustSelfSignedStrategy();
							 X509HostnameVerifier hostnameVerifier = SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;
							 socketFactory = new SSLSocketFactory(trustStrategy, hostnameVerifier);
						 }
						 else {
						 }
					 }
					 if (socketFactory != null) {
						 Scheme sch = new Scheme(""https"", port, socketFactory);
						 httpClient.getConnectionManager().getSchemeRegistry().register(sch);
					 }
				 }
				 catch (Exception e) {
					 LOG.warn(""Error setting trust for uri {
					}
					"", uri);
					 throw Exceptions.propagate(e);
				 }
			 }
			 if (uri != null && credentials != null) {
				 String hostname = uri.getHost();
				 int port = uri.getPort();
				 httpClient.getCredentialsProvider().setCredentials(new AuthScope(hostname, port), credentials);
			 }
			 if (uri==null && credentials!=null) {
				 LOG.warn(""credentials have no effect in builder unless URI for host is specified"");
			 }
			 return httpClient;
		 }
	 }
	 protected static abstract class HttpRequestBuilder<B extends HttpRequestBuilder<B, R>, R extends HttpRequest> {
		 protected R req;
		 protected HttpRequestBuilder(R req) {
			 this.req = req;
		 }
		 protected B self() {
			 return (B) this;
		 }
		 public B headers(Map<String,String> headers) {
			 if (headers!=null) {
				 for (Map.Entry<String,String> entry : headers.entrySet()) {
					 req.addHeader(entry.getKey(), entry.getValue());
				 }
			 }
			 return self();
		 }
		 public B headers(Multimap<String,String> headers) {
			 if (headers!=null) {
				 for (Map.Entry<String,String> entry : headers.entries()) {
					 req.addHeader(entry.getKey(), entry.getValue());
				 }
			 }
			 return self();
		 }
		 public R build() {
			 return req;
		 }
	 }
	 protected static abstract class HttpEntityEnclosingRequestBaseBuilder<B extends HttpEntityEnclosingRequestBaseBuilder<B,R>, R extends HttpEntityEnclosingRequestBase> extends HttpRequestBuilder<B, R> {
		 protected HttpEntityEnclosingRequestBaseBuilder(R req) {
			 super(req);
		 }
		 public B body(byte[] body) {
			 if (body != null) {
				 HttpEntity httpEntity = new ByteArrayEntity(body);
				 req.setEntity(httpEntity);
			 }
			 return self();
		 }
	 }
	 public static class HttpGetBuilder extends HttpRequestBuilder<HttpGetBuilder, HttpGet> {
		 public HttpGetBuilder(URI uri) {
			 super(new HttpGet(uri));
		 }
	 }
	 public static class HttpHeadBuilder extends HttpRequestBuilder<HttpHeadBuilder, HttpHead> {
		 public HttpHeadBuilder(URI uri) {
			 super(new HttpHead(uri));
		 }
	 }
	 public static class HttpDeleteBuilder extends HttpRequestBuilder<HttpDeleteBuilder, HttpDelete> {
		 public HttpDeleteBuilder(URI uri) {
			 super(new HttpDelete(uri));
		 }
	 }
	 public static class HttpPostBuilder extends HttpEntityEnclosingRequestBaseBuilder<HttpPostBuilder, HttpPost> {
		 HttpPostBuilder(URI uri) {
			 super(new HttpPost(uri));
		 }
	 }
	 public static class HttpFormPostBuilder extends HttpRequestBuilder<HttpFormPostBuilder, HttpPost> {
		 HttpFormPostBuilder(URI uri) {
			 super(new HttpPost(uri));
		 }
		 public HttpFormPostBuilder params(Map<String, String> params) {
			 if (params != null) {
				 Collection<NameValuePair> httpParams = new ArrayList<NameValuePair>(params.size());
				 for (Entry<String, String> param : params.entrySet()) {
					 httpParams.add(new BasicNameValuePair(param.getKey(), param.getValue()));
				 }
				 req.setEntity(new UrlEncodedFormEntity(httpParams));
			 }
			 return self();
		 }
	 }
	 public static class HttpPutBuilder extends HttpEntityEnclosingRequestBaseBuilder<HttpPutBuilder, HttpPut> {
		 public HttpPutBuilder(URI uri) {
			 super(new HttpPut(uri));
		 }
	 }
	 public static HttpToolResponse httpGet(HttpClient httpClient, URI uri, Map<String,String> headers) {
		 HttpGet req = new HttpGetBuilder(uri).headers(headers).build();
		 return execAndConsume(httpClient, req);
	 }
	 public static HttpToolResponse httpPost(HttpClient httpClient, URI uri, Map<String,String> headers, byte[] body) {
		 HttpPost req = new HttpPostBuilder(uri).headers(headers).body(body).build();
		 return execAndConsume(httpClient, req);
	 }
	 public static HttpToolResponse httpPut(HttpClient httpClient, URI uri, Map<String, String> headers, byte[] body) {
		 HttpPut req = new HttpPutBuilder(uri).headers(headers).body(body).build();
		 return execAndConsume(httpClient, req);
	 }
	 public static HttpToolResponse httpPost(HttpClient httpClient, URI uri, Map<String,String> headers, Map<String, String> params) {
		 HttpPost req = new HttpFormPostBuilder(uri).headers(headers).params(params).build();
		 return execAndConsume(httpClient, req);
	 }
	 public static HttpToolResponse httpDelete(HttpClient httpClient, URI uri, Map<String,String> headers) {
		 HttpDelete req = new HttpDeleteBuilder(uri).headers(headers).build();
		 return execAndConsume(httpClient, req);
	 }
	 public static HttpToolResponse httpHead(HttpClient httpClient, URI uri, Map<String,String> headers) {
		 HttpHead req = new HttpHeadBuilder(uri).headers(headers).build();
		 return execAndConsume(httpClient, req);
	 }
	 public static HttpToolResponse execAndConsume(HttpClient httpClient, HttpUriRequest req) {
		 long startTime = System.currentTimeMillis();
		 try {
			 HttpResponse httpResponse = httpClient.execute(req);
			 try {
				 return new HttpToolResponse(httpResponse, startTime);
			 }
			 finally {
				 EntityUtils.consume(httpResponse.getEntity());
			 }
		 }
		 catch (Exception e) {
			 throw Exceptions.propagate(e);
		 }
	 }
	 public static boolean isStatusCodeHealthy(int code) {
		 return (code>=200 && code<=299);
	 }
	 public static String toBasicAuthorizationValue(UsernamePasswordCredentials credentials) {
		 return ""Basic ""+Base64.encodeBase64String( (credentials.getUserName()+"":""+credentials.getPassword()).getBytes() );
	 }
	 public static String encodeUrlParams(Map<?,?> data) {
		 if (data==null) return """";
		 Iterable<String> args = Iterables.transform(data.entrySet(), new Function<Map.Entry<?,?>,String>() {
			 public String apply(Map.Entry<?,?> entry) {
				 Object k = entry.getKey();
				 Object v = entry.getValue();
				 return URLParamEncoder.encode(Strings.toString(k)) + (v != null ? ""="" + URLParamEncoder.encode(Strings.toString(v)) : """");
			 }
		 }
		);
		 return Joiner.on(""&"").join(args);
	 }
}",0,0,0,0
"public class SequenceFile {
	 public static final Log LOG = LogFactory.getLog(""org.apache.hadoop.io.SequenceFile"");
	 private SequenceFile() {
	}
	 private static final byte BLOCK_COMPRESS_VERSION = (byte)4;
	 private static final byte CUSTOM_COMPRESS_VERSION = (byte)5;
	 private static byte[] VERSION = new byte[] {
	 (byte)'S', (byte)'E', (byte)'Q', CUSTOM_COMPRESS_VERSION }
	;
	 private static final int SYNC_ESCAPE = -1;
	 private static final int SYNC_HASH_SIZE = 16;
	 private static final int SYNC_SIZE = 4+SYNC_HASH_SIZE;
	 public static final int SYNC_INTERVAL = 100*SYNC_SIZE;
	 public static enum CompressionType {
	 NONE, RECORD, BLOCK }
	 static public CompressionType getCompressionType(Configuration job) {
		 String name = job.get(""io.seqfile.compression.type"");
		 return name == null ? CompressionType.RECORD : CompressionType.valueOf(name);
	 }
	 static public void setCompressionType(Configuration job, CompressionType val) {
		 job.set(""io.seqfile.compression.type"", val.toString());
	 }
	 public static Writer createWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass) throws IOException {
		 return createWriter(fs,conf,name,keyClass,valClass, getCompressionType(conf));
	 }
	 public static Writer createWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType) throws IOException {
		 Writer writer = null;
		 if (compressionType == CompressionType.NONE) {
			 writer = new Writer(fs, conf, name, keyClass, valClass);
		 }
		 else if (compressionType == CompressionType.RECORD) {
			 writer = new RecordCompressWriter(fs, conf, name, keyClass, valClass, new DefaultCodec());
		 }
		 else if (compressionType == CompressionType.BLOCK){
			 writer = new BlockCompressWriter(fs, conf, name, keyClass, valClass, new DefaultCodec());
		 }
		 return writer;
	 }
	 public static Writer createWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, Progressable progress) throws IOException {
		 Writer writer = null;
		 if (compressionType == CompressionType.NONE) {
			 writer = new Writer(fs, conf, name, keyClass, valClass, progress);
		 }
		 else if (compressionType == CompressionType.RECORD) {
			 writer = new RecordCompressWriter(fs, conf, name, keyClass, valClass, new DefaultCodec(), progress);
		 }
		 else if (compressionType == CompressionType.BLOCK){
			 writer = new BlockCompressWriter(fs, conf, name, keyClass, valClass, new DefaultCodec(), progress);
		 }
		 return writer;
	 }
	 public static Writer createWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, CompressionCodec codec) throws IOException {
		 if ((codec instanceof GzipCodec) && !NativeCodeLoader.isNativeCodeLoaded() && !ZlibFactory.isNativeZlibLoaded()) {
			 throw new IllegalArgumentException(""SequenceFile doesn't work with "" + ""GzipCodec without native-hadoop code!"");
		 }
		 Writer writer = null;
		 if (compressionType == CompressionType.NONE) {
			 writer = new Writer(fs, conf, name, keyClass, valClass);
		 }
		 else if (compressionType == CompressionType.RECORD) {
			 writer = new RecordCompressWriter(fs, conf, name, keyClass, valClass, codec);
		 }
		 else if (compressionType == CompressionType.BLOCK){
			 writer = new BlockCompressWriter(fs, conf, name, keyClass, valClass, codec);
		 }
		 return writer;
	 }
	 public static Writer createWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, CompressionCodec codec, Progressable progress) throws IOException {
		 if ((codec instanceof GzipCodec) && !NativeCodeLoader.isNativeCodeLoaded() && !ZlibFactory.isNativeZlibLoaded()) {
			 throw new IllegalArgumentException(""SequenceFile doesn't work with "" + ""GzipCodec without native-hadoop code!"");
		 }
		 Writer writer = null;
		 if (compressionType == CompressionType.NONE) {
			 writer = new Writer(fs, conf, name, keyClass, valClass, progress);
		 }
		 else if (compressionType == CompressionType.RECORD) {
			 writer = new RecordCompressWriter(fs, conf, name, keyClass, valClass, codec, progress);
		 }
		 else if (compressionType == CompressionType.BLOCK){
			 writer = new BlockCompressWriter(fs, conf, name, keyClass, valClass, codec, progress);
		 }
		 return writer;
	 }
	 private static Writer createWriter(Configuration conf, FSDataOutputStream out, Class keyClass, Class valClass, boolean compress, boolean blockCompress, CompressionCodec codec) throws IOException {
		 if ((codec instanceof GzipCodec) && !NativeCodeLoader.isNativeCodeLoaded() && !ZlibFactory.isNativeZlibLoaded()) {
			 throw new IllegalArgumentException(""SequenceFile doesn't work with "" + ""GzipCodec without native-hadoop code!"");
		 }
		 Writer writer = null;
		 if (!compress) {
			 writer = new Writer(conf, out, keyClass, valClass);
		 }
		 else if (compress && !blockCompress) {
			 writer = new RecordCompressWriter(conf, out, keyClass, valClass, codec);
		 }
		 else {
			 writer = new BlockCompressWriter(conf, out, keyClass, valClass, codec);
		 }
		 return writer;
	 }
	 public static interface ValueBytes {
		 public void writeUncompressedBytes(DataOutputStream outStream) throws IOException;
		 public void writeCompressedBytes(DataOutputStream outStream) throws IllegalArgumentException, IOException;
	 }
	 private static class UncompressedBytes implements ValueBytes {
		 private int dataSize;
		 private byte[] data;
		 private UncompressedBytes() {
			 data = null;
			 dataSize = 0;
		 }
		 private void reset(DataInputStream in, int length) throws IOException {
			 data = new byte[length];
			 dataSize = -1;
			 in.readFully(data);
			 dataSize = data.length;
		 }
		 public int getSize() {
			 return dataSize;
		 }
		 public void writeUncompressedBytes(DataOutputStream outStream) throws IOException {
			 outStream.write(data, 0, dataSize);
		 }
		 public void writeCompressedBytes(DataOutputStream outStream) throws IllegalArgumentException, IOException {
			 throw new IllegalArgumentException(""UncompressedBytes cannot be compressed!"");
		 }
	 }
	 private static class CompressedBytes implements ValueBytes {
		 private int dataSize;
		 private byte[] data;
		 DataInputBuffer rawData = null;
		 CompressionCodec codec = null;
		 CompressionInputStream decompressedStream = null;
		 private CompressedBytes(CompressionCodec codec) {
			 data = null;
			 dataSize = 0;
			 this.codec = codec;
		 }
		 private void reset(DataInputStream in, int length) throws IOException {
			 data = new byte[length];
			 dataSize = -1;
			 in.readFully(data);
			 dataSize = data.length;
		 }
		 public int getSize() {
			 return dataSize;
		 }
		 public void writeUncompressedBytes(DataOutputStream outStream) throws IOException {
			 if (decompressedStream == null) {
				 rawData = new DataInputBuffer();
				 decompressedStream = codec.createInputStream(rawData);
			 }
			 else {
				 decompressedStream.resetState();
			 }
			 rawData.reset(data, 0, dataSize);
			 byte[] buffer = new byte[8192];
			 int bytesRead = 0;
			 while ((bytesRead = decompressedStream.read(buffer, 0, 8192)) != -1) {
				 outStream.write(buffer, 0, bytesRead);
			 }
		 }
		 public void writeCompressedBytes(DataOutputStream outStream) throws IllegalArgumentException, IOException {
			 outStream.write(data, 0, dataSize);
		 }
	 }
	 public static class Writer {
		 Configuration conf;
		 FSDataOutputStream out;
		 DataOutputBuffer buffer = new DataOutputBuffer();
		 Path target = null;
		 Class keyClass;
		 Class valClass;
		 private boolean compress;
		 CompressionCodec codec = null;
		 CompressionOutputStream deflateFilter = null;
		 DataOutputStream deflateOut = null;
		 long lastSyncPos;
		 byte[] sync;
		 {
			 try {
				 MessageDigest digester = MessageDigest.getInstance(""MD5"");
				 digester.update((new UID()+""@""+InetAddress.getLocalHost()).getBytes());
				 sync = digester.digest();
			 }
			 catch (Exception e) {
				 throw new RuntimeException(e);
			 }
		 }
		 Writer() {
		}
		 public Writer(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass) throws IOException {
			 this(fs, conf, name, keyClass, valClass, null);
		 }
		 public Writer(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, Progressable progress) throws IOException {
			 init(name, conf, fs.create(name, progress), keyClass, valClass, false, null);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 private Writer(Configuration conf, FSDataOutputStream out, Class keyClass, Class valClass) throws IOException {
			 init(null, conf, out, keyClass, valClass, false, null);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 void initializeFileHeader() throws IOException{
			 out.write(VERSION);
		 }
		 void finalizeFileHeader() throws IOException{
			 out.write(sync);
			 out.flush();
		 }
		 boolean isCompressed() {
			 return compress;
		 }
		 boolean isBlockCompressed() {
			 return false;
		 }
		 void writeFileHeader() throws IOException {
			 Text.writeString(out, keyClass.getName());
			 Text.writeString(out, valClass.getName());
			 out.writeBoolean(this.isCompressed());
			 out.writeBoolean(this.isBlockCompressed());
			 if(this.isCompressed()) {
				 Text.writeString(out, (codec.getClass()).getName());
			 }
		 }
		 void init(Path name, Configuration conf, FSDataOutputStream out, Class keyClass, Class valClass, boolean compress, CompressionCodec codec) throws IOException {
			 this.target = name;
			 this.conf = conf;
			 this.out = out;
			 this.keyClass = keyClass;
			 this.valClass = valClass;
			 this.compress = compress;
			 this.codec = codec;
			 if(this.codec != null) {
				 ReflectionUtils.setConf(this.codec, this.conf);
				 this.deflateFilter = this.codec.createOutputStream(buffer);
				 this.deflateOut = new DataOutputStream(new BufferedOutputStream(deflateFilter));
			 }
		 }
		 public Class getKeyClass() {
			 return keyClass;
		 }
		 public Class getValueClass() {
			 return valClass;
		 }
		 public CompressionCodec getCompressionCodec() {
			 return codec;
		 }
		 Configuration getConf() {
			 return conf;
		 }
		 public synchronized void close() throws IOException {
			 if (out != null) {
				 out.close();
				 out = null;
			 }
		 }
		 synchronized void checkAndWriteSync() throws IOException {
			 if (sync != null && out.getPos() >= lastSyncPos+SYNC_INTERVAL) {
				 lastSyncPos = out.getPos();
				 out.writeInt(SYNC_ESCAPE);
				 out.write(sync);
			 }
		 }
		 public synchronized void append(Writable key, Writable val) throws IOException {
			 if (key.getClass() != keyClass) throw new IOException(""wrong key class: ""+key.getClass().getName() +"" is not ""+keyClass);
			 if (val.getClass() != valClass) throw new IOException(""wrong value class: ""+val.getClass().getName() +"" is not ""+valClass);
			 buffer.reset();
			 key.write(buffer);
			 int keyLength = buffer.getLength();
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed: "" + key);
			 if (compress) {
				 deflateFilter.resetState();
				 val.write(deflateOut);
				 deflateOut.flush();
				 deflateFilter.finish();
			 }
			 else {
				 val.write(buffer);
			 }
			 checkAndWriteSync();
			 out.writeInt(buffer.getLength());
			 out.writeInt(keyLength);
			 out.write(buffer.getData(), 0, buffer.getLength());
		 }
		 public synchronized void appendRaw( byte[] keyData, int keyOffset, int keyLength, ValueBytes val) throws IOException {
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed: "" + keyLength);
			 UncompressedBytes value = (UncompressedBytes)val;
			 int valLength = value.getSize();
			 checkAndWriteSync();
			 out.writeInt(keyLength+valLength);
			 out.writeInt(keyLength);
			 out.write(keyData, keyOffset, keyLength);
			 val.writeUncompressedBytes(out);
		 }
		 public synchronized long getLength() throws IOException {
			 return out.getPos();
		 }
	 }
	 static class RecordCompressWriter extends Writer {
		 public RecordCompressWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionCodec codec) throws IOException {
			 super.init(name, conf, fs.create(name), keyClass, valClass, true, codec);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 public RecordCompressWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionCodec codec, Progressable progress) throws IOException {
			 super.init(name, conf, fs.create(name, progress), keyClass, valClass, true, codec);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 private RecordCompressWriter(Configuration conf, FSDataOutputStream out, Class keyClass, Class valClass, CompressionCodec codec) throws IOException {
			 super.init(null, conf, out, keyClass, valClass, true, codec);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 boolean isCompressed() {
			 return true;
		 }
		 boolean isBlockCompressed() {
			 return false;
		 }
		 public synchronized void append(Writable key, Writable val) throws IOException {
			 if (key.getClass() != keyClass) throw new IOException(""wrong key class: ""+key.getClass().getName() +"" is not ""+keyClass);
			 if (val.getClass() != valClass) throw new IOException(""wrong value class: ""+val.getClass().getName() +"" is not ""+valClass);
			 buffer.reset();
			 key.write(buffer);
			 int keyLength = buffer.getLength();
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed: "" + key);
			 deflateFilter.resetState();
			 val.write(deflateOut);
			 deflateOut.flush();
			 deflateFilter.finish();
			 checkAndWriteSync();
			 out.writeInt(buffer.getLength());
			 out.writeInt(keyLength);
			 out.write(buffer.getData(), 0, buffer.getLength());
		 }
		 public synchronized void appendRaw( byte[] keyData, int keyOffset, int keyLength, ValueBytes val ) throws IOException {
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed"");
			 CompressedBytes value = (CompressedBytes)val;
			 int valLength = value.getSize();
			 checkAndWriteSync();
			 out.writeInt(keyLength+valLength);
			 out.writeInt(keyLength);
			 out.write(keyData, keyOffset, keyLength);
			 val.writeCompressedBytes(out);
		 }
	 }
	 static class BlockCompressWriter extends Writer {
		 private int noBufferedRecords = 0;
		 private DataOutputBuffer keyLenBuffer = new DataOutputBuffer();
		 private DataOutputBuffer keyBuffer = new DataOutputBuffer();
		 private DataOutputBuffer valLenBuffer = new DataOutputBuffer();
		 private DataOutputBuffer valBuffer = new DataOutputBuffer();
		 private int compressionBlockSize;
		 public BlockCompressWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionCodec codec) throws IOException {
			 super.init(name, conf, fs.create(name), keyClass, valClass, true, codec);
			 init(conf.getInt(""io.seqfile.compress.blocksize"", 1000000));
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 public BlockCompressWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionCodec codec, Progressable progress) throws IOException {
			 super.init(name, conf, fs.create(name, progress), keyClass, valClass, true, codec);
			 init(conf.getInt(""io.seqfile.compress.blocksize"", 1000000));
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 private BlockCompressWriter(Configuration conf, FSDataOutputStream out, Class keyClass, Class valClass, CompressionCodec codec) throws IOException {
			 super.init(null, conf, out, keyClass, valClass, true, codec);
			 init(1000000);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 boolean isCompressed() {
			 return true;
		 }
		 boolean isBlockCompressed() {
			 return true;
		 }
		 void init(int compressionBlockSize) {
			 this.compressionBlockSize = compressionBlockSize;
		 }
		 private synchronized void writeBuffer(DataOutputBuffer uncompressedDataBuffer) throws IOException {
			 deflateFilter.resetState();
			 buffer.reset();
			 deflateOut.write(uncompressedDataBuffer.getData(), 0, uncompressedDataBuffer.getLength());
			 deflateOut.flush();
			 deflateFilter.finish();
			 WritableUtils.writeVInt(out, buffer.getLength());
			 out.write(buffer.getData(), 0, buffer.getLength());
		 }
		 private synchronized void writeBlock() throws IOException {
			 if (noBufferedRecords > 0) {
				 if (sync != null) {
					 out.writeInt(SYNC_ESCAPE);
					 out.write(sync);
				 }
				 WritableUtils.writeVInt(out, noBufferedRecords);
				 writeBuffer(keyLenBuffer);
				 writeBuffer(keyBuffer);
				 writeBuffer(valLenBuffer);
				 writeBuffer(valBuffer);
				 out.flush();
				 keyLenBuffer.reset();
				 keyBuffer.reset();
				 valLenBuffer.reset();
				 valBuffer.reset();
				 noBufferedRecords = 0;
			 }
		 }
		 public synchronized void close() throws IOException {
			 if (out != null) {
				 writeBlock();
				 out.close();
				 out = null;
			 }
		 }
		 public synchronized void append(Writable key, Writable val) throws IOException {
			 if (key.getClass() != keyClass) throw new IOException(""wrong key class: ""+key+"" is not ""+keyClass);
			 if (val.getClass() != valClass) throw new IOException(""wrong value class: ""+val+"" is not ""+valClass);
			 int oldKeyLength = keyBuffer.getLength();
			 key.write(keyBuffer);
			 int keyLength = keyBuffer.getLength() - oldKeyLength;
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed: "" + key);
			 WritableUtils.writeVInt(keyLenBuffer, keyLength);
			 int oldValLength = valBuffer.getLength();
			 val.write(valBuffer);
			 int valLength = valBuffer.getLength() - oldValLength;
			 WritableUtils.writeVInt(valLenBuffer, valLength);
			 ++noBufferedRecords;
			 int currentBlockSize = keyBuffer.getLength() + valBuffer.getLength();
			 if (currentBlockSize >= compressionBlockSize) {
				 writeBlock();
			 }
		 }
		 public synchronized void appendRaw( byte[] keyData, int keyOffset, int keyLength, ValueBytes val ) throws IOException {
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed"");
			 UncompressedBytes value = (UncompressedBytes)val;
			 int valLength = value.getSize();
			 WritableUtils.writeVInt(keyLenBuffer, keyLength);
			 keyBuffer.write(keyData, keyOffset, keyLength);
			 WritableUtils.writeVInt(valLenBuffer, valLength);
			 val.writeUncompressedBytes(valBuffer);
			 ++noBufferedRecords;
			 int currentBlockSize = keyBuffer.getLength() + valBuffer.getLength();
			 if (currentBlockSize >= compressionBlockSize) {
				 writeBlock();
			 }
		 }
	 }
	 public static class Reader {
		 private Path file;
		 private FSDataInputStream in;
		 private DataOutputBuffer outBuf = new DataOutputBuffer();
		 private byte version;
		 private Class keyClass;
		 private Class valClass;
		 private CompressionCodec codec = null;
		 private byte[] sync = new byte[SYNC_HASH_SIZE];
		 private byte[] syncCheck = new byte[SYNC_HASH_SIZE];
		 private boolean syncSeen;
		 private long end;
		 private int keyLength;
		 private int recordLength;
		 private boolean decompress;
		 private boolean blockCompressed;
		 private Configuration conf;
		 private int noBufferedRecords = 0;
		 private boolean lazyDecompress = true;
		 private boolean valuesDecompressed = true;
		 private int noBufferedKeys = 0;
		 private int noBufferedValues = 0;
		 private DataInputBuffer keyLenBuffer = null;
		 private CompressionInputStream keyLenInFilter = null;
		 private DataInputStream keyLenIn = null;
		 private DataInputBuffer keyBuffer = null;
		 private CompressionInputStream keyInFilter = null;
		 private DataInputStream keyIn = null;
		 private DataInputBuffer valLenBuffer = null;
		 private CompressionInputStream valLenInFilter = null;
		 private DataInputStream valLenIn = null;
		 private DataInputBuffer valBuffer = null;
		 private CompressionInputStream valInFilter = null;
		 private DataInputStream valIn = null;
		 public Reader(FileSystem fs, Path file, Configuration conf) throws IOException {
			 this(fs, file, conf.getInt(""io.file.buffer.size"", 4096), conf);
		 }
		 private Reader(FileSystem fs, Path name, int bufferSize, Configuration conf) throws IOException {
			 this.file = name;
			 this.in = fs.open(file, bufferSize);
			 this.end = fs.getLength(file);
			 this.conf = conf;
			 init();
		 }
		 private Reader(FileSystem fs, Path file, int bufferSize, long start, long length, Configuration conf) throws IOException {
			 this.file = file;
			 this.in = fs.open(file, bufferSize);
			 this.conf = conf;
			 seek(start);
			 this.end = in.getPos() + length;
			 init();
		 }
		 private void init() throws IOException {
			 byte[] versionBlock = new byte[VERSION.length];
			 in.readFully(versionBlock);
			 if ((versionBlock[0] != VERSION[0]) || (versionBlock[1] != VERSION[1]) || (versionBlock[2] != VERSION[2])) throw new IOException(file + "" not a SequenceFile"");
			 version = versionBlock[3];
			 if (version > VERSION[3]) throw new VersionMismatchException(VERSION[3], version);
			 if (version < BLOCK_COMPRESS_VERSION) {
				 UTF8 className = new UTF8();
				 className.readFields(in);
				 this.keyClass = WritableName.getClass(className.toString(), conf);
				 className.readFields(in);
				 this.valClass = WritableName.getClass(className.toString(), conf);
			 }
			 else {
				 this.keyClass = WritableName.getClass(Text.readString(in), conf);
				 this.valClass = WritableName.getClass(Text.readString(in), conf);
			 }
			 if (version > 2) {
				 this.decompress = in.readBoolean();
			 }
			 else {
				 decompress = false;
			 }
			 if (version >= BLOCK_COMPRESS_VERSION) {
				 this.blockCompressed = in.readBoolean();
			 }
			 else {
				 blockCompressed = false;
			 }
			 if (decompress) {
				 if (version >= CUSTOM_COMPRESS_VERSION) {
					 String codecClassname = Text.readString(in);
					 try {
						 Class codecClass = conf.getClassByName(codecClassname);
						 this.codec = (CompressionCodec) ReflectionUtils.newInstance(codecClass, conf);
					 }
					 catch (ClassNotFoundException cnfe) {
						 throw new IllegalArgumentException(""Unknown codec: "" + codecClassname, cnfe);
					 }
				 }
				 else {
					 codec = new DefaultCodec();
				 }
			 }
			 if (version > 1) {
				 in.readFully(sync);
			 }
			 valBuffer = new DataInputBuffer();
			 if (decompress) {
				 valInFilter = this.codec.createInputStream(valBuffer);
				 valIn = new DataInputStream(valInFilter);
			 }
			 else {
				 valIn = valBuffer;
			 }
			 if (blockCompressed) {
				 keyLenBuffer = new DataInputBuffer();
				 keyBuffer = new DataInputBuffer();
				 valLenBuffer = new DataInputBuffer();
				 keyLenInFilter = this.codec.createInputStream(keyLenBuffer);
				 keyLenIn = new DataInputStream(keyLenInFilter);
				 keyInFilter = this.codec.createInputStream(keyBuffer);
				 keyIn = new DataInputStream(keyInFilter);
				 valLenInFilter = this.codec.createInputStream(valLenBuffer);
				 valLenIn = new DataInputStream(valLenInFilter);
			 }
		 }
		 public synchronized void close() throws IOException {
			 in.close();
		 }
		 public Class getKeyClass() {
			 return keyClass;
		 }
		 public Class getValueClass() {
			 return valClass;
		 }
		 public boolean isCompressed() {
			 return decompress;
		 }
		 public boolean isBlockCompressed() {
			 return blockCompressed;
		 }
		 public CompressionCodec getCompressionCodec() {
			 return codec;
		 }
		 Configuration getConf() {
			 return conf;
		 }
		 private synchronized void readBuffer(DataInputBuffer buffer, CompressionInputStream filter) throws IOException {
			 DataOutputBuffer dataBuffer = new DataOutputBuffer();
			 int dataBufferLength = WritableUtils.readVInt(in);
			 dataBuffer.write(in, dataBufferLength);
			 buffer.reset(dataBuffer.getData(), 0, dataBuffer.getLength());
			 filter.resetState();
		 }
		 private synchronized void readBlock() throws IOException {
			 if (lazyDecompress && !valuesDecompressed) {
				 in.seek(WritableUtils.readVInt(in)+in.getPos());
				 in.seek(WritableUtils.readVInt(in)+in.getPos());
			 }
			 noBufferedKeys = 0;
			 noBufferedValues = 0;
			 noBufferedRecords = 0;
			 valuesDecompressed = false;
			 if (sync != null) {
				 in.readInt();
				 in.readFully(syncCheck);
				 if (!Arrays.equals(sync, syncCheck)) throw new IOException(""File is corrupt!"");
			 }
			 syncSeen = true;
			 noBufferedRecords = WritableUtils.readVInt(in);
			 readBuffer(keyLenBuffer, keyLenInFilter);
			 readBuffer(keyBuffer, keyInFilter);
			 noBufferedKeys = noBufferedRecords;
			 if (!lazyDecompress) {
				 readBuffer(valLenBuffer, valLenInFilter);
				 readBuffer(valBuffer, valInFilter);
				 noBufferedValues = noBufferedRecords;
				 valuesDecompressed = true;
			 }
		 }
		 private synchronized void seekToCurrentValue() throws IOException {
			 if (!blockCompressed) {
				 if (decompress) {
					 valInFilter.resetState();
				 }
				 valBuffer.reset();
			 }
			 else {
				 if (lazyDecompress && !valuesDecompressed) {
					 readBuffer(valLenBuffer, valLenInFilter);
					 readBuffer(valBuffer, valInFilter);
					 noBufferedValues = noBufferedRecords;
					 valuesDecompressed = true;
				 }
				 int skipValBytes = 0;
				 int currentKey = noBufferedKeys + 1;
				 for (int i=noBufferedValues;
				 i > currentKey;
				 --i) {
					 skipValBytes += WritableUtils.readVInt(valLenIn);
					 --noBufferedValues;
				 }
				 if (skipValBytes > 0) {
					 if (valIn.skipBytes(skipValBytes) != skipValBytes) {
						 throw new IOException(""Failed to seek to "" + currentKey + ""(th) value!"");
					 }
				 }
			 }
		 }
		 public synchronized void getCurrentValue(Writable val) throws IOException {
			 if (val instanceof Configurable) {
				 ((Configurable) val).setConf(this.conf);
			 }
			 seekToCurrentValue();
			 if (!blockCompressed) {
				 val.readFields(valIn);
				 if (valIn.read() > 0) {
					 LOG.info(""available bytes: "" + valIn.available());
					 throw new IOException(val+"" read ""+(valBuffer.getPosition()-keyLength) + "" bytes, should read "" + (valBuffer.getLength()-keyLength));
				 }
			 }
			 else {
				 int valLength = WritableUtils.readVInt(valLenIn);
				 val.readFields(valIn);
				 --noBufferedValues;
				 if (valLength < 0) {
					 LOG.debug(val + "" is a zero-length value"");
				 }
			 }
		 }
		 public synchronized boolean next(Writable key) throws IOException {
			 if (key.getClass() != keyClass) throw new IOException(""wrong key class: ""+key.getClass().getName() +"" is not ""+keyClass);
			 if (!blockCompressed) {
				 outBuf.reset();
				 keyLength = next(outBuf);
				 if (keyLength < 0) return false;
				 valBuffer.reset(outBuf.getData(), outBuf.getLength());
				 key.readFields(valBuffer);
				 valBuffer.mark(0);
				 if (valBuffer.getPosition() != keyLength) throw new IOException(key + "" read "" + valBuffer.getPosition() + "" bytes, should read "" + keyLength);
			 }
			 else {
				 syncSeen = false;
				 if (noBufferedKeys == 0) {
					 try {
						 readBlock();
					 }
					 catch (EOFException eof) {
						 return false;
					 }
				 }
				 int keyLength = WritableUtils.readVInt(keyLenIn);
				 if (keyLength < 0) {
					 return false;
				 }
				 key.readFields(keyIn);
				 --noBufferedKeys;
			 }
			 return true;
		 }
		 public synchronized boolean next(Writable key, Writable val) throws IOException {
			 if (val.getClass() != valClass) throw new IOException(""wrong value class: ""+val+"" is not ""+valClass);
			 boolean more = next(key);
			 if (more) {
				 getCurrentValue(val);
			 }
			 return more;
		 }
		 private synchronized int checkAndReadSync(int length) throws IOException {
			 if (version > 1 && sync != null && length == SYNC_ESCAPE) {
				 in.readFully(syncCheck);
				 if (!Arrays.equals(sync, syncCheck)) throw new IOException(""File is corrupt!"");
				 syncSeen = true;
				 length = in.readInt();
			 }
			 else {
				 syncSeen = false;
			 }
			 return length;
		 }
		 public synchronized int next(DataOutputBuffer buffer) throws IOException {
			 if (blockCompressed) {
				 throw new IOException(""Unsupported call for block-compressed"" + "" SequenceFiles - use SequenceFile.Reader.next(DataOutputStream, ValueBytes)"");
			 }
			 if (in.getPos() >= end) return -1;
			 try {
				 int length = checkAndReadSync(in.readInt());
				 int keyLength = in.readInt();
				 buffer.write(in, length);
				 return keyLength;
			 }
			 catch (ChecksumException e) {
				 handleChecksumException(e);
				 return next(buffer);
			 }
		 }
		 public ValueBytes createValueBytes() {
			 ValueBytes val = null;
			 if (!decompress || blockCompressed) {
				 val = new UncompressedBytes();
			 }
			 else {
				 val = new CompressedBytes(codec);
			 }
			 return val;
		 }
		 public int nextRaw(DataOutputBuffer key, ValueBytes val) throws IOException {
			 if (!blockCompressed) {
				 if (in.getPos() >= end) return -1;
				 int length = checkAndReadSync(in.readInt());
				 int keyLength = in.readInt();
				 int valLength = length - keyLength;
				 key.write(in, keyLength);
				 if (decompress) {
					 CompressedBytes value = (CompressedBytes)val;
					 value.reset(in, valLength);
				 }
				 else {
					 UncompressedBytes value = (UncompressedBytes)val;
					 value.reset(in, valLength);
				 }
				 return length;
			 }
			 else {
				 syncSeen = false;
				 if (noBufferedKeys == 0) {
					 if (in.getPos() >= end) return -1;
					 try {
						 readBlock();
					 }
					 catch (EOFException eof) {
						 return -1;
					 }
				 }
				 int keyLength = WritableUtils.readVInt(keyLenIn);
				 if (keyLength < 0) {
					 throw new IOException(""zero length key found!"");
				 }
				 key.write(keyIn, keyLength);
				 --noBufferedKeys;
				 seekToCurrentValue();
				 int valLength = WritableUtils.readVInt(valLenIn);
				 UncompressedBytes rawValue = (UncompressedBytes)val;
				 rawValue.reset(valIn, valLength);
				 --noBufferedValues;
				 return (keyLength+valLength);
			 }
		 }
		 public int nextRawKey(DataOutputBuffer key) throws IOException {
			 if (!blockCompressed) {
				 if (in.getPos() >= end) return -1;
				 recordLength = checkAndReadSync(in.readInt());
				 keyLength = in.readInt();
				 key.write(in, keyLength);
				 return keyLength;
			 }
			 else {
				 syncSeen = false;
				 if (noBufferedKeys == 0) {
					 if (in.getPos() >= end) return -1;
					 try {
						 readBlock();
					 }
					 catch (EOFException eof) {
						 return -1;
					 }
				 }
				 int keyLength = WritableUtils.readVInt(keyLenIn);
				 if (keyLength < 0) {
					 throw new IOException(""zero length key found!"");
				 }
				 key.write(keyIn, keyLength);
				 --noBufferedKeys;
				 return keyLength;
			 }
		 }
		 public int nextRawValue(ValueBytes val) throws IOException {
			 seekToCurrentValue();
			 if (!blockCompressed) {
				 int valLength = recordLength - keyLength;
				 if (decompress) {
					 CompressedBytes value = (CompressedBytes)val;
					 value.reset(in, valLength);
				 }
				 else {
					 UncompressedBytes value = (UncompressedBytes)val;
					 value.reset(in, valLength);
				 }
				 return valLength;
			 }
			 else {
				 int valLength = WritableUtils.readVInt(valLenIn);
				 UncompressedBytes rawValue = (UncompressedBytes)val;
				 rawValue.reset(valIn, valLength);
				 --noBufferedValues;
				 return valLength;
			 }
		 }
		 private void handleChecksumException(ChecksumException e) throws IOException {
			 if (this.conf.getBoolean(""io.skip.checksum.errors"", false)) {
				 LOG.warn(""Bad checksum at ""+getPosition()+"". Skipping entries."");
				 sync(getPosition()+this.conf.getInt(""io.bytes.per.checksum"", 512));
			 }
			 else {
				 throw e;
			 }
		 }
		 public synchronized void seek(long position) throws IOException {
			 in.seek(position);
			 if (blockCompressed) {
				 noBufferedKeys = 0;
				 valuesDecompressed = true;
			 }
		 }
		 public synchronized void sync(long position) throws IOException {
			 if (position+SYNC_SIZE >= end) {
				 seek(end);
				 return;
			 }
			 try {
				 seek(position+4);
				 in.readFully(syncCheck);
				 int syncLen = sync.length;
				 for (int i = 0;
				 in.getPos() < end;
				 i++) {
					 int j = 0;
					 for (;
					 j < syncLen;
					 j++) {
						 if (sync[j] != syncCheck[(i+j)%syncLen]) break;
					 }
					 if (j == syncLen) {
						 in.seek(in.getPos() - SYNC_SIZE);
						 return;
					 }
					 syncCheck[i%syncLen] = in.readByte();
				 }
			 }
			 catch (ChecksumException e) {
				 handleChecksumException(e);
			 }
		 }
		 public boolean syncSeen() {
			 return syncSeen;
		 }
		 public synchronized long getPosition() throws IOException {
			 return in.getPos();
		 }
		 public String toString() {
			 return file.toString();
		 }
	 }
	 public static class Sorter {
		 private WritableComparator comparator;
		 private Path[] inFiles;
		 private Path outFile;
		 private int memory;
		 private int factor;
		 private FileSystem fs = null;
		 private Class keyClass;
		 private Class valClass;
		 private Configuration conf;
		 public Sorter(FileSystem fs, Class keyClass, Class valClass, Configuration conf) {
			 this(fs, new WritableComparator(keyClass), valClass, conf);
		 }
		 public Sorter(FileSystem fs, WritableComparator comparator, Class valClass, Configuration conf) {
			 this.fs = fs;
			 this.comparator = comparator;
			 this.keyClass = comparator.getKeyClass();
			 this.valClass = valClass;
			 this.memory = conf.getInt(""io.sort.mb"", 100) * 1024 * 1024;
			 this.factor = conf.getInt(""io.sort.factor"", 100);
			 this.conf = conf;
		 }
		 public void setFactor(int factor) {
			 this.factor = factor;
		 }
		 public int getFactor() {
			 return factor;
		 }
		 public void setMemory(int memory) {
			 this.memory = memory;
		 }
		 public int getMemory() {
			 return memory;
		 }
		 public void sort(Path[] inFiles, Path outFile, boolean deleteInput) throws IOException {
			 if (fs.exists(outFile)) {
				 throw new IOException(""already exists: "" + outFile);
			 }
			 this.inFiles = inFiles;
			 this.outFile = outFile;
			 int segments = sortPass(deleteInput);
			 if (segments > 1) {
				 segments = mergePass();
			 }
		 }
		 public RawKeyValueIterator sortAndIterate(Path[] inFiles, Path tempDir, boolean deleteInput) throws IOException {
			 Path outFile = new Path(tempDir + Path.SEPARATOR + ""all.2"");
			 if (fs.exists(outFile)) {
				 throw new IOException(""already exists: "" + outFile);
			 }
			 this.inFiles = inFiles;
			 this.outFile = outFile;
			 int segments = sortPass(deleteInput);
			 if (segments > 1) return merge(outFile.suffix("".0""), outFile.suffix("".0.index""));
			 else if (segments == 1) return merge(new Path[]{
			outFile}
			, true);
			 else return null;
		 }
		 public void sort(Path inFile, Path outFile) throws IOException {
			 sort(new Path[]{
			inFile}
			, outFile, false);
		 }
		 private int sortPass(boolean deleteInput) throws IOException {
			 LOG.debug(""running sort pass"");
			 SortPass sortPass = new SortPass();
			 try {
				 return sortPass.run(deleteInput);
			 }
			 finally {
				 sortPass.close();
			 }
		 }
		 private class SortPass {
			 private int memoryLimit = memory/4;
			 private int recordLimit = 1000000;
			 private DataOutputBuffer rawKeys = new DataOutputBuffer();
			 private byte[] rawBuffer;
			 private int[] keyOffsets = new int[1024];
			 private int[] pointers = new int[keyOffsets.length];
			 private int[] pointersCopy = new int[keyOffsets.length];
			 private int[] keyLengths = new int[keyOffsets.length];
			 private ValueBytes[] rawValues = new ValueBytes[keyOffsets.length];
			 private ArrayList segmentLengths = new ArrayList();
			 private Reader in = null;
			 private FSDataOutputStream out = null;
			 private FSDataOutputStream indexOut = null;
			 private Path outName;
			 public int run(boolean deleteInput) throws IOException {
				 int segments = 0;
				 int currentFile = 0;
				 boolean atEof = (currentFile >= inFiles.length);
				 boolean isCompressed = false;
				 boolean isBlockCompressed = false;
				 CompressionCodec codec = null;
				 segmentLengths.clear();
				 if (atEof) {
					 return 0;
				 }
				 in = new Reader(fs, inFiles[currentFile], conf);
				 isCompressed = in.isCompressed();
				 isBlockCompressed = in.isBlockCompressed();
				 codec = in.getCompressionCodec();
				 for (int i=0;
				 i < rawValues.length;
				 ++i) {
					 rawValues[i] = null;
				 }
				 while (!atEof) {
					 int count = 0;
					 int bytesProcessed = 0;
					 rawKeys.reset();
					 while (!atEof && bytesProcessed < memoryLimit && count < recordLimit) {
						 int keyOffset = rawKeys.getLength();
						 ValueBytes rawValue = (count == keyOffsets.length || rawValues[count] == null) ? in.createValueBytes() : rawValues[count];
						 int recordLength = in.nextRaw(rawKeys, rawValue);
						 if (recordLength == -1) {
							 in.close();
							 if (deleteInput) {
								 fs.delete(inFiles[currentFile]);
							 }
							 currentFile += 1;
							 atEof = currentFile >= inFiles.length;
							 if (!atEof) {
								 in = new Reader(fs, inFiles[currentFile], conf);
							 }
							 else {
								 in = null;
							 }
							 continue;
						 }
						 int keyLength = rawKeys.getLength() - keyOffset;
						 if (count == keyOffsets.length) grow();
						 keyOffsets[count] = keyOffset;
						 pointers[count] = count;
						 keyLengths[count] = keyLength;
						 rawValues[count] = rawValue;
						 bytesProcessed += recordLength;
						 count++;
					 }
					 LOG.debug(""flushing segment "" + segments);
					 rawBuffer = rawKeys.getData();
					 sort(count);
					 flush(count, bytesProcessed, isCompressed, isBlockCompressed, codec, segments==0 && atEof);
					 segments++;
				 }
				 return segments;
			 }
			 public void close() throws IOException {
				 if (in != null) {
					 in.close();
				 }
				 if (out != null) {
					 out.close();
				 }
				 if (indexOut != null) {
					 indexOut.close();
				 }
			 }
			 private void grow() {
				 int newLength = keyOffsets.length * 3 / 2;
				 keyOffsets = grow(keyOffsets, newLength);
				 pointers = grow(pointers, newLength);
				 pointersCopy = new int[newLength];
				 keyLengths = grow(keyLengths, newLength);
				 rawValues = grow(rawValues, newLength);
			 }
			 private int[] grow(int[] old, int newLength) {
				 int[] result = new int[newLength];
				 System.arraycopy(old, 0, result, 0, old.length);
				 return result;
			 }
			 private ValueBytes[] grow(ValueBytes[] old, int newLength) {
				 ValueBytes[] result = new ValueBytes[newLength];
				 System.arraycopy(old, 0, result, 0, old.length);
				 for (int i=old.length;
				 i < newLength;
				 ++i) {
					 result[i] = null;
				 }
				 return result;
			 }
			 private void flush(int count, int bytesProcessed, boolean isCompressed, boolean isBlockCompressed, CompressionCodec codec, boolean done) throws IOException {
				 if (out == null) {
					 outName = done ? outFile : outFile.suffix("".0"");
					 out = fs.create(outName);
					 if (!done) {
						 indexOut = fs.create(outName.suffix("".index""));
					 }
				 }
				 long segmentStart = out.getPos();
				 Writer writer = createWriter(conf, out, keyClass, valClass, isCompressed, isBlockCompressed, codec);
				 if (!done) {
					 writer.sync = null;
				 }
				 for (int i = 0;
				 i < count;
				 i++) {
					 int p = pointers[i];
					 writer.appendRaw(rawBuffer, keyOffsets[p], keyLengths[p], rawValues[p]);
				 }
				 if (writer instanceof SequenceFile.BlockCompressWriter) {
					 SequenceFile.BlockCompressWriter bcWriter = (SequenceFile.BlockCompressWriter) writer;
					 bcWriter.writeBlock();
				 }
				 writer.out.flush();
				 if (!done) {
					 WritableUtils.writeVLong(indexOut, segmentStart);
					 WritableUtils.writeVLong(indexOut, (writer.out.getPos()-segmentStart));
					 indexOut.flush();
				 }
			 }
			 private void sort(int count) {
				 System.arraycopy(pointers, 0, pointersCopy, 0, count);
				 mergeSort(pointersCopy, pointers, 0, count);
			 }
			 private int compare(int i, int j) {
				 return comparator.compare(rawBuffer, keyOffsets[i], keyLengths[i], rawBuffer, keyOffsets[j], keyLengths[j]);
			 }
			 private void mergeSort(int src[], int dest[], int low, int high) {
				 int length = high - low;
				 if (length < 7) {
					 for (int i=low;
					 i<high;
					 i++) for (int j=i;
					 j>low && compare(dest[j-1], dest[j])>0;
					 j--) swap(dest, j, j-1);
					 return;
				 }
				 int mid = (low + high) >> 1;
				 mergeSort(dest, src, low, mid);
				 mergeSort(dest, src, mid, high);
				 if (compare(src[mid-1], src[mid]) <= 0) {
					 System.arraycopy(src, low, dest, low, length);
					 return;
				 }
				 for (int i = low, p = low, q = mid;
				 i < high;
				 i++) {
					 if (q>=high || p<mid && compare(src[p], src[q]) <= 0) dest[i] = src[p++];
					 else dest[i] = src[q++];
				 }
			 }
			 private void swap(int x[], int a, int b) {
				 int t = x[a];
				 x[a] = x[b];
				 x[b] = t;
			 }
		 }
		 public static interface RawKeyValueIterator {
			 DataOutputBuffer getKey() throws IOException;
			 ValueBytes getValue() throws IOException;
			 boolean next() throws IOException;
			 void close() throws IOException;
			 Progress getProgress();
		 }
		 public RawKeyValueIterator merge(List <SegmentDescriptor> segments) throws IOException {
			 MergeQueue mQueue = new MergeQueue(segments);
			 return mQueue.merge();
		 }
		 public RawKeyValueIterator merge(Path [] inNames, boolean deleteInputs) throws IOException {
			 ArrayList <SegmentDescriptor> a = new ArrayList <SegmentDescriptor>();
			 for (int i = 0;
			 i < inNames.length;
			 i++) {
				 SegmentDescriptor s = new SegmentDescriptor(0, fs.getLength(inNames[i]), inNames[i]);
				 s.preserveInput(!deleteInputs);
				 s.doSync();
				 a.add(s);
			 }
			 factor = inNames.length;
			 MergeQueue mQueue = new MergeQueue(a);
			 return mQueue.merge();
		 }
		 public Writer cloneFileAttributes(FileSystem fileSys, Path inputFile, Path outputFile, Progressable prog) throws IOException {
			 Reader reader = new Reader(fileSys, inputFile, memory/(factor+1), conf);
			 boolean compress = reader.isCompressed();
			 boolean blockCompress = reader.isBlockCompressed();
			 CompressionCodec codec = reader.getCompressionCodec();
			 reader.close();
			 FSDataOutputStream out;
			 if (prog != null) out = fs.create(outputFile, true, memory/(factor+1), prog);
			 else out = fs.create(outputFile, true, memory/(factor+1));
			 Writer writer = createWriter(conf, out, keyClass, valClass, compress, blockCompress, codec);
			 return writer;
		 }
		 public void writeFile(RawKeyValueIterator records, Writer writer) throws IOException {
			 while(records.next()) {
				 writer.appendRaw(records.getKey().getData(), 0, records.getKey().getLength(), records.getValue());
			 }
			 if (writer instanceof SequenceFile.BlockCompressWriter) {
				 SequenceFile.BlockCompressWriter bcWriter = (SequenceFile.BlockCompressWriter) writer;
				 bcWriter.writeBlock();
			 }
		 }
		 public void merge(Path[] inFiles, Path outFile) throws IOException {
			 if (fs.exists(outFile)) {
				 throw new IOException(""already exists: "" + outFile);
			 }
			 RawKeyValueIterator r = merge(inFiles, false);
			 Writer writer = cloneFileAttributes(fs, inFiles[0], outFile, null);
			 writeFile(r, writer);
			 writer.close();
		 }
		 private int mergePass() throws IOException {
			 LOG.debug(""running merge pass"");
			 Writer writer = cloneFileAttributes(fs, outFile.suffix("".0""), outFile, null);
			 RawKeyValueIterator r = merge(outFile.suffix("".0""), outFile.suffix("".0.index""));
			 writeFile(r, writer);
			 writer.close();
			 return 0;
		 }
		 private RawKeyValueIterator merge(Path inName, Path indexIn) throws IOException {
			 SegmentContainer container = new SegmentContainer(inName, indexIn);
			 MergeQueue mQueue = new MergeQueue(container.getSegmentList());
			 return mQueue.merge();
		 }
		 private class MergeQueue extends PriorityQueue implements RawKeyValueIterator {
			 private boolean compress;
			 private boolean blockCompress;
			 private DataOutputBuffer rawKey = new DataOutputBuffer();
			 private ValueBytes rawValue;
			 private long totalBytesProcessed;
			 private float progPerByte;
			 private Progress mergeProgress = new Progress();
			 private Map <SegmentDescriptor, Void> sortedSegmentSizes = new TreeMap();
			 public void put(SegmentDescriptor stream) throws IOException {
				 if (size() == 0) {
					 compress = stream.in.isCompressed();
					 blockCompress = stream.in.isBlockCompressed();
				 }
				 else if (compress != stream.in.isCompressed() || blockCompress != stream.in.isBlockCompressed()) {
					 throw new IOException(""All merged files must be compressed or not."");
				 }
				 super.put(stream);
			 }
			 public MergeQueue(List <SegmentDescriptor> segments) {
				 int size = segments.size();
				 for (int i = 0;
				 i < size;
				 i++) {
					 sortedSegmentSizes.put(segments.get(i), null);
				 }
			 }
			 protected boolean lessThan(Object a, Object b) {
				 SegmentDescriptor msa = (SegmentDescriptor)a;
				 SegmentDescriptor msb = (SegmentDescriptor)b;
				 return comparator.compare(msa.getKey().getData(), 0, msa.getKey().getLength(), msb.getKey().getData(), 0, msb.getKey().getLength()) < 0;
			 }
			 public void close() throws IOException {
				 SegmentDescriptor ms;
				 while ((ms = (SegmentDescriptor)pop()) != null) {
					 ms.cleanup();
				 }
			 }
			 public DataOutputBuffer getKey() throws IOException {
				 return rawKey;
			 }
			 public ValueBytes getValue() throws IOException {
				 return rawValue;
			 }
			 public boolean next() throws IOException {
				 if (size() == 0) return false;
				 SegmentDescriptor ms = (SegmentDescriptor)top();
				 rawKey.reset();
				 rawKey.write(ms.getKey().getData(), 0, ms.getKey().getLength());
				 if(rawValue == null) rawValue = ms.in.createValueBytes();
				 int valLength = ms.nextRawValue(rawValue);
				 if (ms.nextRawKey()) {
					 adjustTop();
				 }
				 else {
					 pop();
					 ms.cleanup();
				 }
				 if (progPerByte > 0) {
					 totalBytesProcessed += rawKey.getLength() + valLength;
					 mergeProgress.set(totalBytesProcessed * progPerByte);
				 }
				 return true;
			 }
			 public Progress getProgress() {
				 return mergeProgress;
			 }
			 public RawKeyValueIterator merge() throws IOException {
				 int numSegments = sortedSegmentSizes.size();
				 int origFactor = factor;
				 int passNo = 1;
				 do {
					 factor = getPassFactor(passNo, numSegments);
					 SegmentDescriptor[] mStream = getSegmentDescriptors(factor);
					 initialize(mStream.length);
					 clear();
					 for (int i = 0;
					 i < mStream.length;
					 i++) {
						 if (mStream[i].nextRawKey()) put(mStream[i]);
					 }
					 if (numSegments <= factor) {
						 long totalBytes = 0;
						 for (int i = 0;
						 i < numSegments;
						 i++) totalBytes += mStream[i].segmentLength;
						 if (totalBytes != 0) progPerByte = 1.0f / (float)totalBytes;
						 return this;
					 }
					 else {
						 Path outputFile = conf.getLocalPath(""mapred.local.dir"", (outFile.suffix(""."" + passNo)).toString());
						 Writer writer = cloneFileAttributes(fs, mStream[0].segmentPathName, outputFile, null);
						 writer.sync = null;
						 writeFile(this, writer);
						 writer.close();
						 this.close();
						 SegmentDescriptor tempSegment = new SegmentDescriptor(0, fs.getLength(outputFile), outputFile);
						 sortedSegmentSizes.put(tempSegment, null);
						 numSegments = sortedSegmentSizes.size();
						 passNo++;
					 }
					 factor = origFactor;
				 }
				 while(true);
			 }
			 public int getPassFactor(int passNo, int numSegments) {
				 if (passNo > 1 || numSegments <= factor || factor == 1) return factor;
				 int mod = (numSegments - 1) % (factor - 1);
				 if (mod == 0) return factor;
				 return mod + 1;
			 }
			 public SegmentDescriptor[] getSegmentDescriptors(int numDescriptors) {
				 if (numDescriptors > sortedSegmentSizes.size()) numDescriptors = sortedSegmentSizes.size();
				 SegmentDescriptor[] SegmentDescriptors = new SegmentDescriptor[numDescriptors];
				 Iterator iter = sortedSegmentSizes.keySet().iterator();
				 int i = 0;
				 while (i < numDescriptors) {
					 SegmentDescriptors[i++] = (SegmentDescriptor)iter.next();
					 iter.remove();
				 }
				 return SegmentDescriptors;
			 }
		 }
		 public class SegmentDescriptor implements Comparable {
			 long segmentOffset;
			 long segmentLength;
			 Path segmentPathName;
			 boolean ignoreSync = true;
			 private Reader in = null;
			 private DataOutputBuffer rawKey = null;
			 private boolean preserveInput = false;
			 public SegmentDescriptor (long segmentOffset, long segmentLength, Path segmentPathName) {
				 this.segmentOffset = segmentOffset;
				 this.segmentLength = segmentLength;
				 this.segmentPathName = segmentPathName;
			 }
			 public void doSync() {
				ignoreSync = false;
			}
			 public void preserveInput(boolean preserve) {
				 preserveInput = preserve;
			 }
			 public boolean shouldPreserveInput() {
				 return preserveInput;
			 }
			 public int compareTo(Object o) {
				 SegmentDescriptor that = (SegmentDescriptor)o;
				 if (this.segmentLength != that.segmentLength) {
					 return (this.segmentLength < that.segmentLength ? -1 : 1);
				 }
				 if (this.segmentOffset != that.segmentOffset) {
					 return (this.segmentOffset < that.segmentOffset ? -1 : 1);
				 }
				 return (this.segmentPathName.toString()). compareTo(that.segmentPathName.toString());
			 }
			 public boolean nextRawKey() throws IOException {
				 if (in == null) {
					 Reader reader = new Reader(fs, segmentPathName, memory/(factor+1), segmentOffset, segmentLength, conf);
					 if (ignoreSync) reader.sync = null;
					 if (reader.keyClass != keyClass) throw new IOException(""wrong key class: "" + reader.getKeyClass() + "" is not "" + keyClass);
					 if (reader.valClass != valClass) throw new IOException(""wrong value class: ""+reader.getValueClass()+ "" is not "" + valClass);
					 this.in = reader;
					 rawKey = new DataOutputBuffer();
				 }
				 rawKey.reset();
				 int keyLength = in.nextRawKey(rawKey);
				 return (keyLength >= 0);
			 }
			 public int nextRawValue(ValueBytes rawValue) throws IOException {
				 int valLength = in.nextRawValue(rawValue);
				 return valLength;
			 }
			 public DataOutputBuffer getKey() {
				 return rawKey;
			 }
			 private void close() throws IOException {
				 this.in.close();
			 }
			 public void cleanup() throws IOException {
				 close();
				 if (!preserveInput) {
					 fs.delete(segmentPathName);
				 }
			 }
		 }
		 private class LinkedSegmentsDescriptor extends SegmentDescriptor {
			 SegmentContainer parentContainer = null;
			 public LinkedSegmentsDescriptor (long segmentOffset, long segmentLength, Path segmentPathName, SegmentContainer parent) {
				 super(segmentOffset, segmentLength, segmentPathName);
				 this.parentContainer = parent;
			 }
			 public void cleanup() throws IOException {
				 super.close();
				 if (super.shouldPreserveInput()) return;
				 parentContainer.cleanup();
			 }
		 }
		 private class SegmentContainer {
			 private int numSegmentsCleanedUp = 0;
			 private int numSegmentsContained;
			 private Path inName;
			 private ArrayList <SegmentDescriptor> segments = new ArrayList <SegmentDescriptor>();
			 public SegmentContainer(Path inName, Path indexIn) throws IOException {
				 FSDataInputStream fsIndexIn = fs.open(indexIn);
				 long end = fs.getLength(indexIn);
				 while (fsIndexIn.getPos() < end) {
					 long segmentOffset = WritableUtils.readVLong(fsIndexIn);
					 long segmentLength = WritableUtils.readVLong(fsIndexIn);
					 Path segmentName = inName;
					 segments.add(new LinkedSegmentsDescriptor(segmentOffset, segmentLength, segmentName, this));
				 }
				 fsIndexIn.close();
				 fs.delete(indexIn);
				 numSegmentsContained = segments.size();
				 this.inName = inName;
			 }
			 public List <SegmentDescriptor> getSegmentList() {
				 return segments;
			 }
			 public void cleanup() throws IOException {
				 numSegmentsCleanedUp++;
				 if (numSegmentsCleanedUp == numSegmentsContained) {
					 fs.delete(inName);
				 }
			 }
		 }
	 }
 }",1,0,0,0
"public static final class Builder extends com.google.protobuf.GeneratedMessage.Builder<Builder> implements org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProtoOrBuilder {
	 public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
		 return org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.internal_static_UpdateQueryRequestProto_descriptor;
	 }
	 protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
		 return org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.internal_static_UpdateQueryRequestProto_fieldAccessorTable .ensureFieldAccessorsInitialized( org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto.class, org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto.Builder.class);
	 }
	 private Builder() {
		 maybeForceBuilderInitialization();
	 }
	 private Builder( com.google.protobuf.GeneratedMessage.BuilderParent parent) {
		 super(parent);
		 maybeForceBuilderInitialization();
	 }
	 private void maybeForceBuilderInitialization() {
		 if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
		 }
	 }
	 private static Builder create() {
		 return new Builder();
	 }
	 public Builder clear() {
		 super.clear();
		 guaranteedTaskCount_ = 0;
		 bitField0_ = (bitField0_ & ~0x00000001);
		 return this;
	 }
	 public Builder clone() {
		 return create().mergeFrom(buildPartial());
	 }
	 public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
		 return org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.internal_static_UpdateQueryRequestProto_descriptor;
	 }
	 public org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto getDefaultInstanceForType() {
		 return org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto.getDefaultInstance();
	 }
	 public org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto build() {
		 org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto result = buildPartial();
		 if (!result.isInitialized()) {
			 throw newUninitializedMessageException(result);
		 }
		 return result;
	 }
	 public org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto buildPartial() {
		 org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto result = new org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto(this);
		 int from_bitField0_ = bitField0_;
		 int to_bitField0_ = 0;
		 if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
			 to_bitField0_ |= 0x00000001;
		 }
		 result.guaranteedTaskCount_ = guaranteedTaskCount_;
		 result.bitField0_ = to_bitField0_;
		 onBuilt();
		 return result;
	 }
	 public Builder mergeFrom(com.google.protobuf.Message other) {
		 if (other instanceof org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto) {
			 return mergeFrom((org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto)other);
		 }
		 else {
			 super.mergeFrom(other);
			 return this;
		 }
	 }
	 public Builder mergeFrom(org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto other) {
		 if (other == org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto.getDefaultInstance()) return this;
		 if (other.hasGuaranteedTaskCount()) {
			 setGuaranteedTaskCount(other.getGuaranteedTaskCount());
		 }
		 this.mergeUnknownFields(other.getUnknownFields());
		 return this;
	 }
	 public final boolean isInitialized() {
		 return true;
	 }
	 public Builder mergeFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		 org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto parsedMessage = null;
		 try {
			 parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
		 }
		 catch (com.google.protobuf.InvalidProtocolBufferException e) {
			 parsedMessage = (org.apache.hadoop.hive.llap.plugin.rpc.LlapPluginProtocolProtos.UpdateQueryRequestProto) e.getUnfinishedMessage();
			 throw e;
		 }
		 finally {
			 if (parsedMessage != null) {
				 mergeFrom(parsedMessage);
			 }
		 }
		 return this;
	 }
	 private int bitField0_;
	 private int guaranteedTaskCount_ ;
	 public boolean hasGuaranteedTaskCount() {
		 return ((bitField0_ & 0x00000001) == 0x00000001);
	 }
	 public int getGuaranteedTaskCount() {
		 return guaranteedTaskCount_;
	 }
	 public Builder setGuaranteedTaskCount(int value) {
		 bitField0_ |= 0x00000001;
		 guaranteedTaskCount_ = value;
		 onChanged();
		 return this;
	 }
	 public Builder clearGuaranteedTaskCount() {
		 bitField0_ = (bitField0_ & ~0x00000001);
		 guaranteedTaskCount_ = 0;
		 onChanged();
		 return this;
	 }
 }",1,0,0,0
"public Properties getMetadata() {
	 return metadata;
 }",0,0,0,0
"public class Attachment {
	 private String fallback;
	 private String color;
	 private String pretext;
	 private String authorName;
	 private String authorLink;
	 private String authorIcon;
	 private String title;
	 private String titleLink;
	 private String text;
	 private String imageUrl;
	 private String thumbUrl;
	 private String footer;
	 private String footerIcon;
	 private Long ts;
	 private List<Field> fields;
	 public String getFallback() {
		 return fallback;
	 }
	 public void setFallback(String fallback) {
		 this.fallback = fallback;
	 }
	 public String getColor() {
		 return color;
	 }
	 public void setColor(String color) {
		 this.color = color;
	 }
	 public String getPretext() {
		 return pretext;
	 }
	 public void setPretext(String pretext) {
		 this.pretext = pretext;
	 }
	 public String getAuthorName() {
		 return authorName;
	 }
	 public void setAuthorName(String authorName) {
		 this.authorName = authorName;
	 }
	 public String getAuthorLink() {
		 return authorLink;
	 }
	 public void setAuthorLink(String authorLink) {
		 this.authorLink = authorLink;
	 }
	 public String getAuthorIcon() {
		 return authorIcon;
	 }
	 public void setAuthorIcon(String authorIcon) {
		 this.authorIcon = authorIcon;
	 }
	 public String getTitle() {
		 return title;
	 }
	 public void setTitle(String title) {
		 this.title = title;
	 }
	 public String getTitleLink() {
		 return titleLink;
	 }
	 public void setTitleLink(String titleLink) {
		 this.titleLink = titleLink;
	 }
	 public String getText() {
		 return text;
	 }
	 public void setText(String text) {
		 this.text = text;
	 }
	 public String getImageUrl() {
		 return imageUrl;
	 }
	 public void setImageUrl(String imageUrl) {
		 this.imageUrl = imageUrl;
	 }
	 public String getThumbUrl() {
		 return thumbUrl;
	 }
	 public void setThumbUrl(String thumbUrl) {
		 this.thumbUrl = thumbUrl;
	 }
	 public String getFooter() {
		 return footer;
	 }
	 public void setFooter(String footer) {
		 this.footer = footer;
	 }
	 public String getFooterIcon() {
		 return footerIcon;
	 }
	 public void setFooterIcon(String footerIcon) {
		 this.footerIcon = footerIcon;
	 }
	 public Long getTs() {
		 return ts;
	 }
	 public void setTs(Long ts) {
		 this.ts = ts;
	 }
	 public List<Field> getFields() {
		 return fields;
	 }
	 public void setFields(List<Field> fields) {
		 this.fields = fields;
	 }
	 public class Field {
		 private String title;
		 private String value;
		 private Boolean shortValue;
		 public String getTitle() {
			 return title;
		 }
		 public void setTitle(String title) {
			 this.title = title;
		 }
		 public String getValue() {
			 return value;
		 }
		 public void setValue(String value) {
			 this.value = value;
		 }
		 public Boolean isShortValue() {
			 return shortValue;
		 }
		 public void setShortValue(Boolean shortValue) {
			 this.shortValue = shortValue;
		 }
	 }
 }",1,1,0,0
"private void assemble(String file, ArrayList<Segment> list) throws IOException {
	InputStream in = null;
	OutputStream out = null;
	totalAssembled = 0L;
	assembling = true;
	Logger.log(""Combining "" + file + "" "" + list.size());
	try {
		if (stopFlag)return;
		byte buf[] = new byte[8192 * 8];
		Logger.log(""assembling... "" + stopFlag);
		Collections.sort(list, new SegmentComparator());
		out = new FileOutputStream(new File(folder, file));
		for (int i = 0;
		 i < list.size();
		 i++) {
			Logger.log(""chunk "" + i + "" "" + stopFlag);
			Segment c = list.get(i);
			in = new FileInputStream(new File(folder, c.getId()));
			long rem = c.getLength();
			while (true) {
				int x = (int) (rem > 0 ? (rem > buf.length ? buf.length : rem) : buf.length);
				int r = in.read(buf, 0, x);
				if (stopFlag) {
					return;
				}
				if (r == -1) {
					if (length > 0) {
						in.close();
						out.close();
						throw new IllegalArgumentException(""Assemble EOF"");
					}
					 else {
						break;
					}
				}
				out.write(buf, 0, r);
				if (stopFlag) {
					return;
				}
				if (length > 0) {
					rem -= r;
					if (rem == 0)break;
				}
				totalAssembled += r;
				long now = System.currentTimeMillis();
				if (now - lastUpdated > 1000) {
					updateStatus();
					lastUpdated = now;
				}
			}
			in.close();
		}
		out.close();
	}
	 catch (Exception e) {
		Logger.log(e);
		throw new IOException(e);
	}
	 finally {
		if (in != null) {
			try {
				in.close();
			}
			 catch (Exception e2) {
			}
		}
		if (out != null) {
			try {
				out.close();
			}
			 catch (Exception e2) {
			}
		}
	}
}",0,0,1,0
"public class CoapEncoder implements StatelessProtocolEncoder<CoapMessage, ByteBuffer> {
	 private static final Logger LOG = LoggerFactory.getLogger(CoapEncoder.class);
	 private static final int HEADER_SIZE = 4;
	 public Void createEncoderState() {
		 return null;
	 }
	 public ByteBuffer encode(CoapMessage message, Void context) {
		 LOG.debug(""encoding {
		}
		"", message);
		 int size = HEADER_SIZE + message.getToken().length;
		 int delta = 0;
		 for (CoapOption opt : message.getOptions()) {
			 int code = opt.getType().getCode();
			 delta = code - delta;
			 if (delta < 13) {
				 size += 1;
			 }
			 else if (delta < 256 + 13) {
				 size += 2;
			 }
			 else if (delta < 65536 + 269) {
				 size += 3;
			 }
			 int optLength = opt.getData().length;
			 if (optLength < 13) {
				 size += 0;
			 }
			 else if (optLength < 256 + 13) {
				 size += 1;
			 }
			 else if (optLength < 65536 + 269) {
				 size += 2;
			 }
			 size += optLength;
		 }
		 if (message.getPayload() != null && message.getPayload().length > 0) {
			 size += 1;
			 size += message.getPayload().length;
		 }
		 ByteBuffer buffer = ByteBuffer.allocate(size);
		 buffer.order(ByteOrder.BIG_ENDIAN);
		 buffer.put((byte) (((message.getVersion() & 0x03) << 6) | (message.getType().getCode() & 0x03) << 4 | (message .getToken().length & 0x0F)));
		 buffer.put((byte) message.getCode());
		 buffer.putShort((short) message.getId());
		 buffer.put(message.getToken());
		 int lastOptCode = 0;
		 for (CoapOption opt : message.getOptions()) {
			 int optionDelta = opt.getType().getCode() - lastOptCode;
			 int deltaQuartet = getQuartet(optionDelta);
			 int optionLength = opt.getData().length;
			 int optionQuartet = getQuartet(optionLength);
			 buffer.put((byte) ((deltaQuartet << 4) | optionQuartet));
			 if (deltaQuartet == 13) {
				 buffer.put((byte) (optionDelta - 13));
			 }
			 else if (deltaQuartet == 14) {
				 buffer.putShort((short) (optionDelta - 269));
			 }
			 if (optionQuartet == 13) {
				 buffer.put((byte) (optionLength - 13));
			 }
			 else if (optionQuartet == 14) {
				 buffer.putShort((short) (optionLength - 269));
			 }
			 buffer.put(opt.getData());
			 lastOptCode = opt.getType().getCode();
		 }
		 if (message.getPayload() != null && message.getPayload().length > 0) {
			 buffer.put((byte) 0xFF);
			 buffer.put(message.getPayload());
		 }
		 buffer.flip();
		 return buffer;
	 }
	 private int getQuartet(int value) {
		 if (value <= 12) {
			 return value;
		 }
		 else if (value <= 255 + 13) {
			 return 13;
		 }
		 else {
			 return 14;
		 }
	 }
}",1,0,0,0
"protected void scheduleJobs(Scheduler sched) throws SchedulerException {
	 List<JobDetail> jobs = new LinkedList(getLoadedJobs());
	 List<Trigger> triggers = new LinkedList(getLoadedTriggers());
	 log.info(""Adding "" + jobs.size() + "" jobs, "" + triggers.size() + "" triggers."");
	 Map<String, List<Trigger>> triggersByFQJobName = buildTriggersByFQJobNameMap(triggers);
	 Iterator<JobDetail> itr = jobs.iterator();
	 while(itr.hasNext()) {
		 JobDetail detail = itr.next();
		 itr.remove();
		 JobDetail dupeJ = sched.getJobDetail(detail.getName(), detail.getGroup());
		 if ((dupeJ != null)) {
			 if(!isOverWriteExistingData() && isIgnoreDuplicates()) {
				 log.info(""Not overwriting existing job: "" + dupeJ.getFullName());
				 continue;
			 }
			 if(!isOverWriteExistingData() && !isIgnoreDuplicates()) {
				 throw new ObjectAlreadyExistsException(detail);
			 }
		 }
		 if (dupeJ != null) {
			 log.info(""Replacing job: "" + detail.getFullName());
		 }
		 else {
			 log.info(""Adding job: "" + detail.getFullName());
		 }
		 List<Trigger> triggersOfJob = triggersByFQJobName.get(detail.getFullName());
		 if (!detail.isDurable() && (triggersOfJob == null || triggersOfJob.size() == 0)) {
			 if (dupeJ == null) {
				 throw new SchedulerException( ""A new job defined without any triggers must be durable: "" + detail.getFullName());
			 }
			 if ((dupeJ.isDurable() && (sched.getTriggersOfJob( detail.getName(), detail.getGroup()).length == 0))) {
				 throw new SchedulerException( ""Can't change existing durable job without triggers to non-durable: "" + detail.getFullName());
			 }
		 }
		 if(dupeJ != null || detail.isDurable()) {
			 sched.addJob(detail, true);
		 }
		 else {
			 boolean addJobWithFirstSchedule = true;
			 Iterator<Trigger> titr = triggersOfJob.iterator();
			 while(titr.hasNext()) {
				 Trigger trigger = titr.next();
				 triggers.remove(trigger);
				 if(trigger.getStartTime() == null) {
					 trigger.setStartTime(new Date());
				 }
				 boolean addedTrigger = false;
				 while (addedTrigger == false) {
					 Trigger dupeT = sched.getTrigger(trigger.getName(), trigger.getGroup());
					 if (dupeT != null) {
						 if(isOverWriteExistingData()) {
							 if (log.isDebugEnabled()) {
								 log.debug( ""Rescheduling job: "" + trigger.getFullJobName() + "" with updated trigger: "" + trigger.getFullName());
							 }
						 }
						 else if(isIgnoreDuplicates()) {
							 log.info(""Not overwriting existing trigger: "" + dupeT.getFullName());
							 continue;
						 }
						 else {
							 throw new ObjectAlreadyExistsException(trigger);
						 }
						 if(!dupeT.getJobGroup().equals(trigger.getJobGroup()) || !dupeT.getJobName().equals(trigger.getJobName())) {
							 log.warn(""Possibly duplicately named ({
							}
							) triggers in jobs xml file! "", trigger.getFullName());
						 }
						 sched.rescheduleJob(trigger.getName(), trigger.getGroup(), trigger);
					 }
					 else {
						 if (log.isDebugEnabled()) {
							 log.debug( ""Scheduling job: "" + trigger.getFullJobName() + "" with trigger: "" + trigger.getFullName());
						 }
						 try {
							 if(addJobWithFirstSchedule) {
								 sched.scheduleJob(detail, trigger);
								 addJobWithFirstSchedule = false;
							 }
							 else {
								 sched.scheduleJob(trigger);
							 }
						 }
						 catch (ObjectAlreadyExistsException e) {
							 if (log.isDebugEnabled()) {
								 log.debug( ""Adding trigger: "" + trigger.getFullName() + "" for job: "" + detail.getFullName() + "" failed because the trigger already existed. "" + ""This is likely due to a race condition between multiple instances "" + ""in the cluster. Will try to reschedule instead."");
							 }
							 continue;
						 }
					 }
					 addedTrigger = true;
				 }
			 }
		 }
	 }
	 for(Trigger trigger: triggers) {
		 if(trigger.getStartTime() == null) {
			 trigger.setStartTime(new Date());
		 }
		 boolean addedTrigger = false;
		 while (addedTrigger == false) {
			 Trigger dupeT = sched.getTrigger(trigger.getName(), trigger.getGroup());
			 if (dupeT != null) {
				 if(isOverWriteExistingData()) {
					 if (log.isDebugEnabled()) {
						 log.debug( ""Rescheduling job: "" + trigger.getFullJobName() + "" with updated trigger: "" + trigger.getFullName());
					 }
				 }
				 else if(isIgnoreDuplicates()) {
					 log.info(""Not overwriting existing trigger: "" + dupeT.getFullName());
					 continue;
				 }
				 else {
					 throw new ObjectAlreadyExistsException(trigger);
				 }
				 if(!dupeT.getJobGroup().equals(trigger.getJobGroup()) || !dupeT.getJobName().equals(trigger.getJobName())) {
					 log.warn(""Possibly duplicately named ({
					}
					) triggers in jobs xml file! "", trigger.getFullName());
				 }
				 sched.rescheduleJob(trigger.getName(), trigger.getGroup(), trigger);
			 }
			 else {
				 if (log.isDebugEnabled()) {
					 log.debug( ""Scheduling job: "" + trigger.getFullJobName() + "" with trigger: "" + trigger.getFullName());
				 }
				 try {
					 sched.scheduleJob(trigger);
				 }
				 catch (ObjectAlreadyExistsException e) {
					 if (log.isDebugEnabled()) {
						 log.debug( ""Adding trigger: "" + trigger.getFullName() + "" for job: "" +trigger.getFullJobName() + "" failed because the trigger already existed. "" + ""This is likely due to a race condition between multiple instances "" + ""in the cluster. Will try to reschedule instead."");
					 }
					 continue;
				 }
			 }
			 addedTrigger = true;
		 }
	 }
 }",0,0,1,0
"public class DataSourceLoginService extends AbstractLoginService{
	 private static final Logger LOG = Log.getLogger(DataSourceLoginService.class);
	 private String _jndiName = ""javax.sql.DataSource/default"";
	 private DataSource _datasource;
	 private Server _server;
	 private String _userTableName = ""users"";
	 private String _userTableKey = ""id"";
	 private String _userTableUserField = ""username"";
	 private String _userTablePasswordField = ""pwd"";
	 private String _roleTableName = ""roles"";
	 private String _roleTableKey = ""id"";
	 private String _roleTableRoleField = ""role"";
	 private String _userRoleTableName = ""user_roles"";
	 private String _userRoleTableUserKey = ""user_id"";
	 private String _userRoleTableRoleKey = ""role_id"";
	 private String _userSql;
	 private String _roleSql;
	 private boolean _createTables = false;
	 public class DBUserPrincipal extends UserPrincipal {
		 private int _key;
		 public DBUserPrincipal(String name, Credential credential, int key) {
			 super(name, credential);
			 _key = key;
		 }
		 public int getKey () {
			 return _key;
		 }
	 }
	 public DataSourceLoginService() {
	 }
	 public DataSourceLoginService(String name) {
		 setName(name);
	 }
	 public DataSourceLoginService(String name, IdentityService identityService) {
		 setName(name);
		 setIdentityService(identityService);
	 }
	 public void setJndiName (String jndi) {
		 _jndiName = jndi;
	 }
	 public String getJndiName () {
		 return _jndiName;
	 }
	 public void setServer (Server server) {
		 _server=server;
	 }
	 public Server getServer() {
		 return _server;
	 }
	 public void setCreateTables(boolean createTables) {
		 _createTables = createTables;
	 }
	 public boolean getCreateTables() {
		 return _createTables;
	 }
	 public void setUserTableName (String name) {
		 _userTableName=name;
	 }
	 public String getUserTableName() {
		 return _userTableName;
	 }
	 public String getUserTableKey() {
		 return _userTableKey;
	 }
	 public void setUserTableKey(String tableKey) {
		 _userTableKey = tableKey;
	 }
	 public String getUserTableUserField() {
		 return _userTableUserField;
	 }
	 public void setUserTableUserField(String tableUserField) {
		 _userTableUserField = tableUserField;
	 }
	 public String getUserTablePasswordField() {
		 return _userTablePasswordField;
	 }
	 public void setUserTablePasswordField(String tablePasswordField) {
		 _userTablePasswordField = tablePasswordField;
	 }
	 public String getRoleTableName() {
		 return _roleTableName;
	 }
	 public void setRoleTableName(String tableName) {
		 _roleTableName = tableName;
	 }
	 public String getRoleTableKey() {
		 return _roleTableKey;
	 }
	 public void setRoleTableKey(String tableKey) {
		 _roleTableKey = tableKey;
	 }
	 public String getRoleTableRoleField() {
		 return _roleTableRoleField;
	 }
	 public void setRoleTableRoleField(String tableRoleField) {
		 _roleTableRoleField = tableRoleField;
	 }
	 public String getUserRoleTableName() {
		 return _userRoleTableName;
	 }
	 public void setUserRoleTableName(String roleTableName) {
		 _userRoleTableName = roleTableName;
	 }
	 public String getUserRoleTableUserKey() {
		 return _userRoleTableUserKey;
	 }
	 public void setUserRoleTableUserKey(String roleTableUserKey) {
		 _userRoleTableUserKey = roleTableUserKey;
	 }
	 public String getUserRoleTableRoleKey() {
		 return _userRoleTableRoleKey;
	 }
	 public void setUserRoleTableRoleKey(String roleTableRoleKey) {
		 _userRoleTableRoleKey = roleTableRoleKey;
	 }
	 public UserPrincipal loadUserInfo (String username) {
		 try {
			 try (Connection connection = getConnection();
			 PreparedStatement statement1 = connection.prepareStatement(_userSql)) {
				 statement1.setObject(1, username);
				 try (ResultSet rs1 = statement1.executeQuery()) {
					 if (rs1.next()) {
						 int key = rs1.getInt(_userTableKey);
						 String credentials = rs1.getString(_userTablePasswordField);
						 return new DBUserPrincipal(username, Credential.getCredential(credentials), key);
					 }
				 }
			 }
		 }
		 catch (NamingException e) {
			 LOG.warn(""No datasource for ""+_jndiName, e);
		 }
		 catch (SQLException e) {
			 LOG.warn(""Problem loading user info for ""+username, e);
		 }
		 return null;
	 }
	 public String[] loadRoleInfo (UserPrincipal user) {
		 DBUserPrincipal dbuser = (DBUserPrincipal)user;
		 try {
			 try (Connection connection = getConnection();
			 PreparedStatement statement2 = connection.prepareStatement(_roleSql)) {
				 List<String> roles = new ArrayList<String>();
				 statement2.setInt(1, dbuser.getKey());
				 try (ResultSet rs2 = statement2.executeQuery()) {
					 while (rs2.next()) {
						 roles.add(rs2.getString(_roleTableRoleField));
					 }
					 return roles.toArray(new String[roles.size()]);
				 }
			 }
		 }
		 catch (NamingException e) {
			 LOG.warn(""No datasource for ""+_jndiName, e);
		 }
		 catch (SQLException e) {
			 LOG.warn(""Problem loading user info for ""+user.getName(), e);
		 }
		 return null;
	 }
	 public void initDb() throws NamingException, SQLException {
		 if (_datasource != null) return;
		 InitialContext ic = new InitialContext();
		 assert ic!=null;
		 if (_server != null) {
			 try {
				 _datasource = (DataSource)NamingEntryUtil.lookup(_server, _jndiName);
			 }
			 catch (NameNotFoundException e) {
			 }
		 }
		 if (_datasource==null) {
			 _datasource = (DataSource)NamingEntryUtil.lookup(null, _jndiName);
		 }
		 _userSql = ""select "" + _userTableKey + "","" + _userTablePasswordField + "" from "" + _userTableName + "" where ""+ _userTableUserField + "" = ?"";
		 _roleSql = ""select r."" + _roleTableRoleField + "" from "" + _roleTableName + "" r, "" + _userRoleTableName + "" u where u.""+ _userRoleTableUserKey + "" = ?"" + "" and r."" + _roleTableKey + "" = u."" + _userRoleTableRoleKey;
		 prepareTables();
	 }
	 private void prepareTables() throws NamingException, SQLException {
		 if (_createTables) {
			 boolean autocommit = true;
			 Connection connection = getConnection();
			 try (Statement stmt = connection.createStatement()) {
				 autocommit = connection.getAutoCommit();
				 connection.setAutoCommit(false);
				 DatabaseMetaData metaData = connection.getMetaData();
				 String tableName = (metaData.storesLowerCaseIdentifiers()? _userTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userTableName.toUpperCase(Locale.ENGLISH): _userTableName));
				 try (ResultSet result = metaData.getTables(null, null, tableName, null)) {
					 if (!result.next()) {
						 stmt.executeUpdate(""create table ""+_userTableName+ ""(""+_userTableKey+"" integer,""+ _userTableUserField+"" varchar(100) not null unique,""+ _userTablePasswordField+"" varchar(20) not null, primary key(""+_userTableKey+""))"");
						 if (LOG.isDebugEnabled()) LOG.debug(""Created table ""+_userTableName);
					 }
				 }
				 tableName = (metaData.storesLowerCaseIdentifiers()? _roleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_roleTableName.toUpperCase(Locale.ENGLISH): _roleTableName));
				 try (ResultSet result = metaData.getTables(null, null, tableName, null)) {
					 if (!result.next()) {
						 String str = ""create table ""+_roleTableName+"" (""+_roleTableKey+"" integer, ""+ _roleTableRoleField+"" varchar(100) not null unique, primary key(""+_roleTableKey+""))"";
						 stmt.executeUpdate(str);
						 if (LOG.isDebugEnabled()) LOG.debug(""Created table ""+_roleTableName);
					 }
				 }
				 tableName = (metaData.storesLowerCaseIdentifiers()? _userRoleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userRoleTableName.toUpperCase(Locale.ENGLISH): _userRoleTableName));
				 try (ResultSet result = metaData.getTables(null, null, tableName, null)) {
					 if (!result.next()) {
						 stmt.executeUpdate(""create table ""+_userRoleTableName+"" (""+_userRoleTableUserKey+"" integer, ""+ _userRoleTableRoleKey+"" integer, ""+ ""primary key (""+_userRoleTableUserKey+"", ""+_userRoleTableRoleKey+""))"");
						 stmt.executeUpdate(""create index indx_user_role on ""+_userRoleTableName+""(""+_userRoleTableUserKey+"")"");
						 if (LOG.isDebugEnabled()) LOG.debug(""Created table ""+_userRoleTableName +"" and index"");
					 }
				 }
				 connection.commit();
			 }
			 finally {
				 try {
					 connection.setAutoCommit(autocommit);
				 }
				 catch (SQLException e) {
					 if (LOG.isDebugEnabled()) LOG.debug(""Prepare tables"", e);
				 }
				 finally {
					 try {
						 connection.close();
					 }
					 catch (SQLException e) {
						 if (LOG.isDebugEnabled()) LOG.debug(""Prepare tables"", e);
					 }
				 }
			 }
		 }
		 else if (LOG.isDebugEnabled()) {
			 LOG.debug(""createTables false"");
		 }
	 }
	 private Connection getConnection () throws NamingException, SQLException {
		 initDb();
		 return _datasource.getConnection();
	 }
}",1,1,0,0
"public void SwitchTo(int lexState){
	 if (lexState >= 3 || lexState < 0) throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
	 else curLexState = lexState;
}",0,0,0,0
"public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras);",0,0,0,1
"public interface SecuredModel extends Model, SecuredItem, SecuredPrefixMapping {
}",1,0,0,0
"private void checkConfiguration() throws BuildException {
	 if (ejbdescriptor == null) {
		 String msg = ""The standard EJB descriptor must be specified using "" + ""the \""ejbdescriptor\"" attribute."";
		 throw new BuildException(msg, getLocation());
	 }
	 if ((!ejbdescriptor.exists()) || (!ejbdescriptor.isFile())) {
		 String msg = ""The standard EJB descriptor ("" + ejbdescriptor + "") was not found or isn't a file."";
		 throw new BuildException(msg, getLocation());
	 }
	 if (iasdescriptor == null) {
		 String msg = ""The iAS-speific XML descriptor must be specified using"" + "" the \""iasdescriptor\"" attribute."";
		 throw new BuildException(msg, getLocation());
	 }
	 if ((!iasdescriptor.exists()) || (!iasdescriptor.isFile())) {
		 String msg = ""The iAS-specific XML descriptor ("" + iasdescriptor + "") was not found or isn't a file."";
		 throw new BuildException(msg, getLocation());
	 }
	 if (dest == null) {
		 String msg = ""The destination directory must be specified using "" + ""the \""dest\"" attribute."";
		 throw new BuildException(msg, getLocation());
	 }
	 if ((!dest.exists()) || (!dest.isDirectory())) {
		 String msg = ""The destination directory ("" + dest + "") was not "" + ""found or isn't a directory."";
		 throw new BuildException(msg, getLocation());
	 }
	 if ((iashome != null) && (!iashome.isDirectory())) {
		 String msg = ""If \""iashome\"" is specified, it must be a valid "" + ""directory (it was set to "" + iashome + "")."";
		 throw new BuildException(msg, getLocation());
	 }
 }",0,0,0,0
"public void execute() throws BuildException {
	 Commandline commandLine = new Commandline();
	 Project aProj = getProject();
	 int result = 0;
	 if (getTypeName() == null) {
		 throw new BuildException(""Required attribute TypeName not specified"");
	 }
	 if (getViewPath() == null) {
		 setViewPath(aProj.getBaseDir().getPath());
	 }
	 commandLine.setExecutable(getClearToolCommand());
	 commandLine.createArgument().setValue(COMMAND_MKLABEL);
	 checkOptions(commandLine);
	 if (!getFailOnErr()) {
		 getProject().log(""Ignoring any errors that occur for: "" + getViewPathBasename(), Project.MSG_VERBOSE);
	 }
	 result = run(commandLine);
	 if (Execute.isFailure(result) && getFailOnErr()) {
		 String msg = ""Failed executing: "" + commandLine.toString();
		 throw new BuildException(msg, getLocation());
	 }
 }",0,0,0,0
"public boolean equals(Object o) {
	 if (o == null) {
		 return false;
	 }
	 Metadata other = null;
	 try {
		 other = (Metadata) o;
	 }
	 catch (ClassCastException cce) {
		 return false;
	 }
	 if (other.size() != size()) {
		 return false;
	 }
	 String[] names = names();
	 for (int i = 0;
	 i < names.length;
	 i++) {
		 String[] otherValues = other._getValues(names[i]);
		 String[] thisValues = _getValues(names[i]);
		 if (otherValues.length != thisValues.length) {
			 return false;
		 }
		 for (int j = 0;
		 j < otherValues.length;
		 j++) {
			 if (!otherValues[j].equals(thisValues[j])) {
				 return false;
			 }
		 }
	 }
	 return true;
 }",0,0,0,0
"static JFreeChart createStackedXYAreaChart(String title, String xAxisLabel, String yAxisLabel, TableXYDataset dataset, PlotOrientation orientation, boolean legend, boolean tooltips, boolean urls);",0,0,0,1
"public class ItemSorter extends ViewerSorter{
	public int compare( Viewer viewer, Object e1, Object e2 ){
		if ( e1 instanceof DataSourceHandle && e2 instanceof DataSourceHandle ){
			return super.compare( viewer, e1, e2 );
		}
		if ( e1 instanceof DataSetHandle && e2 instanceof DataSetHandle ){
			return super.compare( viewer, e1, e2 );
		}
		if ( e1 instanceof CubeHandle && e2 instanceof CubeHandle ){
			return super.compare( viewer, e1, e2 );
		}
		return 0;
	}
}",0,0,0,0
"public ConnectionTable(Receiver r, InetAddress bind_addr, InetAddress external_addr, int srv_port, int max_port) throws Exception;",0,0,0,1
"final class PolyglotExceptionImpl extends AbstractExceptionImpl implements com.oracle.truffle.polyglot.PolyglotImpl.VMObject {
	 private static final String CAUSE_CAPTION = ""Caused by host exception: "";
	 private static final boolean TRACE_STACK_TRACE_WALKING = false;
	 private PolyglotException api;
	 final PolyglotContextImpl context;
	 private final PolyglotEngineImpl engine;
	 final Throwable exception;
	 private final List<TruffleStackTraceElement> guestFrames;
	 private StackTraceElement[] javaStackTrace;
	 private List<StackFrame> materializedFrames;
	 private final SourceSection sourceLocation;
	 private final boolean internal;
	 private final boolean cancelled;
	 private final boolean exit;
	 private final boolean incompleteSource;
	 private final boolean syntaxError;
	 private final int exitStatus;
	 private final Value guestObject;
	 private final String message;
	 private Object fileSystemContext;
	 PolyglotExceptionImpl(PolyglotLanguageContext languageContext, Throwable original) {
		 this(languageContext.getImpl(), languageContext.getEngine(), languageContext, original);
	 }
	 PolyglotExceptionImpl(PolyglotEngineImpl engine, Throwable original) {
		 this(engine.impl, engine, null, original);
	 }
	 private PolyglotExceptionImpl(AbstractPolyglotImpl impl, PolyglotEngineImpl engine, PolyglotLanguageContext languageContext, Throwable original) {
		 super(impl);
		 Objects.requireNonNull(engine);
		 this.engine = engine;
		 this.context = (languageContext != null) ? languageContext.context : null;
		 this.exception = original;
		 this.guestFrames = TruffleStackTrace.getStackTrace(original);
		 if (exception instanceof TruffleException) {
			 TruffleException truffleException = (TruffleException) exception;
			 this.internal = truffleException.isInternalError();
			 this.cancelled = truffleException.isCancelled();
			 this.syntaxError = truffleException.isSyntaxError();
			 this.incompleteSource = truffleException.isIncompleteSource();
			 this.exit = truffleException.isExit();
			 this.exitStatus = this.exit ? truffleException.getExitStatus() : 0;
			 com.oracle.truffle.api.source.SourceSection section = truffleException.getSourceLocation();
			 if (section != null) {
				 Objects.requireNonNull(languageContext, ""Source location can not be accepted without language context."");
				 com.oracle.truffle.api.source.Source truffleSource = section.getSource();
				 String language = truffleSource.getLanguage();
				 if (language == null) {
					 PolyglotLanguage foundLanguage = languageContext.getEngine().findLanguage(language, truffleSource.getMimeType(), false);
					 if (foundLanguage != null) {
						 language = foundLanguage.getId();
					 }
				 }
				 Source source = getAPIAccess().newSource(language, truffleSource);
				 this.sourceLocation = getAPIAccess().newSourceSection(source, section);
			 }
			 else {
				 this.sourceLocation = null;
			 }
			 Object exceptionObject;
			 if (languageContext != null && !(exception instanceof HostException) && (exceptionObject = ((TruffleException) exception).getExceptionObject()) != null) {
				 Object receiver = exceptionObject;
				 if (receiver instanceof Proxy) {
					 receiver = languageContext.toGuestValue(receiver);
				 }
				 this.guestObject = languageContext.asValue(receiver);
			 }
			 else {
				 this.guestObject = null;
			 }
		 }
		 else {
			 this.cancelled = false;
			 this.internal = true;
			 this.syntaxError = false;
			 this.incompleteSource = false;
			 this.exit = false;
			 this.exitStatus = 0;
			 this.sourceLocation = null;
			 this.guestObject = null;
		 }
		 if (isHostException()) {
			 this.message = asHostException().getMessage();
		 }
		 else {
			 if (internal) {
				 this.message = exception.toString();
			 }
			 else {
				 this.message = exception.getMessage();
			 }
		 }
		 VMAccessor.LANGUAGE.materializeHostFrames(original);
	 }
	 public boolean equals(Object obj) {
		 if (obj instanceof PolyglotExceptionImpl) {
			 return exception == ((PolyglotExceptionImpl) obj).exception;
		 }
		 return false;
	 }
	 public int hashCode() {
		 return exception.hashCode();
	 }
	 public org.graalvm.polyglot.SourceSection getSourceLocation() {
		 return sourceLocation;
	 }
	 public void onCreate(PolyglotException instance) {
		 this.api = instance;
	 }
	 public boolean isHostException() {
		 return exception instanceof HostException;
	 }
	 public Throwable asHostException() {
		 if (!(exception instanceof HostException)) {
			 throw new PolyglotUnsupportedException( String.format(""Unsupported operation %s.%s. You can ensure that the operation is supported using %s.%s."", PolyglotException.class.getSimpleName(), ""asHostException()"", PolyglotException.class.getSimpleName(), ""isHostException()""));
		 }
		 return ((HostException) exception).getOriginal();
	 }
	 public void printStackTrace(PrintWriter s) {
		 printStackTrace(new WrappedPrintWriter(s));
	 }
	 public void printStackTrace(PrintStream s) {
		 printStackTrace(new WrappedPrintStream(s));
	 }
	 private void printStackTrace(PrintStreamOrWriter s) {
		 synchronized (s.lock()) {
			 if (isInternalError() || getMessage() == null || getMessage().isEmpty()) {
				 s.println(api);
			 }
			 else {
				 s.println(getMessage());
			 }
			 materialize();
			 int languageIdLength = 0;
			 for (StackFrame traceElement : getPolyglotStackTrace()) {
				 if (!traceElement.isHostFrame()) {
					 languageIdLength = Math.max(languageIdLength, getAPIAccess().getImpl(traceElement).getLanguage().getId().length());
				 }
			 }
			 for (StackFrame traceElement : getPolyglotStackTrace()) {
				 s.println(""\tat "" + getAPIAccess().getImpl(traceElement).toStringImpl(languageIdLength));
			 }
			 if (isHostException()) {
				 s.println(CAUSE_CAPTION + asHostException());
			 }
			 if (isInternalError()) {
				 s.println(""Original Internal Error: "");
				 s.printStackTrace(exception);
			 }
		 }
	 }
	 public String getMessage() {
		 return message;
	 }
	 public StackTraceElement[] getJavaStackTrace() {
		 if (javaStackTrace == null) {
			 materialize();
			 javaStackTrace = new StackTraceElement[materializedFrames.size()];
			 for (int i = 0;
			 i < javaStackTrace.length;
			 i++) {
				 javaStackTrace[i] = materializedFrames.get(i).toHostFrame();
			 }
		 }
		 return javaStackTrace;
	 }
	 private void materialize() {
		 if (this.materializedFrames == null) {
			 List<StackFrame> frames = new ArrayList<>();
			 for (StackFrame frame : getPolyglotStackTrace()) {
				 frames.add(frame);
			 }
			 this.materializedFrames = Collections.unmodifiableList(frames);
		 }
	 }
	 public StackTraceElement[] getStackTrace() {
		 return getJavaStackTrace().clone();
	 }
	 public PolyglotEngineImpl getEngine() {
		 return engine;
	 }
	 public boolean isInternalError() {
		 return internal;
	 }
	 public Iterable<StackFrame> getPolyglotStackTrace() {
		 if (materializedFrames != null) {
			 return materializedFrames;
		 }
		 else {
			 return new Iterable<StackFrame>() {
				 public Iterator<StackFrame> iterator() {
					 return new StackFrameIterator(PolyglotExceptionImpl.this);
				 }
			 }
			;
		 }
	 }
	 public boolean isCancelled() {
		 return cancelled;
	 }
	 public boolean isExit() {
		 return exit;
	 }
	 public boolean isIncompleteSource() {
		 return incompleteSource;
	 }
	 public int getExitStatus() {
		 return exitStatus;
	 }
	 public boolean isSyntaxError() {
		 return syntaxError;
	 }
	 public Value getGuestObject() {
		 return guestObject;
	 }
	 Object getFileSystemContext() {
		 if (fileSystemContext != null) {
			 return fileSystemContext;
		 }
		 if (context == null) {
			 return null;
		 }
		 return VMAccessor.LANGUAGE.createFileSystemContext(context.config.fileSystem, context.engine.getFileTypeDetectorsSupplier());
	 }
	 private abstract static class PrintStreamOrWriter {
		 abstract Object lock();
		 abstract void println(Object o);
		 abstract void printStackTrace(Throwable t);
	 }
	 private static class WrappedPrintStream extends PrintStreamOrWriter {
		 private final PrintStream printStream;
		 WrappedPrintStream(PrintStream printStream) {
			 this.printStream = printStream;
		 }
		 Object lock() {
			 return printStream;
		 }
		 void println(Object o) {
			 printStream.println(o);
		 }
		 void printStackTrace(Throwable t) {
			 t.printStackTrace(printStream);
		 }
	 }
	 private static class WrappedPrintWriter extends PrintStreamOrWriter {
		 private final PrintWriter printWriter;
		 WrappedPrintWriter(PrintWriter printWriter) {
			 this.printWriter = printWriter;
		 }
		 Object lock() {
			 return printWriter;
		 }
		 void println(Object o) {
			 printWriter.println(o);
		 }
		 void printStackTrace(Throwable t) {
			 t.printStackTrace(printWriter);
		 }
	 }
	 private static class StackFrameIterator implements Iterator<StackFrame> {
		 private static final String POLYGLOT_PACKAGE = Engine.class.getName().substring(0, Engine.class.getName().lastIndexOf('.') + 1);
		 private static final String HOST_INTEROP_PACKAGE = ""com.oracle.truffle.polyglot."";
		 private static final String[] JAVA_INTEROP_HOST_TO_GUEST = {
		 HOST_INTEROP_PACKAGE + ""PolyglotMap"", HOST_INTEROP_PACKAGE + ""PolyglotList"", HOST_INTEROP_PACKAGE + ""PolyglotFunction"", HOST_INTEROP_PACKAGE + ""FunctionProxyHandler"", HOST_INTEROP_PACKAGE + ""ObjectProxyHandler"" }
		;
		 final PolyglotExceptionImpl impl;
		 final Iterator<TruffleStackTraceElement> guestFrames;
		 final StackTraceElement[] hostStack;
		 final ListIterator<StackTraceElement> hostFrames;
		 final APIAccess apiAccess;
		 boolean inHostLanguage;
		 boolean firstGuestFrame = true;
		 PolyglotExceptionFrame fetchedNext;
		 StackFrameIterator(PolyglotExceptionImpl impl) {
			 this.impl = impl;
			 this.apiAccess = impl.getAPIAccess();
			 Throwable cause = impl.exception;
			 while (cause.getCause() != null && cause.getStackTrace().length == 0) {
				 if (cause instanceof HostException) {
					 cause = ((HostException) cause).getOriginal();
				 }
				 else {
					 cause = cause.getCause();
				 }
			 }
			 if (VMAccessor.LANGUAGE.isTruffleStackTrace(cause)) {
				 this.hostStack = VMAccessor.LANGUAGE.getInternalStackTraceElements(cause);
			 }
			 else if (cause.getStackTrace() == null || cause.getStackTrace().length == 0) {
				 this.hostStack = impl.exception.getStackTrace();
			 }
			 else {
				 this.hostStack = cause.getStackTrace();
			 }
			 this.guestFrames = impl.guestFrames == null ? Collections.<TruffleStackTraceElement> emptyList().iterator() : impl.guestFrames.iterator();
			 this.hostFrames = Arrays.asList(hostStack).listIterator();
			 this.inHostLanguage = impl.isHostException() || impl.isInternalError();
			 if (TRACE_STACK_TRACE_WALKING) {
				 PrintStream out = System.out;
				 out.println();
			 }
		 }
		 public boolean hasNext() {
			 return fetchNext() != null;
		 }
		 public StackFrame next() {
			 PolyglotExceptionFrame next = fetchNext();
			 if (next == null) {
				 throw new NoSuchElementException();
			 }
			 fetchedNext = null;
			 return apiAccess.newPolyglotStackTraceElement(impl.api, next);
		 }
		 PolyglotExceptionFrame fetchNext() {
			 if (fetchedNext != null) {
				 return fetchedNext;
			 }
			 while (hostFrames.hasNext()) {
				 StackTraceElement element = hostFrames.next();
				 traceStackTraceElement(element);
				 if (inHostLanguage) {
					 int guestToHost = isGuestToHost(element, hostStack, hostFrames.nextIndex());
					 if (guestToHost >= 0) {
						 assert !isHostToGuest(element);
						 inHostLanguage = false;
						 for (int i = 0;
						 i < guestToHost;
						 i++) {
							 assert isGuestToHostReflectiveCall(element);
							 element = hostFrames.next();
							 traceStackTraceElement(element);
						 }
						 assert isGuestToHostCallFromHostInterop(element);
					 }
				 }
				 else {
					 if (isHostToGuest(element)) {
						 inHostLanguage = true;
						 while (hostFrames.hasNext()) {
							 StackTraceElement next = hostFrames.next();
							 traceStackTraceElement(next);
							 if (isHostToGuest(next)) {
								 element = next;
							 }
							 else {
								 hostFrames.previous();
								 break;
							 }
						 }
					 }
				 }
				 if (isGuestCall(element)) {
					 inHostLanguage = false;
					 TruffleStackTraceElement guestFrame = null;
					 if (guestFrames.hasNext()) {
						 guestFrame = guestFrames.next();
					 }
					 PolyglotExceptionFrame frame = PolyglotExceptionFrame.createGuest(impl, guestFrame, firstGuestFrame);
					 firstGuestFrame = false;
					 if (frame != null) {
						 fetchedNext = frame;
						 return fetchedNext;
					 }
				 }
				 else if (inHostLanguage) {
					 fetchedNext = (PolyglotExceptionFrame.createHost(impl, element));
					 return fetchedNext;
				 }
				 else {
				 }
			 }
			 if (guestFrames.hasNext()) {
				 TruffleStackTraceElement guestFrame = guestFrames.next();
				 PolyglotExceptionFrame frame = PolyglotExceptionFrame.createGuest(impl, guestFrame, firstGuestFrame);
				 firstGuestFrame = false;
				 if (frame != null) {
					 fetchedNext = frame;
					 return fetchedNext;
				 }
			 }
			 return null;
		 }
		 static boolean isLazyStackTraceElement(StackTraceElement element) {
			 return element == null;
		 }
		 static boolean isGuestCall(StackTraceElement element) {
			 return isLazyStackTraceElement(element) || VMAccessor.SPI.isGuestCallStackElement(element);
		 }
		 static boolean isHostToGuest(StackTraceElement element) {
			 if (isLazyStackTraceElement(element)) {
				 return false;
			 }
			 if (element.getClassName().startsWith(POLYGLOT_PACKAGE) && element.getClassName().indexOf('.', POLYGLOT_PACKAGE.length()) < 0) {
				 return true;
			 }
			 else if (element.getClassName().startsWith(HOST_INTEROP_PACKAGE)) {
				 for (String hostToGuestClassName : JAVA_INTEROP_HOST_TO_GUEST) {
					 if (element.getClassName().equals(hostToGuestClassName)) {
						 return true;
					 }
				 }
			 }
			 return false;
		 }
		 static int isGuestToHost(StackTraceElement firstElement, StackTraceElement[] hostStack, int nextElementIndex) {
			 if (isLazyStackTraceElement(firstElement)) {
				 return -1;
			 }
			 StackTraceElement element = firstElement;
			 int index = nextElementIndex;
			 while (isGuestToHostReflectiveCall(element) && nextElementIndex < hostStack.length) {
				 element = hostStack[index++];
			 }
			 if (isGuestToHostCallFromHostInterop(element)) {
				 return index - nextElementIndex;
			 }
			 else {
				 return -1;
			 }
		 }
		 private static boolean isGuestToHostCallFromHostInterop(StackTraceElement element) {
			 switch (element.getClassName()) {
				 case ""com.oracle.truffle.polyglot.HostMethodDesc$SingleMethod$MHBase"": return element.getMethodName().equals(""invokeHandle"");
				 case ""com.oracle.truffle.polyglot.HostMethodDesc$SingleMethod$MethodReflectImpl"": return element.getMethodName().equals(""reflectInvoke"");
				 case ""com.oracle.truffle.polyglot.PolyglotProxy$ExecuteNode"": case ""com.oracle.truffle.polyglot.PolyglotProxy$InstantiateNode"": case ""com.oracle.truffle.polyglot.PolyglotProxy$AsPointerNode"": case ""com.oracle.truffle.polyglot.PolyglotProxy$ArrayGetNode"": case ""com.oracle.truffle.polyglot.PolyglotProxy$ArraySetNode"": case ""com.oracle.truffle.polyglot.PolyglotProxy$ArrayRemoveNode"": case ""com.oracle.truffle.polyglot.PolyglotProxy$ArraySizeNode"": case ""com.oracle.truffle.polyglot.PolyglotProxy$GetMemberKeysNode"": case ""com.oracle.truffle.polyglot.PolyglotProxy$PutMemberNode"": case ""com.oracle.truffle.polyglot.PolyglotProxy$RemoveMemberNode"": case ""com.oracle.truffle.polyglot.PolyglotProxy$HasMemberNode"": return element.getMethodName().equals(""executeImpl"");
				 default: return false;
			 }
		 }
		 private static boolean isGuestToHostReflectiveCall(StackTraceElement element) {
			 switch (element.getClassName()) {
				 case ""sun.reflect.NativeMethodAccessorImpl"": case ""sun.reflect.DelegatingMethodAccessorImpl"": case ""jdk.internal.reflect.NativeMethodAccessorImpl"": case ""jdk.internal.reflect.DelegatingMethodAccessorImpl"": case ""java.lang.reflect.Method"": return element.getMethodName().startsWith(""invoke"");
				 default: return false;
			 }
		 }
		 private void traceStackTraceElement(StackTraceElement element) {
			 if (TRACE_STACK_TRACE_WALKING) {
				 PrintStream out = System.out;
				 out.printf(""host: %5s, guestToHost: %2s, hostToGuest: %5s, guestCall: %5s, -- %s %n"", inHostLanguage, isGuestToHost(element, hostStack, hostFrames.nextIndex()), isHostToGuest(element), isGuestCall(element), element);
			 }
		 }
	 }
}",1,1,0,0
"public class MergedMarkup extends Markup{
	private final static Logger log = LoggerFactory.getLogger(MergedMarkup.class);
	public MergedMarkup(final Markup markup, final Markup baseMarkup, int extendIndex){
		super(new MarkupResourceData());
		getMarkupResourceData().setResource(markup.getMarkupResourceData().getResource());
		getMarkupResourceData().setXmlDeclaration(markup.getMarkupResourceData().getXmlDeclaration());
		getMarkupResourceData().setEncoding(markup.getMarkupResourceData().getEncoding());
		getMarkupResourceData().setWicketNamespace(markup.getMarkupResourceData().getWicketNamespace());
		getMarkupResourceData().setBaseMarkup(baseMarkup);
		if (log.isDebugEnabled()){
			String derivedResource = Strings.afterLast(markup.getMarkupResourceData().getResource().toString(), '/');
			String baseResource = Strings.afterLast(baseMarkup.getMarkupResourceData().getResource().toString(), '/');
			log.debug(""Merge markup: derived markup: "" + derivedResource + "";
			 base markup: "" +baseResource);
		}
		merge(markup, baseMarkup, extendIndex);
		initialize();
		if (log.isDebugEnabled()){
			log.debug(""Merge markup: "" + toString());
		}
	}
	public String locationAsString(){
		String l1 = getMarkupResourceData().getBaseMarkup().locationAsString();
		String l2 = getMarkupResourceData().getResource().locationAsString();
		if ((l1 == null) && (l2 == null)){
			return null;
		}
		return l1 + "":"" + l2;
	}
	private void merge(final Markup markup, final Markup baseMarkup, int extendIndex){
		boolean wicketHeadProcessed = false;
		boolean foundHeadTag = false;
		WicketTag childTag = null;
		int baseIndex = 0;
		for (;
		 baseIndex < baseMarkup.size();
		 baseIndex++){
			MarkupElement element = baseMarkup.get(baseIndex);
			if (element instanceof RawMarkup){
				addMarkupElement(element);
				continue;
			}
			final ComponentTag tag = (ComponentTag)element;
			if ((baseMarkup.getMarkupResourceData().getResource() != null) &&(tag.getMarkupClass() == null)){
				tag.setMarkupClass(baseMarkup.getMarkupResourceData().getResource().getMarkupClass());
			}
			if (element instanceof WicketTag){
				WicketTag wtag = (WicketTag)element;
				if (wtag.isChildTag() &&(tag.getMarkupClass() == baseMarkup.getMarkupResourceData().getResource().getMarkupClass())){
					if (wtag.isOpenClose()){
						childTag = wtag;
						WicketTag childOpenTag = (WicketTag)wtag.mutable();
						childOpenTag.getXmlTag().setType(XmlTag.OPEN);
						childOpenTag.setMarkupClass(baseMarkup.getMarkupResourceData().getResource().getMarkupClass());
						addMarkupElement(childOpenTag);
						break;
					}
					else if (wtag.isOpen()){
						addMarkupElement(wtag);
						break;
					}
					else{
						throw new WicketRuntimeException(""Did not expect a </wicket:child> tag in "" + baseMarkup.toString());
					}
				}
				if (wicketHeadProcessed == false){
					if (wtag.isClose() && wtag.isHeadTag() && (foundHeadTag == false)){
						wicketHeadProcessed = true;
						addMarkupElement(wtag);
						copyWicketHead(markup, extendIndex);
						continue;
					}
					if (wtag.isOpen() && wtag.isMajorWicketComponentTag()){
						wicketHeadProcessed = true;
						copyWicketHead(markup, extendIndex);
					}
				}
			}
			if (wicketHeadProcessed == false){
				if (tag.isOpen() && TagUtils.isHeadTag(tag)){
					foundHeadTag = true;
				}
				if ((tag.isClose() && TagUtils.isHeadTag(tag)) ||(tag.isOpen() && TagUtils.isBodyTag(tag))){
					wicketHeadProcessed = true;
					copyWicketHead(markup, extendIndex);
				}
			}
			addMarkupElement(element);
		}
		if (baseIndex == baseMarkup.size()){
			throw new WicketRuntimeException(""Expected to find <wicket:child/> in base markup: "" +baseMarkup.toString());
		}
		for (;
		 extendIndex < markup.size();
		 extendIndex++){
			MarkupElement element = markup.get(extendIndex);
			addMarkupElement(element);
			if (element instanceof WicketTag){
				WicketTag wtag = (WicketTag)element;
				if (wtag.isExtendTag() && wtag.isClose()){
					break;
				}
			}
		}
		if (extendIndex == markup.size()){
			throw new WicketRuntimeException(""Missing close tag </wicket:extend> in derived markup: "" + markup.toString());
		}
		if (((ComponentTag)baseMarkup.get(baseIndex)).isOpen()){
			for (baseIndex++;
			 baseIndex < baseMarkup.size();
			 baseIndex++){
				MarkupElement element = baseMarkup.get(baseIndex);
				if (element instanceof WicketTag){
					WicketTag tag = (WicketTag)element;
					if (tag.isChildTag() && tag.isClose()){
						tag.setMarkupClass(baseMarkup.getMarkupResourceData().getResource().getMarkupClass());
						addMarkupElement(tag);
						break;
					}
					else{
						throw new WicketRuntimeException(""Wicket tags like <wicket:xxx> are not allowed in between <wicket:child> and </wicket:child> tags: "" +markup.toString());
					}
				}
				else if (element instanceof ComponentTag){
					throw new WicketRuntimeException(""Wicket tags identified by wicket:id are not allowed in between <wicket:child> and </wicket:child> tags: "" +markup.toString());
				}
			}
			if (baseIndex == baseMarkup.size()){
				throw new WicketRuntimeException(""Expected to find </wicket:child> in base markup: "" + baseMarkup.toString());
			}
		}
		else{
			WicketTag childCloseTag = (WicketTag)childTag.mutable();
			childCloseTag.getXmlTag().setType(XmlTag.CLOSE);
			childCloseTag.setMarkupClass(baseMarkup.getMarkupResourceData().getResource().getMarkupClass());
			addMarkupElement(childCloseTag);
		}
		for (baseIndex++;
		 baseIndex < baseMarkup.size();
		 baseIndex++){
			MarkupElement element = baseMarkup.get(baseIndex);
			addMarkupElement(element);
			if ((element instanceof ComponentTag) &&(baseMarkup.getMarkupResourceData().getResource() != null)){
				ComponentTag tag = (ComponentTag)element;
				tag.setMarkupClass(baseMarkup.getMarkupResourceData().getResource().getMarkupClass());
			}
		}
		if (Page.class.isAssignableFrom(markup.getMarkupResourceData().getResource().getMarkupClass())){
			int hasOpenWicketHead = -1;
			int hasCloseWicketHead = -1;
			int hasHead = -1;
			for (int i = 0;
			 i < size();
			 i++){
				MarkupElement element = get(i);
				if ((hasOpenWicketHead == -1) && (element instanceof WicketTag) &&((WicketTag)element).isHeadTag()){
					hasOpenWicketHead = i;
				}
				else if ((element instanceof WicketTag) && ((WicketTag)element).isHeadTag() &&((WicketTag)element).isClose()){
					hasCloseWicketHead = i;
				}
				else if ((hasHead == -1) && (element instanceof ComponentTag) &&TagUtils.isHeadTag((ComponentTag)element)){
					hasHead = i;
				}
				else if ((hasHead != -1) && (hasOpenWicketHead != -1)){
					break;
				}
			}
			if ((hasOpenWicketHead != -1) && (hasHead == -1)){
				final XmlTag headOpenTag = new XmlTag();
				headOpenTag.setName(""head"");
				headOpenTag.setType(XmlTag.OPEN);
				final ComponentTag openTag = new ComponentTag(headOpenTag);
				openTag.setId(HtmlHeaderSectionHandler.HEADER_ID);
				openTag.setAutoComponentTag(true);
				final XmlTag headCloseTag = new XmlTag();
				headCloseTag.setName(headOpenTag.getName());
				headCloseTag.setType(XmlTag.CLOSE);
				final ComponentTag closeTag = new ComponentTag(headCloseTag);
				closeTag.setOpenTag(openTag);
				closeTag.setId(HtmlHeaderSectionHandler.HEADER_ID);
				addMarkupElement(hasOpenWicketHead, openTag);
				addMarkupElement(hasCloseWicketHead + 2, closeTag);
			}
		}
	}
	private void copyWicketHead(final Markup markup, int extendIndex){
		boolean copy = false;
		for (int i = 0;
		 i < extendIndex;
		 i++){
			MarkupElement elem = markup.get(i);
			if (elem instanceof WicketTag){
				WicketTag etag = (WicketTag)elem;
				if (etag.isHeadTag()){
					if (etag.isOpen()){
						copy = true;
					}
					else{
						addMarkupElement(elem);
						break;
					}
				}
			}
			if (copy == true){
				addMarkupElement(elem);
			}
		}
	}
}",0,0,0,0
"public static class createExperiment_result implements org.apache.thrift.TBase<createExperiment_result, createExperiment_result._Fields>, java.io.Serializable, Cloneable, Comparable<createExperiment_result> {
	 private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct(""createExperiment_result"");
	 private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField(""success"", org.apache.thrift.protocol.TType.STRING, (short)0);
	 private static final org.apache.thrift.protocol.TField IRE_FIELD_DESC = new org.apache.thrift.protocol.TField(""ire"", org.apache.thrift.protocol.TType.STRUCT, (short)1);
	 private static final org.apache.thrift.protocol.TField ACE_FIELD_DESC = new org.apache.thrift.protocol.TField(""ace"", org.apache.thrift.protocol.TType.STRUCT, (short)2);
	 private static final org.apache.thrift.protocol.TField ASE_FIELD_DESC = new org.apache.thrift.protocol.TField(""ase"", org.apache.thrift.protocol.TType.STRUCT, (short)3);
	 private static final org.apache.thrift.protocol.TField AE_FIELD_DESC = new org.apache.thrift.protocol.TField(""ae"", org.apache.thrift.protocol.TType.STRUCT, (short)4);
	 private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
	 static {
		 schemes.put(StandardScheme.class, new createExperiment_resultStandardSchemeFactory());
		 schemes.put(TupleScheme.class, new createExperiment_resultTupleSchemeFactory());
	 }
	 public String success;
	 public org.apache.airavata.model.error.InvalidRequestException ire;
	 public org.apache.airavata.model.error.AiravataClientException ace;
	 public org.apache.airavata.model.error.AiravataSystemException ase;
	 public org.apache.airavata.model.error.AuthorizationException ae;
	 public enum _Fields implements org.apache.thrift.TFieldIdEnum {
		 SUCCESS((short)0, ""success""), IRE((short)1, ""ire""), ACE((short)2, ""ace""), ASE((short)3, ""ase""), AE((short)4, ""ae"");
		 private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
		 static {
			 for (_Fields field : EnumSet.allOf(_Fields.class)) {
				 byName.put(field.getFieldName(), field);
			 }
		 }
		 public static _Fields findByThriftId(int fieldId) {
			 switch(fieldId) {
				 case 0: return SUCCESS;
				 case 1: return IRE;
				 case 2: return ACE;
				 case 3: return ASE;
				 case 4: return AE;
				 default: return null;
			 }
		 }
		 public static _Fields findByThriftIdOrThrow(int fieldId) {
			 _Fields fields = findByThriftId(fieldId);
			 if (fields == null) throw new IllegalArgumentException(""Field "" + fieldId + "" doesn't exist!"");
			 return fields;
		 }
		 public static _Fields findByName(String name) {
			 return byName.get(name);
		 }
		 private final short _thriftId;
		 private final String _fieldName;
		 _Fields(short thriftId, String fieldName) {
			 _thriftId = thriftId;
			 _fieldName = fieldName;
		 }
		 public short getThriftFieldId() {
			 return _thriftId;
		 }
		 public String getFieldName() {
			 return _fieldName;
		 }
	 }
	 public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
	 static {
		 Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
		 tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData(""success"", org.apache.thrift.TFieldRequirementType.DEFAULT, new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
		 tmpMap.put(_Fields.IRE, new org.apache.thrift.meta_data.FieldMetaData(""ire"", org.apache.thrift.TFieldRequirementType.DEFAULT, new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
		 tmpMap.put(_Fields.ACE, new org.apache.thrift.meta_data.FieldMetaData(""ace"", org.apache.thrift.TFieldRequirementType.DEFAULT, new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
		 tmpMap.put(_Fields.ASE, new org.apache.thrift.meta_data.FieldMetaData(""ase"", org.apache.thrift.TFieldRequirementType.DEFAULT, new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
		 tmpMap.put(_Fields.AE, new org.apache.thrift.meta_data.FieldMetaData(""ae"", org.apache.thrift.TFieldRequirementType.DEFAULT, new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));
		 metaDataMap = Collections.unmodifiableMap(tmpMap);
		 org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(createExperiment_result.class, metaDataMap);
	 }
	 public createExperiment_result() {
	 }
	 public createExperiment_result( String success, org.apache.airavata.model.error.InvalidRequestException ire, org.apache.airavata.model.error.AiravataClientException ace, org.apache.airavata.model.error.AiravataSystemException ase, org.apache.airavata.model.error.AuthorizationException ae) {
		 this();
		 this.success = success;
		 this.ire = ire;
		 this.ace = ace;
		 this.ase = ase;
		 this.ae = ae;
	 }
	 public createExperiment_result(createExperiment_result other) {
		 if (other.isSetSuccess()) {
			 this.success = other.success;
		 }
		 if (other.isSetIre()) {
			 this.ire = new org.apache.airavata.model.error.InvalidRequestException(other.ire);
		 }
		 if (other.isSetAce()) {
			 this.ace = new org.apache.airavata.model.error.AiravataClientException(other.ace);
		 }
		 if (other.isSetAse()) {
			 this.ase = new org.apache.airavata.model.error.AiravataSystemException(other.ase);
		 }
		 if (other.isSetAe()) {
			 this.ae = new org.apache.airavata.model.error.AuthorizationException(other.ae);
		 }
	 }
	 public createExperiment_result deepCopy() {
		 return new createExperiment_result(this);
	 }
	 public void clear() {
		 this.success = null;
		 this.ire = null;
		 this.ace = null;
		 this.ase = null;
		 this.ae = null;
	 }
	 public String getSuccess() {
		 return this.success;
	 }
	 public createExperiment_result setSuccess(String success) {
		 this.success = success;
		 return this;
	 }
	 public void unsetSuccess() {
		 this.success = null;
	 }
	 public boolean isSetSuccess() {
		 return this.success != null;
	 }
	 public void setSuccessIsSet(boolean value) {
		 if (!value) {
			 this.success = null;
		 }
	 }
	 public org.apache.airavata.model.error.InvalidRequestException getIre() {
		 return this.ire;
	 }
	 public createExperiment_result setIre(org.apache.airavata.model.error.InvalidRequestException ire) {
		 this.ire = ire;
		 return this;
	 }
	 public void unsetIre() {
		 this.ire = null;
	 }
	 public boolean isSetIre() {
		 return this.ire != null;
	 }
	 public void setIreIsSet(boolean value) {
		 if (!value) {
			 this.ire = null;
		 }
	 }
	 public org.apache.airavata.model.error.AiravataClientException getAce() {
		 return this.ace;
	 }
	 public createExperiment_result setAce(org.apache.airavata.model.error.AiravataClientException ace) {
		 this.ace = ace;
		 return this;
	 }
	 public void unsetAce() {
		 this.ace = null;
	 }
	 public boolean isSetAce() {
		 return this.ace != null;
	 }
	 public void setAceIsSet(boolean value) {
		 if (!value) {
			 this.ace = null;
		 }
	 }
	 public org.apache.airavata.model.error.AiravataSystemException getAse() {
		 return this.ase;
	 }
	 public createExperiment_result setAse(org.apache.airavata.model.error.AiravataSystemException ase) {
		 this.ase = ase;
		 return this;
	 }
	 public void unsetAse() {
		 this.ase = null;
	 }
	 public boolean isSetAse() {
		 return this.ase != null;
	 }
	 public void setAseIsSet(boolean value) {
		 if (!value) {
			 this.ase = null;
		 }
	 }
	 public org.apache.airavata.model.error.AuthorizationException getAe() {
		 return this.ae;
	 }
	 public createExperiment_result setAe(org.apache.airavata.model.error.AuthorizationException ae) {
		 this.ae = ae;
		 return this;
	 }
	 public void unsetAe() {
		 this.ae = null;
	 }
	 public boolean isSetAe() {
		 return this.ae != null;
	 }
	 public void setAeIsSet(boolean value) {
		 if (!value) {
			 this.ae = null;
		 }
	 }
	 public void setFieldValue(_Fields field, Object value) {
		 switch (field) {
			 case SUCCESS: if (value == null) {
				 unsetSuccess();
			 }
			 else {
				 setSuccess((String)value);
			 }
			 break;
			 case IRE: if (value == null) {
				 unsetIre();
			 }
			 else {
				 setIre((org.apache.airavata.model.error.InvalidRequestException)value);
			 }
			 break;
			 case ACE: if (value == null) {
				 unsetAce();
			 }
			 else {
				 setAce((org.apache.airavata.model.error.AiravataClientException)value);
			 }
			 break;
			 case ASE: if (value == null) {
				 unsetAse();
			 }
			 else {
				 setAse((org.apache.airavata.model.error.AiravataSystemException)value);
			 }
			 break;
			 case AE: if (value == null) {
				 unsetAe();
			 }
			 else {
				 setAe((org.apache.airavata.model.error.AuthorizationException)value);
			 }
			 break;
		 }
	 }
	 public Object getFieldValue(_Fields field) {
		 switch (field) {
			 case SUCCESS: return getSuccess();
			 case IRE: return getIre();
			 case ACE: return getAce();
			 case ASE: return getAse();
			 case AE: return getAe();
		 }
		 throw new IllegalStateException();
	 }
	 public boolean isSet(_Fields field) {
		 if (field == null) {
			 throw new IllegalArgumentException();
		 }
		 switch (field) {
			 case SUCCESS: return isSetSuccess();
			 case IRE: return isSetIre();
			 case ACE: return isSetAce();
			 case ASE: return isSetAse();
			 case AE: return isSetAe();
		 }
		 throw new IllegalStateException();
	 }
	 public boolean equals(Object that) {
		 if (that == null) return false;
		 if (that instanceof createExperiment_result) return this.equals((createExperiment_result)that);
		 return false;
	 }
	 public boolean equals(createExperiment_result that) {
		 if (that == null) return false;
		 boolean this_present_success = true && this.isSetSuccess();
		 boolean that_present_success = true && that.isSetSuccess();
		 if (this_present_success || that_present_success) {
			 if (!(this_present_success && that_present_success)) return false;
			 if (!this.success.equals(that.success)) return false;
		 }
		 boolean this_present_ire = true && this.isSetIre();
		 boolean that_present_ire = true && that.isSetIre();
		 if (this_present_ire || that_present_ire) {
			 if (!(this_present_ire && that_present_ire)) return false;
			 if (!this.ire.equals(that.ire)) return false;
		 }
		 boolean this_present_ace = true && this.isSetAce();
		 boolean that_present_ace = true && that.isSetAce();
		 if (this_present_ace || that_present_ace) {
			 if (!(this_present_ace && that_present_ace)) return false;
			 if (!this.ace.equals(that.ace)) return false;
		 }
		 boolean this_present_ase = true && this.isSetAse();
		 boolean that_present_ase = true && that.isSetAse();
		 if (this_present_ase || that_present_ase) {
			 if (!(this_present_ase && that_present_ase)) return false;
			 if (!this.ase.equals(that.ase)) return false;
		 }
		 boolean this_present_ae = true && this.isSetAe();
		 boolean that_present_ae = true && that.isSetAe();
		 if (this_present_ae || that_present_ae) {
			 if (!(this_present_ae && that_present_ae)) return false;
			 if (!this.ae.equals(that.ae)) return false;
		 }
		 return true;
	 }
	 public int hashCode() {
		 List<Object> list = new ArrayList<Object>();
		 boolean present_success = true && (isSetSuccess());
		 list.add(present_success);
		 if (present_success) list.add(success);
		 boolean present_ire = true && (isSetIre());
		 list.add(present_ire);
		 if (present_ire) list.add(ire);
		 boolean present_ace = true && (isSetAce());
		 list.add(present_ace);
		 if (present_ace) list.add(ace);
		 boolean present_ase = true && (isSetAse());
		 list.add(present_ase);
		 if (present_ase) list.add(ase);
		 boolean present_ae = true && (isSetAe());
		 list.add(present_ae);
		 if (present_ae) list.add(ae);
		 return list.hashCode();
	 }
	 public int compareTo(createExperiment_result other) {
		 if (!getClass().equals(other.getClass())) {
			 return getClass().getName().compareTo(other.getClass().getName());
		 }
		 int lastComparison = 0;
		 lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (isSetSuccess()) {
			 lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 lastComparison = Boolean.valueOf(isSetIre()).compareTo(other.isSetIre());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (isSetIre()) {
			 lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ire, other.ire);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 lastComparison = Boolean.valueOf(isSetAce()).compareTo(other.isSetAce());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (isSetAce()) {
			 lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ace, other.ace);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 lastComparison = Boolean.valueOf(isSetAse()).compareTo(other.isSetAse());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (isSetAse()) {
			 lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ase, other.ase);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 lastComparison = Boolean.valueOf(isSetAe()).compareTo(other.isSetAe());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (isSetAe()) {
			 lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ae, other.ae);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 return 0;
	 }
	 public _Fields fieldForId(int fieldId) {
		 return _Fields.findByThriftId(fieldId);
	 }
	 public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
		 schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
	 }
	 public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
		 schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder(""createExperiment_result("");
		 boolean first = true;
		 sb.append(""success:"");
		 if (this.success == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.success);
		 }
		 first = false;
		 if (!first) sb.append("", "");
		 sb.append(""ire:"");
		 if (this.ire == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.ire);
		 }
		 first = false;
		 if (!first) sb.append("", "");
		 sb.append(""ace:"");
		 if (this.ace == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.ace);
		 }
		 first = false;
		 if (!first) sb.append("", "");
		 sb.append(""ase:"");
		 if (this.ase == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.ase);
		 }
		 first = false;
		 if (!first) sb.append("", "");
		 sb.append(""ae:"");
		 if (this.ae == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.ae);
		 }
		 first = false;
		 sb.append("")"");
		 return sb.toString();
	 }
	 public void validate() throws org.apache.thrift.TException {
	 }
	 private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
		 try {
			 write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
		 }
		 catch (org.apache.thrift.TException te) {
			 throw new java.io.IOException(te);
		 }
	 }
	 private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
		 try {
			 read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
		 }
		 catch (org.apache.thrift.TException te) {
			 throw new java.io.IOException(te);
		 }
	 }
	 private static class createExperiment_resultStandardSchemeFactory implements SchemeFactory {
		 public createExperiment_resultStandardScheme getScheme() {
			 return new createExperiment_resultStandardScheme();
		 }
	 }
	 private static class createExperiment_resultStandardScheme extends StandardScheme<createExperiment_result> {
		 public void read(org.apache.thrift.protocol.TProtocol iprot, createExperiment_result struct) throws org.apache.thrift.TException {
			 org.apache.thrift.protocol.TField schemeField;
			 iprot.readStructBegin();
			 while (true) {
				 schemeField = iprot.readFieldBegin();
				 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
					 break;
				 }
				 switch (schemeField.id) {
					 case 0: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
						 struct.success = iprot.readString();
						 struct.setSuccessIsSet(true);
					 }
					 else {
						 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
						 struct.ire = new org.apache.airavata.model.error.InvalidRequestException();
						 struct.ire.read(iprot);
						 struct.setIreIsSet(true);
					 }
					 else {
						 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 case 2: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
						 struct.ace = new org.apache.airavata.model.error.AiravataClientException();
						 struct.ace.read(iprot);
						 struct.setAceIsSet(true);
					 }
					 else {
						 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 case 3: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
						 struct.ase = new org.apache.airavata.model.error.AiravataSystemException();
						 struct.ase.read(iprot);
						 struct.setAseIsSet(true);
					 }
					 else {
						 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 case 4: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
						 struct.ae = new org.apache.airavata.model.error.AuthorizationException();
						 struct.ae.read(iprot);
						 struct.setAeIsSet(true);
					 }
					 else {
						 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 iprot.readFieldEnd();
			 }
			 iprot.readStructEnd();
			 struct.validate();
		 }
		 public void write(org.apache.thrift.protocol.TProtocol oprot, createExperiment_result struct) throws org.apache.thrift.TException {
			 struct.validate();
			 oprot.writeStructBegin(STRUCT_DESC);
			 if (struct.success != null) {
				 oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
				 oprot.writeString(struct.success);
				 oprot.writeFieldEnd();
			 }
			 if (struct.ire != null) {
				 oprot.writeFieldBegin(IRE_FIELD_DESC);
				 struct.ire.write(oprot);
				 oprot.writeFieldEnd();
			 }
			 if (struct.ace != null) {
				 oprot.writeFieldBegin(ACE_FIELD_DESC);
				 struct.ace.write(oprot);
				 oprot.writeFieldEnd();
			 }
			 if (struct.ase != null) {
				 oprot.writeFieldBegin(ASE_FIELD_DESC);
				 struct.ase.write(oprot);
				 oprot.writeFieldEnd();
			 }
			 if (struct.ae != null) {
				 oprot.writeFieldBegin(AE_FIELD_DESC);
				 struct.ae.write(oprot);
				 oprot.writeFieldEnd();
			 }
			 oprot.writeFieldStop();
			 oprot.writeStructEnd();
		 }
	 }
	 private static class createExperiment_resultTupleSchemeFactory implements SchemeFactory {
		 public createExperiment_resultTupleScheme getScheme() {
			 return new createExperiment_resultTupleScheme();
		 }
	 }
	 private static class createExperiment_resultTupleScheme extends TupleScheme<createExperiment_result> {
		 public void write(org.apache.thrift.protocol.TProtocol prot, createExperiment_result struct) throws org.apache.thrift.TException {
			 TTupleProtocol oprot = (TTupleProtocol) prot;
			 BitSet optionals = new BitSet();
			 if (struct.isSetSuccess()) {
				 optionals.set(0);
			 }
			 if (struct.isSetIre()) {
				 optionals.set(1);
			 }
			 if (struct.isSetAce()) {
				 optionals.set(2);
			 }
			 if (struct.isSetAse()) {
				 optionals.set(3);
			 }
			 if (struct.isSetAe()) {
				 optionals.set(4);
			 }
			 oprot.writeBitSet(optionals, 5);
			 if (struct.isSetSuccess()) {
				 oprot.writeString(struct.success);
			 }
			 if (struct.isSetIre()) {
				 struct.ire.write(oprot);
			 }
			 if (struct.isSetAce()) {
				 struct.ace.write(oprot);
			 }
			 if (struct.isSetAse()) {
				 struct.ase.write(oprot);
			 }
			 if (struct.isSetAe()) {
				 struct.ae.write(oprot);
			 }
		 }
		 public void read(org.apache.thrift.protocol.TProtocol prot, createExperiment_result struct) throws org.apache.thrift.TException {
			 TTupleProtocol iprot = (TTupleProtocol) prot;
			 BitSet incoming = iprot.readBitSet(5);
			 if (incoming.get(0)) {
				 struct.success = iprot.readString();
				 struct.setSuccessIsSet(true);
			 }
			 if (incoming.get(1)) {
				 struct.ire = new org.apache.airavata.model.error.InvalidRequestException();
				 struct.ire.read(iprot);
				 struct.setIreIsSet(true);
			 }
			 if (incoming.get(2)) {
				 struct.ace = new org.apache.airavata.model.error.AiravataClientException();
				 struct.ace.read(iprot);
				 struct.setAceIsSet(true);
			 }
			 if (incoming.get(3)) {
				 struct.ase = new org.apache.airavata.model.error.AiravataSystemException();
				 struct.ase.read(iprot);
				 struct.setAseIsSet(true);
			 }
			 if (incoming.get(4)) {
				 struct.ae = new org.apache.airavata.model.error.AuthorizationException();
				 struct.ae.read(iprot);
				 struct.setAeIsSet(true);
			 }
		 }
	 }
 }",1,1,0,0
"public TCPConnectionMap(String service_name, ThreadFactory f, Receiver r, InetAddress bind_addr, InetAddress external_addr, int srv_port, int max_port, long reaper_interval, long conn_expire_time ) throws Exception;",0,0,0,1
"public class WebsphereDeploymentTool extends GenericDeploymentTool {
	 public static final String PUBLICID_EJB11 = ""- public static final String PUBLICID_EJB20 = ""- protected static final String SCHEMA_DIR = ""Schema/"";
	 protected static final String WAS_EXT = ""ibm-ejb-jar-ext.xmi"";
	 protected static final String WAS_BND = ""ibm-ejb-jar-bnd.xmi"";
	 protected static final String WAS_CMP_MAP = ""Map.mapxmi"";
	 protected static final String WAS_CMP_SCHEMA = ""Schema.dbxmi"";
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private String jarSuffix = "".jar"";
	 private String ejb11DTD;
	 private boolean keepGeneric = false;
	 private boolean alwaysRebuild = true;
	 private boolean ejbdeploy = true;
	 private boolean newCMP = false;
	 private Path wasClasspath = null;
	 private String dbVendor;
	 private String dbName;
	 private String dbSchema;
	 private boolean codegen;
	 private boolean quiet = true;
	 private boolean novalidate;
	 private boolean nowarn;
	 private boolean noinform;
	 private boolean trace;
	 private String rmicOptions;
	 private boolean use35MappingRules;
	 private String tempdir = ""_ejbdeploy_temp"";
	 private File websphereHome;
	 public Path createWASClasspath() {
		 if (wasClasspath == null) {
			 wasClasspath = new Path(getTask().getProject());
		 }
		 return wasClasspath.createPath();
	 }
	 public void setWASClasspath(Path wasClasspath) {
		 this.wasClasspath = wasClasspath;
	 }
	 public void setDbvendor(String dbvendor) {
		 this.dbVendor = dbvendor;
	 }
	 public void setDbname(String dbName) {
		 this.dbName = dbName;
	 }
	 public void setDbschema(String dbSchema) {
		 this.dbSchema = dbSchema;
	 }
	 public void setCodegen(boolean codegen) {
		 this.codegen = codegen;
	 }
	 public void setQuiet(boolean quiet) {
		 this.quiet = quiet;
	 }
	 public void setNovalidate(boolean novalidate) {
		 this.novalidate = novalidate;
	 }
	 public void setNowarn(boolean nowarn) {
		 this.nowarn = nowarn;
	 }
	 public void setNoinform(boolean noinform) {
		 this.noinform = noinform;
	 }
	 public void setTrace(boolean trace) {
		 this.trace = trace;
	 }
	 public void setRmicoptions(String options) {
		 this.rmicOptions = options;
	 }
	 public void setUse35(boolean attr) {
		 use35MappingRules = attr;
	 }
	 public void setRebuild(boolean rebuild) {
		 this.alwaysRebuild = rebuild;
	 }
	 public void setSuffix(String inString) {
		 this.jarSuffix = inString;
	 }
	 public void setKeepgeneric(boolean inValue) {
		 this.keepGeneric = inValue;
	 }
	 public void setEjbdeploy(boolean ejbdeploy) {
		 this.ejbdeploy = ejbdeploy;
	 }
	 public void setEJBdtd(String inString) {
		 this.ejb11DTD = inString;
	 }
	 public void setOldCMP(boolean oldCMP) {
		 this.newCMP = !oldCMP;
	 }
	 public void setNewCMP(boolean newCMP) {
		 this.newCMP = newCMP;
	 }
	 public void setTempdir(String tempdir) {
		 this.tempdir = tempdir;
	 }
	 protected DescriptorHandler getDescriptorHandler(File srcDir) {
		 DescriptorHandler handler = new DescriptorHandler(getTask(), srcDir);
		 handler.registerDTD(PUBLICID_EJB11, ejb11DTD);
		 for (Iterator i = getConfig().dtdLocations.iterator();
		 i.hasNext();
		) {
			 EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();
			 handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
		 }
		 return handler;
	 }
	 protected DescriptorHandler getWebsphereDescriptorHandler(final File srcDir) {
		 DescriptorHandler handler = new DescriptorHandler(getTask(), srcDir) {
			 protected void processElement() {
			 }
		 }
		;
		 for (Iterator i = getConfig().dtdLocations.iterator();
		 i.hasNext();
		) {
			 EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();
			 handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
		 }
		 return handler;
	 }
	 protected void addVendorFiles(Hashtable ejbFiles, String baseName) {
		 String ddPrefix = (usingBaseJarName() ? """" : baseName);
		 String dbPrefix = (dbVendor == null) ? """" : dbVendor + ""-"";
		 File websphereEXT = new File(getConfig().descriptorDir, ddPrefix + WAS_EXT);
		 if (websphereEXT.exists()) {
			 ejbFiles.put(META_DIR + WAS_EXT, websphereEXT);
		 }
		 else {
			 log(""Unable to locate websphere extensions. "" + ""It was expected to be in "" + websphereEXT.getPath(), Project.MSG_VERBOSE);
		 }
		 File websphereBND = new File(getConfig().descriptorDir, ddPrefix + WAS_BND);
		 if (websphereBND.exists()) {
			 ejbFiles.put(META_DIR + WAS_BND, websphereBND);
		 }
		 else {
			 log(""Unable to locate websphere bindings. "" + ""It was expected to be in "" + websphereBND.getPath(), Project.MSG_VERBOSE);
		 }
		 if (!newCMP) {
			 log(""The old method for locating CMP files has been DEPRECATED."", Project.MSG_VERBOSE);
			 log(""Please adjust your websphere descriptor and set "" + ""newCMP=\""true\"" to use the new CMP descriptor "" + ""inclusion mechanism. "", Project.MSG_VERBOSE);
		 }
		 else {
			 try {
				 File websphereMAP = new File(getConfig().descriptorDir, ddPrefix + dbPrefix + WAS_CMP_MAP);
				 if (websphereMAP.exists()) {
					 ejbFiles.put(META_DIR + WAS_CMP_MAP, websphereMAP);
				 }
				 else {
					 log(""Unable to locate the websphere Map: "" + websphereMAP.getPath(), Project.MSG_VERBOSE);
				 }
				 File websphereSchema = new File(getConfig().descriptorDir, ddPrefix + dbPrefix + WAS_CMP_SCHEMA);
				 if (websphereSchema.exists()) {
					 ejbFiles.put(META_DIR + SCHEMA_DIR + WAS_CMP_SCHEMA, websphereSchema);
				 }
				 else {
					 log(""Unable to locate the websphere Schema: "" + websphereSchema.getPath(), Project.MSG_VERBOSE);
				 }
			 }
			 catch (Exception e) {
				 String msg = ""Exception while adding Vendor specific files: "" + e.toString();
				 throw new BuildException(msg, e);
			 }
		 }
	 }
	 File getVendorOutputJarFile(String baseName) {
		 return new File(getDestDir(), baseName + jarSuffix);
	 }
	 protected String getOptions() {
		 StringBuffer options = new StringBuffer();
		 if (dbVendor != null) {
			 options.append("" -dbvendor "").append(dbVendor);
		 }
		 if (dbName != null) {
			 options.append("" -dbname \"""").append(dbName).append(""\"""");
		 }
		 if (dbSchema != null) {
			 options.append("" -dbschema \"""").append(dbSchema).append(""\"""");
		 }
		 if (codegen) {
			 options.append("" -codegen"");
		 }
		 if (quiet) {
			 options.append("" -quiet"");
		 }
		 if (novalidate) {
			 options.append("" -novalidate"");
		 }
		 if (nowarn) {
			 options.append("" -nowarn"");
		 }
		 if (noinform) {
			 options.append("" -noinform"");
		 }
		 if (trace) {
			 options.append("" -trace"");
		 }
		 if (use35MappingRules) {
			 options.append("" -35"");
		 }
		 if (rmicOptions != null) {
			 options.append("" -rmic \"""").append(rmicOptions).append(""\"""");
		 }
		 return options.toString();
	 }
	 private void buildWebsphereJar(File sourceJar, File destJar) {
		 try {
			 if (ejbdeploy) {
				 Java javaTask = new Java(getTask());
				 javaTask.createJvmarg().setValue(""-Xms64m"");
				 javaTask.createJvmarg().setValue(""-Xmx128m"");
				 Environment.Variable var = new Environment.Variable();
				 var.setKey(""websphere.lib.dir"");
				 File libdir = new File(websphereHome, ""lib"");
				 var.setValue(libdir.getAbsolutePath());
				 javaTask.addSysproperty(var);
				 javaTask.setDir(websphereHome);
				 javaTask.setTaskName(""ejbdeploy"");
				 javaTask.setClassname(""com.ibm.etools.ejbdeploy.EJBDeploy"");
				 javaTask.createArg().setValue(sourceJar.getPath());
				 javaTask.createArg().setValue(tempdir);
				 javaTask.createArg().setValue(destJar.getPath());
				 javaTask.createArg().setLine(getOptions());
				 if (getCombinedClasspath() != null && getCombinedClasspath().toString().length() > 0) {
					 javaTask.createArg().setValue(""-cp"");
					 javaTask.createArg().setValue(getCombinedClasspath().toString());
				 }
				 Path classpath = wasClasspath;
				 if (classpath == null) {
					 classpath = getCombinedClasspath();
				 }
				 javaTask.setFork(true);
				 if (classpath != null) {
					 javaTask.setClasspath(classpath);
				 }
				 log(""Calling websphere.ejbdeploy for "" + sourceJar.toString(), Project.MSG_VERBOSE);
				 javaTask.execute();
			 }
		 }
		 catch (Exception e) {
			 String msg = ""Exception while calling ejbdeploy. Details: "" + e.toString();
			 throw new BuildException(msg, e);
		 }
	 }
	 protected void writeJar(String baseName, File jarFile, Hashtable files, String publicId) throws BuildException {
		 if (ejbdeploy) {
			 File genericJarFile = super.getVendorOutputJarFile(baseName);
			 super.writeJar(baseName, genericJarFile, files, publicId);
			 if (alwaysRebuild || isRebuildRequired(genericJarFile, jarFile)) {
				 buildWebsphereJar(genericJarFile, jarFile);
			 }
			 if (!keepGeneric) {
				 log(""deleting generic jar "" + genericJarFile.toString(), Project.MSG_VERBOSE);
				 genericJarFile.delete();
			 }
		 }
		 else {
			 super.writeJar(baseName, jarFile, files, publicId);
		 }
	 }
	 public void validateConfigured() throws BuildException {
		 super.validateConfigured();
		 if (ejbdeploy) {
			 String home = getTask().getProject().getProperty(""websphere.home"");
			 if (home == null) {
				 throw new BuildException(""The 'websphere.home' property must "" + ""be set when 'ejbdeploy=true'"");
			 }
			 websphereHome = getTask().getProject().resolveFile(home);
		 }
	 }
	 protected boolean isRebuildRequired(File genericJarFile, File websphereJarFile) {
		 boolean rebuild = false;
		 JarFile genericJar = null;
		 JarFile wasJar = null;
		 File newwasJarFile = null;
		 JarOutputStream newJarStream = null;
		 ClassLoader genericLoader = null;
		 try {
			 log(""Checking if websphere Jar needs to be rebuilt for jar "" + websphereJarFile.getName(), Project.MSG_VERBOSE);
			 if (genericJarFile.exists() && genericJarFile.isFile() && websphereJarFile.exists() && websphereJarFile.isFile()) {
				 genericJar = new JarFile(genericJarFile);
				 wasJar = new JarFile(websphereJarFile);
				 Hashtable genericEntries = new Hashtable();
				 Hashtable wasEntries = new Hashtable();
				 Hashtable replaceEntries = new Hashtable();
				 for (Enumeration e = genericJar.entries();
				 e.hasMoreElements();
				) {
					 JarEntry je = (JarEntry) e.nextElement();
					 genericEntries.put(je.getName().replace('\\', '/'), je);
				 }
				 for (Enumeration e = wasJar.entries();
				 e.hasMoreElements();
				) {
					 JarEntry je = (JarEntry) e.nextElement();
					 wasEntries.put(je.getName(), je);
				 }
				 genericLoader = getClassLoaderFromJar(genericJarFile);
				 for (Enumeration e = genericEntries.keys();
				 e.hasMoreElements();
				) {
					 String filepath = (String) e.nextElement();
					 if (wasEntries.containsKey(filepath)) {
						 JarEntry genericEntry = (JarEntry) genericEntries.get(filepath);
						 JarEntry wasEntry = (JarEntry) wasEntries.get(filepath);
						 if ((genericEntry.getCrc() != wasEntry.getCrc()) || (genericEntry.getSize() != wasEntry.getSize())) {
							 if (genericEntry.getName().endsWith("".class"")) {
								 String classname = genericEntry.getName().replace(File.separatorChar, '.');
								 classname = classname.substring(0, classname.lastIndexOf("".class""));
								 Class genclass = genericLoader.loadClass(classname);
								 if (genclass.isInterface()) {
									 log(""Interface "" + genclass.getName() + "" has changed"", Project.MSG_VERBOSE);
									 rebuild = true;
									 break;
								 }
								 else {
									 replaceEntries.put(filepath, genericEntry);
								 }
							 }
							 else {
								 if (!genericEntry.getName().equals(""META-INF/MANIFEST.MF"")) {
									 log(""Non class file "" + genericEntry.getName() + "" has changed"", Project.MSG_VERBOSE);
									 rebuild = true;
								 }
								 break;
							 }
						 }
					 }
					 else {
						 log(""File "" + filepath + "" not present in websphere jar"", Project.MSG_VERBOSE);
						 rebuild = true;
						 break;
					 }
				 }
				 if (!rebuild) {
					 log(""No rebuild needed - updating jar"", Project.MSG_VERBOSE);
					 newwasJarFile = new File(websphereJarFile.getAbsolutePath() + "".temp"");
					 if (newwasJarFile.exists()) {
						 newwasJarFile.delete();
					 }
					 newJarStream = new JarOutputStream(new FileOutputStream(newwasJarFile));
					 newJarStream.setLevel(0);
					 for (Enumeration e = wasEntries.elements();
					 e.hasMoreElements();
					) {
						 byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
						 int bytesRead;
						 InputStream is;
						 JarEntry je = (JarEntry) e.nextElement();
						 if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) {
							 newJarStream.setLevel(0);
						 }
						 else {
							 newJarStream.setLevel(JAR_COMPRESS_LEVEL);
						 }
						 if (replaceEntries.containsKey(je.getName())) {
							 log(""Updating Bean class from generic Jar "" + je.getName(), Project.MSG_VERBOSE);
							 je = (JarEntry) replaceEntries.get(je.getName());
							 is = genericJar.getInputStream(je);
						 }
						 else {
							 is = wasJar.getInputStream(je);
						 }
						 newJarStream.putNextEntry(new JarEntry(je.getName()));
						 while ((bytesRead = is.read(buffer)) != -1) {
							 newJarStream.write(buffer, 0, bytesRead);
						 }
						 is.close();
					 }
				 }
				 else {
					 log(""websphere Jar rebuild needed due to changed "" + ""interface or XML"", Project.MSG_VERBOSE);
				 }
			 }
			 else {
				 rebuild = true;
			 }
		 }
		 catch (ClassNotFoundException cnfe) {
			 String cnfmsg = ""ClassNotFoundException while processing ejb-jar file"" + "". Details: "" + cnfe.getMessage();
			 throw new BuildException(cnfmsg, cnfe);
		 }
		 catch (IOException ioe) {
			 String msg = ""IOException while processing ejb-jar file "" + "". Details: "" + ioe.getMessage();
			 throw new BuildException(msg, ioe);
		 }
		 finally {
			 if (genericJar != null) {
				 try {
					 genericJar.close();
				 }
				 catch (IOException closeException) {
				 }
			 }
			 if (wasJar != null) {
				 try {
					 wasJar.close();
				 }
				 catch (IOException closeException) {
				 }
			 }
			 if (newJarStream != null) {
				 try {
					 newJarStream.close();
				 }
				 catch (IOException closeException) {
				 }
				 try {
					 FILE_UTILS.rename(newwasJarFile, websphereJarFile);
				 }
				 catch (IOException renameException) {
					 log(renameException.getMessage(), Project.MSG_WARN);
					 rebuild = true;
				 }
			 }
			 if (genericLoader != null && genericLoader instanceof AntClassLoader) {
				 AntClassLoader loader = (AntClassLoader) genericLoader;
				 loader.cleanup();
			 }
		 }
		 return rebuild;
	 }
	 protected ClassLoader getClassLoaderFromJar(File classjar) throws IOException {
		 Path lookupPath = new Path(getTask().getProject());
		 lookupPath.setLocation(classjar);
		 Path classpath = getCombinedClasspath();
		 if (classpath != null) {
			 lookupPath.append(classpath);
		 }
		 return getTask().getProject().createClassLoader(lookupPath);
	 }
}",0,0,0,0
"class TaskTrackerStatus implements Writable {
	 static {
		 WritableFactories.setFactory (TaskTrackerStatus.class, new WritableFactory() {
			 public Writable newInstance() {
				 return new TaskTrackerStatus();
			 }
		 }
		);
	 }
	 String trackerName;
	 String host;
	 int port;
	 int failures;
	 Vector taskReports;
	 volatile long lastSeen;
	 public TaskTrackerStatus() {
	 }
	 public TaskTrackerStatus(String trackerName, String host, int port, Vector taskReports, int failures) {
		 this.trackerName = trackerName;
		 this.host = host;
		 this.port = port;
		 this.taskReports = new Vector();
		 this.taskReports.addAll(taskReports);
		 this.failures = failures;
	 }
	 public String getTrackerName() {
		 return trackerName;
	 }
	 public String getHost() {
		 return host;
	 }
	 public int getPort() {
		 return port;
	 }
	 public int getFailures() {
		 return failures;
	 }
	 public Iterator taskReports() {
		 return taskReports.iterator();
	 }
	 public int countMapTasks() {
		 int mapCount = 0;
		 for (Iterator it = taskReports.iterator();
		 it.hasNext();
		 ) {
			 TaskStatus ts = (TaskStatus) it.next();
			 if (ts.getIsMap()) {
				 mapCount++;
			 }
		 }
		 return mapCount;
	 }
	 public int countReduceTasks() {
		 return taskReports.size() - countMapTasks();
	 }
	 public long getLastSeen() {
		 return lastSeen;
	 }
	 public void setLastSeen(long lastSeen) {
		 this.lastSeen = lastSeen;
	 }
	 public void write(DataOutput out) throws IOException {
		 UTF8.writeString(out, trackerName);
		 UTF8.writeString(out, host);
		 out.writeInt(port);
		 out.writeInt(taskReports.size());
		 out.writeInt(failures);
		 for (Iterator it = taskReports.iterator();
		 it.hasNext();
		 ) {
			 ((TaskStatus) it.next()).write(out);
		 }
	 }
	 public void readFields(DataInput in) throws IOException {
		 this.trackerName = UTF8.readString(in);
		 this.host = UTF8.readString(in);
		 this.port = in.readInt();
		 taskReports = new Vector();
		 taskReports.clear();
		 int numTasks = in.readInt();
		 this.failures = in.readInt();
		 for (int i = 0;
		 i < numTasks;
		 i++) {
			 TaskStatus tmp = new TaskStatus();
			 tmp.readFields(in);
			 taskReports.add(tmp);
		 }
	 }
}",0,0,0,0
"public class Type extends ResourceComparator {
	 protected int resourceCompare(Resource foo, Resource bar) {
		 boolean f = foo.isDirectory();
		 if (f == bar.isDirectory()) {
			 return 0;
		 }
		 return f ? 1 : -1;
	 }
}",0,0,0,0
"public void setPort(int p) {
	 this.port = p;
 }",0,0,0,0
"public Path createClasspath() {
	 if (compileClasspath == null) {
		 compileClasspath = new Path(getProject());
	 }
	 return compileClasspath;
 }",0,0,0,0
"public class LogUtils {
	 private static final String HIVE_L4J = ""metastore-log4j2.properties"";
	 private static final Logger l4j = LoggerFactory.getLogger(LogUtils.class);
	 public static class LogInitializationException extends Exception {
		 LogInitializationException(String msg) {
			 super(msg);
		 }
	 }
	 public static class StackTraceLogger extends Exception {
		 public StackTraceLogger(final String msg) {
			 super(msg);
		 }
	 }
	 public static String initHiveLog4j(Configuration conf) throws LogInitializationException {
		 return initHiveLog4jCommon(conf, MetastoreConf.ConfVars.LOG4J_FILE);
	 }
	 private static String initHiveLog4jCommon(Configuration conf, ConfVars confVarName) throws LogInitializationException {
		 if (MetastoreConf.getVar(conf, confVarName).equals("""")) {
			 return initHiveLog4jDefault(conf, """", confVarName);
		 }
		 else {
			 String log4jFileName = MetastoreConf.getVar(conf, confVarName);
			 File log4jConfigFile = new File(log4jFileName);
			 boolean fileExists = log4jConfigFile.exists();
			 if (!fileExists) {
				 return initHiveLog4jDefault( conf, ""Not able to find conf file: "" + log4jConfigFile, confVarName);
			 }
			 else {
				 final boolean async = checkAndSetAsyncLogging(conf);
				 System.setProperty(DefaultThreadContextMap.INHERITABLE_MAP, ""true"");
				 Configurator.initialize(null, log4jFileName);
				 logConfigLocation();
				 return ""Logging initialized using configuration in "" + log4jConfigFile + "" Async: "" + async;
			 }
		 }
	 }
	 private static boolean checkAndSetAsyncLogging(final Configuration conf) {
		 final boolean asyncLogging = MetastoreConf.getBoolVar(conf, ConfVars.ASYNC_LOG_ENABLED);
		 if (asyncLogging) {
			 System.setProperty(""Log4jContextSelector"", ""org.apache.logging.log4j.core.async.AsyncLoggerContextSelector"");
			 LogManager.setFactory(new Log4jContextFactory());
		 }
		 return asyncLogging;
	 }
	 private static String initHiveLog4jDefault(Configuration conf, String logMessage, ConfVars confVarName) throws LogInitializationException {
		 URL hive_l4j = null;
		 switch (confVarName) {
			 case LOG4J_FILE: hive_l4j = LogUtils.class.getClassLoader().getResource(HIVE_L4J);
			 break;
			 default: break;
		 }
		 if (hive_l4j != null) {
			 final boolean async = checkAndSetAsyncLogging(conf);
			 System.setProperty(DefaultThreadContextMap.INHERITABLE_MAP, ""true"");
			 Configurator.initialize(null, hive_l4j.toString());
			 logConfigLocation();
			 return (logMessage + ""\n"" + ""Logging initialized using configuration in "" + hive_l4j + "" Async: "" + async);
		 }
		 else {
			 throw new LogInitializationException( logMessage + ""Unable to initialize logging using "" + LogUtils.HIVE_L4J + "", not found on CLASSPATH!"");
		 }
	 }
	 private static void logConfigLocation() throws LogInitializationException {
		 if (MetastoreConf.getHiveDefaultLocation() != null) {
			 l4j.warn(""DEPRECATED: Ignoring hive-default.xml found on the CLASSPATH at "" + MetastoreConf.getHiveDefaultLocation().getPath());
		 }
		 if (MetastoreConf.getHiveSiteLocation() == null) {
			 l4j.warn(""hive-site.xml not found on CLASSPATH"");
		 }
		 else {
			 l4j.debug(""Using hive-site.xml found on CLASSPATH at "" + MetastoreConf.getHiveSiteLocation().getPath());
		 }
	 }
}",1,0,0,0
"private JPanel createBrowserIntPanel() {
	JPanel p = new JPanel();
	p.setLayout(null);
	p.setOpaque(false);
	int y = 30;
	int h = 70;
	JTextArea txt1 = createTextArea(""DESC_MONITORING_1"");
	txt1.setBounds(15, y, 350 - 30, h);
	p.add(txt1);
	y += h;
	y += 30;
	h = 25;
	JLabel lblFirefox = new JLabel(StringResource.get(""DESC_MOZILLA_FIREFOX""));
	lblFirefox.setFont(FontResource.getBigFont());
	lblFirefox.setBounds(15, y, 135, h);
	p.add(lblFirefox);
	JLabel lblChrome = new JLabel(StringResource.get(""DESC_GOOGLE_CHROME""));
	lblChrome.setFont(FontResource.getBigFont());
	lblChrome.setBounds(180, y, 135, h);
	p.add(lblChrome);
	y += h;
	JButton btnFF = createButton2(""DESC_INSTALL"");
	btnFF.setName(""FF_INSTALL"");
	btnFF.setBounds(15, y, 140, h);
	p.add(btnFF);
	JButton btnCr = createButton2(""DESC_INSTALL"");
	btnCr.setName(""CR_INSTALL"");
	btnCr.setBounds(180, y, 140, h);
	p.add(btnCr);
	y += h;
	y += 15;
	h = 25;
	JLabel lblOpera = new JLabel(StringResource.get(""DESC_OPERA""));
	lblOpera.setFont(FontResource.getBigFont());
	lblOpera.setBounds(15, y, 135, h);
	p.add(lblOpera);
	JLabel lblCm = new JLabel(StringResource.get(""DESC_CHROMIUM""));
	lblCm.setFont(FontResource.getBigFont());
	lblCm.setBounds(180, y, 135, h);
	p.add(lblCm);
	y += h;
	JButton btnOp = createButton2(""DESC_INSTALL"");
	btnOp.setName(""OP_INSTALL"");
	btnOp.setBounds(15, y, 140, h);
	p.add(btnOp);
	JButton btnCm = createButton2(""DESC_INSTALL"");
	btnCm.setName(""CM_INSTALL"");
	btnCm.setBounds(180, y, 140, h);
	p.add(btnCm);
	y += h;
	y += 15;
	h = 25;
	JLabel lblEdge = new JLabel(StringResource.get(""DESC_VIVALDI""));
	lblEdge.setFont(FontResource.getBigFont());
	lblEdge.setName(""VL_INSTALL"");
	lblEdge.setBounds(15, y, 135, h);
	p.add(lblEdge);
	y += h;
	JButton btnEdge = createButton2(""DESC_INSTALL"");
	btnEdge.setName(""VL_INSTALL"");
	btnEdge.addActionListener(this);
	btnEdge.setBounds(15, y, 140, h);
	p.add(btnEdge);
	y += h;
	y += 40;
	h = 50;
	JTextArea txt2 = createTextArea(""DESC_OTHER_BROWSERS"");
	txt2.setBounds(15, y, 350 - 30, h);
	p.add(txt2);
	y += h;
	h = 30;
	JLabel labelMoz = new JLabel(StringResource.get(""DESC_MOZ""));
	labelMoz.setCursor(new Cursor(Cursor.HAND_CURSOR));
	labelMoz.addMouseListener(new MouseAdapter() {
		public void mouseClicked(MouseEvent e) {
			showMsgFF();
		}
	}
	);
	Font font = FontResource.getNormalFont();
	Map attributes = font.getAttributes();
	attributes.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
	labelMoz.setBounds(15, y, 350 - 30, h);
	labelMoz.setFont(font.deriveFont(attributes));
	labelMoz.setForeground(Color.WHITE);
	p.add(labelMoz);
	y += h;
	h = 30;
	JLabel labelCr = new JLabel(StringResource.get(""DESC_CHROME""));
	labelCr.setCursor(new Cursor(Cursor.HAND_CURSOR));
	labelCr.addMouseListener(new MouseAdapter() {
		public void mouseClicked(MouseEvent e) {
			showMsgChrome();
		}
	}
	);
	labelCr.setBounds(15, y, 350 - 30, h);
	labelCr.setFont(font.deriveFont(attributes));
	labelCr.setForeground(Color.WHITE);
	p.add(labelCr);
	y += h;
	y += 40;
	h = 40;
	JTextArea txt3 = createTextArea(""DESC_FILETYPES"");
	txt3.setBounds(15, y, 350 - 40, h);
	p.add(txt3);
	y += h;
	h = 70;
	txtFileTyp = new JTextArea();
	txtFileTyp.setBorder(new LineBorder(ColorResource.getDarkBgColor()));
	txtFileTyp.setOpaque(false);
	txtFileTyp.setWrapStyleWord(true);
	txtFileTyp.setLineWrap(true);
	txtFileTyp.setForeground(Color.WHITE);
	txtFileTyp.setFont(FontResource.getNormalFont());
	txtFileTyp.setBounds(15, y, 350 - 40, h);
	p.add(txtFileTyp);
	y += h;
	y += 10;
	h = 25;
	JButton btnDef1 = createButton2(""DESC_DEF"");
	btnDef1.setName(""BTN_DEF_FILE_EXT"");
	btnDef1.setBounds(310 - 125, y, 140, h);
	p.add(btnDef1);
	y += h;
	y += 40;
	h = 30;
	chkVidPan = createCheckBox(""OPT_VID_PANE"");
	chkVidPan.setBounds(15, y, 350 - 30, h);
	p.add(chkVidPan);
	y += h;
	y += 10;
	h = 40;
	JTextArea txt4 = createTextArea(""DESC_VIDEOTYPES"");
	txt4.setBounds(15, y, 350 - 40, h);
	p.add(txt4);
	y += h;
	h = 70;
	txtVidType = new JTextArea();
	txtVidType.setOpaque(false);
	txtVidType.setBorder(new LineBorder(ColorResource.getDarkBgColor()));
	txtVidType.setWrapStyleWord(true);
	txtVidType.setLineWrap(true);
	txtVidType.setForeground(Color.WHITE);
	txtVidType.setFont(FontResource.getNormalFont());
	txtVidType.setBounds(15, y, 350 - 40, h);
	p.add(txtVidType);
	y += h;
	y += 10;
	h = 25;
	JButton btnDef2 = createButton2(""DESC_DEF"");
	btnDef2.setName(""BTN_DEF_VID_EXT"");
	btnDef2.setBounds(310 - 125, y, 140, h);
	p.add(btnDef2);
	y += h;
	y += 40;
	h = 40;
	JTextArea txt6 = createTextArea(""DESC_SITEEXCEPTIONS"");
	txt6.setBounds(15, y, 350 - 30, h);
	p.add(txt6);
	y += h;
	h = 70;
	txtBlockedHosts = new JTextArea();
	txtBlockedHosts.setOpaque(false);
	txtBlockedHosts.setBorder(new LineBorder(ColorResource.getDarkBgColor()));
	txtBlockedHosts.setWrapStyleWord(true);
	txtBlockedHosts.setLineWrap(true);
	txtBlockedHosts.setForeground(Color.WHITE);
	txtBlockedHosts.setFont(FontResource.getNormalFont());
	txtBlockedHosts.setBounds(15, y, 350 - 40, h);
	p.add(txtBlockedHosts);
	y += h;
	y += 20;
	y += 30;
	p.setPreferredSize(new Dimension(350, y));
	return p;
}",0,0,1,0
"protected Endpoint createEndpoint(final String uri, final String remaining, final Map<String, Object> parameters) throws Exception {
	 final int concurrentConsumers = getAndRemoveParameter(parameters, ""concurrentConsumers"", Integer.class, defaultConcurrentConsumers);
	 final boolean limitConcurrentConsumers = getAndRemoveParameter(parameters, ""limitConcurrentConsumers"", Boolean.class, true);
	 if (limitConcurrentConsumers && concurrentConsumers > MAX_CONCURRENT_CONSUMERS) {
		 throw new IllegalArgumentException( ""The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than "" + MAX_CONCURRENT_CONSUMERS + "" was "" + concurrentConsumers);
	 }
	 if (concurrentConsumers < 0) {
		 throw new IllegalArgumentException(""concurrentConsumers found to be "" + concurrentConsumers + "", must be greater than 0"");
	 }
	 int size = 0;
	 if (parameters.containsKey(""size"")) {
		 size = getAndRemoveParameter(parameters, ""size"", int.class);
		 if (size <= 0) {
			 throw new IllegalArgumentException(""size found to be "" + size + "", must be greater than 0"");
		 }
	 }
	 if (parameters.containsKey(""pollTimeout"")) {
		 throw new IllegalArgumentException(""The 'pollTimeout' argument is not supported by the Disruptor component"");
	 }
	 final DisruptorWaitStrategy waitStrategy = getAndRemoveParameter(parameters, ""waitStrategy"", DisruptorWaitStrategy.class, defaultWaitStrategy);
	 final DisruptorProducerType producerType = getAndRemoveParameter(parameters, ""producerType"", DisruptorProducerType.class, defaultProducerType);
	 final boolean multipleConsumers = getAndRemoveParameter(parameters, ""multipleConsumers"", boolean.class, defaultMultipleConsumers);
	 final boolean blockWhenFull = getAndRemoveParameter(parameters, ""blockWhenFull"", boolean.class, defaultBlockWhenFull);
	 final DisruptorReference disruptorReference = getOrCreateDisruptor(uri, remaining, size, producerType, waitStrategy);
	 final DisruptorEndpoint disruptorEndpoint = new DisruptorEndpoint(uri, this, disruptorReference, concurrentConsumers, multipleConsumers, blockWhenFull);
	 disruptorEndpoint.setWaitStrategy(waitStrategy);
	 disruptorEndpoint.setProducerType(producerType);
	 disruptorEndpoint.configureProperties(parameters);
	 return disruptorEndpoint;
 }",0,0,1,0
"public interface TreeState {
	 void restore(GuiPackage guiInstance);
	 static final TreeState NOTHING = (GuiPackage guiInstance) -> {
	}
	;
	 public static TreeState from(GuiPackage guiPackage) {
		 if (guiPackage == null) {
			 return NOTHING;
		 }
		 MainFrame mainframe = guiPackage.getMainFrame();
		 if (mainframe != null) {
			 final JTree tree = mainframe.getTree();
			 int savedSelected = tree.getMinSelectionRow();
			 ArrayList<Integer> savedExpanded = new ArrayList<>();
			 for (int rowN = 0;
			 rowN < tree.getRowCount();
			 rowN++) {
				 if (tree.isExpanded(rowN)) {
					 savedExpanded.add(rowN);
				 }
			 }
			 return new TreeStateImpl(savedSelected, savedExpanded);
		 }
		 return NOTHING;
	 }
	 static final class TreeStateImpl implements TreeState {
		 private final List<Integer> savedExpanded;
		 private final int savedSelected;
		 public TreeStateImpl(int savedSelected, List<Integer> savedExpanded) {
			 this.savedSelected = savedSelected;
			 this.savedExpanded = savedExpanded;
		 }
		 public void restore(GuiPackage guiInstance) {
			 MainFrame mainframe = guiInstance.getMainFrame();
			 if (mainframe == null) {
				 return;
			 }
			 final JTree tree = mainframe.getTree();
			 if (!savedExpanded.isEmpty()) {
				 savedExpanded.forEach(tree::expandRow);
			 }
			 else {
				 tree.expandRow(0);
			 }
			 tree.setSelectionRow(savedSelected);
		 }
	 }
}",0,0,0,0
"private static class BucketList<V> implements Iterable<Bucket<V>> {
	 private final ArrayList<Bucket<V>> bucketList;
	 private final List<Bucket<V>> immutableVisibleList;
	 private BucketList(ArrayList<Bucket<V>> bucketList, ArrayList<Bucket<V>> publicBucketList) {
		 this.bucketList = bucketList;
		 int displayIndex = 0;
		 for (Bucket<V> bucket : publicBucketList) {
			 bucket.displayIndex = displayIndex++;
		 }
		 immutableVisibleList = Collections.unmodifiableList(publicBucketList);
	 }
	 private int getBucketCount() {
		 return immutableVisibleList.size();
	 }
	 private int getBucketIndex(CharSequence name, Collator collatorPrimaryOnly) {
		 int start = 0;
		 int limit = bucketList.size();
		 while ((start + 1) < limit) {
			 int i = (start + limit) / 2;
			 Bucket<V> bucket = bucketList.get(i);
			 int nameVsBucket = collatorPrimaryOnly.compare(name, bucket.lowerBoundary);
			 if (nameVsBucket < 0) {
				 limit = i;
			 }
			 else {
				 start = i;
			 }
		 }
		 Bucket<V> bucket = bucketList.get(start);
		 if (bucket.displayBucket != null) {
			 bucket = bucket.displayBucket;
		 }
		 return bucket.displayIndex;
	 }
	 private Iterator<Bucket<V>> fullIterator() {
		 return bucketList.iterator();
	 }
	 public Iterator<Bucket<V>> iterator() {
		 return immutableVisibleList.iterator();
	 }
 }",1,0,0,0
"public class HistoryClientService extends AbstractService {
	 private static final Log LOG = LogFactory.getLog(HistoryClientService.class);
	 private HSClientProtocol protocolHandler;
	 private Server server;
	 private WebApp webApp;
	 private InetSocketAddress bindAddress;
	 private HistoryContext history;
	 private JHSDelegationTokenSecretManager jhsDTSecretManager;
	 public HistoryClientService(HistoryContext history, JHSDelegationTokenSecretManager jhsDTSecretManager) {
		 super(""HistoryClientService"");
		 this.history = history;
		 this.protocolHandler = new HSClientProtocolHandler();
		 this.jhsDTSecretManager = jhsDTSecretManager;
	 }
	 protected void serviceStart() throws Exception {
		 Configuration conf = getConfig();
		 YarnRPC rpc = YarnRPC.create(conf);
		 initializeWebApp(conf);
		 InetSocketAddress address = conf.getSocketAddr( JHAdminConfig.MR_HISTORY_BIND_HOST, JHAdminConfig.MR_HISTORY_ADDRESS, JHAdminConfig.DEFAULT_MR_HISTORY_ADDRESS, JHAdminConfig.DEFAULT_MR_HISTORY_PORT);
		 server = rpc.getServer(HSClientProtocol.class, protocolHandler, address, conf, jhsDTSecretManager, conf.getInt(JHAdminConfig.MR_HISTORY_CLIENT_THREAD_COUNT, JHAdminConfig.DEFAULT_MR_HISTORY_CLIENT_THREAD_COUNT));
		 if (conf.getBoolean( CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION, false)) {
			 server.refreshServiceAcl(conf, new ClientHSPolicyProvider());
		 }
		 server.start();
		 this.bindAddress = conf.updateConnectAddr(JHAdminConfig.MR_HISTORY_BIND_HOST, JHAdminConfig.MR_HISTORY_ADDRESS, JHAdminConfig.DEFAULT_MR_HISTORY_ADDRESS, server.getListenerAddress());
		 LOG.info(""Instantiated HistoryClientService at "" + this.bindAddress);
		 super.serviceStart();
	 }
	 protected void initializeWebApp(Configuration conf) {
		 webApp = new HsWebApp(history);
		 InetSocketAddress bindAddress = MRWebAppUtil.getJHSWebBindAddress(conf);
		 WebApps .$for(""jobhistory"", HistoryClientService.class, this, ""ws"") .with(conf) .withHttpSpnegoKeytabKey( JHAdminConfig.MR_WEBAPP_SPNEGO_KEYTAB_FILE_KEY) .withHttpSpnegoPrincipalKey( JHAdminConfig.MR_WEBAPP_SPNEGO_USER_NAME_KEY) .at(NetUtils.getHostPortString(bindAddress)).start(webApp);
		 String connectHost = MRWebAppUtil.getJHSWebappURLWithoutScheme(conf).split("":"")[0];
		 MRWebAppUtil.setJHSWebappURLWithoutScheme(conf, connectHost + "":"" + webApp.getListenerAddress().getPort());
	 }
	 protected void serviceStop() throws Exception {
		 if (server != null) {
			 server.stop();
		 }
		 if (webApp != null) {
			 webApp.stop();
		 }
		 super.serviceStop();
	 }
	 public MRClientProtocol getClientHandler() {
		 return this.protocolHandler;
	 }
	 public InetSocketAddress getBindAddress() {
		 return this.bindAddress;
	 }
	 private class HSClientProtocolHandler implements HSClientProtocol {
		 private RecordFactory recordFactory = RecordFactoryProvider.getRecordFactory(null);
		 public InetSocketAddress getConnectAddress() {
			 return getBindAddress();
		 }
		 private Job verifyAndGetJob(final JobId jobID) throws IOException {
			 UserGroupInformation loginUgi = null;
			 Job job = null;
			 try {
				 loginUgi = UserGroupInformation.getLoginUser();
				 job = loginUgi.doAs(new PrivilegedExceptionAction<Job>() {
					 public Job run() throws Exception {
						 Job job = history.getJob(jobID);
						 return job;
					 }
				 }
				);
			 }
			 catch (InterruptedException e) {
				 throw new IOException(e);
			 }
			 if (job != null) {
				 JobACL operation = JobACL.VIEW_JOB;
				 checkAccess(job, operation);
			 }
			 return job;
		 }
		 public GetCountersResponse getCounters(GetCountersRequest request) throws IOException {
			 JobId jobId = request.getJobId();
			 Job job = verifyAndGetJob(jobId);
			 GetCountersResponse response = recordFactory.newRecordInstance(GetCountersResponse.class);
			 response.setCounters(TypeConverter.toYarn(job.getAllCounters()));
			 return response;
		 }
		 public GetJobReportResponse getJobReport(GetJobReportRequest request) throws IOException {
			 JobId jobId = request.getJobId();
			 Job job = verifyAndGetJob(jobId);
			 GetJobReportResponse response = recordFactory.newRecordInstance(GetJobReportResponse.class);
			 if (job != null) {
				 response.setJobReport(job.getReport());
			 }
			 else {
				 response.setJobReport(null);
			 }
			 return response;
		 }
		 public GetTaskAttemptReportResponse getTaskAttemptReport( GetTaskAttemptReportRequest request) throws IOException {
			 TaskAttemptId taskAttemptId = request.getTaskAttemptId();
			 Job job = verifyAndGetJob(taskAttemptId.getTaskId().getJobId());
			 GetTaskAttemptReportResponse response = recordFactory.newRecordInstance(GetTaskAttemptReportResponse.class);
			 response.setTaskAttemptReport(job.getTask(taskAttemptId.getTaskId()).getAttempt(taskAttemptId).getReport());
			 return response;
		 }
		 public GetTaskReportResponse getTaskReport(GetTaskReportRequest request) throws IOException {
			 TaskId taskId = request.getTaskId();
			 Job job = verifyAndGetJob(taskId.getJobId());
			 GetTaskReportResponse response = recordFactory.newRecordInstance(GetTaskReportResponse.class);
			 response.setTaskReport(job.getTask(taskId).getReport());
			 return response;
		 }
		 public GetTaskAttemptCompletionEventsResponse getTaskAttemptCompletionEvents( GetTaskAttemptCompletionEventsRequest request) throws IOException {
			 JobId jobId = request.getJobId();
			 int fromEventId = request.getFromEventId();
			 int maxEvents = request.getMaxEvents();
			 Job job = verifyAndGetJob(jobId);
			 GetTaskAttemptCompletionEventsResponse response = recordFactory.newRecordInstance(GetTaskAttemptCompletionEventsResponse.class);
			 response.addAllCompletionEvents(Arrays.asList(job.getTaskAttemptCompletionEvents(fromEventId, maxEvents)));
			 return response;
		 }
		 public KillJobResponse killJob(KillJobRequest request) throws IOException {
			 throw new IOException(""Invalid operation on completed job"");
		 }
		 public KillTaskResponse killTask(KillTaskRequest request) throws IOException {
			 throw new IOException(""Invalid operation on completed job"");
		 }
		 public KillTaskAttemptResponse killTaskAttempt( KillTaskAttemptRequest request) throws IOException {
			 throw new IOException(""Invalid operation on completed job"");
		 }
		 public GetDiagnosticsResponse getDiagnostics(GetDiagnosticsRequest request) throws IOException {
			 TaskAttemptId taskAttemptId = request.getTaskAttemptId();
			 Job job = verifyAndGetJob(taskAttemptId.getTaskId().getJobId());
			 GetDiagnosticsResponse response = recordFactory.newRecordInstance(GetDiagnosticsResponse.class);
			 response.addAllDiagnostics(job.getTask(taskAttemptId.getTaskId()).getAttempt(taskAttemptId).getDiagnostics());
			 return response;
		 }
		 public FailTaskAttemptResponse failTaskAttempt( FailTaskAttemptRequest request) throws IOException {
			 throw new IOException(""Invalid operation on completed job"");
		 }
		 public GetTaskReportsResponse getTaskReports(GetTaskReportsRequest request) throws IOException {
			 JobId jobId = request.getJobId();
			 TaskType taskType = request.getTaskType();
			 GetTaskReportsResponse response = recordFactory.newRecordInstance(GetTaskReportsResponse.class);
			 Job job = verifyAndGetJob(jobId);
			 Collection<Task> tasks = job.getTasks(taskType).values();
			 for (Task task : tasks) {
				 response.addTaskReport(task.getReport());
			 }
			 return response;
		 }
		 public GetDelegationTokenResponse getDelegationToken( GetDelegationTokenRequest request) throws IOException {
			 UserGroupInformation ugi = UserGroupInformation.getCurrentUser();
			 if (!isAllowedDelegationTokenOp()) {
				 throw new IOException( ""Delegation Token can be issued only with kerberos authentication"");
			 }
			 GetDelegationTokenResponse response = recordFactory.newRecordInstance( GetDelegationTokenResponse.class);
			 String user = ugi.getUserName();
			 Text owner = new Text(user);
			 Text realUser = null;
			 if (ugi.getRealUser() != null) {
				 realUser = new Text(ugi.getRealUser().getUserName());
			 }
			 MRDelegationTokenIdentifier tokenIdentifier = new MRDelegationTokenIdentifier(owner, new Text( request.getRenewer()), realUser);
			 Token<MRDelegationTokenIdentifier> realJHSToken = new Token<MRDelegationTokenIdentifier>(tokenIdentifier, jhsDTSecretManager);
			 org.apache.hadoop.yarn.api.records.Token mrDToken = org.apache.hadoop.yarn.api.records.Token.newInstance( realJHSToken.getIdentifier(), realJHSToken.getKind().toString(), realJHSToken.getPassword(), realJHSToken.getService().toString());
			 response.setDelegationToken(mrDToken);
			 return response;
		 }
		 public RenewDelegationTokenResponse renewDelegationToken( RenewDelegationTokenRequest request) throws IOException {
			 if (!isAllowedDelegationTokenOp()) {
				 throw new IOException( ""Delegation Token can be renewed only with kerberos authentication"");
			 }
			 org.apache.hadoop.yarn.api.records.Token protoToken = request.getDelegationToken();
			 Token<MRDelegationTokenIdentifier> token = new Token<MRDelegationTokenIdentifier>( protoToken.getIdentifier().array(), protoToken.getPassword() .array(), new Text(protoToken.getKind()), new Text( protoToken.getService()));
			 String user = UserGroupInformation.getCurrentUser().getShortUserName();
			 long nextExpTime = jhsDTSecretManager.renewToken(token, user);
			 RenewDelegationTokenResponse renewResponse = Records .newRecord(RenewDelegationTokenResponse.class);
			 renewResponse.setNextExpirationTime(nextExpTime);
			 return renewResponse;
		 }
		 public CancelDelegationTokenResponse cancelDelegationToken( CancelDelegationTokenRequest request) throws IOException {
			 if (!isAllowedDelegationTokenOp()) {
				 throw new IOException( ""Delegation Token can be cancelled only with kerberos authentication"");
			 }
			 org.apache.hadoop.yarn.api.records.Token protoToken = request.getDelegationToken();
			 Token<MRDelegationTokenIdentifier> token = new Token<MRDelegationTokenIdentifier>( protoToken.getIdentifier().array(), protoToken.getPassword() .array(), new Text(protoToken.getKind()), new Text( protoToken.getService()));
			 String user = UserGroupInformation.getCurrentUser().getUserName();
			 jhsDTSecretManager.cancelToken(token, user);
			 return Records.newRecord(CancelDelegationTokenResponse.class);
		 }
		 private void checkAccess(Job job, JobACL jobOperation) throws IOException {
			 UserGroupInformation callerUGI;
			 callerUGI = UserGroupInformation.getCurrentUser();
			 if (!job.checkAccess(callerUGI, jobOperation)) {
				 throw new IOException(new AccessControlException(""User "" + callerUGI.getShortUserName() + "" cannot perform operation "" + jobOperation.name() + "" on "" + job.getID()));
			 }
		 }
		 private boolean isAllowedDelegationTokenOp() throws IOException {
			 if (UserGroupInformation.isSecurityEnabled()) {
				 return EnumSet.of(AuthenticationMethod.KERBEROS, AuthenticationMethod.KERBEROS_SSL, AuthenticationMethod.CERTIFICATE) .contains(UserGroupInformation.getCurrentUser() .getRealAuthenticationMethod());
			 }
			 else {
				 return true;
			 }
		 }
	 }
}",1,1,0,0
"public void setQuirkCssPositioningOneSideOnly(boolean quirkCssPositioningOneSideOnly){
	this.quirkCssPositioningOneSideOnly = quirkCssPositioningOneSideOnly;
}",0,0,0,0
"public class Row{
	 private static RowSerializer serializer = new RowSerializer();
	 public static RowSerializer serializer() {
		 return serializer;
	 }
	 public final DecoratedKey<?> key;
	 public final ColumnFamily cf;
	 public Row(DecoratedKey<?> key, ColumnFamily cf) {
		 assert key != null;
		 this.key = key;
		 this.cf = cf;
	 }
	 public int getLiveColumnCount() {
		 return cf == null ? 0 : cf.getLiveColumnCount();
	 }
	 public String toString() {
		 return ""Row("" + ""key="" + key + "", cf="" + cf + ')';
	 }
	 public static class RowSerializer implements IVersionedSerializer<Row> {
		 public void serialize(Row row, DataOutput dos, int version) throws IOException {
			 ByteBufferUtil.writeWithShortLength(row.key.key, dos);
			 ColumnFamily.serializer().serialize(row.cf, dos);
		 }
		 public Row deserialize(DataInput dis, int version, IColumnSerializer.Flag flag, ISortedColumns.Factory factory) throws IOException {
			 return new Row(StorageService.getPartitioner().decorateKey(ByteBufferUtil.readWithShortLength(dis)), ColumnFamily.serializer().deserialize(dis, flag, factory));
		 }
		 public Row deserialize(DataInput dis, int version) throws IOException {
			 return deserialize(dis, version, IColumnSerializer.Flag.LOCAL, TreeMapBackedSortedColumns.factory());
		 }
		 public long serializedSize(Row row, int version) {
			 return DBConstants.shortSize + row.key.key.remaining() + ColumnFamily.serializer().serializedSize(row.cf);
		 }
	 }
}",0,0,0,0
"public int readInt() throws IOException {
	 int i = source.readInt();
	 bytesRead += 4;
	 return i;
 }",0,0,0,0
"public static String generateSourceMaps( Type type, Map<SourcePosition, SourcePosition> javaSourcePositionByOutputSourcePosition) throws IOException {
	 return renderSourceMapToString(type, javaSourcePositionByOutputSourcePosition);
 }",0,0,0,0
"public class IdMapKeyAccessor implements Accessor {
	 public static final Accessor SHARED_ACCESSOR = new IdMapKeyAccessor();
	 public String getName() {
		 return ""IdMapKeyAccessor"";
	 }
	 public Object getValue(Object object) throws PropertyException {
		 if (object instanceof Persistent) {
			 ObjectId id = ((Persistent) object).getObjectId();
			 if (id.isTemporary()) {
				 return id;
			 }
			 Map<?, ?> map = id.getIdSnapshot();
			 if (map.size() == 1) {
				 Map.Entry<?, ?> pkEntry = map.entrySet().iterator().next();
				 return pkEntry.getValue();
			 }
			 return id;
		 }
		 else {
			 throw new IllegalArgumentException(""Object must be Persistent: "" + object);
		 }
	 }
	 public void setValue(Object object, Object newValue) throws PropertyException {
		 throw new UnsupportedOperationException(""Setting map key is not supported"");
	 }
}",0,0,0,0
"public Object getValue(final String columnLabel, final Class<T> type) throws SQLException {
	 Object result;
	 if (Object.class == type) {
		 result = decrypt(columnLabel, resultSet.getObject(columnLabel));
	 }
	 else if (boolean.class == type) {
		 result = decrypt(columnLabel, resultSet.getBoolean(columnLabel));
	 }
	 else if (byte.class == type) {
		 result = decrypt(columnLabel, resultSet.getByte(columnLabel));
	 }
	 else if (short.class == type) {
		 result = decrypt(columnLabel, resultSet.getShort(columnLabel));
	 }
	 else if (int.class == type) {
		 result = decrypt(columnLabel, resultSet.getInt(columnLabel));
	 }
	 else if (long.class == type) {
		 result = decrypt(columnLabel, resultSet.getLong(columnLabel));
	 }
	 else if (float.class == type) {
		 result = decrypt(columnLabel, resultSet.getFloat(columnLabel));
	 }
	 else if (double.class == type) {
		 result = decrypt(columnLabel, resultSet.getDouble(columnLabel));
	 }
	 else if (String.class == type) {
		 result = decrypt(columnLabel, resultSet.getString(columnLabel));
	 }
	 else if (BigDecimal.class == type) {
		 result = decrypt(columnLabel, resultSet.getBigDecimal(columnLabel));
	 }
	 else if (byte[].class == type) {
		 result = resultSet.getBytes(columnLabel);
	 }
	 else if (Date.class == type) {
		 result = resultSet.getDate(columnLabel);
	 }
	 else if (Time.class == type) {
		 result = resultSet.getTime(columnLabel);
	 }
	 else if (Timestamp.class == type) {
		 result = resultSet.getTimestamp(columnLabel);
	 }
	 else if (URL.class == type) {
		 result = resultSet.getURL(columnLabel);
	 }
	 else if (Blob.class == type) {
		 result = resultSet.getBlob(columnLabel);
	 }
	 else if (Clob.class == type) {
		 result = resultSet.getClob(columnLabel);
	 }
	 else if (SQLXML.class == type) {
		 result = resultSet.getSQLXML(columnLabel);
	 }
	 else if (Reader.class == type) {
		 result = resultSet.getCharacterStream(columnLabel);
	 }
	 else {
		 result = decrypt(columnLabel, resultSet.getObject(columnLabel));
	 }
	 return result;
 }",0,0,1,0
"public class SerializingCacheProvider implements IRowCacheProvider{
	 public ICache<RowCacheKey, IRowCacheEntry> create(int capacity, boolean useMemoryWeigher) {
		 return new SerializingCache<RowCacheKey, IRowCacheEntry>(capacity, useMemoryWeigher, new RowCacheSerializer());
	 }
	 private static class RowCacheSerializer implements ISerializer<IRowCacheEntry> {
		 public void serialize(IRowCacheEntry cf, DataOutput out) {
			 assert cf != null;
			 try {
				 out.writeBoolean(cf instanceof RowCacheSentinel);
				 if (cf instanceof RowCacheSentinel) out.writeLong(((RowCacheSentinel) cf).sentinelId);
				 else ColumnFamily.serializer.serialize((ColumnFamily) cf, out);
			 }
			 catch (IOException e) {
				 throw new IOError(e);
			 }
		 }
		 public IRowCacheEntry deserialize(DataInput in) throws IOException {
			 boolean isSentinel = in.readBoolean();
			 if (isSentinel) return new RowCacheSentinel(in.readLong());
			 return ColumnFamily.serializer.deserialize(in);
		 }
		 public long serializedSize(IRowCacheEntry cf) {
			 return DBConstants.boolSize + (cf instanceof RowCacheSentinel ? DBConstants.intSize + DBConstants.longSize : ColumnFamily.serializer().serializedSize((ColumnFamily) cf));
		 }
	 }
}",0,0,0,0
"public final void viewInBrowser(){
	int webRootPathIndex = getThisClassFileURL().getPath().indexOf(""/WEB-INF"");
	String webRootPath = getThisClassFileURL().getPath().substring(0, webRootPathIndex);
	File temp = new File(webRootPath + ""/"" + getTemperaryDumpHtmlFileName());
	FileOutputStream out = null;
	try{
		out = new FileOutputStream(temp);
		out.write(tester.getServletResponse().getDocument().getBytes(getHtmlEncoding()));
		out.flush();
	}
	catch (UnsupportedEncodingException e){
		throw convertoUnexpect(e);
	}
	catch (IOException e){
		throw convertoUnexpect(e);
	}
	finally{
		if (out != null){
			try{
				out.close();
			}
			catch (IOException e){
				throw convertoUnexpect(e);
			}
		}
	}
	if (!new File(getBrowserPath()).exists()){
		throw new IllegalStateException(""No browser found at "" + getBrowserPath());
	}
	throw new RuntimeException(""Not yet supported"");
}",0,0,0,0
"public class FFMPEGTranscoder implements TranscodeEngine{
	 private static final boolean XCODE_DEBUG = Sage.DBG && Sage.getBoolean(""media_server/transcode_debug"", false);
	 static final String BITRATE_OPTIONS_SIZE_KEY = ""httpls_bandwidth/%s/video_size"";
	 public FFMPEGTranscoder() {
	 }
	 public long getAvailableTranscodeBytes() {
		 if (bufferOutput) return Math.max(0, xcodeBufferVirtualSize - xcodeBufferVirtualReadPos);
		 else {
			 if (xcodeDone) return 0;
			 else return 65536;
		 }
	 }
	 public long getVirtualReadPosition() {
		 return xcodeBufferVirtualReadPos;
	 }
	 public long getVirtualTranscodeSize() {
		 return xcodeBufferVirtualSize;
	 }
	 public boolean isTranscodeDone() {
		 return xcodeDone;
	 }
	 public boolean didTranscodeCompleteOK() {
		 if (!xcodeDone) return false;
		 if (xcodeProcess != null) {
			 try {
				 lastExitCode = xcodeProcess.exitValue();
			 }
			 catch (IllegalThreadStateException ise) {
				 lastExitCode = -1;
			 }
		 }
		 return xcodeDone && lastExitCode == 0;
	 }
	 public void pauseTranscode() {
	 }
	 public void readFullyTranscodedData(byte[] buf, int inOffset, int inLength) throws java.io.IOException {
		 readFullyTranscodedData(null, buf, inOffset, inLength);
	 }
	 public void readFullyTranscodedData(java.nio.ByteBuffer buf) throws java.io.IOException {
		 readFullyTranscodedData(buf, null, buf.position(), buf.remaining());
	 }
	 private void readFullyTranscodedData(java.nio.ByteBuffer bb, byte[] buf, int inOffset, int inLength) throws java.io.IOException {
		 int leftToRead = inLength;
		 if (bufferOutput) {
			 long overage = inLength - getAvailableTranscodeBytes();
			 int numTries = 50;
			 if (XCODE_DEBUG && overage > 0) System.out.println(""Waiting for more data to appear in transcode buffer over="" + overage + "" xcodeDone="" + xcodeDone);
			 while (overage > 0 && !xcodeDone && (numTries-- > 0)) {
				 try {
					 Thread.sleep(200);
				 }
				 catch (Exception e){
				}
				 overage = inLength - getAvailableTranscodeBytes();
			 }
			 if (overage > 0) {
				 if (overage > leftToRead) {
					 leftToRead = 0;
					 overage = inLength;
				 }
				 else {
					 leftToRead -= overage;
				 }
			 }
			 int buffNum = (int) (((xcodeBufferVirtualReadPos - xcodeBufferVirtualOffset) / xcodeBuffer[0].length) + xcodeBufferBaseNum) % xcodeBuffer.length;
			 int buffOffset = (int) (xcodeBufferVirtualReadPos - xcodeBufferVirtualOffset) % xcodeBuffer[0].length;
			 if (XCODE_DEBUG) System.out.println(""Xcode readTranscodedData("" + inLength + "") buffNum="" + buffNum + "" buffOffset="" + buffOffset);
			 int tempOffset = inOffset;
			 while (leftToRead > 0) {
				 int currRead = Math.min((int)leftToRead, xcodeBuffer[buffNum].length - buffOffset);
				 if (bb != null) bb.put(xcodeBuffer[buffNum], buffOffset, currRead);
				 else System.arraycopy(xcodeBuffer[buffNum], buffOffset, buf, tempOffset, currRead);
				 tempOffset += currRead;
				 leftToRead -= currRead;
				 buffNum = (buffNum + 1) % xcodeBuffer.length;
				 buffOffset = 0;
			 }
			 if (XCODE_DEBUG) System.out.println(""Xcode transferData complete overage="" + overage);
			 xcodeBufferVirtualReadPos += inLength;
			 synchronized (xcodeSyncLock) {
				 while (xcodeBufferVirtualReadPos - xcodeBufferVirtualOffset >= xcodeBuffer[0].length) {
					 xcodeBufferBaseNum = (xcodeBufferBaseNum + 1) % xcodeBuffer.length;
					 xcodeBufferVirtualOffset += xcodeBuffer[0].length;
					 numFilledXcodeBuffers--;
					 if (XCODE_DEBUG) System.out.println(""Adjusted buffer nums xcodeBufferBaseNum="" + xcodeBufferBaseNum + "" xcodeBufferVirtualOffset="" + xcodeBufferVirtualOffset + "" numFilledBuffers="" + numFilledXcodeBuffers);
					 xcodeSyncLock.notifyAll();
				 }
			 }
			 if (overage > 0) {
				 if (bb != null) {
					 while (bb.remaining() > 0) bb.put((byte) 0xFF);
				 }
				 else java.util.Arrays.fill(buf, (int)(inOffset + inLength - overage), inOffset + inLength, (byte)0xFF);
				 if (XCODE_DEBUG) System.out.println(""Xcoder Sending overage="" + overage);
			 }
		 }
		 else {
			 while (leftToRead > 0) {
				 int numRead;
				 if (bb != null) {
					 if (nioTmpBuf == null) nioTmpBuf = new byte[4096];
					 numRead = xcodeStdout.read(nioTmpBuf, 0, Math.min(leftToRead, nioTmpBuf.length));
					 bb.put(nioTmpBuf, 0, numRead);
				 }
				 else numRead = xcodeStdout.read(buf, inOffset, leftToRead);
				 if (XCODE_DEBUG) System.out.println(""Xcoder readFully "" + numRead + "" bytes directly from transcoder and is pushing it out"");
				 if (numRead == -1) {
					 if (XCODE_DEBUG) System.out.println(""XCoder sending overage for incomplete buffer read"");
					 if (bb != null) {
						 while (bb.remaining() > 0) bb.put((byte) 0xFF);
					 }
					 else java.util.Arrays.fill(buf, inOffset, inOffset + leftToRead, (byte)0xFF);
					 leftToRead = 0;
					 xcodeDone = true;
				 }
				 else {
					 inOffset += numRead;
					 leftToRead -= numRead;
				 }
			 }
			 xcodeBufferVirtualReadPos = xcodeBufferVirtualOffset = xcodeBufferVirtualSize = xcodeBufferVirtualReadPos + inLength;
		 }
	 }
	 protected long estimateTranscodeSeekTimeFromOffset(long offset) {
		 double streamRate = (lastXcodeStreamPosition / ((double)lastXcodeStreamTime));
		 long rv = Math.round(offset / streamRate);
		 if (XCODE_DEBUG) System.out.println(""Xcode seeking estimRate="" + streamRate + "" offset="" + offset + "" time="" + rv);
		 return rv;
	 }
	 public long getCurrentTranscodeStreamTime() {
		 return lastXcodeStreamTime;
	 }
	 public void seekToPosition(long offset) throws java.io.IOException {
		 if (!isTranscoding()) {
			 if (offset == 0) startTranscode();
			 else throw new java.io.IOException(""Cannot do seekToPosition in transcoder because it hasn't been started yet!"");
			 return;
		 }
		 if ((!bufferOutput && offset != xcodeBufferVirtualOffset) || (bufferOutput && (offset < xcodeBufferVirtualOffset || offset >= xcodeBufferVirtualOffset + xcodeBuffer.length*xcodeBuffer[0].length))) {
			 long seekTime = estimateTranscodeSeekTimeFromOffset(offset);
			 stopTranscode();
			 if (XCODE_DEBUG) System.out.println(""Restarting transcode to perform seek so read can continue time="" + seekTime);
			 xcodeBufferVirtualReadPos = xcodeBufferVirtualOffset = xcodeBufferVirtualSize = offset;
			 transcodeStartSeekTime = seekTime;
			 startTranscode();
		 }
		 else {
			 xcodeBufferVirtualReadPos = offset;
			 synchronized (xcodeSyncLock) {
				 while (offset - xcodeBufferVirtualOffset >= xcodeBuffer[0].length) {
					 xcodeBufferBaseNum = (xcodeBufferBaseNum + 1) % xcodeBuffer.length;
					 xcodeBufferVirtualOffset += xcodeBuffer[0].length;
					 numFilledXcodeBuffers--;
					 if (XCODE_DEBUG) System.out.println(""Adjusted buffer nums from seekToPosition xcodeBufferBaseNum="" + xcodeBufferBaseNum + "" xcodeBufferVirtualOffset="" + xcodeBufferVirtualOffset + "" numFilledBuffers="" + numFilledXcodeBuffers);
					 xcodeSyncLock.notifyAll();
				 }
			 }
		 }
	 }
	 public void seekToTime(long milliSeekTime) throws java.io.IOException {
		 stopTranscode();
		 transcodeStartSeekTime = milliSeekTime;
		 xcodeBufferVirtualReadPos = xcodeBufferVirtualOffset = xcodeBufferVirtualSize = 0;
		 startTranscode();
	 }
	 public void sendTranscodeOutputToChannel(long offset, long length, java.nio.channels.WritableByteChannel chan) throws java.io.IOException {
		 long leftToRead = length;
		 if ((!bufferOutput && offset != xcodeBufferVirtualOffset) || (bufferOutput && (offset < xcodeBufferVirtualOffset || offset + length > xcodeBufferVirtualOffset + xcodeBuffer.length*xcodeBuffer[0].length))) {
			 seekToPosition(offset);
		 }
		 if (bufferOutput) {
			 long overage = offset + length - xcodeBufferVirtualSize;
			 int numTries = 50;
			 if (XCODE_DEBUG && overage > 0) System.out.println(""Xcoder waiting for more data to appear in transcode buffer over="" + overage + "" xcodeDone="" + xcodeDone);
			 while (overage > 0 && !xcodeDone && (numTries-- > 0)) {
				 try {
					 Thread.sleep(200);
				 }
				 catch (Exception e){
				}
				 overage = offset + length - xcodeBufferVirtualSize;
			 }
			 if (overage > 0) {
				 if (overage > leftToRead) {
					 leftToRead = 0;
					 overage = length;
				 }
				 else {
					 leftToRead -= overage;
				 }
			 }
			 int buffNum = (int) (((offset - xcodeBufferVirtualOffset) / xcodeBuffer[0].length) + xcodeBufferBaseNum) % xcodeBuffer.length;
			 int buffOffset = (int) (offset - xcodeBufferVirtualOffset) % xcodeBuffer[0].length;
			 if (XCODE_DEBUG) System.out.println(""Xcode transferData("" + offset + "", "" + leftToRead + "") buffNum="" + buffNum + "" buffOffset="" + buffOffset);
			 while (leftToRead > 0) {
				 int currRead = Math.min((int)leftToRead, xcodeBuffer[buffNum].length - buffOffset);
				 chan.write(java.nio.ByteBuffer.wrap(xcodeBuffer[buffNum], buffOffset, currRead));
				 leftToRead -= currRead;
				 buffNum = (buffNum + 1) % xcodeBuffer.length;
				 buffOffset = 0;
			 }
			 if (XCODE_DEBUG) System.out.println(""Xcode transferData complete overage="" + overage);
			 synchronized (xcodeSyncLock) {
				 while (offset - xcodeBufferVirtualOffset >= xcodeBuffer[0].length) {
					 xcodeBufferBaseNum = (xcodeBufferBaseNum + 1) % xcodeBuffer.length;
					 xcodeBufferVirtualOffset += xcodeBuffer[0].length;
					 numFilledXcodeBuffers--;
					 if (XCODE_DEBUG) System.out.println(""Adjusted buffer nums xcodeBufferBaseNum="" + xcodeBufferBaseNum + "" xcodeBufferVirtualOffset="" + xcodeBufferVirtualOffset + "" numFilledBuffers="" + numFilledXcodeBuffers);
					 xcodeSyncLock.notifyAll();
				 }
			 }
			 while (overage > 0) {
				 initOverageBuffer();
				 overageBuf.limit((int)Math.min(overage, overageBuf.capacity()));
				 if (XCODE_DEBUG) System.out.println(""Xcoder sending overage="" + overageBuf.limit());
				 int numWritten = chan.write(overageBuf);
				 overage -= numWritten;
				 if (XCODE_DEBUG) System.out.println(""Xcoder overage sent capacity="" + overageBuf.capacity() + "" overage="" + overage + "" numWritten="" + numWritten);
			 }
			 xcodeBufferVirtualReadPos = offset + length;
		 }
		 else {
			 if (hackBuf == null) {
				 hackBuf = java.nio.ByteBuffer.allocate(65536);
			 }
			 hackBuf.clear();
			 byte[] dataBuf = hackBuf.array();
			 int myOffset = 0;
			 while (leftToRead > 0) {
				 int currRead = Math.min((int)leftToRead, hackBuf.remaining());
				 int numRead = xcodeStdout.read(dataBuf, myOffset, currRead);
				 if (XCODE_DEBUG) System.out.println(""Xcoder read "" + numRead + "" bytes directly from transcoder and is pushing it out"");
				 if (numRead == -1) {
					 initOverageBuffer();
					 if (XCODE_DEBUG) System.out.println(""XCoder sending overage for incomplete buffer read"");
					 overageBuf.limit((int)Math.min(leftToRead, overageBuf.capacity()));
					 leftToRead -= chan.write(overageBuf);
					 xcodeDone = true;
				 }
				 else {
					 hackBuf.position(numRead);
					 chan.write(hackBuf);
					 hackBuf.clear();
					 leftToRead -= numRead;
				 }
			 }
			 xcodeBufferVirtualReadPos = xcodeBufferVirtualOffset = xcodeBufferVirtualSize = offset + length;
		 }
	 }
	 protected void initOverageBuffer() {
		 if (overageBuf == null) {
			 overageBuf = java.nio.ByteBuffer.allocate(8192);
			 byte[] overageFF = new byte[256];
			 java.util.Arrays.fill(overageFF, 0, overageFF.length, (byte)0xFF);
			 for (int i = 0;
			 i < 8192;
			 i += 256) overageBuf.put(overageFF);
		 }
		 overageBuf.clear();
	 }
	 public void setOutputFile(java.io.File theFile) {
		 outputFile = theFile;
	 }
	 public void setSourceFile(String server, java.io.File theFile) {
		 currFile = theFile;
		 currServer = server;
	 }
	 public void setTranscodeFormat(sage.media.format.ContainerFormat inSourceFormat, sage.media.format.ContainerFormat newFormat) {
		 sourceFormat = inSourceFormat;
		 if (Sage.DBG) System.out.println(""Set Transcode format source="" + sourceFormat + "" dest="" + newFormat);
		 xcodeParams = """";
		 String newFormatName = substituteName(newFormat.getFormatName());
		 if (""wmv"".equals(newFormatName)) newFormatName = ""asf"";
		 xcodeParams += ""-f "" + newFormatName;
		 String extraProps = newFormat.getMetadataProperty(sage.media.format.MediaFormat.META_COMPRESSION_DETAILS);
		 boolean redoAudio = false;
		 if (newFormat.getNumberOfStreams() > 0) {
			 sage.media.format.BitstreamFormat[] bfs = newFormat.getStreamFormats();
			 boolean foundVideo = false;
			 boolean foundAudio = false;
			 boolean needAudioChannels = true;
			 for (int i = 0;
			 i < bfs.length;
			 i++) {
				 if (bfs[i] instanceof sage.media.format.AudioFormat) {
					 sage.media.format.AudioFormat audformat = (sage.media.format.AudioFormat) bfs[i];
					 foundAudio = true;
					 String fname = bfs[i].getFormatName();
					 if (fname == null || fname.length() == 0 || fname.equalsIgnoreCase(""copy"")) {
						 redoAudio = true;
					 }
					 else {
						 xcodeParams += "" -acodec "" + substituteName(fname);
					 }
					 if (audformat.getBitrate() > 0) {
						 xcodeParams += "" -ab "" + (audformat.getBitrate() / 1000);
						 preservedAudioBitrate = audformat.getBitrate();
					 }
					 if (audformat.getChannels() > 0) {
						 needAudioChannels = false;
						 xcodeParams += "" -ac "" + audformat.getChannels();
					 }
					 if (audformat.getSamplingRate() > 0) xcodeParams += "" -ar "" + audformat.getSamplingRate();
				 }
				 else if (bfs[i] instanceof sage.media.format.VideoFormat) {
					 sage.media.format.VideoFormat vidformat = (sage.media.format.VideoFormat) bfs[i];
					 foundVideo = true;
					 String fname = bfs[i].getFormatName();
					 if (fname == null || fname.length() == 0 || fname.equalsIgnoreCase(""copy"")) {
						 xcodeParams += "" -vcodec copy"";
					 }
					 else {
						 xcodeParams += "" -vcodec "" + substituteName(fname);
					 }
					 if (vidformat.getBitrate() > 0) {
						 xcodeParams += "" -b "" + vidformat.getBitrate()/1000;
						 preservedVideoBitrate = vidformat.getBitrate();
					 }
					 if (vidformat.getWidth() != 0 && vidformat.getHeight() != 0) xcodeParams += "" -s "" + vidformat.getWidth() + ""x"" + vidformat.getHeight();
					 if (vidformat.getFps() > 0) xcodeParams += "" -r "" + vidformat.getFps();
					 if (vidformat.getArNum() > 0 && vidformat.getArDen() > 0) xcodeParams += "" -aspect "" + vidformat.getArNum() + "":"" + vidformat.getArDen();
				 }
			 }
			 if (!foundVideo) xcodeParams += "" -vn"";
			 if (!foundAudio) xcodeParams += "" -an"";
			 if (redoAudio && (extraProps == null || extraProps.indexOf("" -acodec "") == -1) && xcodeParams.indexOf("" -acodec "") == -1) {
				 sage.media.format.AudioFormat af = sourceFormat.getAudioFormat();
				 if (af != null) {
					 String aformat = af.getFormatName();
					 if (sage.media.format.MediaFormat.AC3.equalsIgnoreCase(aformat) || sage.media.format.MediaFormat.MP2.equalsIgnoreCase(aformat) || sage.media.format.MediaFormat.MP3.equalsIgnoreCase(aformat) || sage.media.format.MediaFormat.AAC.equalsIgnoreCase(aformat)) {
						 xcodeParams += "" -acodec "" + substituteName(aformat);
					 }
					 else if (af.getChannels() <= 2) xcodeParams += "" -acodec mp2"";
					 else xcodeParams += "" -acodec ac3"";
					 if (af.getChannels() > 0) xcodeParams += "" -ac "" + Integer.toString(af.getChannels());
					 if (af.getSamplingRate() > 0) xcodeParams += "" -ar "" + Integer.toString(af.getSamplingRate());
					 if ((af.getBitrate()/1000) > 0 && (af.getBitrate()/1000) < 400) {
						 xcodeParams += "" -ab "" + Integer.toString(af.getBitrate() / 1000);
						 preservedAudioBitrate = af.getBitrate();
					 }
					 else if (sage.media.format.MediaFormat.AC3.equalsIgnoreCase(aformat) || xcodeParams.indexOf(""-acodec ac3"") != -1) xcodeParams += "" -ab 384"";
					 else xcodeParams += "" -ab 192"";
				 }
			 }
			 else if (needAudioChannels) {
				 sage.media.format.AudioFormat af = sourceFormat.getAudioFormat();
				 if (af != null) {
					 if (af.getChannels() > 0) xcodeParams += "" -ac "" + Integer.toString(af.getChannels());
				 }
			 }
			 if (foundVideo && (extraProps == null || extraProps.indexOf("" -aspect "") == -1) && xcodeParams.indexOf("" -aspect "") == -1) {
				 sage.media.format.VideoFormat vf = sourceFormat.getVideoFormat();
				 if (vf != null) {
					 if (vf.getArNum() > 0 && vf.getArDen() > 0) xcodeParams += "" -aspect "" + vf.getArNum() + "":"" + vf.getArDen();
					 else xcodeParams += "" -aspect "" + vf.getWidth() + "":"" + vf.getHeight();
				 }
			 }
		 }
		 if (extraProps != null && extraProps.length() > 0) xcodeParams += "" "" + extraProps;
	 }
	 public void setTranscodeFormat(String str, sage.media.format.ContainerFormat inSourceFormat) {
		 sourceFormat = inSourceFormat;
		 if (""dynamic"".equalsIgnoreCase(str)) dynamicRateAdjust = true;
		 else if (""dynamicts"".equalsIgnoreCase(str)) {
			 iOSMode = true;
			 dynamicRateAdjust = true;
		 }
		 else {
			 xcodeParams = Sage.get(MediaServer.XCODE_QUALITIES_PROPERTY_ROOT + str, null);
			 if (xcodeParams == null) {
				 String f = ""dvd"";
				 String vcodec = ""mpeg4"";
				 String s = MMC.getInstance().isNTSCVideoFormat() ? ""352x240"" : ""352x288"";
				 String ac = (Sage.getBoolean(""xcode_disable_mono_audio"", true) ? ""2"" : ""1"");
				 String g = ""300"";
				 String bf = ""2"";
				 String acodec = ""mp2"";
				 String r = MMC.getInstance().isNTSCVideoFormat() ? ""30"" : ""25"";
				 String b = ""300"";
				 String ar = ""48000"";
				 String ab = ""64"";
				 String packetsize = ""1024"";
				 boolean deinterlace = false;
				 java.util.StringTokenizer toker = new java.util.StringTokenizer(str, "";
				"");
				 while (toker.hasMoreTokens()) {
					 String currToke = toker.nextToken();
					 int eqIdx = currToke.indexOf('=');
					 if (eqIdx == -1) continue;
					 String propName = currToke.substring(0, eqIdx);
					 String propVal = currToke.substring(eqIdx + 1);
					 try {
						 if (""videocodec"".equals(propName)) vcodec = propVal;
						 else if (""audiocodec"".equals(propName)) acodec = propVal;
						 else if (""videobitrate"".equals(propName)) {
							 preservedVideoBitrate = Integer.parseInt(propVal);
							 b = Integer.toString(preservedVideoBitrate/1000);
						 }
						 else if (""audiobitrate"".equals(propName)) {
							 preservedAudioBitrate = Integer.parseInt(propVal);
							 ab = Integer.toString(preservedAudioBitrate/1000);
						 }
						 else if (""gop"".equals(propName)) g = propVal;
						 else if (""bframes"".equals(propName)) bf = propVal;
						 else if (""fps"".equals(propName)) r = propVal;
						 else if (""audiosampling"".equals(propName)) ar = propVal;
						 else if (""resolution"".equals(propName)) {
							 if (""D1"".equals(propVal)) {
								 s = MMC.getInstance().isNTSCVideoFormat() ? ""720x480"" : ""720x576"";
								 deinterlace = false;
							 }
							 else s = MMC.getInstance().isNTSCVideoFormat() ? ""352x240"" : ""352x288"";
						 }
						 else if (""container"".equals(propName)) f = propVal;
					 }
					 catch (NumberFormatException e) {
					}
				 }
				 xcodeParams = ""-f "" + f + "" -vcodec "" + vcodec + "" -s "" + s + "" -ac "" + ac + "" -g "" + g + "" -bf "" + bf + (deinterlace ? "" -deinterlace "" : """") + "" -acodec "" + acodec + "" -r "" + r + "" -b "" + b + "" -ar "" + ar + "" -ab "" + ab + "" -packetsize "" + packetsize;
			 }
			 dynamicRateAdjust = false;
		 }
	 }
	 public static String getTranscoderPath() {
		 if (new java.io.File(Sage.getToolPath(""SageTVTranscoder"")).isFile()) return Sage.getToolPath(""SageTVTranscoder"");
		 else if (new java.io.File(Sage.getToolPath(""ffmpeg"")).isFile()) return Sage.getToolPath(""ffmpeg"");
		 else throw new RuntimeException(""Transcoder executable is missing!!! checked at: "" + Sage.getToolPath(""SageTVTranscoder"") + "" and "" + Sage.getToolPath(""ffmpeg""));
	 }
	 public void startTranscode() throws java.io.IOException {
		 xcodeBufferBaseNum = 0;
		 lastExitCode = -1;
		 java.util.ArrayList xcodeParamsVec = new java.util.ArrayList();
		 if (!Sage.WINDOWS_OS && Sage.getBoolean(""xcode_reduce_process_priority"", true)) xcodeParamsVec.add(""nice"");
		 xcodeParamsVec.add(getTranscoderPath());
		 currStreamOverheadPerct = 0.10f;
		 if (transcodeStartSeekTime != 0) {
			 xcodeParamsVec.add(""-ss"");
			 xcodeParamsVec.add(Long.toString(transcodeStartSeekTime/1000));
		 }
		 if (httplsMode) segmentTargetCounter = (int)(transcodeStartSeekTime / segmentDur);
		 xcodeParamsVec.add(""-v"");
		 xcodeParamsVec.add(""3"");
		 xcodeParamsVec.add(""-y"");
		 if(multiThread) {
			 xcodeParamsVec.add(""-threads"");
			 xcodeParamsVec.add(""2"");
		 }
		 xcodeParamsVec.add(""-sn"");
		 if (sourceFormat != null && sage.media.format.MediaFormat.MPEG2_TS.equals(sourceFormat.getFormatName()) && sage.media.format.MediaFormat.H264.equals(sourceFormat.getPrimaryVideoFormat()) && sage.media.format.MediaFormat.AC3.equals(sourceFormat.getPrimaryAudioFormat()) && Sage.getBoolean(""xcode_fix_broken_hdpvr_streams"", false)) xcodeParamsVec.add(""-brokendts"");
		 int syncIndexInsert = xcodeParamsVec.size();
		 xcodeParamsVec.add("""");
		 xcodeParamsVec.add("""");
		 xcodeParamsVec.add("""");
		 xcodeParamsVec.add("""");
		 if (dynamicRateAdjust) {
		 }
		 if (transcodeEditDuration > 0) {
			 xcodeParamsVec.add(""-t"");
			 xcodeParamsVec.add(Long.toString(transcodeEditDuration/1000));
		 }
		 if (activeFile) xcodeParamsVec.add(""-activefile"");
		 xcodeParamsVec.add(""-stdinctrl"");
		 int targetWidth=720,targetHeight=480;
		 sage.media.format.VideoFormat srcVideo = sourceFormat == null ? null : sourceFormat.getVideoFormat();
		 if (srcVideo != null) {
			 targetWidth = srcVideo.getWidth();
			 targetHeight = srcVideo.getHeight();
		 }
		 String videoCodec = """";
		 xcodeParamsVec.add(""-i"");
		 if (currServer == null || currServer.length() == 0) xcodeParamsVec.add(IOUtils.getLibAVFilenameString(currFile.toString()));
		 else xcodeParamsVec.add(IOUtils.getLibAVFilenameString(""stv: int numThreads = Sage.getInt(""xcode_process_num_threads"", 0);
		 if (numThreads == 0) {
			 try {
				 numThreads = Runtime.getRuntime().availableProcessors() + 1;
			 }
			 catch (Throwable t) {
				 System.out.println(""ERROR calling "" + Runtime.getRuntime().availableProcessors() + "" of "" + t);
				 numThreads = 3;
			 }
		 }
		 if (numThreads > 1 && multiThread) {
			 numThreads = Math.min(7, numThreads);
			 if (Sage.DBG) System.out.println(""Using "" + numThreads + "" threads for the transcoder"");
			 xcodeParamsVec.add(""-threads"");
			 xcodeParamsVec.add(Integer.toString(numThreads));
		 }
		 int currFps = 30;
		 int qmin = 1;
		 boolean isMpeg4Codec = false;
		 if (httplsMode) {
			 isMpeg4Codec = true;
			 xcodeParamsVec.add(""-f"");
			 xcodeParamsVec.add(""mpegts"");
			 xcodeParamsVec.add(""-vcodec"");
			 xcodeParamsVec.add(videoCodec = ""libx264"");
			 String sizeKey = String.format(BITRATE_OPTIONS_SIZE_KEY, estimatedBandwidth/1000);
			 String xcodeSize = Sage.get(sizeKey, Sage.get(String.format(BITRATE_OPTIONS_SIZE_KEY, ""default""), ""480x272""));
			 if (Sage.DBG) System.out.println(""FFMpegTranscoder: httpls: Using framesize ""+xcodeSize+"" for bandwidth: ""+(estimatedBandwidth/1000)+"" base on key: "" + sizeKey);
			 int size[] = parseFrameSize(xcodeSize, 480, 272);
			 if (Sage.DBG) System.out.println(""FFMpegTranscoder: httpls: Calculated framesize "" + size[0] + ""x"" + size[1]);
			 targetWidth = size[0];
			 targetHeight = size[1];
			 currAudioBitrateKbps = 32;
			 currVideoBitrateKbps = (int)Math.max(64000, (estimatedBandwidth - 32000))/1000;
			 xcodeParamsVec.add(""-b"");
			 xcodeParamsVec.add(currVideoBitrateKbps*1000 + """");
			 xcodeParamsVec.add(""-s"");
			 xcodeParamsVec.add(targetWidth + ""x"" + targetHeight);
			 xcodeParamsVec.add(""-r"");
			 xcodeParamsVec.add(""29.97"");
			 xcodeParamsVec.add(""-acodec"");
			 xcodeParamsVec.add(""libfaac"");
			 xcodeParamsVec.add(""-ab"");
			 xcodeParamsVec.add(Integer.toString(currAudioBitrateKbps * 1000));
			 xcodeParamsVec.add(""-ac"");
			 xcodeParamsVec.add(""2"");
			 xcodeParamsVec.add(""-ar"");
			 xcodeParamsVec.add(""44100"");
			 xcodeParamsVec.add(""-coder"");
			 xcodeParamsVec.add(""0"");
			 xcodeParamsVec.add(""-flags"");
			 xcodeParamsVec.add(""+loop"");
			 xcodeParamsVec.add(""-cmp"");
			 xcodeParamsVec.add(""+chroma"");
			 xcodeParamsVec.add(""-partitions"");
			 xcodeParamsVec.add(""+parti8x8+parti4x4-partp8x8-partb8x8"");
			 xcodeParamsVec.add(""-me_method"");
			 xcodeParamsVec.add(""dia"");
			 xcodeParamsVec.add(""-subq"");
			 xcodeParamsVec.add(""1"");
			 xcodeParamsVec.add(""-me_range"");
			 xcodeParamsVec.add(""16"");
			 xcodeParamsVec.add(""-g"");
			 xcodeParamsVec.add(""250"");
			 xcodeParamsVec.add(""-keyint_min"");
			 xcodeParamsVec.add(""25"");
			 xcodeParamsVec.add(""-sc_threshold"");
			 xcodeParamsVec.add(""40"");
			 xcodeParamsVec.add(""-i_qfactor"");
			 xcodeParamsVec.add(""0.71"");
			 xcodeParamsVec.add(""-b_strategy"");
			 xcodeParamsVec.add(""1"");
			 xcodeParamsVec.add(""-qcomp"");
			 xcodeParamsVec.add(""0.6"");
			 xcodeParamsVec.add(""-qmin"");
			 xcodeParamsVec.add(""10"");
			 xcodeParamsVec.add(""-qmax"");
			 xcodeParamsVec.add(""51"");
			 xcodeParamsVec.add(""-qdiff"");
			 xcodeParamsVec.add(""4"");
			 xcodeParamsVec.add(""-bf"");
			 xcodeParamsVec.add(""0"");
			 xcodeParamsVec.add(""-refs"");
			 xcodeParamsVec.add(""1"");
			 xcodeParamsVec.add(""-directpred"");
			 xcodeParamsVec.add(""1"");
			 xcodeParamsVec.add(""-trellis"");
			 xcodeParamsVec.add(""0"");
			 xcodeParamsVec.add(""-flags2"");
			 xcodeParamsVec.add(""-wpred-dct8x8"");
			 xcodeParamsVec.add(""-wpredp"");
			 xcodeParamsVec.add(""0"");
			 xcodeParamsVec.add(""-rc_lookahead"");
			 xcodeParamsVec.add(""50"");
			 xcodeParamsVec.add(""-level"");
			 xcodeParamsVec.add(""30"");
			 xcodeParamsVec.add(""-maxrate"");
			 xcodeParamsVec.add(currVideoBitrateKbps*6000/5 + """");
			 xcodeParamsVec.add(""-bufsize"");
			 xcodeParamsVec.add(currVideoBitrateKbps*5000 + """");
			 if (xcodeParams.indexOf(""-deinterlace"") == -1 && srcVideo != null && srcVideo.isInterlaced() && targetHeight > srcVideo.getHeight()/2 && Sage.getBoolean(""xcode_auto_deinterlace"", true)) {
				 if (Sage.DBG) System.out.println(""Automatically adding -deinterlace option to transcoding process"");
				 xcodeParamsVec.add(""-deinterlace"");
			 }
			 if (sourceFormat != null) {
				 sage.media.format.VideoFormat vidForm = sourceFormat.getVideoFormat();
				 if (vidForm != null) {
					 xcodeParamsVec.add(""-aspect"");
					 if (vidForm.getArNum() > 0 && vidForm.getArDen() > 0) xcodeParamsVec.add(vidForm.getArNum() + "":"" + vidForm.getArDen());
					 else xcodeParamsVec.add(vidForm.getWidth() + "":"" + vidForm.getHeight());
				 }
			 }
		 }
		 else if (dynamicRateAdjust) {
			 isMpeg4Codec = true;
			 xcodeParamsVec.add(""-f"");
			 xcodeParamsVec.add(iOSMode ? ""mpegts"" : ""dvd"");
			 xcodeParamsVec.add(""-vcodec"");
			 xcodeParamsVec.add(videoCodec = ""mpeg4"");
			 xcodeParamsVec.add(""-s"");
			 xcodeParamsVec.add(MMC.getInstance().isNTSCVideoFormat() ? ""352x240"" : ""352x288"");
			 targetWidth = 352;
			 targetHeight = MMC.getInstance().isNTSCVideoFormat() ? 240 : 288;
			 xcodeParamsVec.add(""-ac"");
			 xcodeParamsVec.add(Sage.getBoolean(""xcode_disable_mono_audio"", true) ? ""2"" : ""1"");
			 xcodeParamsVec.add(""-g"");
			 xcodeParamsVec.add(""300"");
			 xcodeParamsVec.add(""-bf"");
			 xcodeParamsVec.add(""2"");
			 xcodeParamsVec.add(""-acodec"");
			 xcodeParamsVec.add(iOSMode ? ""libfaac"" : Sage.get(""xcode_dynamic_audio_codec"", ""mp2""));
			 int currAudioSampling, currPacketSize;
			 if (estimatedBandwidth < 90000) {
				 if (currVideoBitrateKbps == -1) currVideoBitrateKbps = 50;
				 if (currAudioBitrateKbps == -1) currAudioBitrateKbps = 24;
				 currFps = 10;
				 currAudioSampling = 24000;
				 currPacketSize = 1024;
				 qmin = 10;
			 }
			 else if (estimatedBandwidth < 150000) {
				 if (currVideoBitrateKbps == -1) currVideoBitrateKbps = 64;
				 if (currAudioBitrateKbps == -1) currAudioBitrateKbps = 48;
				 currFps = 15;
				 currAudioSampling = 24000;
				 currPacketSize = 1024;
				 qmin = 5;
			 }
			 else if (estimatedBandwidth < 900000) {
				 if (currVideoBitrateKbps == -1) currVideoBitrateKbps = (int)estimatedBandwidth/2000;
				 if (currAudioBitrateKbps == -1) currAudioBitrateKbps = 64;
				 currFps = 15;
				 currAudioSampling = 48000;
				 currPacketSize = 2048;
			 }
			 else {
				 if (currVideoBitrateKbps == -1) currVideoBitrateKbps = Math.min(1000, (int)estimatedBandwidth/2000);
				 if (currAudioBitrateKbps == -1) currAudioBitrateKbps = 128;
				 currFps = MMC.getInstance().isNTSCVideoFormat() ? 30 : 25;
				 currAudioSampling = 48000;
				 currPacketSize = 2048;
			 }
			 xcodeParamsVec.add(""-r"");
			 xcodeParamsVec.add(Integer.toString(currFps));
			 xcodeParamsVec.add(""-b"");
			 xcodeParamsVec.add(Integer.toString(currVideoBitrateKbps * 1000));
			 xcodeParamsVec.add(""-ar"");
			 xcodeParamsVec.add(Integer.toString(currAudioSampling));
			 xcodeParamsVec.add(""-ab"");
			 xcodeParamsVec.add(Integer.toString(currAudioBitrateKbps * 1000));
			 xcodeParamsVec.add(""-packetsize"");
			 xcodeParamsVec.add(Integer.toString(currPacketSize));
			 if (sourceFormat != null) {
				 sage.media.format.VideoFormat vidForm = sourceFormat.getVideoFormat();
				 if (vidForm != null) {
					 xcodeParamsVec.add(""-aspect"");
					 if (vidForm.getArNum() > 0 && vidForm.getArDen() > 0) xcodeParamsVec.add(vidForm.getArNum() + "":"" + vidForm.getArDen());
					 else xcodeParamsVec.add(vidForm.getWidth() + "":"" + vidForm.getHeight());
				 }
			 }
		 }
		 else {
			 int flagsIndex = -1;
			 java.util.StringTokenizer toker = new java.util.StringTokenizer(xcodeParams);
			 while (toker.hasMoreTokens()) {
				 String currToke = toker.nextToken();
				 xcodeParamsVec.add(currToke);
				 if (currToke.equals(""-b"") && toker.hasMoreTokens()) {
					 currToke = toker.nextToken();
					 try {
						 currVideoBitrateKbps = Integer.parseInt(currToke);
						 if (preservedVideoBitrate > 0) xcodeParamsVec.add(Integer.toString(preservedVideoBitrate));
						 else xcodeParamsVec.add(Integer.toString(currVideoBitrateKbps * 1000));
					 }
					catch (NumberFormatException e) {
						 System.out.println(""Bad video bitrate parsed of "" + currToke + "" err:"" + e);
						 xcodeParamsVec.add(currToke);
					 }
				 }
				 else if (currToke.equals(""-ab"") && toker.hasMoreTokens()) {
					 currToke = toker.nextToken();
					 try {
						 currAudioBitrateKbps = Integer.parseInt(currToke);
						 if (preservedAudioBitrate > 0) xcodeParamsVec.add(Integer.toString(preservedAudioBitrate));
						 else xcodeParamsVec.add(Integer.toString(currAudioBitrateKbps * 1000));
					 }
					catch (NumberFormatException e) {
						 System.out.println(""Bad audio bitrate parsed of "" + currToke + "" err:"" + e);
					 }
				 }
				 else if (currToke.equals(""-r"") && toker.hasMoreTokens()) {
					 currToke = toker.nextToken();
					 xcodeParamsVec.add(currToke);
					 try {
						 currFps = Math.round(Float.parseFloat(currToke));
					 }
					catch (NumberFormatException e) {
						 System.out.println(""Bad fps parsed of "" + currToke + "" err:"" + e);
					 }
				 }
				 else if (currToke.equals(""-vcodec"") && toker.hasMoreTokens()) {
					 currToke = videoCodec = toker.nextToken();
					 xcodeParamsVec.add(currToke);
					 if (currToke.equals(""mpeg4"")) isMpeg4Codec = true;
				 }
				 else if (currToke.equals(""-s"") && toker.hasMoreTokens()) {
					 currToke = toker.nextToken();
					 xcodeParamsVec.add(currToke);
					 try {
						 targetWidth = Integer.parseInt(currToke.substring(0, currToke.indexOf('x')));
						 targetHeight = Integer.parseInt(currToke.substring(currToke.indexOf('x') + 1));
					 }
					catch (NumberFormatException e) {
						 System.out.println(""Bad target size parsed of "" + currToke + "" err:"" + e);
					 }
				 }
				 else if (currToke.equals(""-vn"")) {
					 currVideoBitrateKbps = 0;
				 }
				 else if (currToke.equals(""-an"")) {
					 currAudioBitrateKbps = 0;
				 }
				 else if (currToke.equals(""-flags"")) {
					 flagsIndex = xcodeParamsVec.size();
				 }
			 }
			 if (xcodeParams.indexOf(""-aspect"") == -1 && sourceFormat != null) {
				 sage.media.format.VideoFormat vidForm = sourceFormat.getVideoFormat();
				 if (vidForm != null) {
					 xcodeParamsVec.add(""-aspect"");
					 if (vidForm.getArNum() > 0 && vidForm.getArDen() > 0) xcodeParamsVec.add(vidForm.getArNum() + "":"" + vidForm.getArDen());
					 else xcodeParamsVec.add(vidForm.getWidth() + "":"" + vidForm.getHeight());
				 }
			 }
			 if (xcodeParams.indexOf(""-deinterlace"") == -1 && srcVideo != null && srcVideo.isInterlaced() && targetHeight > srcVideo.getHeight()/2 && Sage.getBoolean(""xcode_auto_deinterlace"", true)) {
				 if (Sage.DBG) System.out.println(""Automatically adding -deinterlace option to transcoding process"");
				 xcodeParamsVec.add(""-deinterlace"");
			 }
		 }
		 if (currVideoBitrateKbps == -1) currVideoBitrateKbps = 200;
		 if (currAudioBitrateKbps == -1) currAudioBitrateKbps = 64;
		 if (isMpeg4Codec && outputFile == null && !httplsMode) {
			 xcodeParamsVec.add(""-muxrate"");
			 xcodeParamsVec.add(""2000000"");
			 xcodeParamsVec.add(""-rc_init_cplx"");
			 int complexity = (currVideoBitrateKbps * 8000/currFps) / (((targetWidth + 15)/16) * ((targetHeight + 15)/16));
			 xcodeParamsVec.add(Integer.toString(complexity));
			 xcodeParamsVec.add(""-maxrate"");
			 xcodeParamsVec.add(Integer.toString(currVideoBitrateKbps * 1000));
			 xcodeParamsVec.add(""-minrate"");
			 xcodeParamsVec.add(""0"");
			 xcodeParamsVec.add(""-bufsize"");
			 xcodeParamsVec.add(Integer.toString(currVideoBitrateKbps * 1000));
			 xcodeParamsVec.add(""-mbd"");
			 xcodeParamsVec.add(""2"");
			 if (dynamicRateAdjust) {
				 xcodeParamsVec.add(""-rc_eq"");
				 xcodeParamsVec.add(""isI*200+isP*75+isB*75"");
				 if (qmin > 1) {
					 xcodeParamsVec.add(""-qmin"");
					 xcodeParamsVec.add(Integer.toString(qmin));
				 }
			 }
		 }
		 if (sourceFormat != null) {
			 String aud = sourceFormat.getPrimaryAudioFormat();
			 if (aud != null && aud.startsWith(""0X"")) {
				 if (Sage.DBG) System.out.println(""Disabling audio in transcoder since it's an unsupported audio format"");
				 xcodeParamsVec.add(""-an"");
				 currAudioBitrateKbps = 0;
			 }
		 }
		 if (currAudioBitrateKbps > 0 && sourceFormat != null && sourceFormat.getNumAudioStreams() > 1 && currVideoBitrateKbps > 0) {
			 sage.media.format.ContainerFormat ffFormat = sage.media.format.FormatParser.getFFMPEGFileFormat(currFile.toString());
			 if (ffFormat != null) {
				 sage.media.format.VideoFormat vf = ffFormat.getVideoFormat();
				 if (vf != null && vf.getOrderIndex() >= 0) {
					 sage.media.format.AudioFormat[] srcAudioFormats = sourceFormat.getAudioFormats();
					 sage.media.format.AudioFormat srcAudioFormat = null;
					 for (int i = 0;
					 i < srcAudioFormats.length;
					 i++) {
						 if (!srcAudioFormats[i].getFormatName().equals(sage.media.format.MediaFormat.DOLBY_HD) && !srcAudioFormats[i].getFormatName().equals(sage.media.format.MediaFormat.DTS_HD) && !srcAudioFormats[i].getFormatName().equals(sage.media.format.MediaFormat.DTS_MA)) {
							 srcAudioFormat = srcAudioFormats[i];
							 break;
						 }
					 }
					 if (srcAudioFormat == null) srcAudioFormat = sourceFormat.getAudioFormat();
					 String mainsrcid = srcAudioFormat.getId();
					 boolean isAC3 = sage.media.format.MediaFormat.AC3.equals(srcAudioFormat.getFormatName());
					 sage.media.format.AudioFormat af = null;
					 if (mainsrcid != null) {
						 sage.media.format.AudioFormat[] afs = ffFormat.getAudioFormats();
						 for (int i = 0;
						 i < afs.length;
						 i++) {
							 if (mainsrcid.equals(afs[i].getId()) || (isAC3 && mainsrcid.startsWith(""bd-"" + afs[i].getId()))) {
								 af = afs[i];
								 break;
							 }
						 }
					 }
					 if (af == null) af = ffFormat.getAudioFormat();
					 if (af != null && af.getOrderIndex() >= 0) {
						 xcodeParamsVec.add(""-map"");
						 xcodeParamsVec.add(""0:"" + vf.getOrderIndex());
						 xcodeParamsVec.add(""-map"");
						 xcodeParamsVec.add(""0:"" + af.getOrderIndex());
					 }
				 }
			 }
		 }
		 if (sourceFormat != null && sourceFormat.getVideoFormat() != null && sourceFormat.getVideoFormat().isInterlaced() && ""mpeg2video"".equals(videoCodec)) {
			 xcodeParamsVec.add(""-flags"");
			 xcodeParamsVec.add(""ildct"");
			 xcodeParamsVec.add(""-flags"");
			 xcodeParamsVec.add(""ilme"");
		 }
		 if (pass != 0) {
			 xcodeParamsVec.add(""-pass"");
			 xcodeParamsVec.add(Integer.toString(pass));
			 xcodeParamsVec.add(""-passlogfile"");
			 xcodeParamsVec.add(""multipassxcode"");
		 }
		 if (dynamicRateAdjust || (isMpeg4Codec && outputFile == null)) {
			 xcodeParamsVec.set(syncIndexInsert, ""-vsync"");
			 if (httplsMode || (transcodeStartSeekTime != 0 && sourceFormat != null && (sage.media.format.MediaFormat.AVI.equals(sourceFormat.getFormatName()) || sage.media.format.MediaFormat.MATROSKA.equals(sourceFormat.getFormatName())))) xcodeParamsVec.set(syncIndexInsert + 1, ""1"");
			 else xcodeParamsVec.set(syncIndexInsert + 1, ""0"");
			 xcodeParamsVec.set(syncIndexInsert + 2, ""-async"");
			 xcodeParamsVec.set(syncIndexInsert + 3, ""1"");
		 }
		 else {
			 xcodeParamsVec.set(syncIndexInsert, ""-vsync"");
			 xcodeParamsVec.set(syncIndexInsert + 1, ""1"");
			 xcodeParamsVec.set(syncIndexInsert + 2, ""-async"");
			 xcodeParamsVec.set(syncIndexInsert + 3, ""100"");
		 }
		 if (Sage.DBG && ""TRUE"".equals(Sage.get(""xcode_video_bitrate_stats"", null))) xcodeParamsVec.add(""-vstats"");
		 if (Sage.WINDOWS_OS && Sage.getBoolean(""xcode_reduce_process_priority"", true)) {
			 xcodeParamsVec.add(""-priority"");
			 if (outputFile != null) xcodeParamsVec.add(Sage.get(""xcode_process_priority_offline"", ""idle""));
			 else xcodeParamsVec.add(Sage.get(""xcode_process_priority_streaming"", ""belownormal""));
		 }
		 if (outputFile != null) {
			 xcodeParamsVec.add(IOUtils.getLibAVFilenameString(outputFile.toString()));
			 bufferOutput = false;
		 }
		 else xcodeParamsVec.add(""-"");
		 String[] xcodeParamArray = (String[]) xcodeParamsVec.toArray(Pooler.EMPTY_STRING_ARRAY);
		 if (Sage.DBG && ""TRUE"".equals(Sage.get(""xcode_cmdline_debug"", null))) System.out.println(""Executing xcoding process with args: "" + java.util.Arrays.asList(xcodeParamArray));
		 xcodeProcess = Runtime.getRuntime().exec(xcodeParamArray);
		 xcodeDone = false;
		 if (xcodeBuffer == null) {
			 if (currVideoBitrateKbps >= 1000) xcodeBuffer = new byte[16][32768];
			 else xcodeBuffer = new byte[32][currVideoBitrateKbps >= 300 ? 16384 : 4096];
		 }
		 xcodeStderrThread = new Thread(""XcodeStderrConsumer"") {
			 public void run() {
				 try {
					 java.io.InputStream buf = xcodeProcess.getErrorStream();
					 StringBuffer sb = new StringBuffer();
					 long nextSegmentTime = segmentDur;
					 if (httplsMode) lastXcodeStreamTime = 0;
					 do {
						 int c = buf.read();
						 if (c == -1) break;
						 else sb.append((char) c);
						 if (c == '\n') {
							 if (XCODE_DEBUG) System.out.println(sb.toString().trim());
							 sb.setLength(0);
						 }
						 else if (c == '\r') {
							 if (XCODE_DEBUG) System.out.println(sb.toString().trim());
							 int sizeIdx = sb.indexOf(""size="");
							 int timeIdx = sb.indexOf(""time="");
							 int kbIdx = sb.indexOf(""kB"", sizeIdx);
							 int bitrateIdx = sb.indexOf(""bitrate="");
							 if (sizeIdx != -1 && timeIdx != -1 && kbIdx != -1 && bitrateIdx != -1) {
								 String sizeStr = sb.substring(sizeIdx + 5, kbIdx).trim();
								 String timeStr = sb.substring(timeIdx + 5, bitrateIdx).trim();
								 if (sizeStr.indexOf('.') == -1) {
									 try {
										 lastXcodeStreamTime = Math.round(1000 * Double.parseDouble(timeStr));
										 lastXcodeStreamPosition = Long.parseLong(sizeStr) * 1024;
									 }
									 catch (NumberFormatException e) {
										 System.out.println(""ERROR parsing transcoder time of:"" + e);
									 }
								 }
							 }
							 if (httplsMode) {
								 if (lastXcodeStreamTime >= nextSegmentTime) {
									 synchronized (segFileSyncLock) {
										 segmentTargetCounter++;
										 if (XCODE_DEBUG) System.out.println(""Stderr reader has read a timecode that indicates end of segment, increment counter, target="" + nextSegmentTime + "" read="" + lastXcodeStreamTime + "" newCounterValue="" + segmentTargetCounter);
										 segFileSyncLock.notifyAll();
									 }
									 nextSegmentTime += segmentDur;
								 }
							 }
							 sb.setLength(0);
						 }
					 }
					while (true);
					 buf.close();
				 }
				 catch (Exception e){
				}
				 finally {
					 xcodeDone = true;
				 }
			 }
		 }
		;
		 xcodeStderrThread.setDaemon(true);
		 xcodeStderrThread.start();
		 numFilledXcodeBuffers = 0;
		 xcodeStdout = xcodeProcess.getInputStream();
		 forciblyStopped = false;
		 if (bufferOutput) {
			 xcodeStdoutThread = new Thread(""XcodeDataConsumer"") {
				 public void run() {
					 try {
						 do {
							 int currBuffNum;
							 int currBufReadPos = 0;
							 synchronized (xcodeSyncLock) {
								 if (numFilledXcodeBuffers == xcodeBuffer.length && !xcodeDone) {
									 if (XCODE_DEBUG) System.out.println(""Waiting for transcode buffer to become available..."");
									 try {
										 xcodeSyncLock.wait(100);
									 }
									 catch (InterruptedException e){
									}
									 continue;
								 }
								 currBuffNum = (xcodeBufferBaseNum + numFilledXcodeBuffers) % xcodeBuffer.length;
							 }
							 int leftToRead = xcodeBuffer[currBuffNum].length;
							 int numRead;
							 do {
								 numRead = xcodeStdout.read(xcodeBuffer[currBuffNum], xcodeBuffer[currBuffNum].length - leftToRead, leftToRead);
								 if (XCODE_DEBUG) System.out.println(""Read "" + numRead + "" bytes from transcoder"");
								 leftToRead -= numRead;
							 }
							 while (numRead != -1 && leftToRead > 0);
							 if (numRead == -1) {
								 xcodeDone = true;
								 break;
							 }
							 else {
								 synchronized (xcodeSyncLock) {
									 numFilledXcodeBuffers++;
									 xcodeBufferVirtualSize += xcodeBuffer[currBuffNum].length;
									 if (XCODE_DEBUG) System.out.println(""Number of transcode buffers filled="" + numFilledXcodeBuffers + "" virtXcodedBytes="" + xcodeBufferVirtualSize);
								 }
							 }
						 }
						while (true);
					 }
					 catch (Exception e){
					}
					 finally {
						 xcodeDone = true;
					 }
				 }
			 }
			;
			 xcodeStdoutThread.setDaemon(true);
			 xcodeStdoutThread.start();
		 }
		 else if (httplsMode) {
			 for (int i = 0;
			 i < segmentData.length;
			 i++) {
				 segmentData[i].state = SEGMENT_FREE;
				 segmentData[i].num = -1;
			 }
			 segmentData[0].state = SEGMENT_FILLING;
			 segmentData[0].num = segmentTargetCounter;
			 xcodeStdoutThread = new Thread(""XcodeDataConsumer"") {
				 public void run() {
					 byte[] readBuf;
					 if (currVideoBitrateKbps >= 1000) readBuf = new byte[32768];
					 else readBuf = new byte[currVideoBitrateKbps >= 300 ? 16384 : 4096];
					 int lastDataIdx = -1;
					 java.io.OutputStream fos = null;
					 SegmentFileData currSegData = null;
					 try {
						 lastDataIdx = 0;
						 currSegData = segmentData[0];
						 if (XCODE_DEBUG) System.out.println(""Output consumer selected initial segment buffer #"" + lastDataIdx + "" for writing of part #"" + segmentTargetCounter);
						 fos = new java.io.BufferedOutputStream(new java.io.FileOutputStream(currSegData.file));
						 int numRead;
						 do {
							 numRead = xcodeStdout.read(readBuf);
							 if (XCODE_DEBUG) System.out.println(""Read "" + numRead + "" bytes from transcoder"");
							 fos.write(readBuf, 0, numRead);
							 synchronized (segFileSyncLock) {
								 if (currSegData.num != segmentTargetCounter) {
									 if (XCODE_DEBUG) System.out.println(""Finished writing to current segment file buffer #"" + currSegData.num + "" for part #"" + currSegData.num + "", closing file and moving on"");
									 fos.close();
									 fos = null;
									 currSegData.state = SEGMENT_FILLED;
									 lastDataIdx = (lastDataIdx + 1) % segmentData.length;
									 while (segmentData[lastDataIdx].state != SEGMENT_FREE && segmentData[lastDataIdx].state != SEGMENT_CONSUMED && !xcodeDone) {
										 if (XCODE_DEBUG) System.out.println(""Waiting for segment file buffer to become available..."");
										 try {
											 segFileSyncLock.wait(500);
										 }
										 catch (InterruptedException e){
										}
									 }
									 if (xcodeDone) return;
									 if (XCODE_DEBUG) System.out.println(""Output consumer selected segment buffer #"" + lastDataIdx + "" for writing of part #"" + segmentTargetCounter);
									 currSegData = segmentData[lastDataIdx];
									 currSegData.state = SEGMENT_FILLING;
									 currSegData.num = segmentTargetCounter;
									 fos = new java.io.BufferedOutputStream(new java.io.FileOutputStream(currSegData.file));
									 segFileSyncLock.notifyAll();
								 }
							 }
						 }
						 while (numRead != -1 && !xcodeDone);
						 if (numRead == -1 || xcodeDone) {
							 xcodeDone = true;
						 }
					 }
					 catch (Exception e){
					}
					 finally {
						 xcodeDone = true;
						 if (fos != null) {
							 try{
								fos.close();
							}
							catch(Exception e){
							}
							 fos = null;
						 }
						 if (!forciblyStopped && currSegData != null && currSegData.state == SEGMENT_FILLING) {
							 synchronized (segFileSyncLock) {
								 currSegData.state = SEGMENT_FILLED;
								 segFileSyncLock.notifyAll();
							 }
						 }
					 }
				 }
			 }
			;
			 xcodeStdoutThread.setDaemon(true);
			 xcodeStdoutThread.start();
		 }
		 xcodeStdin = xcodeProcess.getOutputStream();
	 }
	 int[] parseFrameSize(String xcodeWxH, int defWidth, int defHeight) {
		 int size[] = new int[] {
		defWidth, defHeight}
		;
		 if (xcodeWxH == null) {
			 return size;
		 }
		 xcodeWxH = xcodeWxH.toLowerCase();
		 if (""original"".equals(xcodeWxH)) {
			 if (sourceFormat!=null && sourceFormat.getVideoFormat()!=null) {
				 size[0] = sourceFormat.getVideoFormat().getWidth();
				 size[1] = sourceFormat.getVideoFormat().getHeight();
				 size[0] = (size[0]<=0) ? defWidth : size[0];
				 size[1] = (size[1]<=0) ? defHeight : size[1];
				 return size;
			 }
			 else {
				 if (Sage.DBG) System.out.println(""FFMpegTranscoder: parseFrameSize(): 'original' was passed but there isn't any video information. Using defaults."");
				 return size;
			 }
		 }
		 String parts[] = xcodeWxH.split(""x"");
		 if (parts.length != 2) {
			 if (Sage.DBG) System.out.println(""FFMpegTranscoder: parseFrameSize(): Invalid xcode size option ""+xcodeWxH+"" (should be widthxheight, eg, 1280x720)"");
			 return size;
		 }
		 int w,h;
		 try {
			 w = Integer.parseInt(parts[0].trim());
		 }
		 catch (Throwable t) {
			 if (Sage.DBG) System.out.println(""FFMpegTranscoder: parseFrameSize(): Invalid xcode size option ""+xcodeWxH+"" (should be widthxheight, eg, 1280x720)"");
			 return size;
		 }
		 try {
			 h = Integer.parseInt(parts[1].trim());
		 }
		 catch (Throwable t) {
			 if (Sage.DBG) System.out.println(""FFMpegTranscoder: parseFrameSize(): Invalid xcode size option ""+xcodeWxH+"" (should be widthxheight, eg, 1280x720)"");
			 return size;
		 }
		 if (h>0 && w>0) {
			 size[0]=w;
			 size[1]=h;
		 }
		 return size;
	 }
	 public void stopTranscode() {
		 forciblyStopped = true;
		 xcodeDone = true;
		 if (XCODE_DEBUG) System.out.println(""Destroying old transcode process..."");
		 if (xcodeProcess != null) {
			 try {
				 lastExitCode = xcodeProcess.exitValue();
			 }
			 catch (IllegalThreadStateException ise) {
				 lastExitCode = -1;
			 }
			 xcodeProcess.destroy();
		 }
		 xcodeProcess = null;
		 if (XCODE_DEBUG) System.out.println(""Destroyed!"");
		 try {
			 if (xcodeStderrThread != null) {
				 xcodeStderrThread.join(2000);
				 xcodeStderrThread = null;
				 if (XCODE_DEBUG) System.out.println(""Stderr consumer thread has terminated for xcoder"");
			 }
		 }
		catch(InterruptedException e){
		}
		 try {
			 if (xcodeStdoutThread != null) {
				 xcodeStdoutThread.join(2000);
				 xcodeStdoutThread = null;
				 if (XCODE_DEBUG) System.out.println(""Stdout consumer thread has terminated for xcoder"");
			 }
		 }
		catch(InterruptedException e){
		}
		 try {
			 if (xcodeStdout != null) xcodeStdout.close();
		 }
		 catch (java.io.IOException e){
		}
		 xcodeStdout = null;
		 try {
			 if (xcodeStdin != null) {
				 xcodeStdin.close();
			 }
		 }
		catch(java.io.IOException e){
		}
		 xcodeStdin = null;
		 if (httplsMode && segmentData != null) {
			 for (int i = 0;
			 i < segmentData.length;
			 i++) segmentData[i].file.delete();
		 }
	 }
	 public void setEnableOutputBuffering(boolean x) {
		 bufferOutput = x;
	 }
	 public void setActiveFile(boolean x) {
		 if (activeFile != x) {
			 activeFile = x;
			 if (xcodeStdin != null && !activeFile) {
				 try {
					 xcodeStdin.write(""inactivefile\n"".getBytes(Sage.BYTE_CHARSET));
					 xcodeStdin.flush();
				 }
				 catch (Exception e) {
					 System.out.println(""Error writing to xcoder stdin of:"" + e);
				 }
			 }
		 }
	 }
	 public void dynamicVideoRateAdjust(int kbpsAdjust) {
		 if (xcodeStdin != null && !xcodeDone) {
			 try {
				 xcodeStdin.write((""videorateadapt "" + kbpsAdjust + ""\n"").getBytes(Sage.BYTE_CHARSET));
				 xcodeStdin.flush();
				 currVideoBitrateKbps += kbpsAdjust;
				 estimatedBandwidth += kbpsAdjust;
			 }
			 catch (Exception e) {
				 System.out.println(""Error writing to xcoder stdin of:"" + e);
			 }
		 }
	 }
	 public int getCurrentVideoBitrateKbps() {
		 return currVideoBitrateKbps;
	 }
	 public int getCurrentStreamBitrateKbps() {
		 return Math.round(((currAudioBitrateKbps + currVideoBitrateKbps) * (1 + currStreamOverheadPerct)));
	 }
	 public boolean isTranscoding() {
		 return !xcodeDone && xcodeProcess != null;
	 }
	 public void setEstimatedBandwidth(long bps) {
		 estimatedBandwidth = bps;
	 }
	 private static String substituteName(String s) {
		 if (s == null) return null;
		 if (""aac"".equalsIgnoreCase(s)) return ""libfaac"";
		 if (""xvid"".equalsIgnoreCase(s)) return ""libxvid"";
		 if (""h264"".equalsIgnoreCase(s)) return ""libx264"";
		 if (""mp3"".equalsIgnoreCase(s) && Sage.getBoolean(""xcode_disable_mp3_encoder"", true)) return ""mp2"";
		 for (int i = 0;
		 i < sage.media.format.FormatParser.FORMAT_SUBSTITUTIONS.length;
		 i++) if (sage.media.format.FormatParser.FORMAT_SUBSTITUTIONS[i][1].equalsIgnoreCase(s) && sage.media.format.FormatParser.FORMAT_SUBSTITUTIONS[i][0].indexOf('/') == -1) return sage.media.format.FormatParser.FORMAT_SUBSTITUTIONS[i][0];
		 return s.toLowerCase();
	 }
	 public void setEditParameters(long startTime, long duration) {
		 transcodeStartSeekTime = startTime;
		 transcodeEditDuration = duration;
	 }
	 public void setPass(int x) {
		 pass = x;
	 }
	 public void setThreadingEnabled(boolean x) {
		 multiThread = x;
	 }
	 public void enableSegmentedOutput(int segmentDurMsec, java.io.File[] segFiles) {
		 httplsMode = true;
		 segmentData = new SegmentFileData[segFiles.length];
		 for (int i = 0;
		 i < segmentData.length;
		 i++) {
			 segmentData[i] = new SegmentFileData();
			 segmentData[i].file = segFiles[i];
			 segmentData[i].num = -1;
		 }
		 segmentDur = segmentDurMsec;
	 }
	 public java.io.File getSegmentFile(int segNum) throws java.io.IOException {
		 synchronized (segFileSyncLock) {
			 for (int i = 0;
			 i < segmentData.length;
			 i++) if (segmentData[i].num == segNum) {
				 if (segmentData[i].state == SEGMENT_FILLED || segmentData[i].state == SEGMENT_CONSUMED || segmentData[i].state == SEGMENT_CONSUMING) {
					 if (XCODE_DEBUG) System.out.println(""Part #"" + segNum + "" was requested from transcode, it's already filled, so returning the buffer file #"" + i);
					 segmentData[i].state = SEGMENT_CONSUMING;
					 return segmentData[i].file;
				 }
				 else if (segmentData[i].state == SEGMENT_FILLING) {
					 while (!xcodeDone && segmentData[i].state == SEGMENT_FILLING && segmentData[i].num == segNum) {
						 try {
							 if (XCODE_DEBUG) System.out.println(""Part #"" + segNum + "" was requested from transcode, it's currently filling, so wait before returning the buffer file #"" + i);
							 segFileSyncLock.wait(500);
						 }
						 catch (InterruptedException ioe){
						}
					 }
					 if (xcodeDone || segmentData[i].num != segNum || (segmentData[i].state != SEGMENT_FILLED && segmentData[i].state != SEGMENT_CONSUMED && segmentData[i].state != SEGMENT_CONSUMING)) return null;
					 if (XCODE_DEBUG) System.out.println(""Part #"" + segNum + "" was requested from transcode, it's filled now, so returning the buffer file #"" + i);
					 segmentData[i].state = SEGMENT_CONSUMING;
					 return segmentData[i].file;
				 }
			 }
		 }
		 if (XCODE_DEBUG) System.out.println(""Part #"" + segNum + "" was requested from transcode but it's buffer is not filling/filled, seek the transcoder now to "" + (segNum * segmentDur));
		 seekToTime(segNum * segmentDur);
		 return getSegmentFile(segNum);
	 }
	 public void markSegmentConsumed(int segNum) {
		 synchronized (segFileSyncLock) {
			 for (int i = 0;
			 i < segmentData.length;
			 i++) if (segmentData[i].num == segNum) {
				 segmentData[i].state = SEGMENT_CONSUMED;
				 segFileSyncLock.notifyAll();
				 break;
			 }
		 }
	 }
	 protected String xcodeParams = """";
	 protected boolean xcodeDone;
	 protected Process xcodeProcess;
	 protected boolean activeFile;
	 protected java.io.OutputStream xcodeStdin;
	 protected byte[][] xcodeBuffer;
	 protected Object xcodeSyncLock = new Object();
	 protected int xcodeBufferBaseNum;
	 protected long xcodeBufferVirtualOffset;
	 protected int numFilledXcodeBuffers;
	 protected long xcodeBufferVirtualSize;
	 protected long xcodeBufferVirtualReadPos;
	 protected long lastXcodeStreamTime;
	 protected long lastXcodeStreamPosition;
	 protected Thread xcodeStderrThread;
	 protected Thread xcodeStdoutThread;
	 protected java.nio.ByteBuffer hackBuf;
	 protected java.nio.ByteBuffer overageBuf;
	 protected java.io.File currFile;
	 protected String currServer;
	 protected java.io.File outputFile;
	 protected long transcodeStartSeekTime;
	 protected java.io.FileInputStream fileStream;
	 protected java.nio.channels.FileChannel fileChannel;
	 protected boolean bufferOutput;
	 protected java.io.InputStream xcodeStdout;
	 protected static final int SEGMENT_FREE = 0;
	 protected static final int SEGMENT_FILLING = 1;
	 protected static final int SEGMENT_FILLED = 2;
	 protected static final int SEGMENT_CONSUMING = 3;
	 protected static final int SEGMENT_CONSUMED = 4;
	 protected SegmentFileData[] segmentData;
	 protected int segmentDur;
	 protected Object segFileSyncLock = new Object();
	 protected int segmentTargetCounter;
	 protected int currVideoBitrateKbps = -1;
	 protected int currAudioBitrateKbps = -1;
	 protected float currStreamOverheadPerct;
	 protected boolean dynamicRateAdjust = false;
	 protected boolean iOSMode = false;
	 protected long estimatedBandwidth;
	 protected boolean httplsMode = false;
	 protected int lastExitCode = -1;
	 protected long transcodeEditDuration;
	 protected boolean forciblyStopped;
	 protected sage.media.format.ContainerFormat sourceFormat;
	 protected int pass;
	 protected int preservedAudioBitrate;
	 protected int preservedVideoBitrate;
	 protected boolean multiThread = true;
	 protected byte[] nioTmpBuf;
	 private static class SegmentFileData {
		 public java.io.File file;
		 public int state;
		 public int num;
	 }
}",1,0,0,0
"public interface Model extends ModelCon, ModelGraphInterface, RDFReaderF, RDFWriterF, PrefixMapping, Lock{
	 public RDFReaderI getReader();
	 public RDFReaderI getReader(String lang);
	 public RDFWriterI getWriter();
	 public RDFWriterI getWriter(String lang);
	long size() ;
	 boolean isEmpty();
	ResIterator listSubjects() ;
	NsIterator listNameSpaces() ;
	Resource getResource(String uri) ;
	Property getProperty(String nameSpace, String localName);
	public Resource createResource() ;
	 public Resource createResource( AnonId id );
	public Resource createResource( String uri ) ;
	public Resource createResource( Statement statement ) ;
	public Property createProperty(String nameSpace, String localName);
	public Literal createLiteral(String v, String language);
	 public Literal createLiteral(String v, boolean wellFormed);
	 public Literal createTypedLiteral(String lex, RDFDatatype dtype);
	 public Literal createTypedLiteral(Object value, RDFDatatype dtype);
	 public Literal createTypedLiteral(Object value);
	public Statement createStatement( Resource s, Property p, RDFNode o );
	 public RDFList createList();
	 public RDFList createList( Iterator<? extends RDFNode> members );
	 public RDFList createList( RDFNode... members );
	Model add(Statement s) ;
	 Model add( Statement [] statements );
	 Model remove( Statement [] statements );
	 Model add( List<Statement> statements );
	 Model remove( List<Statement> statements );
	Model add(StmtIterator iter) ;
	Model add(Model m) ;
	public Model read(String url) ;
	public Model read(InputStream in, String base) ;
	public Model read(InputStream in, String base, String lang);
	public Model read(Reader reader, String base) ;
	public Model read(String url, String lang) ;
	public Model read(Reader reader, String base, String lang);
	 Model read( String url, String base, String lang );
	public Model write( Writer writer ) ;
	public Model write( Writer writer, String lang ) ;
	public Model write( Writer writer, String lang, String base );
	public Model write(OutputStream out) ;
	public Model write( OutputStream out, String lang ) ;
	public Model write( OutputStream out, String lang, String base );
	Model remove(Statement s) ;
	Statement getRequiredProperty(Resource s, Property p) ;
	 Statement getRequiredProperty(Resource s, Property p, String lang) ;
	 Statement getProperty( Resource s, Property p );
	 Statement getProperty(Resource s, Property p, String lang) ;
	ResIterator listSubjectsWithProperty( Property p );
	ResIterator listResourcesWithProperty( Property p );
	ResIterator listSubjectsWithProperty( Property p, RDFNode o );
	ResIterator listResourcesWithProperty( Property p, RDFNode o );
	NodeIterator listObjects() ;
	NodeIterator listObjectsOfProperty(Property p) ;
	NodeIterator listObjectsOfProperty(Resource s, Property p);
	boolean contains(Resource s, Property p) ;
	 boolean containsResource( RDFNode r );
	boolean contains(Resource s, Property p, RDFNode o) ;
	boolean contains(Statement s) ;
	boolean containsAny(StmtIterator iter) ;
	boolean containsAll(StmtIterator iter) ;
	boolean containsAny(Model model) ;
	boolean containsAll(Model model) ;
	boolean isReified( Statement s );
	Resource getAnyReifiedStatement( Statement s );
	void removeAllReifications( Statement s );
	 void removeReification( ReifiedStatement rs );
	 StmtIterator listStatements() ;
	 StmtIterator listStatements(Selector s) ;
	 StmtIterator listStatements( Resource s, Property p, RDFNode o );
	 ReifiedStatement createReifiedStatement( Statement s );
	 ReifiedStatement createReifiedStatement( String uri, Statement s );
	 RSIterator listReifiedStatements();
	 RSIterator listReifiedStatements( Statement st );
	Model query(Selector s) ;
	Model union(Model model) ;
	Model intersection(Model model) ;
	Model difference(Model model) ;
	 public boolean equals(Object m);
	Model begin() ;
	Model abort() ;
	Model commit() ;
	 void executeInTxn( Runnable action );
	 <T> T calculateInTxn( Supplier<T> action ) ;
	boolean independent();
	boolean supportsTransactions();
	boolean supportsSetOperations();
	boolean isIsomorphicWith(Model g);
	public void close();
	 public Lock getLock() ;
	 public Model register( ModelChangedListener listener );
	 public Model unregister( ModelChangedListener listener );
	public Model notifyEvent( Object e );
	 public Model removeAll();
	 public Model removeAll( Resource s, Property p, RDFNode r );
	 public boolean isClosed();
	 Model setNsPrefix( String prefix, String uri );
	 Model removeNsPrefix( String prefix );
	 Model clearNsPrefixMap();
	 Model setNsPrefixes( PrefixMapping other );
	 Model setNsPrefixes( Map<String, String> map );
	 Model withDefaultMappings( PrefixMapping map );
}",1,0,0,0
"public class NativeRegExp extends IdScriptableObject implements Function{
	 static final long serialVersionUID = 4965263491464903264L;
	 private static final Object REGEXP_TAG = new Object();
	 public static final int JSREG_GLOB = 0x1;
	 public static final int JSREG_FOLD = 0x2;
	 public static final int JSREG_MULTILINE = 0x4;
	 public static final int TEST = 0;
	 public static final int MATCH = 1;
	 public static final int PREFIX = 2;
	 private static final boolean debug = false;
	 private static final byte REOP_EMPTY = 0;
	 private static final byte REOP_ALT = 1;
	 private static final byte REOP_BOL = 2;
	 private static final byte REOP_EOL = 3;
	 private static final byte REOP_WBDRY = 4;
	 private static final byte REOP_WNONBDRY = 5;
	 private static final byte REOP_QUANT = 6;
	 private static final byte REOP_STAR = 7;
	 private static final byte REOP_PLUS = 8;
	 private static final byte REOP_OPT = 9;
	 private static final byte REOP_LPAREN = 10;
	 private static final byte REOP_RPAREN = 11;
	 private static final byte REOP_DOT = 12;
	 private static final byte REOP_CCLASS = 13;
	 private static final byte REOP_DIGIT = 14;
	 private static final byte REOP_NONDIGIT = 15;
	 private static final byte REOP_ALNUM = 16;
	 private static final byte REOP_NONALNUM = 17;
	 private static final byte REOP_SPACE = 18;
	 private static final byte REOP_NONSPACE = 19;
	 private static final byte REOP_BACKREF = 20;
	 private static final byte REOP_FLAT = 21;
	 private static final byte REOP_FLAT1 = 22;
	 private static final byte REOP_JUMP = 23;
	 private static final byte REOP_DOTSTAR = 24;
	 private static final byte REOP_ANCHOR = 25;
	 private static final byte REOP_EOLONLY = 26;
	 private static final byte REOP_UCFLAT = 27;
	 private static final byte REOP_UCFLAT1 = 28;
	 private static final byte REOP_UCCLASS = 29;
	 private static final byte REOP_NUCCLASS = 30;
	 private static final byte REOP_BACKREFi = 31;
	 private static final byte REOP_FLATi = 32;
	 private static final byte REOP_FLAT1i = 33;
	 private static final byte REOP_UCFLATi = 34;
	 private static final byte REOP_UCFLAT1i = 35;
	 private static final byte REOP_ANCHOR1 = 36;
	 private static final byte REOP_NCCLASS = 37;
	 private static final byte REOP_DOTSTARMIN = 38;
	 private static final byte REOP_LPARENNON = 39;
	 private static final byte REOP_RPARENNON = 40;
	 private static final byte REOP_ASSERT = 41;
	 private static final byte REOP_ASSERT_NOT = 42;
	 private static final byte REOP_ASSERTTEST = 43;
	 private static final byte REOP_ASSERTNOTTEST = 44;
	 private static final byte REOP_MINIMALSTAR = 45;
	 private static final byte REOP_MINIMALPLUS = 46;
	 private static final byte REOP_MINIMALOPT = 47;
	 private static final byte REOP_MINIMALQUANT = 48;
	 private static final byte REOP_ENDCHILD = 49;
	 private static final byte REOP_CLASS = 50;
	 private static final byte REOP_REPEAT = 51;
	 private static final byte REOP_MINIMALREPEAT = 52;
	 private static final byte REOP_END = 53;
	 public static void init(Context cx, Scriptable scope, boolean sealed) {
		 NativeRegExp proto = new NativeRegExp();
		 proto.re = (RECompiled)compileRE(cx, """", null, false);
		 proto.activatePrototypeMap(MAX_PROTOTYPE_ID);
		 proto.setParentScope(scope);
		 proto.setPrototype(getObjectPrototype(scope));
		 NativeRegExpCtor ctor = new NativeRegExpCtor();
		 proto.put(""constructor"", proto, ctor);
		 ScriptRuntime.setFunctionProtoAndParent(ctor, scope);
		 ctor.setImmunePrototypeProperty(proto);
		 if (sealed) {
			 proto.sealObject();
			 ctor.sealObject();
		 }
		 defineProperty(scope, ""RegExp"", ctor, ScriptableObject.DONTENUM);
	 }
	 NativeRegExp(Scriptable scope, Object regexpCompiled) {
		 this.re = (RECompiled)regexpCompiled;
		 this.lastIndex = 0;
		 ScriptRuntime.setObjectProtoAndParent(this, scope);
	 }
	 public String getClassName() {
		 return ""RegExp"";
	 }
	 public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 return execSub(cx, scope, args, MATCH);
	 }
	 public Scriptable construct(Context cx, Scriptable scope, Object[] args) {
		 return (Scriptable)execSub(cx, scope, args, MATCH);
	 }
	 Scriptable compile(Context cx, Scriptable scope, Object[] args) {
		 if (args.length > 0 && args[0] instanceof NativeRegExp) {
			 if (args.length > 1 && args[1] != Undefined.instance) {
				 throw ScriptRuntime.typeError0(""msg.bad.regexp.compile"");
			 }
			 NativeRegExp thatObj = (NativeRegExp) args[0];
			 this.re = thatObj.re;
			 this.lastIndex = thatObj.lastIndex;
			 return this;
		 }
		 String s = args.length == 0 ? """" : ScriptRuntime.toString(args[0]);
		 String global = args.length > 1 && args[1] != Undefined.instance ? ScriptRuntime.toString(args[1]) : null;
		 this.re = (RECompiled)compileRE(cx, s, global, false);
		 this.lastIndex = 0;
		 return this;
	 }
	 public String toString() {
		 StringBuffer buf = new StringBuffer();
		 buf.append('/');
		 if (re.source.length != 0) {
			 buf.append(re.source);
		 }
		 else {
			 buf.append(""(?:)"");
		 }
		 buf.append('/');
		 if ((re.flags & JSREG_GLOB) != 0) buf.append('g');
		 if ((re.flags & JSREG_FOLD) != 0) buf.append('i');
		 if ((re.flags & JSREG_MULTILINE) != 0) buf.append('m');
		 return buf.toString();
	 }
	 NativeRegExp() {
	 }
	 private static RegExpImpl getImpl(Context cx) {
		 return (RegExpImpl) ScriptRuntime.getRegExpProxy(cx);
	 }
	 private Object execSub(Context cx, Scriptable scopeObj, Object[] args, int matchType) {
		 RegExpImpl reImpl = getImpl(cx);
		 String str;
		 if (args.length == 0) {
			 str = reImpl.input;
			 if (str == null) {
				 reportError(""msg.no.re.input.for"", toString());
			 }
		 }
		 else {
			 str = ScriptRuntime.toString(args[0]);
		 }
		 double d = ((re.flags & JSREG_GLOB) != 0) ? lastIndex : 0;
		 Object rval;
		 if (d < 0 || str.length() < d) {
			 lastIndex = 0;
			 rval = null;
		 }
		 else {
			 int indexp[] = {
			 (int)d }
			;
			 rval = executeRegExp(cx, scopeObj, reImpl, str, indexp, matchType);
			 if ((re.flags & JSREG_GLOB) != 0) {
				 lastIndex = (rval == null || rval == Undefined.instance) ? 0 : indexp[0];
			 }
		 }
		 return rval;
	 }
	 static Object compileRE(Context cx, String str, String global, boolean flat) {
		 RECompiled regexp = new RECompiled();
		 regexp.source = str.toCharArray();
		 int length = str.length();
		 int flags = 0;
		 if (global != null) {
			 for (int i = 0;
			 i < global.length();
			 i++) {
				 char c = global.charAt(i);
				 if (c == 'g') {
					 flags |= JSREG_GLOB;
				 }
				 else if (c == 'i') {
					 flags |= JSREG_FOLD;
				 }
				 else if (c == 'm') {
					 flags |= JSREG_MULTILINE;
				 }
				 else {
					 reportError(""msg.invalid.re.flag"", String.valueOf(c));
				 }
			 }
		 }
		 regexp.flags = flags;
		 CompilerState state = new CompilerState(cx, regexp.source, length, flags);
		 if (flat && length > 0) {
			if (debug) {
				System.out.println(""flat = \"""" + str + ""\"""");
			}
			 state.result = new RENode(REOP_FLAT);
			 state.result.chr = state.cpbegin[0];
			 state.result.length = length;
			 state.result.flatIndex = 0;
			 state.progLength += 5;
		 }
		 else if (!parseDisjunction(state)) return null;
		 regexp.program = new byte[state.progLength + 1];
		 if (state.classCount != 0) {
			 regexp.classList = new RECharSet[state.classCount];
			 regexp.classCount = state.classCount;
		 }
		 int endPC = emitREBytecode(state, regexp, 0, state.result);
		 regexp.program[endPC++] = REOP_END;
		if (debug) {
			System.out.println(""Prog. length = "" + endPC);
			for (int i = 0;
			 i < endPC;
			 i++) {
				 System.out.print(regexp.program[i]);
				 if (i < (endPC - 1)) System.out.print("", "");
			}
			System.out.println();
		}
		 regexp.parenCount = state.parenCount;
		 switch (regexp.program[0]) {
			 case REOP_UCFLAT1: case REOP_UCFLAT1i: regexp.anchorCh = (char)getIndex(regexp.program, 1);
			 break;
			 case REOP_FLAT1: case REOP_FLAT1i: regexp.anchorCh = (char)(regexp.program[1] & 0xFF);
			 break;
			 case REOP_FLAT: case REOP_FLATi: int k = getIndex(regexp.program, 1);
			 regexp.anchorCh = regexp.source[k];
			 break;
		 }
		if (debug) {
			if (regexp.anchorCh >= 0) {
				 System.out.println(""Anchor ch = '"" + (char)regexp.anchorCh + ""'"");
			}
		}
		 return regexp;
	 }
	 static boolean isDigit(char c) {
		 return '0' <= c && c <= '9';
	 }
	 private static boolean isWord(char c) {
		 return Character.isLetter(c) || isDigit(c) || c == '_';
	 }
	 private static boolean isLineTerm(char c) {
		 return ScriptRuntime.isJSLineTerminator(c);
	 }
	 private static boolean isREWhiteSpace(int c) {
		 return (c == '\u0020' || c == '\u0009' || c == '\n' || c == '\r' || c == 0x2028 || c == 0x2029 || c == '\u000C' || c == '\u000B' || c == '\u00A0' || Character.getType((char)c) == Character.SPACE_SEPARATOR);
	 }
	 private static char upcase(char ch) {
		 if (ch < 128) {
			 if ('a' <= ch && ch <= 'z') {
				 return (char)(ch + ('A' - 'a'));
			 }
			 return ch;
		 }
		 char cu = Character.toUpperCase(ch);
		 if ((ch >= 128) && (cu < 128)) return ch;
		 return cu;
	 }
	 private static char downcase(char ch) {
		 if (ch < 128) {
			 if ('A' <= ch && ch <= 'Z') {
				 return (char)(ch + ('a' - 'A'));
			 }
			 return ch;
		 }
		 char cl = Character.toLowerCase(ch);
		 if ((ch >= 128) && (cl < 128)) return ch;
		 return cl;
	 }
	 private static int toASCIIHexDigit(int c) {
		 if (c < '0') return -1;
		 if (c <= '9') {
			 return c - '0';
		 }
		 c |= 0x20;
		 if ('a' <= c && c <= 'f') {
			 return c - 'a' + 10;
		 }
		 return -1;
	 }
	 private static boolean parseDisjunction(CompilerState state) {
		 if (!parseAlternative(state)) return false;
		 char[] source = state.cpbegin;
		 int index = state.cp;
		 if (index != source.length && source[index] == '|') {
			 RENode altResult;
			 ++state.cp;
			 altResult = new RENode(REOP_ALT);
			 altResult.kid = state.result;
			 if (!parseDisjunction(state)) return false;
			 altResult.kid2 = state.result;
			 state.result = altResult;
			 state.progLength += 9;
		 }
		 return true;
	 }
	 private static boolean parseAlternative(CompilerState state) {
		 RENode headTerm = null;
		 RENode tailTerm = null;
		 char[] source = state.cpbegin;
		 while (true) {
			 if (state.cp == state.cpend || source[state.cp] == '|' || (state.parenNesting != 0 && source[state.cp] == ')')) {
				 if (headTerm == null) {
					 state.result = new RENode(REOP_EMPTY);
				 }
				 else state.result = headTerm;
				 return true;
			 }
			 if (!parseTerm(state)) return false;
			 if (headTerm == null) headTerm = state.result;
			 else {
				 if (tailTerm == null) {
					 headTerm.next = state.result;
					 tailTerm = state.result;
					 while (tailTerm.next != null) tailTerm = tailTerm.next;
				 }
				 else {
					 tailTerm.next = state.result;
					 tailTerm = tailTerm.next;
					 while (tailTerm.next != null) tailTerm = tailTerm.next;
				 }
			 }
		 }
	 }
	 private static boolean calculateBitmapSize(CompilerState state, RENode target, char[] src, int index, int end) {
		 char rangeStart = 0;
		 char c;
		 int n;
		 int nDigits;
		 int i;
		 int max = 0;
		 boolean inRange = false;
		 target.bmsize = 0;
		 if (index == end) return true;
		 if (src[index] == '^') ++index;
		 while (index != end) {
			 int localMax = 0;
			 nDigits = 2;
			 switch (src[index]) {
				 case '\\': ++index;
				 c = src[index++];
				 switch (c) {
					 case 'b': localMax = 0x8;
					 break;
					 case 'f': localMax = 0xC;
					 break;
					 case 'n': localMax = 0xA;
					 break;
					 case 'r': localMax = 0xD;
					 break;
					 case 't': localMax = 0x9;
					 break;
					 case 'v': localMax = 0xB;
					 break;
					 case 'c': if (((index + 1) < end) && Character.isLetter(src[index + 1])) localMax = (char)(src[index++] & 0x1F);
					 else localMax = '\\';
					 break;
					 case 'u': nDigits += 2;
					 case 'x': n = 0;
					 for (i = 0;
					 (i < nDigits) && (index < end);
					 i++) {
						 c = src[index++];
						 n = Kit.xDigitToInt(c, n);
						 if (n < 0) {
							 index -= (i + 1);
							 n = '\\';
							 break;
						 }
					 }
					 localMax = n;
					 break;
					 case 'd': if (inRange) {
						 reportError(""msg.bad.range"", """");
						 return false;
					 }
					 localMax = '9';
					 break;
					 case 'D': case 's': case 'S': case 'w': case 'W': if (inRange) {
						 reportError(""msg.bad.range"", """");
						 return false;
					 }
					 target.bmsize = 65535;
					 return true;
					 case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': n = (c - '0');
					 c = src[index];
					 if ('0' <= c && c <= '7') {
						 index++;
						 n = 8 * n + (c - '0');
						 c = src[index];
						 if ('0' <= c && c <= '7') {
							 index++;
							 i = 8 * n + (c - '0');
							 if (i <= 0377) n = i;
							 else index--;
						 }
					 }
					 localMax = n;
					 break;
					 default: localMax = c;
					 break;
				 }
				 break;
				 default: localMax = src[index++];
				 break;
			 }
			 if (inRange) {
				 if (rangeStart > localMax) {
					 reportError(""msg.bad.range"", """");
					 return false;
				 }
				 inRange = false;
			 }
			 else {
				 if (index < (end - 1)) {
					 if (src[index] == '-') {
						 ++index;
						 inRange = true;
						 rangeStart = (char)localMax;
						 continue;
					 }
				 }
			 }
			 if ((state.flags & JSREG_FOLD) != 0){
				 char cu = upcase((char)localMax);
				 char cd = downcase((char)localMax);
				 localMax = (cu >= cd) ? cu : cd;
			 }
			 if (localMax > max) max = localMax;
		 }
		 target.bmsize = max;
		 return true;
	 }
	 private static void doFlat(CompilerState state, char c) {
		 state.result = new RENode(REOP_FLAT);
		 state.result.chr = c;
		 state.result.length = 1;
		 state.result.flatIndex = -1;
		 state.progLength += 3;
	 }
	 private static int getDecimalValue(char c, CompilerState state, int maxValue, String overflowMessageId) {
		 boolean overflow = false;
		 int start = state.cp;
		 char[] src = state.cpbegin;
		 int value = c - '0';
		 for (;
		 state.cp != state.cpend;
		 ++state.cp) {
			 c = src[state.cp];
			 if (!isDigit(c)) {
				 break;
			 }
			 if (!overflow) {
				 int digit = c - '0';
				 if (value < (maxValue - digit) / 10) {
					 value = value * 10 + digit;
				 }
				 else {
					 overflow = true;
					 value = maxValue;
				 }
			 }
		 }
		 if (overflow) {
			 reportError(overflowMessageId, String.valueOf(src, start, state.cp - start));
		 }
		 return value;
	 }
	 private static boolean parseTerm(CompilerState state) {
		 char[] src = state.cpbegin;
		 char c = src[state.cp++];
		 int nDigits = 2;
		 int parenBaseCount = state.parenCount;
		 int num, tmp;
		 RENode term;
		 int termStart;
		 switch (c) {
			 case '^': state.result = new RENode(REOP_BOL);
			 state.progLength++;
			 return true;
			 case '$': state.result = new RENode(REOP_EOL);
			 state.progLength++;
			 return true;
			 case '\\': if (state.cp < state.cpend) {
				 c = src[state.cp++];
				 switch (c) {
					 case 'b' : state.result = new RENode(REOP_WBDRY);
					 state.progLength++;
					 return true;
					 case 'B': state.result = new RENode(REOP_WNONBDRY);
					 state.progLength++;
					 return true;
					 case '0': reportWarning(state.cx, ""msg.bad.backref"", """");
					 num = 0;
					 while (state.cp < state.cpend) {
						 c = src[state.cp];
						 if ((c >= '0') && (c <= '7')) {
							 state.cp++;
							 tmp = 8 * num + (c - '0');
							 if (tmp > 0377) break;
							 num = tmp;
						 }
						 else break;
					 }
					 c = (char)(num);
					 doFlat(state, c);
					 break;
					 case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': termStart = state.cp - 1;
					 num = getDecimalValue(c, state, 0xFFFF, ""msg.overlarge.backref"");
					 if (num > state.parenCount) reportWarning(state.cx, ""msg.bad.backref"", """");
					 if ((num > 9) && (num > state.parenCount)) {
						 state.cp = termStart;
						 num = 0;
						 while (state.cp < state.cpend) {
							 c = src[state.cp];
							 if ((c >= '0') && (c <= '7')) {
								 state.cp++;
								 tmp = 8 * num + (c - '0');
								 if (tmp > 0377) break;
								 num = tmp;
							 }
							 else break;
						 }
						 c = (char)(num);
						 doFlat(state, c);
						 break;
					 }
					 state.result = new RENode(REOP_BACKREF);
					 state.result.parenIndex = num - 1;
					 state.progLength += 3;
					 break;
					 case 'f': c = 0xC;
					 doFlat(state, c);
					 break;
					 case 'n': c = 0xA;
					 doFlat(state, c);
					 break;
					 case 'r': c = 0xD;
					 doFlat(state, c);
					 break;
					 case 't': c = 0x9;
					 doFlat(state, c);
					 break;
					 case 'v': c = 0xB;
					 doFlat(state, c);
					 break;
					 case 'c': if (((state.cp + 1) < state.cpend) && Character.isLetter(src[state.cp + 1])) c = (char)(src[state.cp++] & 0x1F);
					 else {
						 --state.cp;
						 c = '\\';
					 }
					 doFlat(state, c);
					 break;
					 case 'u': nDigits += 2;
					 case 'x': {
						 int n = 0;
						 int i;
						 for (i = 0;
						 (i < nDigits) && (state.cp < state.cpend);
						 i++) {
							 c = src[state.cp++];
							 n = Kit.xDigitToInt(c, n);
							 if (n < 0) {
								 state.cp -= (i + 2);
								 n = src[state.cp++];
								 break;
							 }
						 }
						 c = (char)(n);
					 }
					 doFlat(state, c);
					 break;
					 case 'd': state.result = new RENode(REOP_DIGIT);
					 state.progLength++;
					 break;
					 case 'D': state.result = new RENode(REOP_NONDIGIT);
					 state.progLength++;
					 break;
					 case 's': state.result = new RENode(REOP_SPACE);
					 state.progLength++;
					 break;
					 case 'S': state.result = new RENode(REOP_NONSPACE);
					 state.progLength++;
					 break;
					 case 'w': state.result = new RENode(REOP_ALNUM);
					 state.progLength++;
					 break;
					 case 'W': state.result = new RENode(REOP_NONALNUM);
					 state.progLength++;
					 break;
					 default: state.result = new RENode(REOP_FLAT);
					 state.result.chr = c;
					 state.result.length = 1;
					 state.result.flatIndex = state.cp - 1;
					 state.progLength += 3;
					 break;
				 }
				 break;
			 }
			 else {
				 reportError(""msg.trail.backslash"", """");
				 return false;
			 }
			 case '(': {
				 RENode result = null;
				 termStart = state.cp;
				 if (state.cp + 1 < state.cpend && src[state.cp] == '?' && ((c = src[state.cp + 1]) == '=' || c == '!' || c == ':')) {
					 state.cp += 2;
					 if (c == '=') {
						 result = new RENode(REOP_ASSERT);
						 state.progLength += 4;
					 }
					 else if (c == '!') {
						 result = new RENode(REOP_ASSERT_NOT);
						 state.progLength += 4;
					 }
				 }
				 else {
					 result = new RENode(REOP_LPAREN);
					 state.progLength += 6;
					 result.parenIndex = state.parenCount++;
				 }
				 ++state.parenNesting;
				 if (!parseDisjunction(state)) return false;
				 if (state.cp == state.cpend || src[state.cp] != ')') {
					 reportError(""msg.unterm.paren"", """");
					 return false;
				 }
				 ++state.cp;
				 --state.parenNesting;
				 if (result != null) {
					 result.kid = state.result;
					 state.result = result;
				 }
				 break;
			 }
			 case ')': reportError(""msg.re.unmatched.right.paren"", """");
			 return false;
			 case '[': state.result = new RENode(REOP_CLASS);
			 termStart = state.cp;
			 state.result.startIndex = termStart;
			 while (true) {
				 if (state.cp == state.cpend) {
					 reportError(""msg.unterm.class"", """");
					 return false;
				 }
				 if (src[state.cp] == '\\') state.cp++;
				 else {
					 if (src[state.cp] == ']') {
						 state.result.kidlen = state.cp - termStart;
						 break;
					 }
				 }
				 state.cp++;
			 }
			 state.result.index = state.classCount++;
			 if (!calculateBitmapSize(state, state.result, src, termStart, state.cp++)) return false;
			 state.progLength += 3;
			 break;
			 case '.': state.result = new RENode(REOP_DOT);
			 state.progLength++;
			 break;
			 case '*': case '+': case '?': reportError(""msg.bad.quant"", String.valueOf(src[state.cp - 1]));
			 return false;
			 default: state.result = new RENode(REOP_FLAT);
			 state.result.chr = c;
			 state.result.length = 1;
			 state.result.flatIndex = state.cp - 1;
			 state.progLength += 3;
			 break;
		 }
		 term = state.result;
		 if (state.cp == state.cpend) {
			 return true;
		 }
		 boolean hasQ = false;
		 switch (src[state.cp]) {
			 case '+': state.result = new RENode(REOP_QUANT);
			 state.result.min = 1;
			 state.result.max = -1;
			 state.progLength += 8;
			 hasQ = true;
			 break;
			 case '*': state.result = new RENode(REOP_QUANT);
			 state.result.min = 0;
			 state.result.max = -1;
			 state.progLength += 8;
			 hasQ = true;
			 break;
			 case '?': state.result = new RENode(REOP_QUANT);
			 state.result.min = 0;
			 state.result.max = 1;
			 state.progLength += 8;
			 hasQ = true;
			 break;
			 case '{
				': {
					 int min = 0;
					 int max = -1;
					 int leftCurl = state.cp;
					 c = src[++state.cp];
					 if (isDigit(c)) {
						 ++state.cp;
						 min = getDecimalValue(c, state, 0xFFFF, ""msg.overlarge.min"");
						 c = src[state.cp];
						 if (c == ',') {
							 c = src[++state.cp];
							 if (isDigit(c)) {
								 ++state.cp;
								 max = getDecimalValue(c, state, 0xFFFF, ""msg.overlarge.max"");
								 c = src[state.cp];
								 if (min > max) {
									 reportError(""msg.max.lt.min"", String.valueOf(src[state.cp]));
									 return false;
								 }
							 }
						 }
						 else {
							 max = min;
						 }
					 if (c == '}
					') {
						 state.result = new RENode(REOP_QUANT);
						 state.result.min = min;
						 state.result.max = max;
						 state.progLength += 12;
						 hasQ = true;
					 }
				 }
				 if (!hasQ) {
					 state.cp = leftCurl;
				 }
				 break;
			 }
		 }
		 if (!hasQ) return true;
		 ++state.cp;
		 state.result.kid = term;
		 state.result.parenIndex = parenBaseCount;
		 state.result.parenCount = state.parenCount - parenBaseCount;
		 if ((state.cp < state.cpend) && (src[state.cp] == '?')) {
			 ++state.cp;
			 state.result.greedy = false;
		 }
		 else state.result.greedy = true;
		 return true;
	 }
	 private static void resolveForwardJump(byte[] array, int from, int pc) {
		 if (from > pc) throw Kit.codeBug();
		 addIndex(array, from, pc - from);
	 }
	 private static int getOffset(byte[] array, int pc) {
		 return getIndex(array, pc);
	 }
	 private static int addIndex(byte[] array, int pc, int index) {
		 if (index < 0) throw Kit.codeBug();
		 if (index > 0xFFFF) throw Context.reportRuntimeError(""Too complex regexp"");
		 array[pc] = (byte)(index >> 8);
		 array[pc + 1] = (byte)(index);
		 return pc + 2;
	 }
	 private static int getIndex(byte[] array, int pc) {
		 return ((array[pc] & 0xFF) << 8) | (array[pc + 1] & 0xFF);
	 }
	 private static final int OFFSET_LEN = 2;
	 private static final int INDEX_LEN = 2;
	 private static int emitREBytecode(CompilerState state, RECompiled re, int pc, RENode t) {
		 RENode nextAlt;
		 int nextAltFixup, nextTermFixup;
		 byte[] program = re.program;
		 while (t != null) {
			 program[pc++] = t.op;
			 switch (t.op) {
				 case REOP_EMPTY: --pc;
				 break;
				 case REOP_ALT: nextAlt = t.kid2;
				 nextAltFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_JUMP;
				 nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 resolveForwardJump(program, nextAltFixup, pc);
				 pc = emitREBytecode(state, re, pc, nextAlt);
				 program[pc++] = REOP_JUMP;
				 nextAltFixup = pc;
				 pc += OFFSET_LEN;
				 resolveForwardJump(program, nextTermFixup, pc);
				 resolveForwardJump(program, nextAltFixup, pc);
				 break;
				 case REOP_FLAT: if (t.flatIndex != -1) {
					 while ((t.next != null) && (t.next.op == REOP_FLAT) && ((t.flatIndex + t.length) == t.next.flatIndex)) {
						 t.length += t.next.length;
						 t.next = t.next.next;
					 }
				 }
				 if ((t.flatIndex != -1) && (t.length > 1)) {
					 if ((state.flags & JSREG_FOLD) != 0) program[pc - 1] = REOP_FLATi;
					 else program[pc - 1] = REOP_FLAT;
					 pc = addIndex(program, pc, t.flatIndex);
					 pc = addIndex(program, pc, t.length);
				 }
				 else {
					 if (t.chr < 256) {
						 if ((state.flags & JSREG_FOLD) != 0) program[pc - 1] = REOP_FLAT1i;
						 else program[pc - 1] = REOP_FLAT1;
						 program[pc++] = (byte)(t.chr);
					 }
					 else {
						 if ((state.flags & JSREG_FOLD) != 0) program[pc - 1] = REOP_UCFLAT1i;
						 else program[pc - 1] = REOP_UCFLAT1;
						 pc = addIndex(program, pc, t.chr);
					 }
				 }
				 break;
				 case REOP_LPAREN: pc = addIndex(program, pc, t.parenIndex);
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_RPAREN;
				 pc = addIndex(program, pc, t.parenIndex);
				 break;
				 case REOP_BACKREF: pc = addIndex(program, pc, t.parenIndex);
				 break;
				 case REOP_ASSERT: nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_ASSERTTEST;
				 resolveForwardJump(program, nextTermFixup, pc);
				 break;
				 case REOP_ASSERT_NOT: nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_ASSERTNOTTEST;
				 resolveForwardJump(program, nextTermFixup, pc);
				 break;
				 case REOP_QUANT: if ((t.min == 0) && (t.max == -1)) program[pc - 1] = (t.greedy) ? REOP_STAR : REOP_MINIMALSTAR;
				 else if ((t.min == 0) && (t.max == 1)) program[pc - 1] = (t.greedy) ? REOP_OPT : REOP_MINIMALOPT;
				 else if ((t.min == 1) && (t.max == -1)) program[pc - 1] = (t.greedy) ? REOP_PLUS : REOP_MINIMALPLUS;
				 else {
					 if (!t.greedy) program[pc - 1] = REOP_MINIMALQUANT;
					 pc = addIndex(program, pc, t.min);
					 pc = addIndex(program, pc, t.max + 1);
				 }
				 pc = addIndex(program, pc, t.parenCount);
				 pc = addIndex(program, pc, t.parenIndex);
				 nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_ENDCHILD;
				 resolveForwardJump(program, nextTermFixup, pc);
				 break;
				 case REOP_CLASS: pc = addIndex(program, pc, t.index);
				 re.classList[t.index] = new RECharSet(t.bmsize, t.startIndex, t.kidlen);
				 break;
				 default: break;
			 }
			 t = t.next;
		 }
		 return pc;
	 }
	 private static void pushProgState(REGlobalData gData, int min, int max, REBackTrackData backTrackLastToSave, int continuation_pc, int continuation_op) {
		 gData.stateStackTop = new REProgState(gData.stateStackTop, min, max, gData.cp, backTrackLastToSave, continuation_pc, continuation_op);
	 }
	 private static REProgState popProgState(REGlobalData gData) {
		 REProgState state = gData.stateStackTop;
		 gData.stateStackTop = state.previous;
		 return state;
	 }
	 private static void pushBackTrackState(REGlobalData gData, byte op, int target) {
		 gData.backTrackStackTop = new REBackTrackData(gData, op, target);
	 }
	 private static boolean flatNMatcher(REGlobalData gData, int matchChars, int length, char[] chars, int end) {
		 if ((gData.cp + length) > end) return false;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (gData.regexp.source[matchChars + i] != chars[gData.cp + i]) {
				 return false;
			 }
		 }
		 gData.cp += length;
		 return true;
	 }
	 private static boolean flatNIMatcher(REGlobalData gData, int matchChars, int length, char[] chars, int end) {
		 if ((gData.cp + length) > end) return false;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (upcase(gData.regexp.source[matchChars + i]) != upcase(chars[gData.cp + i])) {
				 return false;
			 }
		 }
		 gData.cp += length;
		 return true;
	 }
	 private static boolean backrefMatcher(REGlobalData gData, int parenIndex, char[] chars, int end) {
		 int len;
		 int i;
		 int parenContent = gData.parens_index(parenIndex);
		 if (parenContent == -1) return true;
		 len = gData.parens_length(parenIndex);
		 if ((gData.cp + len) > end) return false;
		 if ((gData.regexp.flags & JSREG_FOLD) != 0) {
			 for (i = 0;
			 i < len;
			 i++) {
				 if (upcase(chars[parenContent + i]) != upcase(chars[gData.cp + i])) return false;
			 }
		 }
		 else {
			 for (i = 0;
			 i < len;
			 i++) {
				 if (chars[parenContent + i] != chars[gData.cp + i]) return false;
			 }
		 }
		 gData.cp += len;
		 return true;
	 }
	 private static void addCharacterToCharSet(RECharSet cs, char c) {
		 int byteIndex = (c / 8);
		 if (c > cs.length) throw new RuntimeException();
		 cs.bits[byteIndex] |= 1 << (c & 0x7);
	 }
	 private static void addCharacterRangeToCharSet(RECharSet cs, char c1, char c2) {
		 int i;
		 int byteIndex1 = (c1 / 8);
		 int byteIndex2 = (c2 / 8);
		 if ((c2 > cs.length) || (c1 > c2)) throw new RuntimeException();
		 c1 &= 0x7;
		 c2 &= 0x7;
		 if (byteIndex1 == byteIndex2) {
			 cs.bits[byteIndex1] |= ((0xFF) >> (7 - (c2 - c1))) << c1;
		 }
		 else {
			 cs.bits[byteIndex1] |= 0xFF << c1;
			 for (i = byteIndex1 + 1;
			 i < byteIndex2;
			 i++) cs.bits[i] = (byte)0xFF;
			 cs.bits[byteIndex2] |= (0xFF) >> (7 - c2);
		 }
	 }
	 private static void processCharSet(REGlobalData gData, RECharSet charSet) {
		 synchronized (charSet) {
			 if (!charSet.converted) {
				 processCharSetImpl(gData, charSet);
				 charSet.converted = true;
			 }
		 }
	 }
	 private static void processCharSetImpl(REGlobalData gData, RECharSet charSet) {
		 int src = charSet.startIndex;
		 int end = src + charSet.strlength;
		 char rangeStart = 0, thisCh;
		 int byteLength;
		 char c;
		 int n;
		 int nDigits;
		 int i;
		 boolean inRange = false;
		 charSet.sense = true;
		 byteLength = (charSet.length / 8) + 1;
		 charSet.bits = new byte[byteLength];
		 if (src == end) return;
		 if (gData.regexp.source[src] == '^') {
			 charSet.sense = false;
			 ++src;
		 }
		 while (src != end) {
			 nDigits = 2;
			 switch (gData.regexp.source[src]) {
				 case '\\': ++src;
				 c = gData.regexp.source[src++];
				 switch (c) {
					 case 'b': thisCh = 0x8;
					 break;
					 case 'f': thisCh = 0xC;
					 break;
					 case 'n': thisCh = 0xA;
					 break;
					 case 'r': thisCh = 0xD;
					 break;
					 case 't': thisCh = 0x9;
					 break;
					 case 'v': thisCh = 0xB;
					 break;
					 case 'c': if (((src + 1) < end) && isWord(gData.regexp.source[src + 1])) thisCh = (char)(gData.regexp.source[src++] & 0x1F);
					 else {
						 --src;
						 thisCh = '\\';
					 }
					 break;
					 case 'u': nDigits += 2;
					 case 'x': n = 0;
					 for (i = 0;
					 (i < nDigits) && (src < end);
					 i++) {
						 c = gData.regexp.source[src++];
						 int digit = toASCIIHexDigit(c);
						 if (digit < 0) {
							 src -= (i + 1);
							 n = '\\';
							 break;
						 }
						 n = (n << 4) | digit;
					 }
					 thisCh = (char)(n);
					 break;
					 case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': n = (c - '0');
					 c = gData.regexp.source[src];
					 if ('0' <= c && c <= '7') {
						 src++;
						 n = 8 * n + (c - '0');
						 c = gData.regexp.source[src];
						 if ('0' <= c && c <= '7') {
							 src++;
							 i = 8 * n + (c - '0');
							 if (i <= 0377) n = i;
							 else src--;
						 }
					 }
					 thisCh = (char)(n);
					 break;
					 case 'd': addCharacterRangeToCharSet(charSet, '0', '9');
					 continue;
					 case 'D': addCharacterRangeToCharSet(charSet, (char)0, (char)('0' - 1));
					 addCharacterRangeToCharSet(charSet, (char)('9' + 1), (char)(charSet.length));
					 continue;
					 case 's': for (i = charSet.length;
					 i >= 0;
					 i--) if (isREWhiteSpace(i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 case 'S': for (i = charSet.length;
					 i >= 0;
					 i--) if (!isREWhiteSpace(i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 case 'w': for (i = charSet.length;
					 i >= 0;
					 i--) if (isWord((char)i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 case 'W': for (i = charSet.length;
					 i >= 0;
					 i--) if (!isWord((char)i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 default: thisCh = c;
					 break;
				 }
				 break;
				 default: thisCh = gData.regexp.source[src++];
				 break;
			 }
			 if (inRange) {
				 if ((gData.regexp.flags & JSREG_FOLD) != 0) {
					 addCharacterRangeToCharSet(charSet, upcase(rangeStart), upcase(thisCh));
					 addCharacterRangeToCharSet(charSet, downcase(rangeStart), downcase(thisCh));
				 }
				 else {
					 addCharacterRangeToCharSet(charSet, rangeStart, thisCh);
				 }
				 inRange = false;
			 }
			 else {
				 if ((gData.regexp.flags & JSREG_FOLD) != 0) {
					 addCharacterToCharSet(charSet, upcase(thisCh));
					 addCharacterToCharSet(charSet, downcase(thisCh));
				 }
				 else {
					 addCharacterToCharSet(charSet, thisCh);
				 }
				 if (src < (end - 1)) {
					 if (gData.regexp.source[src] == '-') {
						 ++src;
						 inRange = true;
						 rangeStart = thisCh;
					 }
				 }
			 }
		 }
	 }
	 private static boolean classMatcher(REGlobalData gData, RECharSet charSet, char ch) {
		 if (!charSet.converted) {
			 processCharSet(gData, charSet);
		 }
		 int byteIndex = ch / 8;
		 if (charSet.sense) {
			 if ((charSet.length == 0) || ( (ch > charSet.length) || ((charSet.bits[byteIndex] & (1 << (ch & 0x7))) == 0) )) return false;
		 }
		 else {
			 if (! ((charSet.length == 0) || ( (ch > charSet.length) || ((charSet.bits[byteIndex] & (1 << (ch & 0x7))) == 0) ))) return false;
		 }
		 return true;
	 }
	 private static boolean executeREBytecode(REGlobalData gData, char[] chars, int end) {
		 int pc = 0;
		 byte program[] = gData.regexp.program;
		 int currentContinuation_op;
		 int currentContinuation_pc;
		 boolean result = false;
		 currentContinuation_pc = 0;
		 currentContinuation_op = REOP_END;
		if (debug) {
			System.out.println(""Input = \"""" + new String(chars) + ""\"", start at "" + gData.cp);
		}
		 int op = program[pc++];
		 for (;
		;
		) {
			if (debug) {
				System.out.println(""Testing at "" + gData.cp + "", op = "" + op);
			}
			 switch (op) {
				 case REOP_EMPTY: result = true;
				 break;
				 case REOP_BOL: if (gData.cp != 0) {
					 if (gData.multiline || ((gData.regexp.flags & JSREG_MULTILINE) != 0)) {
						 if (!isLineTerm(chars[gData.cp - 1])) {
							 result = false;
							 break;
						 }
					 }
					 else {
						 result = false;
						 break;
					 }
				 }
				 result = true;
				 break;
				 case REOP_EOL: if (gData.cp != end) {
					 if (gData.multiline || ((gData.regexp.flags & JSREG_MULTILINE) != 0)) {
						 if (!isLineTerm(chars[gData.cp])) {
							 result = false;
							 break;
						 }
					 }
					 else {
						 result = false;
						 break;
					 }
				 }
				 result = true;
				 break;
				 case REOP_WBDRY: result = ((gData.cp == 0 || !isWord(chars[gData.cp - 1])) ^ !((gData.cp < end) && isWord(chars[gData.cp])));
				 break;
				 case REOP_WNONBDRY: result = ((gData.cp == 0 || !isWord(chars[gData.cp - 1])) ^ ((gData.cp < end) && isWord(chars[gData.cp])));
				 break;
				 case REOP_DOT: result = (gData.cp != end && !isLineTerm(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_DIGIT: result = (gData.cp != end && isDigit(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_NONDIGIT: result = (gData.cp != end && !isDigit(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_SPACE: result = (gData.cp != end && isREWhiteSpace(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_NONSPACE: result = (gData.cp != end && !isREWhiteSpace(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_ALNUM: result = (gData.cp != end && isWord(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_NONALNUM: result = (gData.cp != end && !isWord(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_FLAT: {
					 int offset = getIndex(program, pc);
					 pc += INDEX_LEN;
					 int length = getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = flatNMatcher(gData, offset, length, chars, end);
				 }
				 break;
				 case REOP_FLATi: {
					 int offset = getIndex(program, pc);
					 pc += INDEX_LEN;
					 int length = getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = flatNIMatcher(gData, offset, length, chars, end);
				 }
				 break;
				 case REOP_FLAT1: {
					 char matchCh = (char)(program[pc++] & 0xFF);
					 result = (gData.cp != end && chars[gData.cp] == matchCh);
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_FLAT1i: {
					 char matchCh = (char)(program[pc++] & 0xFF);
					 result = (gData.cp != end && upcase(chars[gData.cp]) == upcase(matchCh));
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_UCFLAT1: {
					 char matchCh = (char)getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = (gData.cp != end && chars[gData.cp] == matchCh);
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_UCFLAT1i: {
					 char matchCh = (char)getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = (gData.cp != end && upcase(chars[gData.cp]) == upcase(matchCh));
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_ALT: {
					 int nextpc;
					 byte nextop;
					 pushProgState(gData, 0, 0, null, currentContinuation_pc, currentContinuation_op);
					 nextpc = pc + getOffset(program, pc);
					 nextop = program[nextpc++];
					 pushBackTrackState(gData, nextop, nextpc);
					 pc += INDEX_LEN;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_JUMP: {
					 int offset;
					 REProgState state = popProgState(gData);
					 currentContinuation_pc = state.continuation_pc;
					 currentContinuation_op = state.continuation_op;
					 offset = getOffset(program, pc);
					 pc += offset;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_LPAREN: {
					 int parenIndex = getIndex(program, pc);
					 pc += INDEX_LEN;
					 gData.set_parens(parenIndex, gData.cp, 0);
					 op = program[pc++];
				 }
				 continue;
				 case REOP_RPAREN: {
					 int cap_index;
					 int parenIndex = getIndex(program, pc);
					 pc += INDEX_LEN;
					 cap_index = gData.parens_index(parenIndex);
					 gData.set_parens(parenIndex, cap_index, gData.cp - cap_index);
					 if (parenIndex > gData.lastParen) gData.lastParen = parenIndex;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_BACKREF: {
					 int parenIndex = getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = backrefMatcher(gData, parenIndex, chars, end);
				 }
				 break;
				 case REOP_CLASS: {
					 int index = getIndex(program, pc);
					 pc += INDEX_LEN;
					 if (gData.cp != end) {
						 if (classMatcher(gData, gData.regexp.classList[index], chars[gData.cp])) {
							 gData.cp++;
							 result = true;
							 break;
						 }
					 }
					 result = false;
				 }
				 break;
				 case REOP_ASSERT: case REOP_ASSERT_NOT: {
					 byte testOp;
					 pushProgState(gData, 0, 0, gData.backTrackStackTop, currentContinuation_pc, currentContinuation_op);
					 if (op == REOP_ASSERT) {
						 testOp = REOP_ASSERTTEST;
					 }
					 else {
						 testOp = REOP_ASSERTNOTTEST;
					 }
					 pushBackTrackState(gData, testOp, pc + getOffset(program, pc));
					 pc += INDEX_LEN;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_ASSERTTEST: case REOP_ASSERTNOTTEST: {
					 REProgState state = popProgState(gData);
					 gData.cp = state.index;
					 gData.backTrackStackTop = state.backTrack;
					 currentContinuation_pc = state.continuation_pc;
					 currentContinuation_op = state.continuation_op;
					 if (result) {
						 if (op == REOP_ASSERTTEST) {
							 result = true;
						 }
						 else {
							 result = false;
						 }
					 }
					 else {
						 if (op == REOP_ASSERTTEST) {
						 }
						 else {
							 result = true;
						 }
					 }
				 }
				 break;
				 case REOP_STAR: case REOP_PLUS: case REOP_OPT: case REOP_QUANT: case REOP_MINIMALSTAR: case REOP_MINIMALPLUS: case REOP_MINIMALOPT: case REOP_MINIMALQUANT: {
					 int min, max;
					 boolean greedy = false;
					 switch (op) {
						 case REOP_STAR: greedy = true;
						 case REOP_MINIMALSTAR: min = 0;
						 max = -1;
						 break;
						 case REOP_PLUS: greedy = true;
						 case REOP_MINIMALPLUS: min = 1;
						 max = -1;
						 break;
						 case REOP_OPT: greedy = true;
						 case REOP_MINIMALOPT: min = 0;
						 max = 1;
						 break;
						 case REOP_QUANT: greedy = true;
						 case REOP_MINIMALQUANT: min = getOffset(program, pc);
						 pc += INDEX_LEN;
						 max = getOffset(program, pc) - 1;
						 pc += INDEX_LEN;
						 break;
						 default: throw Kit.codeBug();
					 }
					 pushProgState(gData, min, max, null, currentContinuation_pc, currentContinuation_op);
					 if (greedy) {
						 currentContinuation_op = REOP_REPEAT;
						 currentContinuation_pc = pc;
						 pushBackTrackState(gData, REOP_REPEAT, pc);
						 pc += 3 * INDEX_LEN;
						 op = program[pc++];
					 }
					 else {
						 if (min != 0) {
							 currentContinuation_op = REOP_MINIMALREPEAT;
							 currentContinuation_pc = pc;
							 pc += 3 * INDEX_LEN;
							 op = program[pc++];
						 }
						 else {
							 pushBackTrackState(gData, REOP_MINIMALREPEAT, pc);
							 popProgState(gData);
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 op = program[pc++];
						 }
					 }
				 }
				 continue;
				 case REOP_ENDCHILD: pc = currentContinuation_pc;
				 op = currentContinuation_op;
				 continue;
				 case REOP_REPEAT: {
					 REProgState state = popProgState(gData);
					 if (!result) {
						 if (state.min == 0) result = true;
						 currentContinuation_pc = state.continuation_pc;
						 currentContinuation_op = state.continuation_op;
						 pc += 2 * INDEX_LEN;
						 pc = pc + getOffset(program, pc);
						 break;
					 }
					 else {
						 if (state.min == 0 && gData.cp == state.index) {
							 result = false;
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 break;
						 }
						 int new_min = state.min, new_max = state.max;
						 if (new_min != 0) new_min--;
						 if (new_max != -1) new_max--;
						 if (new_max == 0) {
							 result = true;
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 break;
						 }
						 pushProgState(gData, new_min, new_max, null, state.continuation_pc, state.continuation_op);
						 currentContinuation_op = REOP_REPEAT;
						 currentContinuation_pc = pc;
						 pushBackTrackState(gData, REOP_REPEAT, pc);
						 int parenCount = getIndex(program, pc);
						 pc += INDEX_LEN;
						 int parenIndex = getIndex(program, pc);
						 pc += 2 * INDEX_LEN;
						 op = program[pc++];
						 for (int k = 0;
						 k < parenCount;
						 k++) {
							 gData.set_parens(parenIndex + k, -1, 0);
						 }
					 }
				 }
				 continue;
				 case REOP_MINIMALREPEAT: {
					 REProgState state = popProgState(gData);
					 if (!result) {
						 if (state.max == -1 || state.max > 0) {
							 pushProgState(gData, state.min, state.max, null, state.continuation_pc, state.continuation_op);
							 currentContinuation_op = REOP_MINIMALREPEAT;
							 currentContinuation_pc = pc;
							 int parenCount = getIndex(program, pc);
							 pc += INDEX_LEN;
							 int parenIndex = getIndex(program, pc);
							 pc += 2 * INDEX_LEN;
							 for (int k = 0;
							 k < parenCount;
							 k++) {
								 gData.set_parens(parenIndex + k, -1, 0);
							 }
							 op = program[pc++];
							 continue;
						 }
						 else {
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 break;
						 }
					 }
					 else {
						 if (state.min == 0 && gData.cp == state.index) {
							 result = false;
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 break;
						 }
						 int new_min = state.min, new_max = state.max;
						 if (new_min != 0) new_min--;
						 if (new_max != -1) new_max--;
						 pushProgState(gData, new_min, new_max, null, state.continuation_pc, state.continuation_op);
						 if (new_min != 0) {
							 currentContinuation_op = REOP_MINIMALREPEAT;
							 currentContinuation_pc = pc;
							 int parenCount = getIndex(program, pc);
							 pc += INDEX_LEN;
							 int parenIndex = getIndex(program, pc);
							 pc += 2 * INDEX_LEN;
							 for (int k = 0;
							 k < parenCount;
							 k++) {
								 gData.set_parens(parenIndex + k, -1, 0);
							 }
							 op = program[pc++];
						 }
						 else {
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 pushBackTrackState(gData, REOP_MINIMALREPEAT, pc);
							 popProgState(gData);
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 op = program[pc++];
						 }
						 continue;
					 }
				 }
				 case REOP_END: return true;
				 default: throw Kit.codeBug();
			 }
			 if (!result) {
				 REBackTrackData backTrackData = gData.backTrackStackTop;
				 if (backTrackData != null) {
					 gData.backTrackStackTop = backTrackData.previous;
					 gData.lastParen = backTrackData.lastParen;
					 if (backTrackData.parens != null) {
						 gData.parens = (long[])backTrackData.parens.clone();
					 }
					 gData.cp = backTrackData.cp;
					 gData.stateStackTop = backTrackData.stateStackTop;
					 currentContinuation_op = gData.stateStackTop.continuation_op;
					 currentContinuation_pc = gData.stateStackTop.continuation_pc;
					 pc = backTrackData.continuation_pc;
					 op = backTrackData.continuation_op;
					 continue;
				 }
				 else return false;
			 }
			 op = program[pc++];
		 }
	 }
	 private static boolean matchRegExp(REGlobalData gData, RECompiled re, char[] chars, int start, int end, boolean multiline) {
		 if (re.parenCount != 0) {
			 gData.parens = new long[re.parenCount];
		 }
		 else {
			 gData.parens = null;
		 }
		 gData.backTrackStackTop = null;
		 gData.stateStackTop = null;
		 gData.multiline = multiline;
		 gData.regexp = re;
		 gData.lastParen = 0;
		 int anchorCh = gData.regexp.anchorCh;
		 for (int i = start;
		 i <= end;
		 ++i) {
			 if (anchorCh >= 0) {
				 for (;
				;
				) {
					 if (i == end) {
						 return false;
					 }
					 char matchCh = chars[i];
					 if (matchCh == anchorCh || ((gData.regexp.flags & JSREG_FOLD) != 0 && upcase(matchCh) == upcase((char)anchorCh))) {
						 break;
					 }
					 ++i;
				 }
			 }
			 gData.cp = i;
			 for (int j = 0;
			 j < re.parenCount;
			 j++) {
				 gData.set_parens(j, -1, 0);
			 }
			 boolean result = executeREBytecode(gData, chars, end);
			 gData.backTrackStackTop = null;
			 gData.stateStackTop = null;
			 if (result) {
				 gData.skipped = i - start;
				 return true;
			 }
		 }
		 return false;
	 }
	 Object executeRegExp(Context cx, Scriptable scopeObj, RegExpImpl res, String str, int indexp[], int matchType) {
		 REGlobalData gData = new REGlobalData();
		 int start = indexp[0];
		 char[] charArray = str.toCharArray();
		 int end = charArray.length;
		 if (start > end) start = end;
		 boolean matches = matchRegExp(gData, re, charArray, start, end, res.multiline);
		 if (!matches) {
			 if (matchType != PREFIX) return null;
			 return Undefined.instance;
		 }
		 int index = gData.cp;
		 int i = index;
		 indexp[0] = i;
		 int matchlen = i - (start + gData.skipped);
		 int ep = index;
		 index -= matchlen;
		 Object result;
		 Scriptable obj;
		 if (matchType == TEST) {
			 result = Boolean.TRUE;
			 obj = null;
		 }
		 else {
			 Scriptable scope = getTopLevelScope(scopeObj);
			 result = ScriptRuntime.newObject(cx, scope, ""Array"", null);
			 obj = (Scriptable) result;
			 String matchstr = new String(charArray, index, matchlen);
			 obj.put(0, obj, matchstr);
		 }
		 if (re.parenCount == 0) {
			 res.parens = null;
			 res.lastParen = SubString.emptySubString;
		 }
		 else {
			 SubString parsub = null;
			 int num;
			 res.parens = new SubString[re.parenCount];
			 for (num = 0;
			 num < re.parenCount;
			 num++) {
				 int cap_index = gData.parens_index(num);
				 String parstr;
				 if (cap_index != -1) {
					 int cap_length = gData.parens_length(num);
					 parsub = new SubString(charArray, cap_index, cap_length);
					 res.parens[num] = parsub;
					 if (matchType == TEST) continue;
					 parstr = parsub.toString();
					 obj.put(num+1, obj, parstr);
				 }
				 else {
					 if (matchType != TEST) obj.put(num+1, obj, Undefined.instance);
				 }
			 }
			 res.lastParen = parsub;
		 }
		 if (! (matchType == TEST)) {
			 obj.put(""index"", obj, new Integer(start + gData.skipped));
			 obj.put(""input"", obj, str);
		 }
		 if (res.lastMatch == null) {
			 res.lastMatch = new SubString();
			 res.leftContext = new SubString();
			 res.rightContext = new SubString();
		 }
		 res.lastMatch.charArray = charArray;
		 res.lastMatch.index = index;
		 res.lastMatch.length = matchlen;
		 res.leftContext.charArray = charArray;
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) {
			 res.leftContext.index = start;
			 res.leftContext.length = gData.skipped;
		 }
		 else {
			 res.leftContext.index = 0;
			 res.leftContext.length = start + gData.skipped;
		 }
		 res.rightContext.charArray = charArray;
		 res.rightContext.index = ep;
		 res.rightContext.length = end - ep;
		 return result;
	 }
	 int getFlags() {
		 return re.flags;
	 }
	 private static void reportWarning(Context cx, String messageId, String arg) {
		 if (cx.hasFeature(Context.FEATURE_STRICT_MODE)) {
			 String msg = ScriptRuntime.getMessage1(messageId, arg);
			 Context.reportWarning(msg);
		 }
	 }
	 private static void reportError(String messageId, String arg) {
		 String msg = ScriptRuntime.getMessage1(messageId, arg);
		 throw ScriptRuntime.constructError(""SyntaxError"", msg);
	 }
	 private static final int Id_lastIndex = 1, Id_source = 2, Id_global = 3, Id_ignoreCase = 4, Id_multiline = 5, MAX_INSTANCE_ID = 5;
	 protected int getMaxInstanceId() {
		 return MAX_INSTANCE_ID;
	 }
	 protected int findInstanceIdInfo(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 int s_length = s.length();
			 if (s_length==6) {
				 c=s.charAt(0);
				 if (c=='g') {
					 X=""global"";
					id=Id_global;
				 }
				 else if (c=='s') {
					 X=""source"";
					id=Id_source;
				 }
			 }
			 else if (s_length==9) {
				 c=s.charAt(0);
				 if (c=='l') {
					 X=""lastIndex"";
					id=Id_lastIndex;
				 }
				 else if (c=='m') {
					 X=""multiline"";
					id=Id_multiline;
				 }
			 }
			 else if (s_length==10) {
				 X=""ignoreCase"";
				id=Id_ignoreCase;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
			 break L0;
		 }
		 if (id == 0) return super.findInstanceIdInfo(s);
		 int attr;
		 switch (id) {
			 case Id_lastIndex: attr = PERMANENT | DONTENUM;
			 break;
			 case Id_source: case Id_global: case Id_ignoreCase: case Id_multiline: attr = PERMANENT | READONLY | DONTENUM;
			 break;
			 default: throw new IllegalStateException();
		 }
		 return instanceIdInfo(attr, id);
	 }
	 protected String getInstanceIdName(int id) {
		 switch (id) {
			 case Id_lastIndex: return ""lastIndex"";
			 case Id_source: return ""source"";
			 case Id_global: return ""global"";
			 case Id_ignoreCase: return ""ignoreCase"";
			 case Id_multiline: return ""multiline"";
		 }
		 return super.getInstanceIdName(id);
	 }
	 protected Object getInstanceIdValue(int id) {
		 switch (id) {
			 case Id_lastIndex: return ScriptRuntime.wrapNumber(lastIndex);
			 case Id_source: return new String(re.source);
			 case Id_global: return ScriptRuntime.wrapBoolean((re.flags & JSREG_GLOB) != 0);
			 case Id_ignoreCase: return ScriptRuntime.wrapBoolean((re.flags & JSREG_FOLD) != 0);
			 case Id_multiline: return ScriptRuntime.wrapBoolean((re.flags & JSREG_MULTILINE) != 0);
		 }
		 return super.getInstanceIdValue(id);
	 }
	 protected void setInstanceIdValue(int id, Object value) {
		 if (id == Id_lastIndex) {
			 lastIndex = ScriptRuntime.toNumber(value);
			 return;
		 }
		 super.setInstanceIdValue(id, value);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_compile: arity=1;
			 s=""compile"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_exec: arity=1;
			 s=""exec"";
			 break;
			 case Id_test: arity=1;
			 s=""test"";
			 break;
			 case Id_prefix: arity=1;
			 s=""prefix"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(REGEXP_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(REGEXP_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case Id_compile: return realThis(thisObj, f).compile(cx, scope, args);
			 case Id_toString: case Id_toSource: return realThis(thisObj, f).toString();
			 case Id_exec: return realThis(thisObj, f).execSub(cx, scope, args, MATCH);
			 case Id_test: {
				 Object x = realThis(thisObj, f).execSub(cx, scope, args, TEST);
				 return Boolean.TRUE.equals(x) ? Boolean.TRUE : Boolean.FALSE;
			 }
			 case Id_prefix: return realThis(thisObj, f).execSub(cx, scope, args, PREFIX);
		 }
		 throw new IllegalArgumentException(String.valueOf(id));
	 }
	 private static NativeRegExp realThis(Scriptable thisObj, IdFunctionObject f) {
		 if (!(thisObj instanceof NativeRegExp)) throw incompatibleCallError(f);
		 return (NativeRegExp)thisObj;
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 4: c=s.charAt(0);
				 if (c=='e') {
					 X=""exec"";
					id=Id_exec;
				 }
				 else if (c=='t') {
					 X=""test"";
					id=Id_test;
				 }
				 break L;
				 case 6: X=""prefix"";
				id=Id_prefix;
				 break L;
				 case 7: X=""compile"";
				id=Id_compile;
				 break L;
				 case 8: c=s.charAt(3);
				 if (c=='o') {
					 X=""toSource"";
					id=Id_toSource;
				 }
				 else if (c=='t') {
					 X=""toString"";
					id=Id_toString;
				 }
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
			 break L0;
		 }
		 return id;
	 }
	 private static final int Id_compile = 1, Id_toString = 2, Id_toSource = 3, Id_exec = 4, Id_test = 5, Id_prefix = 6, MAX_PROTOTYPE_ID = 6;
	 private RECompiled re;
	 double lastIndex;
 }
;
 class RECompiled implements Serializable{
	 static final long serialVersionUID = -6144956577595844213L;
	 char []source;
	 int parenCount;
	 int flags;
	 byte[] program;
	 int classCount;
	 RECharSet[] classList;
	 int anchorCh = -1;
 }
class RENode {
	 RENode(byte op) {
		 this.op = op;
	 }
	 byte op;
	 RENode next;
	 RENode kid;
	 RENode kid2;
	 int num;
	 int parenIndex;
	 int min;
	 int max;
	 int parenCount;
	 boolean greedy;
	 int startIndex;
	 int kidlen;
	 int bmsize;
	 int index;
	 char chr;
	 int length;
	 int flatIndex;
 }
class CompilerState {
	 CompilerState(Context cx, char[] source, int length, int flags) {
		 this.cx = cx;
		 this.cpbegin = source;
		 this.cp = 0;
		 this.cpend = length;
		 this.flags = flags;
		 this.parenCount = 0;
		 this.classCount = 0;
		 this.progLength = 0;
	 }
	 Context cx;
	 char cpbegin[];
	 int cpend;
	 int cp;
	 int flags;
	 int parenCount;
	 int parenNesting;
	 int classCount;
	 int progLength;
	 RENode result;
}
class REProgState{
	 REProgState(REProgState previous, int min, int max, int index, REBackTrackData backTrack, int continuation_pc, int continuation_op) {
		 this.previous = previous;
		 this.min = min;
		 this.max = max;
		 this.index = index;
		 this.continuation_op = continuation_op;
		 this.continuation_pc = continuation_pc;
		 this.backTrack = backTrack;
	 }
	 REProgState previous;
	 int min;
	 int max;
	 int index;
	 int continuation_op;
	 int continuation_pc;
	 REBackTrackData backTrack;
 }
class REBackTrackData {
	 REBackTrackData(REGlobalData gData, int op, int pc) {
		 previous = gData.backTrackStackTop;
		 continuation_op = op;
		 continuation_pc = pc;
		 lastParen = gData.lastParen;
		 if (gData.parens != null) {
			 parens = (long[])gData.parens.clone();
		 }
		 cp = gData.cp;
		 stateStackTop = gData.stateStackTop;
	 }
	 REBackTrackData previous;
	 int continuation_op;
	 int continuation_pc;
	 int lastParen;
	 long[] parens;
	 int cp;
	 REProgState stateStackTop;
 }
class REGlobalData {
	 boolean multiline;
	 RECompiled regexp;
	 int lastParen;
	 int skipped;
	 int cp;
	 long[] parens;
	 REProgState stateStackTop;
	 REBackTrackData backTrackStackTop;
	 int parens_index(int i) {
		 return (int)(parens[i]);
	 }
	 int parens_length(int i) {
		 return (int)(parens[i] >>> 32);
	 }
	 void set_parens(int i, int index, int length) {
		 parens[i] = (index & 0xffffffffL) | ((long)length << 32);
	 }
}
final class RECharSet implements Serializable{
	 static final long serialVersionUID = 7931787979395898394L;
	 RECharSet(int length, int startIndex, int strlength) {
		 this.length = length;
		 this.startIndex = startIndex;
		 this.strlength = strlength;
	 }
	 int length;
	 int startIndex;
	 int strlength;
	 volatile transient boolean converted;
	 volatile transient boolean sense;
	 volatile transient byte[] bits;
}",1,0,0,0
"public class ExecutorTransfer {
	 private static final Logger LOG = LoggerFactory.getLogger(ExecutorTransfer.class);
	 private final WorkerState workerData;
	 private final KryoTupleSerializer serializer;
	 private final boolean isDebug;
	 private int indexingBase = 0;
	 private ArrayList<JCQueue> localReceiveQueues;
	 private AtomicReferenceArray<JCQueue> queuesToFlush;
	 public ExecutorTransfer(WorkerState workerData, Map<String, Object> topoConf) {
		 this.workerData = workerData;
		 this.serializer = new KryoTupleSerializer(topoConf, workerData.getWorkerTopologyContext());
		 this.isDebug = ObjectReader.getBoolean(topoConf.get(Config.TOPOLOGY_DEBUG), false);
	 }
	 public void initLocalRecvQueues() {
		 Integer minTaskId = workerData.getLocalReceiveQueues().keySet().stream().min(Integer::compareTo).get();
		 this.localReceiveQueues = Utils.convertToArray(workerData.getLocalReceiveQueues(), minTaskId);
		 this.indexingBase = minTaskId;
		 this.queuesToFlush = new AtomicReferenceArray<JCQueue>(localReceiveQueues.size());
	 }
	 public boolean tryTransfer(AddressedTuple addressedTuple, Queue<AddressedTuple> pendingEmits) {
		 if (isDebug) {
			 LOG.info(""TRANSFERRING tuple {
			}
			"", addressedTuple);
		 }
		 JCQueue localQueue = getLocalQueue(addressedTuple);
		 if (localQueue != null) {
			 return tryTransferLocal(addressedTuple, localQueue, pendingEmits);
		 }
		 return workerData.tryTransferRemote(addressedTuple, pendingEmits, serializer);
	 }
	 public void flush() throws InterruptedException {
		 flushLocal();
		 workerData.flushRemotes();
	 }
	 private void flushLocal() throws InterruptedException {
		 for (int i = 0;
		 i < queuesToFlush.length();
		 i++) {
			 JCQueue q = queuesToFlush.get(i);
			 if (q != null) {
				 q.flush();
				 queuesToFlush.set(i, null);
			 }
		 }
	 }
	 public JCQueue getLocalQueue(AddressedTuple tuple) {
		 if ((tuple.dest - indexingBase) >= localReceiveQueues.size()) {
			 return null;
		 }
		 return localReceiveQueues.get(tuple.dest - indexingBase);
	 }
	 public boolean tryTransferLocal(AddressedTuple tuple, JCQueue localQueue, Queue<AddressedTuple> pendingEmits) {
		 workerData.checkSerialize(serializer, tuple);
		 if (pendingEmits != null) {
			 if (pendingEmits.isEmpty() && localQueue.tryPublish(tuple)) {
				 queuesToFlush.set(tuple.dest - indexingBase, localQueue);
				 return true;
			 }
			 else {
				 pendingEmits.add(tuple);
				 return false;
			 }
		 }
		 else {
			 return localQueue.tryPublish(tuple);
		 }
	 }
}",1,0,0,0
"protected void tarResource(Resource r, TarOutputStream tOut, String vPath, TarFileSet tarFileSet) throws IOException {
	 if (!r.isExists()) {
		 return;
	 }
	 if (tarFileSet != null) {
		 String fullpath = tarFileSet.getFullpath(this.getProject());
		 if (fullpath.length() > 0) {
			 vPath = fullpath;
		 }
		 else {
			 if (vPath.length() <= 0) {
				 return;
			 }
			 String prefix = tarFileSet.getPrefix(this.getProject());
			 if (prefix.length() > 0 && !prefix.endsWith(""/"")) {
				 prefix = prefix + ""/"";
			 }
			 vPath = prefix + vPath;
		 }
		 if (vPath.startsWith(""/"") && !tarFileSet.getPreserveLeadingSlashes()) {
			 int l = vPath.length();
			 if (l <= 1) {
				 return;
			 }
			 vPath = vPath.substring(1, l);
		 }
	 }
	 if (r.isDirectory() && !vPath.endsWith(""/"")) {
		 vPath += ""/"";
	 }
	 if (vPath.length() >= TarConstants.NAMELEN) {
		 if (longFileMode.isOmitMode()) {
			 log(""Omitting: "" + vPath, Project.MSG_INFO);
			 return;
		 }
		 else if (longFileMode.isWarnMode()) {
			 log(""Entry: "" + vPath + "" longer than "" + TarConstants.NAMELEN + "" characters."", Project.MSG_WARN);
			 if (!longWarningGiven) {
				 log(""Resulting tar file can only be processed "" + ""successfully by GNU compatible tar commands"", Project.MSG_WARN);
				 longWarningGiven = true;
			 }
		 }
		 else if (longFileMode.isFailMode()) {
			 throw new BuildException(""Entry: "" + vPath + "" longer than "" + TarConstants.NAMELEN + ""characters."", getLocation());
		 }
	 }
	 TarEntry te = new TarEntry(vPath);
	 te.setModTime(r.getLastModified());
	 if (r instanceof ArchiveResource) {
		 ArchiveResource ar = (ArchiveResource) r;
		 te.setMode(ar.getMode());
		 if (r instanceof TarResource) {
			 TarResource tr = (TarResource) r;
			 te.setUserName(tr.getUserName());
			 te.setUserId(tr.getUid());
			 te.setGroupName(tr.getGroup());
			 te.setGroupId(tr.getGid());
		 }
	 }
	 if (!r.isDirectory()) {
		 if (r.size() > TarConstants.MAXSIZE) {
			 throw new BuildException( ""Resource: "" + r + "" larger than "" + TarConstants.MAXSIZE + "" bytes."");
		 }
		 te.setSize(r.getSize());
		 if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {
			 te.setMode(tarFileSet.getMode());
		 }
	 }
	 else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {
		 te.setMode(tarFileSet.getDirMode(this.getProject()));
	 }
	 if (tarFileSet != null) {
		 if (tarFileSet.hasUserNameBeenSet()) {
			 te.setUserName(tarFileSet.getUserName());
		 }
		 if (tarFileSet.hasGroupBeenSet()) {
			 te.setGroupName(tarFileSet.getGroup());
		 }
		 if (tarFileSet.hasUserIdBeenSet()) {
			 te.setUserId(tarFileSet.getUid());
		 }
		 if (tarFileSet.hasGroupIdBeenSet()) {
			 te.setGroupId(tarFileSet.getGid());
		 }
	 }
	 InputStream in = null;
	 try {
		 tOut.putNextEntry(te);
		 if (!r.isDirectory()) {
			 in = r.getInputStream();
			 byte[] buffer = new byte[BUFFER_SIZE];
			 int count = 0;
			 do {
				 tOut.write(buffer, 0, count);
				 count = in.read(buffer, 0, buffer.length);
			 }
			 while (count != -1);
		 }
		 tOut.closeEntry();
	 }
	 finally {
		 FileUtils.close(in);
	 }
 }",0,0,1,0
"public class IndexDataWriter{
	 static final int VERSION = 1;
	 static final int F_INDEXED = 1;
	 static final int F_TOKENIZED = 2;
	 static final int F_STORED = 4;
	 static final int F_COMPRESSED = 8;
	 private final DataOutputStream dos;
	 private final GZIPOutputStream gos;
	 private final BufferedOutputStream bos;
	 private final Set<String> allGroups;
	 private final Set<String> rootGroups;
	 private boolean descriptorWritten;
	 public IndexDataWriter( OutputStream os ) throws IOException {
		 bos = new BufferedOutputStream( os, 1024 * 8 );
		 gos = new GZIPOutputStream( bos, 1024 * 2 );
		 dos = new DataOutputStream( gos );
		 this.allGroups = new HashSet<String>();
		 this.rootGroups = new HashSet<String>();
		 this.descriptorWritten = false;
	 }
	 public int write( IndexingContext context, IndexReader indexReader, List<Integer> docIndexes ) throws IOException {
		 writeHeader( context );
		 int n = writeDocuments( indexReader, docIndexes );
		 writeGroupFields();
		 close();
		 return n;
	 }
	 public void close() throws IOException {
		 dos.flush();
		 gos.flush();
		 gos.finish();
		 bos.flush();
	 }
	 public void writeHeader( IndexingContext context ) throws IOException {
		 dos.writeByte( VERSION );
		 Date timestamp = context.getTimestamp();
		 dos.writeLong( timestamp == null ? -1 : timestamp.getTime() );
	 }
	 public void writeGroupFields() throws IOException {
		 {
			 List<IndexableField> allGroupsFields = new ArrayList<>( 2 );
			 allGroupsFields.add( new StringField( ArtifactInfo.ALL_GROUPS, ArtifactInfo.ALL_GROUPS_VALUE, Store.YES ) );
			 allGroupsFields.add( new StringField( ArtifactInfo.ALL_GROUPS_LIST, ArtifactInfo.lst2str( allGroups ), Store.YES ) );
			 writeDocumentFields( allGroupsFields );
		 }
		 {
			 List<IndexableField> rootGroupsFields = new ArrayList<>( 2 );
			 rootGroupsFields.add( new StringField( ArtifactInfo.ROOT_GROUPS, ArtifactInfo.ROOT_GROUPS_VALUE, Store.YES ) );
			 rootGroupsFields.add( new StringField( ArtifactInfo.ROOT_GROUPS_LIST, ArtifactInfo.lst2str( rootGroups ), Store.YES ) );
			 writeDocumentFields( rootGroupsFields );
		 }
	 }
	 public int writeDocuments( IndexReader r, List<Integer> docIndexes ) throws IOException {
		 int n = 0;
		 Bits liveDocs = MultiFields.getLiveDocs( r );
		 if ( docIndexes == null ) {
			 for ( int i = 0;
			 i < r.maxDoc();
			 i++ ) {
				 if ( liveDocs == null || liveDocs.get( i ) ) {
					 if ( writeDocument( r.document( i ) ) ) {
						 n++;
					 }
				 }
			 }
		 }
		 else {
			 for ( int i : docIndexes ) {
				 if ( liveDocs == null || liveDocs.get( i ) ) {
					 if ( writeDocument( r.document( i ) ) ) {
						 n++;
					 }
				 }
			 }
		 }
		 return n;
	 }
	 public boolean writeDocument( final Document document ) throws IOException {
		 List<IndexableField> fields = document.getFields();
		 List<IndexableField> storedFields = new ArrayList<>( fields.size() );
		 for ( IndexableField field : fields ) {
			 if ( DefaultIndexingContext.FLD_DESCRIPTOR.equals( field.name() ) ) {
				 if ( descriptorWritten ) {
					 return false;
				 }
				 else {
					 descriptorWritten = true;
				 }
			 }
			 if ( ArtifactInfo.ALL_GROUPS.equals( field.name() ) ) {
				 final String groupList = document.get( ArtifactInfo.ALL_GROUPS_LIST );
				 if ( groupList != null && groupList.trim().length() > 0 ) {
					 allGroups.addAll( ArtifactInfo.str2lst( groupList ) );
				 }
				 return false;
			 }
			 if ( ArtifactInfo.ROOT_GROUPS.equals( field.name() ) ) {
				 final String groupList = document.get( ArtifactInfo.ROOT_GROUPS_LIST );
				 if ( groupList != null && groupList.trim().length() > 0 ) {
					 rootGroups.addAll( ArtifactInfo.str2lst( groupList ) );
				 }
				 return false;
			 }
			 if ( field.fieldType().stored() ) {
				 storedFields.add( field );
			 }
		 }
		 writeDocumentFields( storedFields );
		 return true;
	 }
	 public void writeDocumentFields( List<IndexableField> fields ) throws IOException {
		 dos.writeInt( fields.size() );
		 for ( IndexableField field : fields ) {
			 writeField( field );
		 }
	 }
	 public void writeField( IndexableField field ) throws IOException {
		 int flags = ( field.fieldType().indexOptions() != IndexOptions.NONE ? F_INDEXED : 0 ) + ( field.fieldType().tokenized() ? F_TOKENIZED : 0 ) + ( field.fieldType().stored() ? F_STORED : 0 );
		 String name = field.name();
		 String value = field.stringValue();
		 dos.write( flags );
		 dos.writeUTF( name );
		 writeUTF( value, dos );
	 }
	 private static void writeUTF( String str, DataOutput out ) throws IOException {
		 int strlen = str.length();
		 int utflen = 0;
		 int c;
		 for ( int i = 0;
		 i < strlen;
		 i++ ) {
			 c = str.charAt( i );
			 if ( ( c >= 0x0001 ) && ( c <= 0x007F ) ) {
				 utflen++;
			 }
			 else if ( c > 0x07FF ) {
				 utflen += 3;
			 }
			 else {
				 utflen += 2;
			 }
		 }
		 out.writeInt( utflen );
		 byte[] bytearr = new byte[utflen];
		 int count = 0;
		 int i = 0;
		 for ( ;
		 i < strlen;
		 i++ ) {
			 c = str.charAt( i );
			 if ( !( ( c >= 0x0001 ) && ( c <= 0x007F ) ) ) {
				 break;
			 }
			 bytearr[count++] = (byte) c;
		 }
		 for ( ;
		 i < strlen;
		 i++ ) {
			 c = str.charAt( i );
			 if ( ( c >= 0x0001 ) && ( c <= 0x007F ) ) {
				 bytearr[count++] = (byte) c;
			 }
			 else if ( c > 0x07FF ) {
				 bytearr[count++] = (byte) ( 0xE0 | ( ( c >> 12 ) & 0x0F ) );
				 bytearr[count++] = (byte) ( 0x80 | ( ( c >> 6 ) & 0x3F ) );
				 bytearr[count++] = (byte) ( 0x80 | ( ( c >> 0 ) & 0x3F ) );
			 }
			 else {
				 bytearr[count++] = (byte) ( 0xC0 | ( ( c >> 6 ) & 0x1F ) );
				 bytearr[count++] = (byte) ( 0x80 | ( ( c >> 0 ) & 0x3F ) );
			 }
		 }
		 out.write( bytearr, 0, utflen );
	 }
}",1,0,0,0
"public List<CharSequence> describe_splits(CharSequence cfName, CharSequence start_token, CharSequence end_token, int keys_per_split) {
	 Token.TokenFactory<T> tf = StorageService.getPartitioner().getTokenFactory();
	 List<Token> tokens = StorageService.instance.getSplits(state().getKeyspace(), cfName.toString(), new Range(tf.fromString(start_token.toString()), tf.fromString(end_token.toString())), keys_per_split);
	 List<CharSequence> splits = new ArrayList<CharSequence>(tokens.size());
	 for (Token token : tokens) {
		 splits.add(tf.toString(token));
	 }
	 return splits;
 }",0,0,0,0
"public class MetricsException extends RuntimeException {
	private static final long serialVersionUID = -1643257498540498497L;
	 public MetricsException() {
	 }
	 public MetricsException(String message) {
		 super(message);
	 }
}",0,0,0,0
"public class JavaTimeSupplementary_es_AR extends OpenListResourceBundle {
	 protected final Object[][] getContents() {
		 final String[] sharedAmPmMarkers = {
		 ""a.m."", ""p.m."", }
		;
		 final String[] sharedDatePatterns = {
		 ""GGGG y MMMM d, EEEE"", ""GGGG y MMMM d"", ""GGGG y MMM d"", ""dd/MM/yy G"", }
		;
		 final String[] sharedDayNarrows = {
		 ""d"", ""l"", ""m"", ""m"", ""j"", ""v"", ""s"", }
		;
		 final String[] sharedTimePatterns = {
		 ""HH:mm:ss zzzz"", ""HH:mm:ss z"", ""HH:mm:ss"", ""HH:mm"", }
		;
		 final String[] sharedJavaTimeDatePatterns = {
		 ""G y MMMM d, EEEE"", ""G y MMMM d"", ""G y MMM d"", ""dd/MM/yy GGGGG"", }
		;
		 return new Object[][] {
			 {
			 ""field.dayperiod"", ""a.m./p.m."" }
			, {
			 ""islamic.AmPmMarkers"", sharedAmPmMarkers }
			, {
			 ""islamic.DatePatterns"", sharedDatePatterns }
			, {
			 ""islamic.DayNarrows"", sharedDayNarrows }
			, {
			 ""islamic.TimePatterns"", sharedTimePatterns }
			, {
			 ""islamic.abbreviated.AmPmMarkers"", sharedAmPmMarkers }
			, {
			 ""islamic.narrow.AmPmMarkers"", sharedAmPmMarkers }
			, {
			 ""java.time.buddhist.DatePatterns"", sharedJavaTimeDatePatterns }
			, {
			 ""java.time.islamic.DatePatterns"", sharedJavaTimeDatePatterns }
			, {
			 ""java.time.roc.DatePatterns"", sharedJavaTimeDatePatterns }
			, {
			 ""roc.AmPmMarkers"", sharedAmPmMarkers }
			, {
			 ""roc.DatePatterns"", sharedDatePatterns }
			, {
			 ""roc.DayNarrows"", sharedDayNarrows }
			, {
				 ""roc.MonthAbbreviations"", new String[] {
				 ""ene."", ""feb."", ""mar."", ""abr."", ""may."", ""jun."", ""jul."", ""ago."", ""sep."", ""oct."", ""nov."", ""dic."", """", }
			 }
			, {
				 ""roc.MonthNarrows"", new String[] {
				 ""e"", ""f"", ""m"", ""a"", ""m"", ""j"", ""j"", ""a"", ""s"", ""o"", ""n"", ""d"", """", }
			 }
			, {
			 ""roc.TimePatterns"", sharedTimePatterns }
			, {
			 ""roc.abbreviated.AmPmMarkers"", sharedAmPmMarkers }
			, {
			 ""roc.narrow.AmPmMarkers"", sharedAmPmMarkers }
		, }
		;
	 }
}",0,1,0,0
"public class Zip extends MatchingTask {
	 private static final int BUFFER_SIZE = 8 * 1024;
	 private static final int ROUNDUP_MILLIS = 1999;
	 protected File zipFile;
	 private ZipScanner zs;
	 private File baseDir;
	 protected Hashtable entries = new Hashtable();
	 private Vector groupfilesets = new Vector();
	 private Vector filesetsFromGroupfilesets = new Vector();
	 protected String duplicate = ""add"";
	 private boolean doCompress = true;
	 private boolean doUpdate = false;
	 private boolean savedDoUpdate = false;
	 private boolean doFilesonly = false;
	 protected String archiveType = ""zip"";
	 private static final long EMPTY_CRC = new CRC32 ().getValue ();
	 protected String emptyBehavior = ""skip"";
	 private Vector resources = new Vector();
	 protected Hashtable addedDirs = new Hashtable();
	 private Vector addedFiles = new Vector();
	 protected boolean doubleFilePass = false;
	 protected boolean skipWriting = false;
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private boolean updatedFile = false;
	 private boolean addingNewFiles = false;
	 private String encoding;
	 private boolean keepCompression = false;
	 private boolean roundUp = true;
	 private String comment = """";
	 private int level = ZipOutputStream.DEFAULT_COMPRESSION;
	 public void setZipfile(File zipFile) {
		 setDestFile(zipFile);
	 }
	 public void setFile(File file) {
		 setDestFile(file);
	 }
	 public void setDestFile(File destFile) {
		 this.zipFile = destFile;
	 }
	 public File getDestFile() {
		 return zipFile;
	 }
	 public void setBasedir(File baseDir) {
		 this.baseDir = baseDir;
	 }
	 public void setCompress(boolean c) {
		 doCompress = c;
	 }
	 public boolean isCompress() {
		 return doCompress;
	 }
	 public void setFilesonly(boolean f) {
		 doFilesonly = f;
	 }
	 public void setUpdate(boolean c) {
		 doUpdate = c;
		 savedDoUpdate = c;
	 }
	 public boolean isInUpdateMode() {
		 return doUpdate;
	 }
	 public void addFileset(FileSet set) {
		 add(set);
	 }
	 public void addZipfileset(ZipFileSet set) {
		 add(set);
	 }
	 public void add(ResourceCollection a) {
		 resources.add(a);
	 }
	 public void addZipGroupFileset(FileSet set) {
		 groupfilesets.addElement(set);
	 }
	 public void setDuplicate(Duplicate df) {
		 duplicate = df.getValue();
	 }
	 public static class WhenEmpty extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""fail"", ""skip"", ""create""}
			;
		 }
	 }
	 public void setWhenempty(WhenEmpty we) {
		 emptyBehavior = we.getValue();
	 }
	 public void setEncoding(String encoding) {
		 this.encoding = encoding;
	 }
	 public String getEncoding() {
		 return encoding;
	 }
	 public void setKeepCompression(boolean keep) {
		 keepCompression = keep;
	 }
	 public void setComment(String comment) {
		 this.comment = comment;
	 }
	 public String getComment() {
		 return comment;
	 }
	 public void setLevel(int level) {
		 this.level = level;
	 }
	 public int getLevel() {
		 return level;
	 }
	 public void setRoundUp(boolean r) {
		 roundUp = r;
	 }
	 public void execute() throws BuildException {
		 if (doubleFilePass) {
			 skipWriting = true;
			 executeMain();
			 skipWriting = false;
			 executeMain();
		 }
		 else {
			 executeMain();
		 }
	 }
	 protected boolean hasUpdatedFile() {
		 return updatedFile;
	 }
	 public void executeMain() throws BuildException {
		 checkAttributesAndElements();
		 File renamedFile = null;
		 addingNewFiles = true;
		 processDoUpdate();
		 processGroupFilesets();
		 Vector vfss = new Vector();
		 if (baseDir != null) {
			 FileSet fs = (FileSet) getImplicitFileSet().clone();
			 fs.setDir(baseDir);
			 vfss.addElement(fs);
		 }
		 for (int i = 0;
		 i < resources.size();
		 i++) {
			 ResourceCollection rc = (ResourceCollection) resources.elementAt(i);
			 vfss.addElement(rc);
		 }
		 ResourceCollection[] fss = new ResourceCollection[vfss.size()];
		 vfss.copyInto(fss);
		 boolean success = false;
		 try {
			 ArchiveState state = getResourcesToAdd(fss, zipFile, false);
			 if (!state.isOutOfDate()) {
				 return;
			 }
			 updatedFile = true;
			 if (!zipFile.exists() && state.isWithoutAnyResources()) {
				 createEmptyZip(zipFile);
				 return;
			 }
			 Resource[][] addThem = state.getResourcesToAdd();
			 if (doUpdate) {
				 renamedFile = renameFile();
			 }
			 String action = doUpdate ? ""Updating "" : ""Building "";
			 log(action + archiveType + "": "" + zipFile.getAbsolutePath());
			 ZipOutputStream zOut = null;
			 try {
				 if (!skipWriting) {
					 zOut = new ZipOutputStream(zipFile);
					 zOut.setEncoding(encoding);
					 zOut.setMethod(doCompress ? ZipOutputStream.DEFLATED : ZipOutputStream.STORED);
					 zOut.setLevel(level);
				 }
				 initZipOutputStream(zOut);
				 for (int i = 0;
				 i < fss.length;
				 i++) {
					 if (addThem[i].length != 0) {
						 addResources(fss[i], addThem[i], zOut);
					 }
				 }
				 if (doUpdate) {
					 addingNewFiles = false;
					 ZipFileSet oldFiles = new ZipFileSet();
					 oldFiles.setProject(getProject());
					 oldFiles.setSrc(renamedFile);
					 oldFiles.setDefaultexcludes(false);
					 for (int i = 0;
					 i < addedFiles.size();
					 i++) {
						 PatternSet.NameEntry ne = oldFiles.createExclude();
						 ne.setName((String) addedFiles.elementAt(i));
					 }
					 DirectoryScanner ds = oldFiles.getDirectoryScanner(getProject());
					 ((ZipScanner) ds).setEncoding(encoding);
					 String[] f = ds.getIncludedFiles();
					 Resource[] r = new Resource[f.length];
					 for (int i = 0;
					 i < f.length;
					 i++) {
						 r[i] = ds.getResource(f[i]);
					 }
					 if (!doFilesonly) {
						 String[] d = ds.getIncludedDirectories();
						 Resource[] dr = new Resource[d.length];
						 for (int i = 0;
						 i < d.length;
						 i++) {
							 dr[i] = ds.getResource(d[i]);
						 }
						 Resource[] tmp = r;
						 r = new Resource[tmp.length + dr.length];
						 System.arraycopy(dr, 0, r, 0, dr.length);
						 System.arraycopy(tmp, 0, r, dr.length, tmp.length);
					 }
					 addResources(oldFiles, r, zOut);
				 }
				 if (zOut != null) {
					 zOut.setComment(comment);
				 }
				 finalizeZipOutputStream(zOut);
				 if (doUpdate) {
					 if (!renamedFile.delete()) {
						 log (""Warning: unable to delete temporary file "" + renamedFile.getName(), Project.MSG_WARN);
					 }
				 }
				 success = true;
			 }
			 finally {
				 closeZout(zOut, success);
			 }
		 }
		 catch (IOException ioe) {
			 String msg = ""Problem creating "" + archiveType + "": "" + ioe.getMessage();
			 if ((!doUpdate || renamedFile != null) && !zipFile.delete()) {
				 msg += "" (and the archive is probably corrupt but I could not "" + ""delete it)"";
			 }
			 if (doUpdate && renamedFile != null) {
				 try {
					 FILE_UTILS.rename(renamedFile, zipFile);
				 }
				 catch (IOException e) {
					 msg += "" (and I couldn't rename the temporary file "" + renamedFile.getName() + "" back)"";
				 }
			 }
			 throw new BuildException(msg, ioe, getLocation());
		 }
		 finally {
			 cleanUp();
		 }
	 }
	 private File renameFile() {
		 File renamedFile = FILE_UTILS.createTempFile( ""zip"", "".tmp"", zipFile.getParentFile(), true, true);
		 try {
			 FILE_UTILS.rename(zipFile, renamedFile);
		 }
		 catch (SecurityException e) {
			 throw new BuildException( ""Not allowed to rename old file ("" + zipFile.getAbsolutePath() + "") to temporary file"");
		 }
		 catch (IOException e) {
			 throw new BuildException( ""Unable to rename old file ("" + zipFile.getAbsolutePath() + "") to temporary file"");
		 }
		 return renamedFile;
	 }
	 private void closeZout(ZipOutputStream zOut, boolean success) throws IOException {
		 if (zOut == null) {
			 return;
		 }
		 try {
			 zOut.close();
		 }
		 catch (IOException ex) {
			 if (success) {
				 throw ex;
			 }
		 }
	 }
	 private void checkAttributesAndElements() {
		 if (baseDir == null && resources.size() == 0 && groupfilesets.size() == 0 && ""zip"".equals(archiveType)) {
			 throw new BuildException(""basedir attribute must be set, "" + ""or at least one "" + ""resource collection must be given!"");
		 }
		 if (zipFile == null) {
			 throw new BuildException(""You must specify the "" + archiveType + "" file to create!"");
		 }
		 if (zipFile.exists() && !zipFile.isFile()) {
			 throw new BuildException(zipFile + "" is not a file."");
		 }
		 if (zipFile.exists() && !zipFile.canWrite()) {
			 throw new BuildException(zipFile + "" is read-only."");
		 }
	 }
	 private void processDoUpdate() {
		 if (doUpdate && !zipFile.exists()) {
			 doUpdate = false;
			 log(""ignoring update attribute as "" + archiveType + "" doesn't exist."", Project.MSG_DEBUG);
		 }
	 }
	 private void processGroupFilesets() {
		 for (int i = 0;
		 i < groupfilesets.size();
		 i++) {
			 log(""Processing groupfileset "", Project.MSG_VERBOSE);
			 FileSet fs = (FileSet) groupfilesets.elementAt(i);
			 FileScanner scanner = fs.getDirectoryScanner(getProject());
			 String[] files = scanner.getIncludedFiles();
			 File basedir = scanner.getBasedir();
			 for (int j = 0;
			 j < files.length;
			 j++) {
				 log(""Adding file "" + files[j] + "" to fileset"", Project.MSG_VERBOSE);
				 ZipFileSet zf = new ZipFileSet();
				 zf.setProject(getProject());
				 zf.setSrc(new File(basedir, files[j]));
				 add(zf);
				 filesetsFromGroupfilesets.addElement(zf);
			 }
		 }
	 }
	 protected final boolean isAddingNewFiles() {
		 return addingNewFiles;
	 }
	 protected final void addResources(FileSet fileset, Resource[] resources, ZipOutputStream zOut) throws IOException {
		 String prefix = """";
		 String fullpath = """";
		 int dirMode = ArchiveFileSet.DEFAULT_DIR_MODE;
		 int fileMode = ArchiveFileSet.DEFAULT_FILE_MODE;
		 ArchiveFileSet zfs = null;
		 if (fileset instanceof ArchiveFileSet) {
			 zfs = (ArchiveFileSet) fileset;
			 prefix = zfs.getPrefix(getProject());
			 fullpath = zfs.getFullpath(getProject());
			 dirMode = zfs.getDirMode(getProject());
			 fileMode = zfs.getFileMode(getProject());
		 }
		 if (prefix.length() > 0 && fullpath.length() > 0) {
			 throw new BuildException(""Both prefix and fullpath attributes must"" + "" not be set on the same fileset."");
		 }
		 if (resources.length != 1 && fullpath.length() > 0) {
			 throw new BuildException(""fullpath attribute may only be specified"" + "" for filesets that specify a single"" + "" file."");
		 }
		 if (prefix.length() > 0) {
			 if (!prefix.endsWith(""/"") && !prefix.endsWith(""\\"")) {
				 prefix += ""/"";
			 }
			 addParentDirs(null, prefix, zOut, """", dirMode);
		 }
		 ZipFile zf = null;
		 try {
			 boolean dealingWithFiles = false;
			 File base = null;
			 if (zfs == null || zfs.getSrc(getProject()) == null) {
				 dealingWithFiles = true;
				 base = fileset.getDir(getProject());
			 }
			 else if (zfs instanceof ZipFileSet) {
				 zf = new ZipFile(zfs.getSrc(getProject()), encoding);
			 }
			 for (int i = 0;
			 i < resources.length;
			 i++) {
				 String name = null;
				 if (fullpath.length() > 0) {
					 name = fullpath;
				 }
				 else {
					 name = resources[i].getName();
				 }
				 name = name.replace(File.separatorChar, '/');
				 if ("""".equals(name)) {
					 continue;
				 }
				 if (resources[i].isDirectory() && !name.endsWith(""/"")) {
					 name = name + ""/"";
				 }
				 if (!doFilesonly && !dealingWithFiles && resources[i].isDirectory() && !zfs.hasDirModeBeenSet()) {
					 int nextToLastSlash = name.lastIndexOf(""/"", name.length() - 2);
					 if (nextToLastSlash != -1) {
						 addParentDirs(base, name.substring(0, nextToLastSlash + 1), zOut, prefix, dirMode);
					 }
					 if (zf != null) {
						 ZipEntry ze = zf.getEntry(resources[i].getName());
						 addParentDirs(base, name, zOut, prefix, ze.getUnixMode());
					 }
					 else {
						 ArchiveResource tr = (ArchiveResource) resources[i];
						 addParentDirs(base, name, zOut, prefix, tr.getMode());
					 }
				 }
				 else {
					 addParentDirs(base, name, zOut, prefix, dirMode);
				 }
				 if (!resources[i].isDirectory() && dealingWithFiles) {
					 File f = FILE_UTILS.resolveFile(base, resources[i].getName());
					 zipFile(f, zOut, prefix + name, fileMode);
				 }
				 else if (!resources[i].isDirectory()) {
					 if (zf != null) {
						 ZipEntry ze = zf.getEntry(resources[i].getName());
						 if (ze != null) {
							 boolean oldCompress = doCompress;
							 if (keepCompression) {
								 doCompress = (ze.getMethod() == ZipEntry.DEFLATED);
							 }
							 InputStream is = null;
							 try {
								 is = zf.getInputStream(ze);
								 zipFile(is, zOut, prefix + name, ze.getTime(), zfs.getSrc(getProject()), zfs.hasFileModeBeenSet() ? fileMode : ze.getUnixMode());
							 }
							 finally {
								 doCompress = oldCompress;
								 FileUtils.close(is);
							 }
						 }
					 }
					 else {
						 ArchiveResource tr = (ArchiveResource) resources[i];
						 InputStream is = null;
						 try {
							 is = tr.getInputStream();
							 zipFile(is, zOut, prefix + name, resources[i].getLastModified(), zfs.getSrc(getProject()), zfs.hasFileModeBeenSet() ? fileMode : tr.getMode());
						 }
						 finally {
							 FileUtils.close(is);
						 }
					 }
				 }
			 }
		 }
		 finally {
			 if (zf != null) {
				 zf.close();
			 }
		 }
	 }
	 protected final void addResources(ResourceCollection rc, Resource[] resources, ZipOutputStream zOut) throws IOException {
		 if (rc instanceof FileSet) {
			 addResources((FileSet) rc, resources, zOut);
			 return;
		 }
		 for (int i = 0;
		 i < resources.length;
		 i++) {
			 String name = resources[i].getName().replace(File.separatorChar, '/');
			 if ("""".equals(name)) {
				 continue;
			 }
			 if (resources[i].isDirectory() && doFilesonly) {
				 continue;
			 }
			 File base = null;
			 if (resources[i] instanceof FileResource) {
				 base = ((FileResource) resources[i]).getBaseDir();
			 }
			 if (resources[i].isDirectory()) {
				 if (!name.endsWith(""/"")) {
					 name = name + ""/"";
				 }
			 }
			 addParentDirs(base, name, zOut, """", ArchiveFileSet.DEFAULT_DIR_MODE);
			 if (!resources[i].isDirectory()) {
				 if (resources[i] instanceof FileResource) {
					 File f = ((FileResource) resources[i]).getFile();
					 zipFile(f, zOut, name, ArchiveFileSet.DEFAULT_FILE_MODE);
				 }
				 else {
					 InputStream is = null;
					 try {
						 is = resources[i].getInputStream();
						 zipFile(is, zOut, name, resources[i].getLastModified(), null, ArchiveFileSet.DEFAULT_FILE_MODE);
					 }
					 finally {
						 FileUtils.close(is);
					 }
				 }
			 }
		 }
	 }
	 protected void initZipOutputStream(ZipOutputStream zOut) throws IOException, BuildException {
	 }
	 protected void finalizeZipOutputStream(ZipOutputStream zOut) throws IOException, BuildException {
	 }
	 protected boolean createEmptyZip(File zipFile) throws BuildException {
		 log(""Note: creating empty "" + archiveType + "" archive "" + zipFile, Project.MSG_INFO);
		 OutputStream os = null;
		 try {
			 os = new FileOutputStream(zipFile);
			 byte[] empty = new byte[22];
			 empty[0] = 80;
			 empty[1] = 75;
			 empty[2] = 5;
			 empty[3] = 6;
			 os.write(empty);
		 }
		 catch (IOException ioe) {
			 throw new BuildException(""Could not create empty ZIP archive "" + ""("" + ioe.getMessage() + "")"", ioe, getLocation());
		 }
		 finally {
			 FileUtils.close(os);
		 }
		 return true;
	 }
	 private synchronized ZipScanner getZipScanner() {
		 if (zs == null) {
			 zs = new ZipScanner();
			 zs.setEncoding(encoding);
			 zs.setSrc(zipFile);
		 }
		 return zs;
	 }
	 protected ArchiveState getResourcesToAdd(ResourceCollection[] rcs, File zipFile, boolean needsUpdate) throws BuildException {
		 ArrayList filesets = new ArrayList();
		 ArrayList rest = new ArrayList();
		 for (int i = 0;
		 i < rcs.length;
		 i++) {
			 if (rcs[i] instanceof FileSet) {
				 filesets.add(rcs[i]);
			 }
			 else {
				 rest.add(rcs[i]);
			 }
		 }
		 ResourceCollection[] rc = (ResourceCollection[]) rest.toArray(new ResourceCollection[rest.size()]);
		 ArchiveState as = getNonFileSetResourcesToAdd(rc, zipFile, needsUpdate);
		 FileSet[] fs = (FileSet[]) filesets.toArray(new FileSet[filesets .size()]);
		 ArchiveState as2 = getResourcesToAdd(fs, zipFile, as.isOutOfDate());
		 if (!as.isOutOfDate() && as2.isOutOfDate()) {
			 as = getNonFileSetResourcesToAdd(rc, zipFile, true);
		 }
		 Resource[][] toAdd = new Resource[rcs.length][];
		 int fsIndex = 0;
		 int restIndex = 0;
		 for (int i = 0;
		 i < rcs.length;
		 i++) {
			 if (rcs[i] instanceof FileSet) {
				 toAdd[i] = as2.getResourcesToAdd()[fsIndex++];
			 }
			 else {
				 toAdd[i] = as.getResourcesToAdd()[restIndex++];
			 }
		 }
		 return new ArchiveState(as2.isOutOfDate(), toAdd);
	 }
	 protected ArchiveState getResourcesToAdd(FileSet[] filesets, File zipFile, boolean needsUpdate) throws BuildException {
		 Resource[][] initialResources = grabResources(filesets);
		 if (isEmpty(initialResources)) {
			 if (needsUpdate && doUpdate) {
				 return new ArchiveState(true, initialResources);
			 }
			 if (emptyBehavior.equals(""skip"")) {
				 if (doUpdate) {
					 log(archiveType + "" archive "" + zipFile + "" not updated because no new files were included."", Project.MSG_VERBOSE);
				 }
				 else {
					 log(""Warning: skipping "" + archiveType + "" archive "" + zipFile + "" because no files were included."", Project.MSG_WARN);
				 }
			 }
			 else if (emptyBehavior.equals(""fail"")) {
				 throw new BuildException(""Cannot create "" + archiveType + "" archive "" + zipFile + "": no files were included."", getLocation());
			 }
			 else {
				 if (!zipFile.exists()) {
					 needsUpdate = true;
				 }
			 }
			 return new ArchiveState(needsUpdate, initialResources);
		 }
		 if (!zipFile.exists()) {
			 return new ArchiveState(true, initialResources);
		 }
		 if (needsUpdate && !doUpdate) {
			 return new ArchiveState(true, initialResources);
		 }
		 Resource[][] newerResources = new Resource[filesets.length][];
		 for (int i = 0;
		 i < filesets.length;
		 i++) {
			 if (!(fileset instanceof ZipFileSet) || ((ZipFileSet) fileset).getSrc(getProject()) == null) {
				 File base = filesets[i].getDir(getProject());
				 for (int j = 0;
				 j < initialResources[i].length;
				 j++) {
					 File resourceAsFile = FILE_UTILS.resolveFile(base, initialResources[i][j].getName());
					 if (resourceAsFile.equals(zipFile)) {
						 throw new BuildException(""A zip file cannot include "" + ""itself"", getLocation());
					 }
				 }
			 }
		 }
		 for (int i = 0;
		 i < filesets.length;
		 i++) {
			 if (initialResources[i].length == 0) {
				 newerResources[i] = new Resource[] {
				}
				;
				 continue;
			 }
			 FileNameMapper myMapper = new IdentityMapper();
			 if (filesets[i] instanceof ZipFileSet) {
				 ZipFileSet zfs = (ZipFileSet) filesets[i];
				 if (zfs.getFullpath(getProject()) != null && !zfs.getFullpath(getProject()).equals("""")) {
					 MergingMapper fm = new MergingMapper();
					 fm.setTo(zfs.getFullpath(getProject()));
					 myMapper = fm;
				 }
				 else if (zfs.getPrefix(getProject()) != null && !zfs.getPrefix(getProject()).equals("""")) {
					 GlobPatternMapper gm = new GlobPatternMapper();
					 gm.setFrom(""*"");
					 String prefix = zfs.getPrefix(getProject());
					 if (!prefix.endsWith(""/"") && !prefix.endsWith(""\\"")) {
						 prefix += ""/"";
					 }
					 gm.setTo(prefix + ""*"");
					 myMapper = gm;
				 }
			 }
			 Resource[] resources = initialResources[i];
			 if (doFilesonly) {
				 resources = selectFileResources(resources);
			 }
			 newerResources[i] = ResourceUtils.selectOutOfDateSources(this, resources, myMapper, getZipScanner());
			 needsUpdate = needsUpdate || (newerResources[i].length > 0);
			 if (needsUpdate && !doUpdate) {
				 break;
			 }
		 }
		 if (needsUpdate && !doUpdate) {
			 return new ArchiveState(true, initialResources);
		 }
		 return new ArchiveState(needsUpdate, newerResources);
	 }
	 protected ArchiveState getNonFileSetResourcesToAdd(ResourceCollection[] rcs, File zipFile, boolean needsUpdate) throws BuildException {
		 Resource[][] initialResources = grabNonFileSetResources(rcs);
		 if (isEmpty(initialResources)) {
			 return new ArchiveState(needsUpdate, initialResources);
		 }
		 if (!zipFile.exists()) {
			 return new ArchiveState(true, initialResources);
		 }
		 if (needsUpdate && !doUpdate) {
			 return new ArchiveState(true, initialResources);
		 }
		 Resource[][] newerResources = new Resource[rcs.length][];
		 for (int i = 0;
		 i < rcs.length;
		 i++) {
			 if (initialResources[i].length == 0) {
				 newerResources[i] = new Resource[] {
				}
				;
				 continue;
			 }
			 for (int j = 0;
			 j < initialResources[i].length;
			 j++) {
				 if (initialResources[i][j] instanceof FileResource && zipFile.equals(((FileResource) initialResources[i][j]).getFile())) {
					 throw new BuildException(""A zip file cannot include "" + ""itself"", getLocation());
				 }
			 }
			 Resource[] rs = initialResources[i];
			 if (doFilesonly) {
				 rs = selectFileResources(rs);
			 }
			 newerResources[i] = ResourceUtils.selectOutOfDateSources(this, rs, new IdentityMapper(), getZipScanner());
			 needsUpdate = needsUpdate || (newerResources[i].length > 0);
			 if (needsUpdate && !doUpdate) {
				 break;
			 }
		 }
		 if (needsUpdate && !doUpdate) {
			 return new ArchiveState(true, initialResources);
		 }
		 return new ArchiveState(needsUpdate, newerResources);
	 }
	 protected Resource[][] grabResources(FileSet[] filesets) {
		 Resource[][] result = new Resource[filesets.length][];
		 for (int i = 0;
		 i < filesets.length;
		 i++) {
			 boolean skipEmptyNames = true;
			 if (filesets[i] instanceof ZipFileSet) {
				 ZipFileSet zfs = (ZipFileSet) filesets[i];
				 skipEmptyNames = zfs.getPrefix(getProject()).equals("""") && zfs.getFullpath(getProject()).equals("""");
			 }
			 DirectoryScanner rs = filesets[i].getDirectoryScanner(getProject());
			 if (rs instanceof ZipScanner) {
				 ((ZipScanner) rs).setEncoding(encoding);
			 }
			 Vector resources = new Vector();
			 if (!doFilesonly) {
				 String[] directories = rs.getIncludedDirectories();
				 for (int j = 0;
				 j < directories.length;
				 j++) {
					 if (!"""".equals(directories[j]) || !skipEmptyNames) {
						 resources.addElement(rs.getResource(directories[j]));
					 }
				 }
			 }
			 String[] files = rs.getIncludedFiles();
			 for (int j = 0;
			 j < files.length;
			 j++) {
				 if (!"""".equals(files[j]) || !skipEmptyNames) {
					 resources.addElement(rs.getResource(files[j]));
				 }
			 }
			 result[i] = new Resource[resources.size()];
			 resources.copyInto(result[i]);
		 }
		 return result;
	 }
	 protected Resource[][] grabNonFileSetResources(ResourceCollection[] rcs) {
		 Resource[][] result = new Resource[rcs.length][];
		 for (int i = 0;
		 i < rcs.length;
		 i++) {
			 Iterator iter = rcs[i].iterator();
			 ArrayList rs = new ArrayList();
			 int lastDir = 0;
			 while (iter.hasNext()) {
				 Resource r = (Resource) iter.next();
				 if (r.isExists()) {
					 if (r.isDirectory()) {
						 rs.add(lastDir++, r);
					 }
					 else {
						 rs.add(r);
					 }
				 }
			 }
			 result[i] = (Resource[]) rs.toArray(new Resource[rs.size()]);
		 }
		 return result;
	 }
	 protected void zipDir(File dir, ZipOutputStream zOut, String vPath, int mode) throws IOException {
		 zipDir(dir, zOut, vPath, mode, null);
	 }
	 protected void zipDir(File dir, ZipOutputStream zOut, String vPath, int mode, ZipExtraField[] extra) throws IOException {
		 if (doFilesonly) {
			 log(""skipping directory "" + vPath + "" for file-only archive"", Project.MSG_VERBOSE);
			 return;
		 }
		 if (addedDirs.get(vPath) != null) {
			 return;
		 }
		 log(""adding directory "" + vPath, Project.MSG_VERBOSE);
		 addedDirs.put(vPath, vPath);
		 if (!skipWriting) {
			 ZipEntry ze = new ZipEntry (vPath);
			 if (dir != null && dir.exists()) {
				 ze.setTime(dir.lastModified() + (roundUp ? ROUNDUP_MILLIS : 0));
			 }
			 else {
				 ze.setTime(System.currentTimeMillis() + (roundUp ? ROUNDUP_MILLIS : 0));
			 }
			 ze.setSize (0);
			 ze.setMethod (ZipEntry.STORED);
			 ze.setCrc (EMPTY_CRC);
			 ze.setUnixMode(mode);
			 if (extra != null) {
				 ze.setExtraFields(extra);
			 }
			 zOut.putNextEntry(ze);
		 }
	 }
	 protected void zipFile(InputStream in, ZipOutputStream zOut, String vPath, long lastModified, File fromArchive, int mode) throws IOException {
		 if (entries.contains(vPath)) {
			 if (duplicate.equals(""preserve"")) {
				 log(vPath + "" already added, skipping"", Project.MSG_INFO);
				 return;
			 }
			 else if (duplicate.equals(""fail"")) {
				 throw new BuildException(""Duplicate file "" + vPath + "" was found and the duplicate "" + ""attribute is 'fail'."");
			 }
			 else {
				 log(""duplicate file "" + vPath + "" found, adding."", Project.MSG_VERBOSE);
			 }
		 }
		 else {
			 log(""adding entry "" + vPath, Project.MSG_VERBOSE);
		 }
		 entries.put(vPath, vPath);
		 if (!skipWriting) {
			 ZipEntry ze = new ZipEntry(vPath);
			 ze.setTime(lastModified);
			 ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);
			 if (!zOut.isSeekable() && !doCompress) {
				 long size = 0;
				 CRC32 cal = new CRC32();
				 if (!in.markSupported()) {
					 ByteArrayOutputStream bos = new ByteArrayOutputStream();
					 byte[] buffer = new byte[BUFFER_SIZE];
					 int count = 0;
					 do {
						 size += count;
						 cal.update(buffer, 0, count);
						 bos.write(buffer, 0, count);
						 count = in.read(buffer, 0, buffer.length);
					 }
					 while (count != -1);
					 in = new ByteArrayInputStream(bos.toByteArray());
				 }
				 else {
					 in.mark(Integer.MAX_VALUE);
					 byte[] buffer = new byte[BUFFER_SIZE];
					 int count = 0;
					 do {
						 size += count;
						 cal.update(buffer, 0, count);
						 count = in.read(buffer, 0, buffer.length);
					 }
					 while (count != -1);
					 in.reset();
				 }
				 ze.setSize(size);
				 ze.setCrc(cal.getValue());
			 }
			 ze.setUnixMode(mode);
			 zOut.putNextEntry(ze);
			 byte[] buffer = new byte[BUFFER_SIZE];
			 int count = 0;
			 do {
				 if (count != 0) {
					 zOut.write(buffer, 0, count);
				 }
				 count = in.read(buffer, 0, buffer.length);
			 }
			 while (count != -1);
		 }
		 addedFiles.addElement(vPath);
	 }
	 protected void zipFile(File file, ZipOutputStream zOut, String vPath, int mode) throws IOException {
		 if (file.equals(zipFile)) {
			 throw new BuildException(""A zip file cannot include itself"", getLocation());
		 }
		 FileInputStream fIn = new FileInputStream(file);
		 try {
			 zipFile(fIn, zOut, vPath, file.lastModified() + (roundUp ? ROUNDUP_MILLIS : 0), null, mode);
		 }
		 finally {
			 fIn.close();
		 }
	 }
	 protected final void addParentDirs(File baseDir, String entry, ZipOutputStream zOut, String prefix, int dirMode) throws IOException {
		 if (!doFilesonly) {
			 Stack directories = new Stack();
			 int slashPos = entry.length();
			 while ((slashPos = entry.lastIndexOf('/', slashPos - 1)) != -1) {
				 String dir = entry.substring(0, slashPos + 1);
				 if (addedDirs.get(prefix + dir) != null) {
					 break;
				 }
				 directories.push(dir);
			 }
			 while (!directories.isEmpty()) {
				 String dir = (String) directories.pop();
				 File f = null;
				 if (baseDir != null) {
					 f = new File(baseDir, dir);
				 }
				 else {
					 f = new File(dir);
				 }
				 zipDir(f, zOut, prefix + dir, dirMode);
			 }
		 }
	 }
	 protected void cleanUp() {
		 addedDirs.clear();
		 addedFiles.removeAllElements();
		 entries.clear();
		 addingNewFiles = false;
		 doUpdate = savedDoUpdate;
		 Enumeration e = filesetsFromGroupfilesets.elements();
		 while (e.hasMoreElements()) {
			 ZipFileSet zf = (ZipFileSet) e.nextElement();
			 resources.removeElement(zf);
		 }
		 filesetsFromGroupfilesets.removeAllElements();
	 }
	 public void reset() {
		 resources.removeAllElements();
		 zipFile = null;
		 baseDir = null;
		 groupfilesets.removeAllElements();
		 duplicate = ""add"";
		 archiveType = ""zip"";
		 doCompress = true;
		 emptyBehavior = ""skip"";
		 doUpdate = false;
		 doFilesonly = false;
		 encoding = null;
	 }
	 protected static final boolean isEmpty(Resource[][] r) {
		 for (int i = 0;
		 i < r.length;
		 i++) {
			 if (r[i].length > 0) {
				 return false;
			 }
		 }
		 return true;
	 }
	 protected Resource[] selectFileResources(Resource[] orig) {
		 if (orig.length == 0) {
			 return orig;
		 }
		 Vector v = new Vector(orig.length);
		 for (int i = 0;
		 i < orig.length;
		 i++) {
			 if (!orig[i].isDirectory()) {
				 v.addElement(orig[i]);
			 }
			 else {
				 log(""Ignoring directory "" + orig[i].getName() + "" as only files will be added."", Project.MSG_VERBOSE);
			 }
		 }
		 if (v.size() != orig.length) {
			 Resource[] r = new Resource[v.size()];
			 v.copyInto(r);
			 return r;
		 }
		 return orig;
	 }
	 public static class Duplicate extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""add"", ""preserve"", ""fail""}
			;
		 }
	 }
	 public static class ArchiveState {
		 private boolean outOfDate;
		 private Resource[][] resourcesToAdd;
		 ArchiveState(boolean state, Resource[][] r) {
			 outOfDate = state;
			 resourcesToAdd = r;
		 }
		 public boolean isOutOfDate() {
			 return outOfDate;
		 }
		 public Resource[][] getResourcesToAdd() {
			 return resourcesToAdd;
		 }
		 public boolean isWithoutAnyResources() {
			 if (resourcesToAdd == null) {
				 return true;
			 }
			 for (int counter = 0;
			 counter < resourcesToAdd.length;
			 counter++) {
				 if (resourcesToAdd[counter] != null) {
					 if (resourcesToAdd[counter].length > 0) {
						 return false;
					 }
				 }
			 }
			 return true;
		 }
	 }
}",1,0,0,0
"public class PackageNameMapper extends GlobPatternMapper {
	 protected String extractVariablePart(String name) {
		 String var = name.substring(prefixLength, name.length() - postfixLength);
		 return var.replace(File.separatorChar, '.');
	 }
}",0,0,0,0
"protected void addSupportClasses(Hashtable ejbFiles) {
	 Project project = task.getProject();
	 for (Iterator i = config.supportFileSets.iterator();
	 i.hasNext();
	) {
		 FileSet supportFileSet = (FileSet) i.next();
		 File supportBaseDir = supportFileSet.getDir(project);
		 DirectoryScanner supportScanner = supportFileSet.getDirectoryScanner(project);
		 supportScanner.scan();
		 String[] supportFiles = supportScanner.getIncludedFiles();
		 for (int j = 0;
		 j < supportFiles.length;
		 ++j) {
			 ejbFiles.put(supportFiles[j], new File(supportBaseDir, supportFiles[j]));
		 }
	 }
 }",0,0,0,0
public NextLineProperty();,0,0,0,0
"public final class StableValue<T> {
	 private final T value;
	 private final Assumption assumption;
	 public StableValue(T value, String name) {
		 this.value = value;
		 this.assumption = Truffle.getRuntime().createAssumption(name);
	 }
	 public T getValue() {
		 return value;
	 }
	 public Assumption getAssumption() {
		 return assumption;
	 }
	 public String toString() {
		 return ""["" + value + "", "" + assumption + ""]"";
	 }
}",0,1,0,0
"public class Identity extends EvalFunc<Tuple> {
	 public Tuple exec(Tuple input) {
		 return input;
	 }
	 public Schema outputSchema(Schema input) {
		 try {
			 return new Schema(new Schema.FieldSchema(null, input, DataType.TUPLE));
		 }
		 catch (FrontendException e) {
			 throw new RuntimeException(e);
		 }
	 }
}",1,0,0,0
"public class FileUtils {
	 private static final int EXPAND_SPACE = 50;
	 private static final FileUtils PRIMARY_INSTANCE = new FileUtils();
	 private static Random rand = new Random(System.currentTimeMillis() + Runtime.getRuntime().freeMemory());
	 private static final boolean ON_NETWARE = Os.isFamily(""netware"");
	 private static final boolean ON_DOS = Os.isFamily(""dos"");
	 private static final boolean ON_WIN9X = Os.isFamily(""win9x"");
	 private static final boolean ON_WINDOWS = Os.isFamily(""windows"");
	 static final int BUF_SIZE = 8192;
	 public static final long FAT_FILE_TIMESTAMP_GRANULARITY = 2000;
	 public static final long UNIX_FILE_TIMESTAMP_GRANULARITY = 1000;
	 public static final long NTFS_FILE_TIMESTAMP_GRANULARITY = 1;
	 private Object cacheFromUriLock = new Object();
	 private String cacheFromUriRequest = null;
	 private String cacheFromUriResponse = null;
	 public static FileUtils newFileUtils() {
		 return new FileUtils();
	 }
	 public static FileUtils getFileUtils() {
		 return PRIMARY_INSTANCE;
	 }
	 protected FileUtils() {
	 }
	 public URL getFileURL(File file) throws MalformedURLException {
		 return new URL(toURI(file.getAbsolutePath()));
	 }
	 public void copyFile(String sourceFile, String destFile) throws IOException {
		 copyFile(new File(sourceFile), new File(destFile), null, false, false);
	 }
	 public void copyFile(String sourceFile, String destFile, FilterSetCollection filters) throws IOException {
		 copyFile(new File(sourceFile), new File(destFile), filters, false, false);
	 }
	 public void copyFile(String sourceFile, String destFile, FilterSetCollection filters, boolean overwrite) throws IOException {
		 copyFile(new File(sourceFile), new File(destFile), filters, overwrite, false);
	 }
	 public void copyFile(String sourceFile, String destFile, FilterSetCollection filters, boolean overwrite, boolean preserveLastModified) throws IOException {
		 copyFile(new File(sourceFile), new File(destFile), filters, overwrite, preserveLastModified);
	 }
	 public void copyFile(String sourceFile, String destFile, FilterSetCollection filters, boolean overwrite, boolean preserveLastModified, String encoding) throws IOException {
		 copyFile(new File(sourceFile), new File(destFile), filters, overwrite, preserveLastModified, encoding);
	 }
	 public void copyFile(String sourceFile, String destFile, FilterSetCollection filters, Vector filterChains, boolean overwrite, boolean preserveLastModified, String encoding, Project project) throws IOException {
		 copyFile(new File(sourceFile), new File(destFile), filters, filterChains, overwrite, preserveLastModified, encoding, project);
	 }
	 public void copyFile(String sourceFile, String destFile, FilterSetCollection filters, Vector filterChains, boolean overwrite, boolean preserveLastModified, String inputEncoding, String outputEncoding, Project project) throws IOException {
		 copyFile(new File(sourceFile), new File(destFile), filters, filterChains, overwrite, preserveLastModified, inputEncoding, outputEncoding, project);
	 }
	 public void copyFile(File sourceFile, File destFile) throws IOException {
		 copyFile(sourceFile, destFile, null, false, false);
	 }
	 public void copyFile(File sourceFile, File destFile, FilterSetCollection filters) throws IOException {
		 copyFile(sourceFile, destFile, filters, false, false);
	 }
	 public void copyFile(File sourceFile, File destFile, FilterSetCollection filters, boolean overwrite) throws IOException {
		 copyFile(sourceFile, destFile, filters, overwrite, false);
	 }
	 public void copyFile(File sourceFile, File destFile, FilterSetCollection filters, boolean overwrite, boolean preserveLastModified) throws IOException {
		 copyFile(sourceFile, destFile, filters, overwrite, preserveLastModified, null);
	 }
	 public void copyFile(File sourceFile, File destFile, FilterSetCollection filters, boolean overwrite, boolean preserveLastModified, String encoding) throws IOException {
		 copyFile(sourceFile, destFile, filters, null, overwrite, preserveLastModified, encoding, null);
	 }
	 public void copyFile(File sourceFile, File destFile, FilterSetCollection filters, Vector filterChains, boolean overwrite, boolean preserveLastModified, String encoding, Project project) throws IOException {
		 copyFile(sourceFile, destFile, filters, filterChains, overwrite, preserveLastModified, encoding, encoding, project);
	 }
	 public void copyFile(File sourceFile, File destFile, FilterSetCollection filters, Vector filterChains, boolean overwrite, boolean preserveLastModified, String inputEncoding, String outputEncoding, Project project) throws IOException {
		 ResourceUtils.copyResource( new FileResource(sourceFile), new FileResource(destFile), filters, filterChains, overwrite, preserveLastModified, inputEncoding, outputEncoding, project);
	 }
	 public void setFileLastModified(File file, long time) {
		 ResourceUtils.setLastModified(new FileResource(file), time);
	 }
	 public File resolveFile(File file, String filename) {
		 if (!isAbsolutePath(filename)) {
			 char sep = File.separatorChar;
			 filename = filename.replace('/', sep).replace('\\', sep);
			 if (isContextRelativePath(filename)) {
				 file = null;
				 String udir = System.getProperty(""user.dir"");
				 if (filename.charAt(0) == sep && udir.charAt(0) == sep) {
					 filename = dissect(udir)[0] + filename.substring(1);
				 }
			 }
			 filename = new File(file, filename).getAbsolutePath();
		 }
		 return normalize(filename);
	 }
	 public static boolean isContextRelativePath(String filename) {
		 if (!(ON_DOS || ON_NETWARE) || filename.length() == 0) {
			 return false;
		 }
		 char sep = File.separatorChar;
		 filename = filename.replace('/', sep).replace('\\', sep);
		 char c = filename.charAt(0);
		 int len = filename.length();
		 return (c == sep && (len == 1 || filename.charAt(1) != sep)) || (Character.isLetter(c) && len > 1 && filename.indexOf(':') == 1 && (len == 2 || filename.charAt(2) != sep));
	 }
	 public static boolean isAbsolutePath(String filename) {
		 int len = filename.length();
		 if (len == 0) {
			 return false;
		 }
		 char sep = File.separatorChar;
		 filename = filename.replace('/', sep).replace('\\', sep);
		 char c = filename.charAt(0);
		 if (!(ON_DOS || ON_NETWARE)) {
			 return (c == sep);
		 }
		 if (c == sep) {
			 if (!(ON_DOS && len > 4 && filename.charAt(1) == sep)) {
				 return false;
			 }
			 int nextsep = filename.indexOf(sep, 2);
			 return nextsep > 2 && nextsep + 1 < len;
		 }
		 int colon = filename.indexOf(':');
		 return (Character.isLetter(c) && colon == 1 && filename.length() > 2 && filename.charAt(2) == sep) || (ON_NETWARE && colon > 0);
	 }
	 public static String translatePath(String toProcess) {
		 if (toProcess == null || toProcess.length() == 0) {
			 return """";
		 }
		 StringBuffer path = new StringBuffer(toProcess.length() + EXPAND_SPACE);
		 PathTokenizer tokenizer = new PathTokenizer(toProcess);
		 while (tokenizer.hasMoreTokens()) {
			 String pathComponent = tokenizer.nextToken();
			 pathComponent = pathComponent.replace('/', File.separatorChar);
			 pathComponent = pathComponent.replace('\\', File.separatorChar);
			 if (path.length() != 0) {
				 path.append(File.pathSeparatorChar);
			 }
			 path.append(pathComponent);
		 }
		 return path.toString();
	 }
	 public File normalize(final String path) {
		 Stack s = new Stack();
		 String[] dissect = dissect(path);
		 s.push(dissect[0]);
		 StringTokenizer tok = new StringTokenizer(dissect[1], File.separator);
		 while (tok.hasMoreTokens()) {
			 String thisToken = tok.nextToken();
			 if (""."".equals(thisToken)) {
				 continue;
			 }
			 if ("".."".equals(thisToken)) {
				 if (s.size() < 2) {
					 return new File(path);
				 }
				 s.pop();
			 }
			 else {
				 s.push(thisToken);
			 }
		 }
		 StringBuffer sb = new StringBuffer();
		 for (int i = 0;
		 i < s.size();
		 i++) {
			 if (i > 1) {
				 sb.append(File.separatorChar);
			 }
			 sb.append(s.elementAt(i));
		 }
		 return new File(sb.toString());
	 }
	 public String[] dissect(String path) {
		 char sep = File.separatorChar;
		 path = path.replace('/', sep).replace('\\', sep);
		 if (!isAbsolutePath(path)) {
			 throw new BuildException(path + "" is not an absolute path"");
		 }
		 String root = null;
		 int colon = path.indexOf(':');
		 if (colon > 0 && (ON_DOS || ON_NETWARE)) {
			 int next = colon + 1;
			 root = path.substring(0, next);
			 char[] ca = path.toCharArray();
			 root += sep;
			 next = (ca[next] == sep) ? next + 1 : next;
			 StringBuffer sbPath = new StringBuffer();
			 for (int i = next;
			 i < ca.length;
			 i++) {
				 if (ca[i] != sep || ca[i - 1] != sep) {
					 sbPath.append(ca[i]);
				 }
			 }
			 path = sbPath.toString();
		 }
		 else if (path.length() > 1 && path.charAt(1) == sep) {
			 int nextsep = path.indexOf(sep, 2);
			 nextsep = path.indexOf(sep, nextsep + 1);
			 root = (nextsep > 2) ? path.substring(0, nextsep + 1) : path;
			 path = path.substring(root.length());
		 }
		 else {
			 root = File.separator;
			 path = path.substring(1);
		 }
		 return new String[] {
		root, path}
		;
	 }
	 public String toVMSPath(File f) {
		 String osPath;
		 String path = normalize(f.getAbsolutePath()).getPath();
		 String name = f.getName();
		 boolean isAbsolute = path.charAt(0) == File.separatorChar;
		 boolean isDirectory = f.isDirectory() && !name.regionMatches(true, name.length() - 4, "".DIR"", 0, 4);
		 String device = null;
		 StringBuffer directory = null;
		 String file = null;
		 int index = 0;
		 if (isAbsolute) {
			 index = path.indexOf(File.separatorChar, 1);
			 if (index == -1) {
				 return path.substring(1) + "":[000000]"";
			 }
			 device = path.substring(1, index++);
		 }
		 if (isDirectory) {
			 directory = new StringBuffer(path.substring(index).replace(File.separatorChar, '.'));
		 }
		 else {
			 int dirEnd = path.lastIndexOf(File.separatorChar, path.length());
			 if (dirEnd == -1 || dirEnd < index) {
				 file = path.substring(index);
			 }
			 else {
				 directory = new StringBuffer(path.substring(index, dirEnd). replace(File.separatorChar, '.'));
				 index = dirEnd + 1;
				 if (path.length() > index) {
					 file = path.substring(index);
				 }
			 }
		 }
		 if (!isAbsolute && directory != null) {
			 directory.insert(0, '.');
		 }
		 osPath = ((device != null) ? device + "":"" : """") + ((directory != null) ? ""["" + directory + ""]"" : """") + ((file != null) ? file : """");
		 return osPath;
	 }
	 public File createTempFile(String prefix, String suffix, File parentDir) {
		 return createTempFile(prefix, suffix, parentDir, false);
	 }
	 public File createTempFile(String prefix, String suffix, File parentDir, boolean deleteOnExit, boolean createFile) {
		 File result = null;
		 String parent = (parentDir == null) ? System.getProperty(""java.io.tmpdir"") : parentDir.getPath();
		 if (createFile) {
			 try {
				 result = File.createTempFile(prefix, suffix, new File(parent));
			 }
			 catch (IOException e) {
				 throw new BuildException(""Could not create tempfile in "" + parent, e);
			 }
		 }
		 else {
			 DecimalFormat fmt = new DecimalFormat(""#####"");
			 synchronized (rand) {
				 do {
					 result = new File(parent, prefix + fmt.format(Math.abs(rand.nextInt())) + suffix);
				 }
				 while (result.exists());
			 }
		 }
		 if (deleteOnExit) {
			 result.deleteOnExit();
		 }
		 return result;
	 }
	 public File createTempFile(String prefix, String suffix, File parentDir, boolean deleteOnExit) {
		 return createTempFile(prefix, suffix, parentDir, deleteOnExit, false);
	 }
	 public boolean contentEquals(File f1, File f2) throws IOException {
		 return contentEquals(f1, f2, false);
	 }
	 public boolean contentEquals(File f1, File f2, boolean textfile) throws IOException {
		 return ResourceUtils.contentEquals(new FileResource(f1), new FileResource(f2), textfile);
	 }
	 public File getParentFile(File f) {
		 return (f == null) ? null : f.getParentFile();
	 }
	 public static String readFully(Reader rdr) throws IOException {
		 return readFully(rdr, BUF_SIZE);
	 }
	 public static String readFully(Reader rdr, int bufferSize) throws IOException {
		 if (bufferSize <= 0) {
			 throw new IllegalArgumentException(""Buffer size must be greater "" + ""than 0"");
		 }
		 final char[] buffer = new char[bufferSize];
		 int bufferLength = 0;
		 StringBuffer textBuffer = null;
		 while (bufferLength != -1) {
			 bufferLength = rdr.read(buffer);
			 if (bufferLength > 0) {
				 textBuffer = (textBuffer == null) ? new StringBuffer() : textBuffer;
				 textBuffer.append(new String(buffer, 0, bufferLength));
			 }
		 }
		 return (textBuffer == null) ? null : textBuffer.toString();
	 }
	 public static String safeReadFully(Reader reader) throws IOException {
		 String ret = readFully(reader);
		 return ret == null ? """" : ret;
	 }
	 public boolean createNewFile(File f) throws IOException {
		 return f.createNewFile();
	 }
	 public boolean createNewFile(File f, boolean mkdirs) throws IOException {
		 File parent = f.getParentFile();
		 if (mkdirs && !(parent.exists())) {
			 parent.mkdirs();
		 }
		 return f.createNewFile();
	 }
	 public boolean isSymbolicLink(File parent, String name) throws IOException {
		 if (parent == null) {
			 File f = new File(name);
			 parent = f.getParentFile();
			 name = f.getName();
		 }
		 File toTest = new File(parent.getCanonicalPath(), name);
		 return !toTest.getAbsolutePath().equals(toTest.getCanonicalPath());
	 }
	 public String removeLeadingPath(File leading, File path) {
		 String l = normalize(leading.getAbsolutePath()).getAbsolutePath();
		 String p = normalize(path.getAbsolutePath()).getAbsolutePath();
		 if (l.equals(p)) {
			 return """";
		 }
		 if (!l.endsWith(File.separator)) {
			 l += File.separator;
		 }
		 return (p.startsWith(l)) ? p.substring(l.length()) : p;
	 }
	 public boolean isLeadingPath(File leading, File path) {
		 String l = normalize(leading.getAbsolutePath()).getAbsolutePath();
		 String p = normalize(path.getAbsolutePath()).getAbsolutePath();
		 if (l.equals(p)) {
			 return true;
		 }
		 if (!l.endsWith(File.separator)) {
			 l += File.separator;
		 }
		 return p.startsWith(l);
	 }
	 public String toURI(String path) {
		 Class uriClazz = null;
		 try {
			 uriClazz = Class.forName(""java.net.URI"");
		 }
		 catch (ClassNotFoundException e) {
		 }
		 if (uriClazz != null) {
			 try {
				 File f = new File(path).getAbsoluteFile();
				 java.lang.reflect.Method toURIMethod = File.class.getMethod(""toURI"", new Class[0]);
				 Object uriObj = toURIMethod.invoke(f, new Object[] {
				}
				);
				 java.lang.reflect.Method toASCIIStringMethod = uriClazz.getMethod(""toASCIIString"", new Class[0]);
				 return (String) toASCIIStringMethod.invoke(uriObj, new Object[] {
				}
				);
			 }
			 catch (Exception e) {
				 e.printStackTrace();
			 }
		 }
		 boolean isDir = new File(path).isDirectory();
		 StringBuffer sb = new StringBuffer(""file:"");
		 path = resolveFile(null, path).getPath();
		 sb.append("" if (!path.startsWith(File.separator)) {
			 sb.append(""/"");
		 }
		 path = path.replace('\\', '/');
		 try {
			 sb.append(Locator.encodeURI(path));
		 }
		 catch (UnsupportedEncodingException exc) {
			 throw new BuildException(exc);
		 }
		 if (isDir && !path.endsWith(""/"")) {
			 sb.append('/');
		 }
		 return sb.toString();
	 }
	 public String fromURI(String uri) {
		 synchronized (cacheFromUriLock) {
			 if (uri.equals(cacheFromUriRequest)) {
				 return cacheFromUriResponse;
			 }
			 String path = Locator.fromURI(uri);
			 String ret = isAbsolutePath(path) ? normalize(path).getAbsolutePath() : path;
			 cacheFromUriRequest = uri;
			 cacheFromUriResponse = ret;
			 return ret;
		 }
	 }
	 public boolean fileNameEquals(File f1, File f2) {
		 return normalize(f1.getAbsolutePath()).getAbsolutePath().equals( normalize(f2.getAbsolutePath()).getAbsolutePath());
	 }
	 public void rename(File from, File to) throws IOException {
		 from = normalize(from.getAbsolutePath()).getCanonicalFile();
		 to = normalize(to.getAbsolutePath());
		 if (!from.exists()) {
			 System.err.println(""Cannot rename nonexistent file "" + from);
			 return;
		 }
		 if (from.equals(to)) {
			 System.err.println(""Rename of "" + from + "" to "" + to + "" is a no-op."");
			 return;
		 }
		 if (to.exists() && !(from.equals(to.getCanonicalFile()) || to.delete())) {
			 throw new IOException(""Failed to delete "" + to + "" while trying to rename "" + from);
		 }
		 File parent = to.getParentFile();
		 if (parent != null && !parent.exists() && !parent.mkdirs()) {
			 throw new IOException(""Failed to create directory "" + parent + "" while trying to rename "" + from);
		 }
		 if (!from.renameTo(to)) {
			 copyFile(from, to);
			 if (!from.delete()) {
				 throw new IOException(""Failed to delete "" + from + "" while trying to rename it."");
			 }
		 }
	 }
	 public long getFileTimestampGranularity() {
		 if (ON_WIN9X) {
			 return FAT_FILE_TIMESTAMP_GRANULARITY;
		 }
		 if (ON_WINDOWS) {
			 return NTFS_FILE_TIMESTAMP_GRANULARITY;
		 }
		 if (ON_DOS) {
			 return FAT_FILE_TIMESTAMP_GRANULARITY;
		 }
		 return UNIX_FILE_TIMESTAMP_GRANULARITY;
	 }
	 public boolean hasErrorInCase(File localFile) {
		 localFile = normalize(localFile.getAbsolutePath());
		 if (!localFile.exists()) {
			 return false;
		 }
		 final String localFileName = localFile.getName();
		 FilenameFilter ff = new FilenameFilter () {
			 public boolean accept(File dir, String name) {
				 return name.equalsIgnoreCase(localFileName) && (!name.equals(localFileName));
			 }
		 }
		;
		 String[] names = localFile.getParentFile().list(ff);
		 return names != null && names.length == 1;
	 }
	 public boolean isUpToDate(File source, File dest, long granularity) {
		 if (!dest.exists()) {
			 return false;
		 }
		 long sourceTime = source.lastModified();
		 long destTime = dest.lastModified();
		 return isUpToDate(sourceTime, destTime, granularity);
	 }
	 public boolean isUpToDate(File source, File dest) {
		 return isUpToDate(source, dest, getFileTimestampGranularity());
	 }
	 public boolean isUpToDate(long sourceTime, long destTime, long granularity) {
		 return destTime != -1 && destTime >= sourceTime + granularity;
	 }
	 public boolean isUpToDate(long sourceTime, long destTime) {
		 return isUpToDate(sourceTime, destTime, getFileTimestampGranularity());
	 }
	 public static void close(Writer device) {
		 if (null != device) {
			 try {
				 device.close();
			 }
			 catch (IOException e) {
			 }
		 }
	 }
	 public static void close(Reader device) {
		 if (null != device) {
			 try {
				 device.close();
			 }
			 catch (IOException e) {
			 }
		 }
	 }
	 public static void close(OutputStream device) {
		 if (null != device) {
			 try {
				 device.close();
			 }
			 catch (IOException e) {
			 }
		 }
	 }
	 public static void close(InputStream device) {
		 if (null != device) {
			 try {
				 device.close();
			 }
			 catch (IOException e) {
			 }
		 }
	 }
	 public static void delete(File file) {
		 if (file != null) {
			 file.delete();
		 }
	 }
	 public static String getRelativePath(File fromFile, File toFile) throws Exception {
		 String fromPath = fromFile.getCanonicalPath();
		 String toPath = toFile.getCanonicalPath();
		 String[] fromPathStack = getPathStack(fromPath);
		 String[] toPathStack = getPathStack(toPath);
		 if (0 < toPathStack.length && 0 < fromPathStack.length) {
			 if (!fromPathStack[0].equals(toPathStack[0])) {
				 return getPath(Arrays.asList(toPathStack));
			 }
		 }
		 else {
			 return getPath(Arrays.asList(toPathStack));
		 }
		 int minLength = Math.min(fromPathStack.length, toPathStack.length);
		 int same = 1;
		 for (;
		 same < minLength && fromPathStack[same].equals(toPathStack[same]);
		 same++) {
		 }
		 List relativePathStack = new ArrayList();
		 for (int i = same;
		 i < fromPathStack.length;
		 i++) {
			 relativePathStack.add("".."");
		 }
		 for (int i = same;
		 i < toPathStack.length;
		 i++) {
			 relativePathStack.add(toPathStack[i]);
		 }
		 return getPath(relativePathStack);
	 }
	 public static String[] getPathStack(String path) {
		 String normalizedPath = path.replace(File.separatorChar, '/');
		 Object[] tokens = StringUtils.split(normalizedPath, '/').toArray();
		 String[] rv = new String[tokens.length];
		 System.arraycopy(tokens, 0, rv, 0, tokens.length);
		 return rv;
	 }
	 public static String getPath(List pathStack) {
		 return getPath(pathStack, '/');
	 }
	 public static String getPath(final List pathStack, final char separatorChar) {
		 final StringBuffer buffer = new StringBuffer();
		 final Iterator iter = pathStack.iterator();
		 if (iter.hasNext()) {
			 buffer.append(iter.next());
		 }
		 while (iter.hasNext()) {
			 buffer.append(separatorChar);
			 buffer.append(iter.next());
		 }
		 return buffer.toString();
	 }
	 public String getDefaultEncoding() {
		 InputStreamReader is = new InputStreamReader( new InputStream() {
			 public int read() {
				 return -1;
			 }
		 }
		);
		 try {
			 return is.getEncoding();
		 }
		 finally {
			 close(is);
		 }
	 }
}",0,0,0,0
"public Component getTreeCellRendererComponent(JTree tree,Object value,boolean sel,boolean expanded,boolean leaf,int row,boolean hasFocus);",0,0,0,1
"public void setAnchor( short col1, int row1, int x1, int y1, short col2, int row2, int x2, int y2 );",0,0,0,1
"final class SortSettings {
	 private AbstractTranslet _translet;
	 private int[] _sortOrders;
	 private int[] _types;
	 private Locale[] _locales;
	 private Collator[] _collators;
	 private String[] _caseOrders;
	 SortSettings(AbstractTranslet translet, int[] sortOrders, int[] types, Locale[] locales, Collator[] collators, String[] caseOrders) {
		 _translet = translet;
		 _sortOrders = sortOrders;
		 _types = types;
		 _locales = locales;
		 _collators = collators;
		 _caseOrders = caseOrders;
	 }
	 AbstractTranslet getTranslet() {
		 return _translet;
	 }
	 int[] getSortOrders() {
		 return _sortOrders;
	 }
	 int[] getTypes() {
		 return _types;
	 }
	 Locale[] getLocales() {
		 return _locales;
	 }
	 Collator[] getCollators() {
		 return _collators;
	 }
	 String[] getCaseOrders() {
		 return _caseOrders;
	 }
}",0,1,0,0
"private void updateChunksUpTo(int lastScreenLine){
	if(lastScreenLine >= lineInfo.length)throw new ArrayIndexOutOfBoundsException(lastScreenLine);
	if(lastScreenLine < firstInvalidLine)return;
	int firstScreenLine = getFirstScreenLine();
	int physicalLine = getUpdateStartLine(firstScreenLine);
	if(Debug.CHUNK_CACHE_DEBUG){
		Log.log(Log.DEBUG,this,""Updating chunks from "" + firstScreenLine+ "" to "" + lastScreenLine);
	}
	out.clear();
	int offset;
	int length;
	for(int i = firstScreenLine;
	 i <= lastScreenLine;
	 i++){
		LineInfo info = lineInfo[i];
		Chunk chunks;
		if(out.isEmpty()){
			if(physicalLine != -1 && i != firstScreenLine){
				physicalLine = textArea.displayManager.getNextVisibleLine(physicalLine);
			}
			if(physicalLine == -1){
				info.chunks = null;
				info.physicalLine = -1;
				info.width = 0;
				continue;
			}
			lineToChunkList(physicalLine,out);
			info.firstSubregion = true;
			if(out.isEmpty()){
				if(i == 0){
					if(textArea.displayManager.firstLine.skew > 0){
						Log.log(Log.ERROR,this,""BUG: skew="" + textArea.displayManager.firstLine.skew + "",out.size()="" + out.size());
						textArea.displayManager.firstLine.skew = 0;
						needFullRepaint = true;
						lastScreenLine = lineInfo.length - 1;
					}
				}
				chunks = null;
				offset = 0;
				length = 1;
			}
			else{
				if(i == 0){
					int skew = textArea.displayManager.firstLine.skew;
					if(skew >= out.size()){
						Log.log(Log.ERROR,this,""BUG: skew="" + skew + "",out.size()="" + out.size());
						needFullRepaint = true;
						lastScreenLine = lineInfo.length - 1;
					}
					else if(skew > 0){
						info.firstSubregion = false;
						for(int j = 0;
						 j < skew;
						 j++)out.remove(0);
					}
				}
				chunks = out.remove(0);
				offset = chunks.offset;
				if (!out.isEmpty())length = out.get(0).offset - offset;
				elselength = textArea.getLineLength(physicalLine) - offset + 1;
			}
		}
		else{
			info.firstSubregion = false;
			chunks = out.remove(0);
			offset = chunks.offset;
			if (!out.isEmpty())length = out.get(0).offset - offset;
			elselength = textArea.getLineLength(physicalLine) - offset + 1;
		}
		boolean lastSubregion = out.isEmpty();
		if(i == lastScreenLine&& lastScreenLine != lineInfo.length - 1){
			if(tokenHandler.getLineContext() !=info.lineContext){
				lastScreenLine++;
				needFullRepaint = true;
			}
			else if(info.physicalLine != physicalLine|| info.lastSubregion != lastSubregion){
				lastScreenLine++;
				needFullRepaint = true;
			}
			else if (!out.isEmpty())lastScreenLine++;
		}
		info.physicalLine = physicalLine;
		info.lastSubregion = lastSubregion;
		info.offset = offset;
		info.length = length;
		info.chunks = chunks;
		info.lineContext = tokenHandler.getLineContext();
	}
	firstInvalidLine = Math.max(lastScreenLine + 1,firstInvalidLine);
}",0,0,1,0
"public int get_count(ByteBuffer key, ColumnParent columnParent, SlicePredicate predicate, ConsistencyLevel consistencyLevel) throws AvroRemoteException, InvalidRequestException, UnavailableException, TimedOutException {
	 if (logger.isDebugEnabled()) logger.debug(""get_count"");
	 return (int)get_slice(key, columnParent, predicate, consistencyLevel).size();
 }",0,0,0,0
"public class NullNode extends AbstractProcessingNode {
	 public NullNode() {
		 super(null);
	 }
	 public final boolean invoke(Environment env, InvokeContext context) throws Exception {
		 getLogger().warn(""Invoke on NullNode at "" + getLocation());
		 return false;
	 }
}",0,0,0,0
"public void execute() throws BuildException {
	 if (""style"".equals(getTaskType())) {
		 log(""Warning: the task name <style> is deprecated. Use <xslt> instead."", Project.MSG_WARN);
	 }
	 File savedBaseDir = baseDir;
	 DirectoryScanner scanner;
	 String[] list;
	 String[] dirs;
	 String baseMessage = ""specify the stylesheet either as a filename in style attribute "" + ""or as a nested resource"";
	 if (xslResource == null && xslFile == null) {
		 handleError(baseMessage);
		 return;
	 }
	 if (xslResource != null && xslFile != null) {
		 handleError(baseMessage + "" but not as both"");
		 return;
	 }
	 if (inFile != null && !inFile.exists()) {
		 handleError(""input file "" + inFile + "" does not exist"");
		 return;
	 }
	 try {
		 setupLoader();
		 if (sysProperties.size() > 0) {
			 sysProperties.setSystem();
		 }
		 Resource styleResource;
		 if (baseDir == null) {
			 baseDir = getProject().getBaseDir();
		 }
		 liaison = getLiaison();
		 if (liaison instanceof XSLTLoggerAware) {
			 ((XSLTLoggerAware) liaison).setLogger(this);
		 }
		 log(""Using "" + liaison.getClass().toString(), Project.MSG_VERBOSE);
		 if (xslFile != null) {
			 File stylesheet = getProject().resolveFile(xslFile);
			 if (!stylesheet.exists()) {
				 File alternative = FILE_UTILS.resolveFile(baseDir, xslFile);
				 if (alternative.exists()) {
					 log(""DEPRECATED - the 'style' attribute should be "" + ""relative to the project's"");
					 log("" basedir, not the tasks's basedir."");
					 stylesheet = alternative;
				 }
			 }
			 FileResource fr = new FileResource();
			 fr.setProject(getProject());
			 fr.setFile(stylesheet);
			 styleResource = fr;
		 }
		 else {
			 styleResource = xslResource;
		 }
		 if (!styleResource.isExists()) {
			 handleError(""stylesheet "" + styleResource + "" doesn't exist."");
			 return;
		 }
		 if (inFile != null && outFile != null) {
			 process(inFile, outFile, styleResource);
			 return;
		 }
		 checkDest();
		 if (useImplicitFileset) {
			 scanner = getDirectoryScanner(baseDir);
			 log(""Transforming into "" + destDir, Project.MSG_INFO);
			 list = scanner.getIncludedFiles();
			 for (int i = 0;
			 i < list.length;
			 ++i) {
				 process(baseDir, list[i], destDir, styleResource);
			 }
			 if (performDirectoryScan) {
				 dirs = scanner.getIncludedDirectories();
				 for (int j = 0;
				 j < dirs.length;
				 ++j) {
					 list = new File(baseDir, dirs[j]).list();
					 for (int i = 0;
					 i < list.length;
					 ++i) {
						 process(baseDir, dirs[j] + File.separator + list[i], destDir, styleResource);
					 }
				 }
			 }
		 }
		 else {
			 if (resources.size() == 0) {
				 if (failOnNoResources) {
					 handleError(""no resources specified"");
				 }
				 return;
			 }
		 }
		 processResources(styleResource);
	 }
	 finally {
		 if (loader != null) {
			 loader.resetThreadContextLoader();
			 loader.cleanup();
			 loader = null;
		 }
		 if (sysProperties.size() > 0) {
			 sysProperties.restoreSystem();
		 }
		 liaison = null;
		 stylesheetLoaded = false;
		 baseDir = savedBaseDir;
	 }
 }",0,0,1,0
"public void read(org.apache.thrift.protocol.TProtocol iprot, WMTrigger struct) throws org.apache.thrift.TException {
	 org.apache.thrift.protocol.TField schemeField;
	 iprot.readStructBegin();
	 while (true) {
		 schemeField = iprot.readFieldBegin();
		 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
			 break;
		 }
		 switch (schemeField.id) {
			 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
				 struct.resourcePlanName = iprot.readString();
				 struct.setResourcePlanNameIsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 case 2: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
				 struct.triggerName = iprot.readString();
				 struct.setTriggerNameIsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 case 3: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
				 struct.triggerExpression = iprot.readString();
				 struct.setTriggerExpressionIsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 case 4: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
				 struct.actionExpression = iprot.readString();
				 struct.setActionExpressionIsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 case 5: if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
				 struct.isInUnmanaged = iprot.readBool();
				 struct.setIsInUnmanagedIsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 case 6: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
				 struct.ns = iprot.readString();
				 struct.setNsIsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
		 }
		 iprot.readFieldEnd();
	 }
	 iprot.readStructEnd();
	 struct.validate();
 }",0,0,1,0
"class ReduceTask extends Task {
	 static {
		 WritableFactories.setFactory (ReduceTask.class, new WritableFactory() {
			 public Writable newInstance() {
				 return new ReduceTask();
			 }
		 }
		);
	 }
	 private class ReduceTaskMetrics {
		 private MetricsRecord metricsRecord = null;
		 private long numInputRecords = 0L;
		 private long numOutputRecords = 0L;
		 ReduceTaskMetrics(String taskId) {
			 metricsRecord = Metrics.createRecord(""mapred"", ""reduce"", ""taskid"", taskId);
		 }
		 synchronized void reduceInput() {
			 Metrics.report(metricsRecord, ""input-records"", ++numInputRecords);
		 }
		 synchronized void reduceOutput() {
			 Metrics.report(metricsRecord, ""output-records"", ++numOutputRecords);
		 }
	 }
	 private ReduceTaskMetrics myMetrics = null;
	 private int numMaps;
	 private boolean sortComplete;
	 {
		 getProgress().setStatus(""reduce"");
		 setPhase(TaskStatus.Phase.SHUFFLE);
	 }
	 private Progress copyPhase = getProgress().addPhase(""copy"");
	 private Progress sortPhase = getProgress().addPhase(""sort"");
	 private Progress reducePhase = getProgress().addPhase(""reduce"");
	 private JobConf conf;
	 private MapOutputFile mapOutputFile = new MapOutputFile();
	 public ReduceTask() {
	}
	 public ReduceTask(String jobId, String jobFile, String tipId, String taskId, int partition, int numMaps) {
		 super(jobId, jobFile, tipId, taskId, partition);
		 this.numMaps = numMaps;
		 myMetrics = new ReduceTaskMetrics(taskId);
	 }
	 public TaskRunner createRunner(TaskTracker tracker) throws IOException {
		 return new ReduceTaskRunner(this, tracker, this.conf);
	 }
	 public boolean isMapTask() {
		 return false;
	 }
	 public int getNumMaps() {
		 return numMaps;
	 }
	 public void localizeConfiguration(JobConf conf) {
		 super.localizeConfiguration(conf);
		 conf.setNumMapTasks(numMaps);
	 }
	 public void write(DataOutput out) throws IOException {
		 super.write(out);
		 out.writeInt(numMaps);
	 }
	 public void readFields(DataInput in) throws IOException {
		 super.readFields(in);
		 numMaps = in.readInt();
		 if (myMetrics == null) {
			 myMetrics = new ReduceTaskMetrics(getTaskId());
		 }
	 }
	 private class ValuesIterator implements Iterator {
		 private SequenceFile.Sorter.RawKeyValueIterator in;
		 private WritableComparable key;
		 private Writable value;
		 private boolean hasNext;
		 private boolean more;
		 private TaskUmbilicalProtocol umbilical;
		 private WritableComparator comparator;
		 private Class keyClass;
		 private Class valClass;
		 private DataOutputBuffer valOut = new DataOutputBuffer();
		 private DataInputBuffer valIn = new DataInputBuffer();
		 private DataInputBuffer keyIn = new DataInputBuffer();
		 public ValuesIterator (SequenceFile.Sorter.RawKeyValueIterator in, WritableComparator comparator, Class keyClass, Class valClass, TaskUmbilicalProtocol umbilical) throws IOException {
			 this.in = in;
			 this.umbilical = umbilical;
			 this.comparator = comparator;
			 this.keyClass = keyClass;
			 this.valClass = valClass;
			 getNext();
		 }
		 public boolean hasNext() {
			 return hasNext;
		 }
		 public Object next() {
			 try {
				 Object result = value;
				 getNext();
				 return result;
			 }
			 catch (IOException e) {
				 throw new RuntimeException(e);
			 }
		 }
		 public void remove() {
			 throw new RuntimeException(""not implemented"");
		 }
		 public void nextKey() {
			 while (hasNext) {
				 next();
			 }
			 hasNext = more;
		 }
		 public boolean more() {
			 return more;
		 }
		 public WritableComparable getKey() {
			 return key;
		 }
		 private void getNext() throws IOException {
			 reducePhase.set(in.getProgress().get());
			 reportProgress(umbilical);
			 Writable lastKey = key;
			 try {
				 key = (WritableComparable)keyClass.newInstance();
				 value = (Writable)valClass.newInstance();
			 }
			 catch (Exception e) {
				 throw new RuntimeException(e);
			 }
			 more = in.next();
			 if (more) {
				 keyIn.reset(in.getKey().getData(), in.getKey().getLength());
				 key.readFields(keyIn);
				 valOut.reset();
				 (in.getValue()).writeUncompressedBytes(valOut);
				 valIn.reset(valOut.getData(), valOut.getLength());
				 value.readFields(valIn);
				 if (lastKey == null) {
					 hasNext = true;
				 }
				 else {
					 hasNext = (comparator.compare(key, lastKey) == 0);
				 }
			 }
			 else {
				 hasNext = false;
			 }
		 }
	 }
	 public void run(JobConf job, final TaskUmbilicalProtocol umbilical) throws IOException {
		 Class valueClass = job.getMapOutputValueClass();
		 Reducer reducer = (Reducer)ReflectionUtils.newInstance( job.getReducerClass(), job);
		 reducer.configure(job);
		 FileSystem lfs = FileSystem.getNamed(""local"", job);
		 copyPhase.complete();
		 Path[] mapFiles = new Path[numMaps];
		 for(int i=0;
		 i < numMaps;
		 i++) {
			 mapFiles[i] = mapOutputFile.getInputFile(i, getTaskId());
		 }
		 Thread sortProgress = new Thread() {
			 public void run() {
				 while (!sortComplete) {
					 try {
						 reportProgress(umbilical);
						 Thread.sleep(PROGRESS_INTERVAL);
					 }
					 catch (InterruptedException e) {
						 return;
					 }
					 catch (Throwable e) {
						 System.out.println(""Thread Exception in "" + ""reporting sort progress\n"" + StringUtils.stringifyException(e));
						 continue;
					 }
				 }
			 }
		 }
		;
		 sortProgress.setName(""Sort progress reporter for task ""+getTaskId());
		 Path tempDir = job.getLocalPath(getTaskId());
		 WritableComparator comparator = job.getOutputKeyComparator();
		 SequenceFile.Sorter.RawKeyValueIterator rIter;
		 try {
			 setPhase(TaskStatus.Phase.SORT) ;
			 sortProgress.start();
			 SequenceFile.Sorter sorter = new SequenceFile.Sorter(lfs, comparator, valueClass, job);
			 rIter = sorter.sortAndIterate(mapFiles, tempDir, !conf.getKeepFailedTaskFiles());
		 }
		 finally {
			 sortComplete = true;
		 }
		 sortPhase.complete();
		 setPhase(TaskStatus.Phase.REDUCE);
		 Reporter reporter = getReporter(umbilical, getProgress());
		 String finalName = getOutputName(getPartition());
		 boolean runSpeculative = job.getSpeculativeExecution();
		 FileSystem fs = FileSystem.get(job) ;
		 if( runSpeculative ){
			 fs = new PhasedFileSystem (fs , getJobId(), getTipId(), getTaskId());
		 }
		 final RecordWriter out = job.getOutputFormat().getRecordWriter(fs, job, finalName, reporter) ;
		 OutputCollector collector = new OutputCollector() {
			 public void collect(WritableComparable key, Writable value) throws IOException {
				 out.write(key, value);
				 myMetrics.reduceOutput();
				 reportProgress(umbilical);
			 }
		 }
		;
		 try {
			 Class keyClass = job.getMapOutputKeyClass();
			 Class valClass = job.getMapOutputValueClass();
			 ValuesIterator values = new ValuesIterator(rIter, comparator, keyClass, valClass, umbilical);
			 while (values.more()) {
				 myMetrics.reduceInput();
				 reducer.reduce(values.getKey(), values, collector, reporter);
				 values.nextKey();
			 }
		 }
		 finally {
			 reducer.close();
			 out.close(reporter);
			 if( runSpeculative ){
				 ((PhasedFileSystem)fs).commit();
			 }
		 }
		 done(umbilical);
	 }
	 private static final NumberFormat NUMBER_FORMAT = NumberFormat.getInstance();
	 static {
		 NUMBER_FORMAT.setMinimumIntegerDigits(5);
		 NUMBER_FORMAT.setGroupingUsed(false);
	 }
	 static synchronized String getOutputName(int partition) {
		 return ""part-"" + NUMBER_FORMAT.format(partition);
	 }
	 public void setConf(Configuration conf) {
		 if (conf instanceof JobConf) {
			 this.conf = (JobConf) conf;
		 }
		 else {
			 this.conf = new JobConf(conf);
		 }
		 this.mapOutputFile.setConf(this.conf);
	 }
	 public Configuration getConf() {
		 return this.conf;
	 }
}",0,0,0,0
"public class Zip extends MatchingTask {
	 private static final int BUFFER_SIZE = 8 * 1024;
	 private static final int ROUNDUP_MILLIS = 1999;
	 protected File zipFile;
	 private ZipScanner zs;
	 private File baseDir;
	 protected Hashtable entries = new Hashtable();
	 private Vector groupfilesets = new Vector();
	 private Vector filesetsFromGroupfilesets = new Vector();
	 protected String duplicate = ""add"";
	 private boolean doCompress = true;
	 private boolean doUpdate = false;
	 private boolean savedDoUpdate = false;
	 private boolean doFilesonly = false;
	 protected String archiveType = ""zip"";
	 private static final long EMPTY_CRC = new CRC32 ().getValue ();
	 protected String emptyBehavior = ""skip"";
	 private Vector resources = new Vector();
	 protected Hashtable addedDirs = new Hashtable();
	 private Vector addedFiles = new Vector();
	 private static final ResourceSelector MISSING_SELECTOR = new ResourceSelector() {
		 public boolean isSelected(Resource target) {
			 return !target.isExists();
		 }
	 }
	;
	 private static final ResourceUtils.ResourceSelectorProvider MISSING_DIR_PROVIDER = new ResourceUtils.ResourceSelectorProvider() {
		 public ResourceSelector getTargetSelectorForSource(Resource sr) {
			 return MISSING_SELECTOR;
		 }
	 }
	;
	 protected boolean doubleFilePass = false;
	 protected boolean skipWriting = false;
	 protected final boolean isFirstPass() {
		 return !doubleFilePass || skipWriting;
	 }
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private boolean updatedFile = false;
	 private boolean addingNewFiles = false;
	 private String encoding;
	 private boolean keepCompression = false;
	 private boolean roundUp = true;
	 private String comment = """";
	 private int level = ZipOutputStream.DEFAULT_COMPRESSION;
	 private boolean preserve0Permissions = false;
	 private boolean useLanguageEncodingFlag = true;
	 private UnicodeExtraField createUnicodeExtraFields = UnicodeExtraField.NEVER;
	 private boolean fallBackToUTF8 = false;
	 public void setZipfile(File zipFile) {
		 setDestFile(zipFile);
	 }
	 public void setFile(File file) {
		 setDestFile(file);
	 }
	 public void setDestFile(File destFile) {
		 this.zipFile = destFile;
	 }
	 public File getDestFile() {
		 return zipFile;
	 }
	 public void setBasedir(File baseDir) {
		 this.baseDir = baseDir;
	 }
	 public void setCompress(boolean c) {
		 doCompress = c;
	 }
	 public boolean isCompress() {
		 return doCompress;
	 }
	 public void setFilesonly(boolean f) {
		 doFilesonly = f;
	 }
	 public void setUpdate(boolean c) {
		 doUpdate = c;
		 savedDoUpdate = c;
	 }
	 public boolean isInUpdateMode() {
		 return doUpdate;
	 }
	 public void addFileset(FileSet set) {
		 add(set);
	 }
	 public void addZipfileset(ZipFileSet set) {
		 add(set);
	 }
	 public void add(ResourceCollection a) {
		 resources.add(a);
	 }
	 public void addZipGroupFileset(FileSet set) {
		 groupfilesets.addElement(set);
	 }
	 public void setDuplicate(Duplicate df) {
		 duplicate = df.getValue();
	 }
	 public static class WhenEmpty extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""fail"", ""skip"", ""create""}
			;
		 }
	 }
	 public void setWhenempty(WhenEmpty we) {
		 emptyBehavior = we.getValue();
	 }
	 public void setEncoding(String encoding) {
		 this.encoding = encoding;
	 }
	 public String getEncoding() {
		 return encoding;
	 }
	 public void setKeepCompression(boolean keep) {
		 keepCompression = keep;
	 }
	 public void setComment(String comment) {
		 this.comment = comment;
	 }
	 public String getComment() {
		 return comment;
	 }
	 public void setLevel(int level) {
		 this.level = level;
	 }
	 public int getLevel() {
		 return level;
	 }
	 public void setRoundUp(boolean r) {
		 roundUp = r;
	 }
	 public void setPreserve0Permissions(boolean b) {
		 preserve0Permissions = b;
	 }
	 public boolean getPreserve0Permissions() {
		 return preserve0Permissions;
	 }
	 public void setUseLanguageEncodingFlag(boolean b) {
		 useLanguageEncodingFlag = b;
	 }
	 public boolean getUseLanguageEnodingFlag() {
		 return useLanguageEncodingFlag;
	 }
	 public void setCreateUnicodeExtraFields(UnicodeExtraField b) {
		 createUnicodeExtraFields = b;
	 }
	 public UnicodeExtraField getCreateUnicodeExtraFields() {
		 return createUnicodeExtraFields;
	 }
	 public void setFallBackToUTF8(boolean b) {
		 fallBackToUTF8 = b;
	 }
	 public boolean getFallBackToUTF8() {
		 return fallBackToUTF8;
	 }
	 public void execute() throws BuildException {
		 if (doubleFilePass) {
			 skipWriting = true;
			 executeMain();
			 skipWriting = false;
			 executeMain();
		 }
		 else {
			 executeMain();
		 }
	 }
	 protected boolean hasUpdatedFile() {
		 return updatedFile;
	 }
	 public void executeMain() throws BuildException {
		 checkAttributesAndElements();
		 File renamedFile = null;
		 addingNewFiles = true;
		 processDoUpdate();
		 processGroupFilesets();
		 Vector vfss = new Vector();
		 if (baseDir != null) {
			 FileSet fs = (FileSet) getImplicitFileSet().clone();
			 fs.setDir(baseDir);
			 vfss.addElement(fs);
		 }
		 final int size = resources.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 ResourceCollection rc = (ResourceCollection) resources.elementAt(i);
			 vfss.addElement(rc);
		 }
		 ResourceCollection[] fss = new ResourceCollection[vfss.size()];
		 vfss.copyInto(fss);
		 boolean success = false;
		 try {
			 ArchiveState state = getResourcesToAdd(fss, zipFile, false);
			 if (!state.isOutOfDate()) {
				 return;
			 }
			 File parent = zipFile.getParentFile();
			 if (parent != null && !parent.isDirectory() && !parent.mkdirs()) {
				 throw new BuildException(""Failed to create missing parent"" + "" directory for "" + zipFile);
			 }
			 updatedFile = true;
			 if (!zipFile.exists() && state.isWithoutAnyResources()) {
				 createEmptyZip(zipFile);
				 return;
			 }
			 Resource[][] addThem = state.getResourcesToAdd();
			 if (doUpdate) {
				 renamedFile = renameFile();
			 }
			 String action = doUpdate ? ""Updating "" : ""Building "";
			 if (!skipWriting) {
				 log(action + archiveType + "": "" + zipFile.getAbsolutePath());
			 }
			 ZipOutputStream zOut = null;
			 try {
				 if (!skipWriting) {
					 zOut = new ZipOutputStream(zipFile);
					 zOut.setEncoding(encoding);
					 zOut.setUseLanguageEncodingFlag(useLanguageEncodingFlag);
					 zOut.setCreateUnicodeExtraFields(createUnicodeExtraFields. getPolicy());
					 zOut.setFallbackToUTF8(fallBackToUTF8);
					 zOut.setMethod(doCompress ? ZipOutputStream.DEFLATED : ZipOutputStream.STORED);
					 zOut.setLevel(level);
				 }
				 initZipOutputStream(zOut);
				 for (int i = 0;
				 i < fss.length;
				 i++) {
					 if (addThem[i].length != 0) {
						 addResources(fss[i], addThem[i], zOut);
					 }
				 }
				 if (doUpdate) {
					 addingNewFiles = false;
					 ZipFileSet oldFiles = new ZipFileSet();
					 oldFiles.setProject(getProject());
					 oldFiles.setSrc(renamedFile);
					 oldFiles.setDefaultexcludes(false);
					 final int addSize = addedFiles.size();
					 for (int i = 0;
					 i < addSize;
					 i++) {
						 PatternSet.NameEntry ne = oldFiles.createExclude();
						 ne.setName((String) addedFiles.elementAt(i));
					 }
					 DirectoryScanner ds = oldFiles.getDirectoryScanner(getProject());
					 ((ZipScanner) ds).setEncoding(encoding);
					 String[] f = ds.getIncludedFiles();
					 Resource[] r = new Resource[f.length];
					 for (int i = 0;
					 i < f.length;
					 i++) {
						 r[i] = ds.getResource(f[i]);
					 }
					 if (!doFilesonly) {
						 String[] d = ds.getIncludedDirectories();
						 Resource[] dr = new Resource[d.length];
						 for (int i = 0;
						 i < d.length;
						 i++) {
							 dr[i] = ds.getResource(d[i]);
						 }
						 Resource[] tmp = r;
						 r = new Resource[tmp.length + dr.length];
						 System.arraycopy(dr, 0, r, 0, dr.length);
						 System.arraycopy(tmp, 0, r, dr.length, tmp.length);
					 }
					 addResources(oldFiles, r, zOut);
				 }
				 if (zOut != null) {
					 zOut.setComment(comment);
				 }
				 finalizeZipOutputStream(zOut);
				 if (doUpdate) {
					 if (!renamedFile.delete()) {
						 log (""Warning: unable to delete temporary file "" + renamedFile.getName(), Project.MSG_WARN);
					 }
				 }
				 success = true;
			 }
			 finally {
				 closeZout(zOut, success);
			 }
		 }
		 catch (IOException ioe) {
			 String msg = ""Problem creating "" + archiveType + "": "" + ioe.getMessage();
			 if ((!doUpdate || renamedFile != null) && !zipFile.delete()) {
				 msg += "" (and the archive is probably corrupt but I could not "" + ""delete it)"";
			 }
			 if (doUpdate && renamedFile != null) {
				 try {
					 FILE_UTILS.rename(renamedFile, zipFile);
				 }
				 catch (IOException e) {
					 msg += "" (and I couldn't rename the temporary file "" + renamedFile.getName() + "" back)"";
				 }
			 }
			 throw new BuildException(msg, ioe, getLocation());
		 }
		 finally {
			 cleanUp();
		 }
	 }
	 private File renameFile() {
		 File renamedFile = FILE_UTILS.createTempFile( ""zip"", "".tmp"", zipFile.getParentFile(), true, false);
		 try {
			 FILE_UTILS.rename(zipFile, renamedFile);
		 }
		 catch (SecurityException e) {
			 throw new BuildException( ""Not allowed to rename old file ("" + zipFile.getAbsolutePath() + "") to temporary file"");
		 }
		 catch (IOException e) {
			 throw new BuildException( ""Unable to rename old file ("" + zipFile.getAbsolutePath() + "") to temporary file"");
		 }
		 return renamedFile;
	 }
	 private void closeZout(ZipOutputStream zOut, boolean success) throws IOException {
		 if (zOut == null) {
			 return;
		 }
		 try {
			 zOut.close();
		 }
		 catch (IOException ex) {
			 if (success) {
				 throw ex;
			 }
		 }
	 }
	 private void checkAttributesAndElements() {
		 if (baseDir == null && resources.size() == 0 && groupfilesets.size() == 0 && ""zip"".equals(archiveType)) {
			 throw new BuildException(""basedir attribute must be set, "" + ""or at least one "" + ""resource collection must be given!"");
		 }
		 if (zipFile == null) {
			 throw new BuildException(""You must specify the "" + archiveType + "" file to create!"");
		 }
		 if (zipFile.exists() && !zipFile.isFile()) {
			 throw new BuildException(zipFile + "" is not a file."");
		 }
		 if (zipFile.exists() && !zipFile.canWrite()) {
			 throw new BuildException(zipFile + "" is read-only."");
		 }
	 }
	 private void processDoUpdate() {
		 if (doUpdate && !zipFile.exists()) {
			 doUpdate = false;
			 logWhenWriting(""ignoring update attribute as "" + archiveType + "" doesn't exist."", Project.MSG_DEBUG);
		 }
	 }
	 private void processGroupFilesets() {
		 final int size = groupfilesets.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 logWhenWriting(""Processing groupfileset "", Project.MSG_VERBOSE);
			 FileSet fs = (FileSet) groupfilesets.elementAt(i);
			 FileScanner scanner = fs.getDirectoryScanner(getProject());
			 String[] files = scanner.getIncludedFiles();
			 File basedir = scanner.getBasedir();
			 for (int j = 0;
			 j < files.length;
			 j++) {
				 logWhenWriting(""Adding file "" + files[j] + "" to fileset"", Project.MSG_VERBOSE);
				 ZipFileSet zf = new ZipFileSet();
				 zf.setProject(getProject());
				 zf.setSrc(new File(basedir, files[j]));
				 add(zf);
				 filesetsFromGroupfilesets.addElement(zf);
			 }
		 }
	 }
	 protected final boolean isAddingNewFiles() {
		 return addingNewFiles;
	 }
	 protected final void addResources(FileSet fileset, Resource[] resources, ZipOutputStream zOut) throws IOException {
		 String prefix = """";
		 String fullpath = """";
		 int dirMode = ArchiveFileSet.DEFAULT_DIR_MODE;
		 int fileMode = ArchiveFileSet.DEFAULT_FILE_MODE;
		 ArchiveFileSet zfs = null;
		 if (fileset instanceof ArchiveFileSet) {
			 zfs = (ArchiveFileSet) fileset;
			 prefix = zfs.getPrefix(getProject());
			 fullpath = zfs.getFullpath(getProject());
			 dirMode = zfs.getDirMode(getProject());
			 fileMode = zfs.getFileMode(getProject());
		 }
		 if (prefix.length() > 0 && fullpath.length() > 0) {
			 throw new BuildException(""Both prefix and fullpath attributes must"" + "" not be set on the same fileset."");
		 }
		 if (resources.length != 1 && fullpath.length() > 0) {
			 throw new BuildException(""fullpath attribute may only be specified"" + "" for filesets that specify a single"" + "" file."");
		 }
		 if (prefix.length() > 0) {
			 if (!prefix.endsWith(""/"") && !prefix.endsWith(""\\"")) {
				 prefix += ""/"";
			 }
			 addParentDirs(null, prefix, zOut, """", dirMode);
		 }
		 ZipFile zf = null;
		 try {
			 boolean dealingWithFiles = false;
			 File base = null;
			 if (zfs == null || zfs.getSrc(getProject()) == null) {
				 dealingWithFiles = true;
				 base = fileset.getDir(getProject());
			 }
			 else if (zfs instanceof ZipFileSet) {
				 zf = new ZipFile(zfs.getSrc(getProject()), encoding);
			 }
			 for (int i = 0;
			 i < resources.length;
			 i++) {
				 String name = null;
				 if (fullpath.length() > 0) {
					 name = fullpath;
				 }
				 else {
					 name = resources[i].getName();
				 }
				 name = name.replace(File.separatorChar, '/');
				 if ("""".equals(name)) {
					 continue;
				 }
				 if (resources[i].isDirectory()) {
					 if (doFilesonly) {
						 continue;
					 }
					 int thisDirMode = zfs != null && zfs.hasDirModeBeenSet() ? dirMode : getUnixMode(resources[i], zf, dirMode);
					 addDirectoryResource(resources[i], name, prefix, base, zOut, dirMode, thisDirMode);
				 }
				 else {
					 addParentDirs(base, name, zOut, prefix, dirMode);
					 if (dealingWithFiles) {
						 File f = FILE_UTILS.resolveFile(base, resources[i].getName());
						 zipFile(f, zOut, prefix + name, fileMode);
					 }
					 else {
						 int thisFileMode = zfs != null && zfs.hasFileModeBeenSet() ? fileMode : getUnixMode(resources[i], zf, fileMode);
						 addResource(resources[i], name, prefix, zOut, thisFileMode, zf, zfs == null ? null : zfs.getSrc(getProject()));
					 }
				 }
			 }
		 }
		 finally {
			 if (zf != null) {
				 zf.close();
			 }
		 }
	 }
	 private void addDirectoryResource(Resource r, String name, String prefix, File base, ZipOutputStream zOut, int defaultDirMode, int thisDirMode) throws IOException {
		 if (!name.endsWith(""/"")) {
			 name = name + ""/"";
		 }
		 int nextToLastSlash = name.lastIndexOf(""/"", name.length() - 2);
		 if (nextToLastSlash != -1) {
			 addParentDirs(base, name.substring(0, nextToLastSlash + 1), zOut, prefix, defaultDirMode);
		 }
		 zipDir(r, zOut, prefix + name, thisDirMode, r instanceof ZipResource ? ((ZipResource) r).getExtraFields() : null);
	 }
	 private int getUnixMode(Resource r, ZipFile zf, int defaultMode) throws IOException {
		 int unixMode = defaultMode;
		 if (zf != null) {
			 ZipEntry ze = zf.getEntry(r.getName());
			 unixMode = ze.getUnixMode();
			 if ((unixMode == 0 || unixMode == UnixStat.DIR_FLAG) && !preserve0Permissions) {
				 unixMode = defaultMode;
			 }
		 }
		 else if (r instanceof ArchiveResource) {
			 unixMode = ((ArchiveResource) r).getMode();
		 }
		 return unixMode;
	 }
	 private void addResource(Resource r, String name, String prefix, ZipOutputStream zOut, int mode, ZipFile zf, File fromArchive) throws IOException {
		 if (zf != null) {
			 ZipEntry ze = zf.getEntry(r.getName());
			 if (ze != null) {
				 boolean oldCompress = doCompress;
				 if (keepCompression) {
					 doCompress = (ze.getMethod() == ZipEntry.DEFLATED);
				 }
				 InputStream is = null;
				 try {
					 is = zf.getInputStream(ze);
					 zipFile(is, zOut, prefix + name, ze.getTime(), fromArchive, mode, ze.getExtraFields(true));
				 }
				 finally {
					 doCompress = oldCompress;
					 FileUtils.close(is);
				 }
			 }
		 }
		 else {
			 InputStream is = null;
			 try {
				 is = r.getInputStream();
				 zipFile(is, zOut, prefix + name, r.getLastModified(), fromArchive, mode, r instanceof ZipResource ? ((ZipResource) r).getExtraFields() : null);
			 }
			 finally {
				 FileUtils.close(is);
			 }
		 }
	 }
	 protected final void addResources(ResourceCollection rc, Resource[] resources, ZipOutputStream zOut) throws IOException {
		 if (rc instanceof FileSet) {
			 addResources((FileSet) rc, resources, zOut);
			 return;
		 }
		 for (int i = 0;
		 i < resources.length;
		 i++) {
			 String name = resources[i].getName().replace(File.separatorChar, '/');
			 if ("""".equals(name)) {
				 continue;
			 }
			 if (resources[i].isDirectory() && doFilesonly) {
				 continue;
			 }
			 File base = null;
			 FileProvider fp = (FileProvider) resources[i].as(FileProvider.class);
			 if (fp != null) {
				 base = ResourceUtils.asFileResource(fp).getBaseDir();
			 }
			 if (resources[i].isDirectory()) {
				 addDirectoryResource(resources[i], name, """", base, zOut, ArchiveFileSet.DEFAULT_DIR_MODE, ArchiveFileSet.DEFAULT_DIR_MODE);
			 }
			 else {
				 addParentDirs(base, name, zOut, """", ArchiveFileSet.DEFAULT_DIR_MODE);
				 if (fp != null) {
					 File f = (fp).getFile();
					 zipFile(f, zOut, name, ArchiveFileSet.DEFAULT_FILE_MODE);
				 }
				 else {
					 addResource(resources[i], name, """", zOut, ArchiveFileSet.DEFAULT_FILE_MODE, null, null);
				 }
			 }
		 }
	 }
	 protected void initZipOutputStream(ZipOutputStream zOut) throws IOException, BuildException {
	 }
	 protected void finalizeZipOutputStream(ZipOutputStream zOut) throws IOException, BuildException {
	 }
	 protected boolean createEmptyZip(File zipFile) throws BuildException {
		 if (!skipWriting) {
			 log(""Note: creating empty "" + archiveType + "" archive "" + zipFile, Project.MSG_INFO);
		 }
		 OutputStream os = null;
		 try {
			 os = new FileOutputStream(zipFile);
			 byte[] empty = new byte[22];
			 empty[0] = 80;
			 empty[1] = 75;
			 empty[2] = 5;
			 empty[3] = 6;
			 os.write(empty);
		 }
		 catch (IOException ioe) {
			 throw new BuildException(""Could not create empty ZIP archive "" + ""("" + ioe.getMessage() + "")"", ioe, getLocation());
		 }
		 finally {
			 FileUtils.close(os);
		 }
		 return true;
	 }
	 private synchronized ZipScanner getZipScanner() {
		 if (zs == null) {
			 zs = new ZipScanner();
			 zs.setEncoding(encoding);
			 zs.setSrc(zipFile);
		 }
		 return zs;
	 }
	 protected ArchiveState getResourcesToAdd(ResourceCollection[] rcs, File zipFile, boolean needsUpdate) throws BuildException {
		 ArrayList filesets = new ArrayList();
		 ArrayList rest = new ArrayList();
		 for (int i = 0;
		 i < rcs.length;
		 i++) {
			 if (rcs[i] instanceof FileSet) {
				 filesets.add(rcs[i]);
			 }
			 else {
				 rest.add(rcs[i]);
			 }
		 }
		 ResourceCollection[] rc = (ResourceCollection[]) rest.toArray(new ResourceCollection[rest.size()]);
		 ArchiveState as = getNonFileSetResourcesToAdd(rc, zipFile, needsUpdate);
		 FileSet[] fs = (FileSet[]) filesets.toArray(new FileSet[filesets .size()]);
		 ArchiveState as2 = getResourcesToAdd(fs, zipFile, as.isOutOfDate());
		 if (!as.isOutOfDate() && as2.isOutOfDate()) {
			 as = getNonFileSetResourcesToAdd(rc, zipFile, true);
		 }
		 Resource[][] toAdd = new Resource[rcs.length][];
		 int fsIndex = 0;
		 int restIndex = 0;
		 for (int i = 0;
		 i < rcs.length;
		 i++) {
			 if (rcs[i] instanceof FileSet) {
				 toAdd[i] = as2.getResourcesToAdd()[fsIndex++];
			 }
			 else {
				 toAdd[i] = as.getResourcesToAdd()[restIndex++];
			 }
		 }
		 return new ArchiveState(as2.isOutOfDate(), toAdd);
	 }
	 private static ThreadLocal haveNonFileSetResourcesToAdd = new ThreadLocal() {
		 protected Object initialValue() {
			 return Boolean.FALSE;
		 }
	 }
	;
	 protected ArchiveState getResourcesToAdd(FileSet[] filesets, File zipFile, boolean needsUpdate) throws BuildException {
		 Resource[][] initialResources = grabResources(filesets);
		 if (isEmpty(initialResources)) {
			 if (Boolean.FALSE.equals(haveNonFileSetResourcesToAdd.get())) {
				 if (needsUpdate && doUpdate) {
					 return new ArchiveState(true, initialResources);
				 }
				 if (emptyBehavior.equals(""skip"")) {
					 if (doUpdate) {
						 logWhenWriting(archiveType + "" archive "" + zipFile + "" not updated because no new files were"" + "" included."", Project.MSG_VERBOSE);
					 }
					 else {
						 logWhenWriting(""Warning: skipping "" + archiveType + "" archive "" + zipFile + "" because no files were included."", Project.MSG_WARN);
					 }
				 }
				 else if (emptyBehavior.equals(""fail"")) {
					 throw new BuildException(""Cannot create "" + archiveType + "" archive "" + zipFile + "": no files were included."", getLocation());
				 }
				 else {
					 if (!zipFile.exists()) {
						 needsUpdate = true;
					 }
				 }
			 }
			 return new ArchiveState(needsUpdate, initialResources);
		 }
		 if (!zipFile.exists()) {
			 return new ArchiveState(true, initialResources);
		 }
		 if (needsUpdate && !doUpdate) {
			 return new ArchiveState(true, initialResources);
		 }
		 Resource[][] newerResources = new Resource[filesets.length][];
		 for (int i = 0;
		 i < filesets.length;
		 i++) {
			 if (!(fileset instanceof ZipFileSet) || ((ZipFileSet) fileset).getSrc(getProject()) == null) {
				 File base = filesets[i].getDir(getProject());
				 for (int j = 0;
				 j < initialResources[i].length;
				 j++) {
					 File resourceAsFile = FILE_UTILS.resolveFile(base, initialResources[i][j].getName());
					 if (resourceAsFile.equals(zipFile)) {
						 throw new BuildException(""A zip file cannot include "" + ""itself"", getLocation());
					 }
				 }
			 }
		 }
		 for (int i = 0;
		 i < filesets.length;
		 i++) {
			 if (initialResources[i].length == 0) {
				 newerResources[i] = new Resource[] {
				}
				;
				 continue;
			 }
			 FileNameMapper myMapper = new IdentityMapper();
			 if (filesets[i] instanceof ZipFileSet) {
				 ZipFileSet zfs = (ZipFileSet) filesets[i];
				 if (zfs.getFullpath(getProject()) != null && !zfs.getFullpath(getProject()).equals("""")) {
					 MergingMapper fm = new MergingMapper();
					 fm.setTo(zfs.getFullpath(getProject()));
					 myMapper = fm;
				 }
				 else if (zfs.getPrefix(getProject()) != null && !zfs.getPrefix(getProject()).equals("""")) {
					 GlobPatternMapper gm = new GlobPatternMapper();
					 gm.setFrom(""*"");
					 String prefix = zfs.getPrefix(getProject());
					 if (!prefix.endsWith(""/"") && !prefix.endsWith(""\\"")) {
						 prefix += ""/"";
					 }
					 gm.setTo(prefix + ""*"");
					 myMapper = gm;
				 }
			 }
			 newerResources[i] = selectOutOfDateResources(initialResources[i], myMapper);
			 needsUpdate = needsUpdate || (newerResources[i].length > 0);
			 if (needsUpdate && !doUpdate) {
				 break;
			 }
		 }
		 if (needsUpdate && !doUpdate) {
			 return new ArchiveState(true, initialResources);
		 }
		 return new ArchiveState(needsUpdate, newerResources);
	 }
	 protected ArchiveState getNonFileSetResourcesToAdd(ResourceCollection[] rcs, File zipFile, boolean needsUpdate) throws BuildException {
		 Resource[][] initialResources = grabNonFileSetResources(rcs);
		 boolean empty = isEmpty(initialResources);
		 haveNonFileSetResourcesToAdd.set(Boolean.valueOf(!empty));
		 if (empty) {
			 return new ArchiveState(needsUpdate, initialResources);
		 }
		 if (!zipFile.exists()) {
			 return new ArchiveState(true, initialResources);
		 }
		 if (needsUpdate && !doUpdate) {
			 return new ArchiveState(true, initialResources);
		 }
		 Resource[][] newerResources = new Resource[rcs.length][];
		 for (int i = 0;
		 i < rcs.length;
		 i++) {
			 if (initialResources[i].length == 0) {
				 newerResources[i] = new Resource[] {
				}
				;
				 continue;
			 }
			 for (int j = 0;
			 j < initialResources[i].length;
			 j++) {
				 FileProvider fp = (FileProvider) initialResources[i][j].as(FileProvider.class);
				 if (fp != null && zipFile.equals(fp.getFile())) {
					 throw new BuildException(""A zip file cannot include "" + ""itself"", getLocation());
				 }
			 }
			 newerResources[i] = selectOutOfDateResources(initialResources[i], new IdentityMapper());
			 needsUpdate = needsUpdate || (newerResources[i].length > 0);
			 if (needsUpdate && !doUpdate) {
				 break;
			 }
		 }
		 if (needsUpdate && !doUpdate) {
			 return new ArchiveState(true, initialResources);
		 }
		 return new ArchiveState(needsUpdate, newerResources);
	 }
	 private Resource[] selectOutOfDateResources(Resource[] initial, FileNameMapper mapper) {
		 Resource[] rs = selectFileResources(initial);
		 Resource[] result = ResourceUtils.selectOutOfDateSources(this, rs, mapper, getZipScanner());
		 if (!doFilesonly) {
			 Union u = new Union();
			 u.addAll(Arrays.asList(selectDirectoryResources(initial)));
			 ResourceCollection rc = ResourceUtils.selectSources(this, u, mapper, getZipScanner(), MISSING_DIR_PROVIDER);
			 if (rc.size() > 0) {
				 ArrayList newer = new ArrayList();
				 newer.addAll(Arrays.asList(((Union) rc).listResources()));
				 newer.addAll(Arrays.asList(result));
				 result = (Resource[]) newer.toArray(result);
			 }
		 }
		 return result;
	 }
	 protected Resource[][] grabResources(FileSet[] filesets) {
		 Resource[][] result = new Resource[filesets.length][];
		 for (int i = 0;
		 i < filesets.length;
		 i++) {
			 boolean skipEmptyNames = true;
			 if (filesets[i] instanceof ZipFileSet) {
				 ZipFileSet zfs = (ZipFileSet) filesets[i];
				 skipEmptyNames = zfs.getPrefix(getProject()).equals("""") && zfs.getFullpath(getProject()).equals("""");
			 }
			 DirectoryScanner rs = filesets[i].getDirectoryScanner(getProject());
			 if (rs instanceof ZipScanner) {
				 ((ZipScanner) rs).setEncoding(encoding);
			 }
			 Vector resources = new Vector();
			 if (!doFilesonly) {
				 String[] directories = rs.getIncludedDirectories();
				 for (int j = 0;
				 j < directories.length;
				 j++) {
					 if (!"""".equals(directories[j]) || !skipEmptyNames) {
						 resources.addElement(rs.getResource(directories[j]));
					 }
				 }
			 }
			 String[] files = rs.getIncludedFiles();
			 for (int j = 0;
			 j < files.length;
			 j++) {
				 if (!"""".equals(files[j]) || !skipEmptyNames) {
					 resources.addElement(rs.getResource(files[j]));
				 }
			 }
			 result[i] = new Resource[resources.size()];
			 resources.copyInto(result[i]);
		 }
		 return result;
	 }
	 protected Resource[][] grabNonFileSetResources(ResourceCollection[] rcs) {
		 Resource[][] result = new Resource[rcs.length][];
		 for (int i = 0;
		 i < rcs.length;
		 i++) {
			 Iterator iter = rcs[i].iterator();
			 ArrayList dirs = new ArrayList();
			 ArrayList files = new ArrayList();
			 while (iter.hasNext()) {
				 Resource r = (Resource) iter.next();
				 if (r.isExists()) {
					 if (r.isDirectory()) {
						 dirs.add(r);
					 }
					 else {
						 files.add(r);
					 }
				 }
			 }
			 Collections.sort(dirs, new Comparator() {
				 public int compare(Object o1, Object o2) {
					 Resource r1 = (Resource) o1;
					 Resource r2 = (Resource) o2;
					 return r1.getName().compareTo(r2.getName());
				 }
			 }
			);
			 ArrayList rs = new ArrayList(dirs);
			 rs.addAll(files);
			 result[i] = (Resource[]) rs.toArray(new Resource[rs.size()]);
		 }
		 return result;
	 }
	 protected void zipDir(File dir, ZipOutputStream zOut, String vPath, int mode) throws IOException {
		 zipDir(dir, zOut, vPath, mode, null);
	 }
	 protected void zipDir(File dir, ZipOutputStream zOut, String vPath, int mode, ZipExtraField[] extra) throws IOException {
		 zipDir(dir == null ? (Resource) null : new FileResource(dir), zOut, vPath, mode, extra);
	 }
	 protected void zipDir(Resource dir, ZipOutputStream zOut, String vPath, int mode, ZipExtraField[] extra) throws IOException {
		 if (doFilesonly) {
			 logWhenWriting(""skipping directory "" + vPath + "" for file-only archive"", Project.MSG_VERBOSE);
			 return;
		 }
		 if (addedDirs.get(vPath) != null) {
			 return;
		 }
		 logWhenWriting(""adding directory "" + vPath, Project.MSG_VERBOSE);
		 addedDirs.put(vPath, vPath);
		 if (!skipWriting) {
			 ZipEntry ze = new ZipEntry (vPath);
			 int millisToAdd = roundUp ? ROUNDUP_MILLIS : 0;
			 if (dir != null && dir.isExists()) {
				 ze.setTime(dir.getLastModified() + millisToAdd);
			 }
			 else {
				 ze.setTime(System.currentTimeMillis() + millisToAdd);
			 }
			 ze.setSize (0);
			 ze.setMethod (ZipEntry.STORED);
			 ze.setCrc (EMPTY_CRC);
			 ze.setUnixMode(mode);
			 if (extra != null) {
				 ze.setExtraFields(extra);
			 }
			 zOut.putNextEntry(ze);
		 }
	 }
	 private static ThreadLocal currentZipExtra = new ThreadLocal() {
		 protected Object initialValue() {
			 return null;
		 }
	 }
	;
	 protected final ZipExtraField[] getCurrentExtraFields() {
		 return (ZipExtraField[]) currentZipExtra.get();
	 }
	 protected final void setCurrentExtraFields(ZipExtraField[] extra) {
		 currentZipExtra.set(extra);
	 }
	 protected void zipFile(InputStream in, ZipOutputStream zOut, String vPath, long lastModified, File fromArchive, int mode) throws IOException {
		 if (entries.containsKey(vPath)) {
			 if (duplicate.equals(""preserve"")) {
				 logWhenWriting(vPath + "" already added, skipping"", Project.MSG_INFO);
				 return;
			 }
			 else if (duplicate.equals(""fail"")) {
				 throw new BuildException(""Duplicate file "" + vPath + "" was found and the duplicate "" + ""attribute is 'fail'."");
			 }
			 else {
				 logWhenWriting(""duplicate file "" + vPath + "" found, adding."", Project.MSG_VERBOSE);
			 }
		 }
		 else {
			 logWhenWriting(""adding entry "" + vPath, Project.MSG_VERBOSE);
		 }
		 entries.put(vPath, vPath);
		 if (!skipWriting) {
			 ZipEntry ze = new ZipEntry(vPath);
			 ze.setTime(lastModified);
			 ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);
			 if (!zOut.isSeekable() && !doCompress) {
				 long size = 0;
				 CRC32 cal = new CRC32();
				 if (!in.markSupported()) {
					 ByteArrayOutputStream bos = new ByteArrayOutputStream();
					 byte[] buffer = new byte[BUFFER_SIZE];
					 int count = 0;
					 do {
						 size += count;
						 cal.update(buffer, 0, count);
						 bos.write(buffer, 0, count);
						 count = in.read(buffer, 0, buffer.length);
					 }
					 while (count != -1);
					 in = new ByteArrayInputStream(bos.toByteArray());
				 }
				 else {
					 in.mark(Integer.MAX_VALUE);
					 byte[] buffer = new byte[BUFFER_SIZE];
					 int count = 0;
					 do {
						 size += count;
						 cal.update(buffer, 0, count);
						 count = in.read(buffer, 0, buffer.length);
					 }
					 while (count != -1);
					 in.reset();
				 }
				 ze.setSize(size);
				 ze.setCrc(cal.getValue());
			 }
			 ze.setUnixMode(mode);
			 ZipExtraField[] extra = getCurrentExtraFields();
			 if (extra != null) {
				 ze.setExtraFields(extra);
			 }
			 zOut.putNextEntry(ze);
			 byte[] buffer = new byte[BUFFER_SIZE];
			 int count = 0;
			 do {
				 if (count != 0) {
					 zOut.write(buffer, 0, count);
				 }
				 count = in.read(buffer, 0, buffer.length);
			 }
			 while (count != -1);
		 }
		 addedFiles.addElement(vPath);
	 }
	 protected final void zipFile(InputStream in, ZipOutputStream zOut, String vPath, long lastModified, File fromArchive, int mode, ZipExtraField[] extra) throws IOException {
		 try {
			 setCurrentExtraFields(extra);
			 zipFile(in, zOut, vPath, lastModified, fromArchive, mode);
		 }
		 finally {
			 setCurrentExtraFields(null);
		 }
	 }
	 protected void zipFile(File file, ZipOutputStream zOut, String vPath, int mode) throws IOException {
		 if (file.equals(zipFile)) {
			 throw new BuildException(""A zip file cannot include itself"", getLocation());
		 }
		 FileInputStream fIn = new FileInputStream(file);
		 try {
			 zipFile(fIn, zOut, vPath, file.lastModified() + (roundUp ? ROUNDUP_MILLIS : 0), null, mode);
		 }
		 finally {
			 fIn.close();
		 }
	 }
	 protected final void addParentDirs(File baseDir, String entry, ZipOutputStream zOut, String prefix, int dirMode) throws IOException {
		 if (!doFilesonly) {
			 Stack directories = new Stack();
			 int slashPos = entry.length();
			 while ((slashPos = entry.lastIndexOf('/', slashPos - 1)) != -1) {
				 String dir = entry.substring(0, slashPos + 1);
				 if (addedDirs.get(prefix + dir) != null) {
					 break;
				 }
				 directories.push(dir);
			 }
			 while (!directories.isEmpty()) {
				 String dir = (String) directories.pop();
				 File f = null;
				 if (baseDir != null) {
					 f = new File(baseDir, dir);
				 }
				 else {
					 f = new File(dir);
				 }
				 zipDir(f, zOut, prefix + dir, dirMode);
			 }
		 }
	 }
	 protected void cleanUp() {
		 addedDirs.clear();
		 addedFiles.removeAllElements();
		 entries.clear();
		 addingNewFiles = false;
		 doUpdate = savedDoUpdate;
		 Enumeration e = filesetsFromGroupfilesets.elements();
		 while (e.hasMoreElements()) {
			 ZipFileSet zf = (ZipFileSet) e.nextElement();
			 resources.removeElement(zf);
		 }
		 filesetsFromGroupfilesets.removeAllElements();
		 haveNonFileSetResourcesToAdd.set(Boolean.FALSE);
	 }
	 public void reset() {
		 resources.removeAllElements();
		 zipFile = null;
		 baseDir = null;
		 groupfilesets.removeAllElements();
		 duplicate = ""add"";
		 archiveType = ""zip"";
		 doCompress = true;
		 emptyBehavior = ""skip"";
		 doUpdate = false;
		 doFilesonly = false;
		 encoding = null;
	 }
	 protected static final boolean isEmpty(Resource[][] r) {
		 for (int i = 0;
		 i < r.length;
		 i++) {
			 if (r[i].length > 0) {
				 return false;
			 }
		 }
		 return true;
	 }
	 protected Resource[] selectFileResources(Resource[] orig) {
		 return selectResources(orig, new ResourceSelector() {
			 public boolean isSelected(Resource r) {
				 if (!r.isDirectory()) {
					 return true;
				 }
				 else if (doFilesonly) {
					 logWhenWriting(""Ignoring directory "" + r.getName() + "" as only files will"" + "" be added."", Project.MSG_VERBOSE);
				 }
				 return false;
			 }
		 }
		);
	 }
	 protected Resource[] selectDirectoryResources(Resource[] orig) {
		 return selectResources(orig, new ResourceSelector() {
			 public boolean isSelected(Resource r) {
				 return r.isDirectory();
			 }
		 }
		);
	 }
	 protected Resource[] selectResources(Resource[] orig, ResourceSelector selector) {
		 if (orig.length == 0) {
			 return orig;
		 }
		 ArrayList v = new ArrayList(orig.length);
		 for (int i = 0;
		 i < orig.length;
		 i++) {
			 if (selector.isSelected(orig[i])) {
				 v.add(orig[i]);
			 }
		 }
		 if (v.size() != orig.length) {
			 Resource[] r = new Resource[v.size()];
			 return (Resource[]) v.toArray(r);
		 }
		 return orig;
	 }
	 protected void logWhenWriting(String msg, int level) {
		 if (!skipWriting) {
			 log(msg, level);
		 }
	 }
	 public static class Duplicate extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""add"", ""preserve"", ""fail""}
			;
		 }
	 }
	 public static class ArchiveState {
		 private boolean outOfDate;
		 private Resource[][] resourcesToAdd;
		 ArchiveState(boolean state, Resource[][] r) {
			 outOfDate = state;
			 resourcesToAdd = r;
		 }
		 public boolean isOutOfDate() {
			 return outOfDate;
		 }
		 public Resource[][] getResourcesToAdd() {
			 return resourcesToAdd;
		 }
		 public boolean isWithoutAnyResources() {
			 if (resourcesToAdd == null) {
				 return true;
			 }
			 for (int counter = 0;
			 counter < resourcesToAdd.length;
			 counter++) {
				 if (resourcesToAdd[counter] != null) {
					 if (resourcesToAdd[counter].length > 0) {
						 return false;
					 }
				 }
			 }
			 return true;
		 }
	 }
	 public static final class UnicodeExtraField extends EnumeratedAttribute {
		 private static final Map POLICIES = new HashMap();
		 private static final String NEVER_KEY = ""never"";
		 private static final String ALWAYS_KEY = ""always"";
		 private static final String N_E_KEY = ""not-encodeable"";
		 static {
			 POLICIES.put(NEVER_KEY, ZipOutputStream.UnicodeExtraFieldPolicy.NEVER);
			 POLICIES.put(ALWAYS_KEY, ZipOutputStream.UnicodeExtraFieldPolicy.ALWAYS);
			 POLICIES.put(N_E_KEY, ZipOutputStream.UnicodeExtraFieldPolicy .NOT_ENCODEABLE);
		 }
		 public String[] getValues() {
			 return new String[] {
			NEVER_KEY, ALWAYS_KEY, N_E_KEY}
			;
		 }
		 public static final UnicodeExtraField NEVER = new UnicodeExtraField(NEVER_KEY);
		 private UnicodeExtraField(String name) {
			 setValue(name);
		 }
		 public UnicodeExtraField() {
		 }
		 public ZipOutputStream.UnicodeExtraFieldPolicy getPolicy() {
			 return (ZipOutputStream.UnicodeExtraFieldPolicy) POLICIES.get(getValue());
		 }
	 }
}",1,0,0,0
"public static class JCasGenThrower implements IError {
	 private Level logLevels[] = {
	 Level.INFO, Level.WARNING, Level.SEVERE }
	;
	 private String m_message = null;
	 public void newError(int severity, String message, Exception ex) {
		 Logger log = UIMAFramework.getLogger();
		 log.log(logLevels[severity], ""JCasGen: "" + message);
		 System.out.println(Messages.getString(""MultiPageEditor.JCasGenErr"") + message);
		 if (null != ex) ex.printStackTrace();
		 if (IError.WARN < severity) {
			 m_message = message;
			 throw new Jg.ErrorExit();
		 }
	 }
	 public String getMessage() {
		 return m_message;
	 }
 }",0,0,0,0
"public class SetModel<T> extends GenericBaseModel<Set<T>>{
	private static final long serialVersionUID = 1L;
	public SetModel(){
	}
	public SetModel(Set<T> set){
		setObject(set);
	}
	protected Set<T> createSerializableVersionOf(Set<T> object){
		return new HashSet<T>(object);
	}
}",0,0,0,0
"public class NonTerminal extends Expansion {
	 private List lhsTokens = new ArrayList();
	 private String name;
	 private List argument_tokens = new ArrayList();
	 private NormalProduction prod;
	 public StringBuffer dump(int indent, Set alreadyDumped) {
		 StringBuffer value = super.dump(indent, alreadyDumped).append(' ').append(name);
		 return value;
	 }
	public void setLhsTokens(List lhsTokens) {
		this.lhsTokens = lhsTokens;
	}
	public List getLhsTokens() {
		return lhsTokens;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getName() {
		return name;
	}
	public void setArgumentTokens(List argument_tokens) {
		this.argument_tokens = argument_tokens;
	}
	public List getArgumentTokens() {
		return argument_tokens;
	}
	public NormalProduction setProd(NormalProduction prod) {
		return this.prod = prod;
	}
	public NormalProduction getProd() {
		return prod;
	}
}",0,1,0,0
"public void sendInbox(CaldavRequest request) throws IOException {
	 CaldavResponse response = new CaldavResponse(HttpStatus.SC_MULTI_STATUS);
	 response.startMultistatus();
	 appendInbox(response, request, null);
	 if (!session.isSharedFolder(request.getFolderPath(null)) && request.getDepth() == 1 && !request.isLightning()) {
		 try {
			 DavGatewayTray.debug(new BundleMessage(""LOG_SEARCHING_CALENDAR_MESSAGES""));
			 List<ExchangeSession.Event> events = session.getEventMessages(request.getFolderPath());
			 DavGatewayTray.debug(new BundleMessage(""LOG_FOUND_CALENDAR_MESSAGES"", events.size()));
			 appendEventsResponses(response, request, events);
		 }
		 catch (HttpException e) {
			 DavGatewayTray.debug(new BundleMessage(""LOG_ACCESS_FORBIDDEN"", request.getFolderPath(), e.getMessage()));
		 }
	 }
	 response.endMultistatus();
	 response.close();
 }",0,0,0,0
"public class NewNodePresentation {
	 private String nodeText;
	 private StyleConfigurator nodeTextStyle;
	 private String nodeInfoText;
	 private StyleConfigurator nodeInfoTextStyle;
	 private SVGResource icon;
	 private Element userElement;
	 private NewNodePresentation(Builder builder) {
		 this.nodeText = builder.nodeText;
		 this.nodeTextStyle = builder.nodeTextStyle;
		 this.nodeInfoText = builder.nodeInfoText;
		 this.nodeInfoTextStyle = builder.nodeInfoTextStyle;
		 this.icon = builder.icon;
		 this.userElement = builder.userElement;
	 }
	 public String getNodeText() {
		 return nodeText;
	 }
	 public StyleConfigurator getNodeTextStyle() {
		 return nodeTextStyle;
	 }
	 public String getNodeInfoText() {
		 return nodeInfoText;
	 }
	 public StyleConfigurator getNodeInfoTextStyle() {
		 return nodeInfoTextStyle;
	 }
	 public SVGResource getIcon() {
		 return icon;
	 }
	 public Element getUserElement() {
		 return userElement;
	 }
	 public static class Builder {
		 private String nodeText;
		 private StyleConfigurator nodeTextStyle;
		 private String nodeInfoText;
		 private StyleConfigurator nodeInfoTextStyle;
		 private SVGResource icon;
		 private Element userElement;
		 public Builder() {
		}
		 public Builder withNodeText(String nodeText) {
			 this.nodeText = nodeText;
			 return this;
		 }
		 public Builder withNodeTextStyle(StyleConfigurator nodeTextStyle) {
			 this.nodeTextStyle = nodeTextStyle;
			 return this;
		 }
		 public Builder withNodeInfoText(String nodeInfoText) {
			 this.nodeInfoText = nodeInfoText;
			 return this;
		 }
		 public Builder withNodeIntoTextStyle(StyleConfigurator nodeInfoTextStyle) {
			 this.nodeInfoTextStyle = nodeInfoTextStyle;
			 return this;
		 }
		 public Builder withIcon(SVGResource icon) {
			 this.icon = icon;
			 return this;
		 }
		 public Builder withUserElement(Element userElement) {
			 this.userElement = userElement;
			 return this;
		 }
		 public NewNodePresentation build() {
			 return new NewNodePresentation(this);
		 }
	 }
}",0,1,0,0
"public boolean isVersioned(){
	if (!getFlag(FLAG_VERSIONED)){
		return false;
	}
	else{
		if (parent != null){
			if (!parent.isVersioned()){
				return false;
			}
		}
		return true;
	}
}",0,0,0,0
"public class GridQueryCancelRequest implements Message {
	 private static final long serialVersionUID = 0L;
	 private long qryReqId;
	 public GridQueryCancelRequest() {
	 }
	 public GridQueryCancelRequest(long qryReqId) {
		 this.qryReqId = qryReqId;
	 }
	 public long queryRequestId() {
		 return qryReqId;
	 }
	 public void onAckReceived() {
	 }
	 public String toString() {
		 return S.toString(GridQueryCancelRequest.class, this);
	 }
	 public boolean writeTo(ByteBuffer buf, MessageWriter writer) {
		 writer.setBuffer(buf);
		 if (!writer.isHeaderWritten()) {
			 if (!writer.writeHeader(directType(), fieldsCount())) return false;
			 writer.onHeaderWritten();
		 }
		 switch (writer.state()) {
			 case 0: if (!writer.writeLong(""qryReqId"", qryReqId)) return false;
			 writer.incrementState();
		 }
		 return true;
	 }
	 public boolean readFrom(ByteBuffer buf, MessageReader reader) {
		 reader.setBuffer(buf);
		 if (!reader.beforeMessageRead()) return false;
		 switch (reader.state()) {
			 case 0: qryReqId = reader.readLong(""qryReqId"");
			 if (!reader.isLastRead()) return false;
			 reader.incrementState();
		 }
		 return reader.afterMessageRead(GridQueryCancelRequest.class);
	 }
	 public short directType() {
		 return 106;
	 }
	 public byte fieldsCount() {
		 return 1;
	 }
}",0,0,0,0
"public interface IValidationMessage {
	 public String getMessage();
	 public String getLocalizedMessage(Locale locale);
	 public Severity getSeverity();
}",0,0,0,0
"public class ObjectFactory {
	 public LWM2M createLWM2M() {
		 return new LWM2M();
	 }
	 public LWM2M.Object createLWM2MObject() {
		 return new LWM2M.Object();
	 }
	 public LWM2M.Object.Resources createLWM2MObjectResources() {
		 return new LWM2M.Object.Resources();
	 }
	 public LWM2M.Object.Resources.Item createLWM2MObjectResourcesItem() {
		 return new LWM2M.Object.Resources.Item();
	 }
}",0,1,0,0
"public class TransformIterator<I, O> implements Iterator<O> {
	 private Iterator<? extends I> iterator;
	 private Transformer<? super I, ? extends O> transformer;
	 public TransformIterator() {
		 super();
	 }
	 public TransformIterator(final Iterator<? extends I> iterator) {
		 super();
		 this.iterator = iterator;
	 }
	 public TransformIterator(final Iterator<? extends I> iterator, final Transformer<? super I, ? extends O> transformer) {
		 super();
		 this.iterator = iterator;
		 this.transformer = transformer;
	 }
	 public boolean hasNext() {
		 return iterator.hasNext();
	 }
	 public O next() {
		 return transform(iterator.next());
	 }
	 public void remove() {
		 iterator.remove();
	 }
	 public Iterator<? extends I> getIterator() {
		 return iterator;
	 }
	 public void setIterator(final Iterator<? extends I> iterator) {
		 this.iterator = iterator;
	 }
	 public Transformer<? super I, ? extends O> getTransformer() {
		 return transformer;
	 }
	 public void setTransformer(final Transformer<? super I, ? extends O> transformer) {
		 this.transformer = transformer;
	 }
	 protected O transform(final I source) {
		 return transformer.transform(source);
	 }
}",1,1,0,0
"class LexerScheme extends AbsLexer implements org.apache.jena.iri.ViolationCodes, org.apache.jena.iri.IRIComponents, Lexer {
	 private static final int YYEOF = -1;
	 private static final int ZZ_BUFFERSIZE = 2048;
	 public static final int YYINITIAL = 0;
	 private static final int ZZ_LEXSTATE[] = {
	 0, 1 }
	;
	 private static final String ZZ_CMAP_PACKED = ""\12\0\1\0\40\0\1\3\1\0\1\4\1\3\1\0\12\3\7\0""+ ""\32\2\6\0\1\1\31\1\uff85\0"";
	 private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);
	 private static final int [] ZZ_ACTION = zzUnpackAction();
	 private static final String ZZ_ACTION_PACKED_0 = ""\2\0\1\1\1\2\1\3\1\4\1\5\1\6\1\7"";
	 private static int [] zzUnpackAction() {
		 int [] result = new int[9];
		 int offset = 0;
		 offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAction(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
	 private static final String ZZ_ROWMAP_PACKED_0 = ""\0\0\0\5\0\12\0\12\0\12\0\12\0\12\0\12""+ ""\0\12"";
	 private static int [] zzUnpackRowMap() {
		 int [] result = new int[9];
		 int offset = 0;
		 offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackRowMap(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int high = packed.charAt(i++) << 16;
			 result[j++] = high | packed.charAt(i++);
		 }
		 return j;
	 }
	 private static final int [] ZZ_TRANS = zzUnpackTrans();
	 private static final String ZZ_TRANS_PACKED_0 = ""\1\3\1\4\1\5\1\6\1\7\1\3\1\4\1\5""+ ""\1\10\1\11\5\0"";
	 private static int [] zzUnpackTrans() {
		 int [] result = new int[15];
		 int offset = 0;
		 offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackTrans(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 value--;
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int ZZ_UNKNOWN_ERROR = 0;
	 private static final int ZZ_NO_MATCH = 1;
	 private static final int ZZ_PUSHBACK_2BIG = 2;
	 private static final String ZZ_ERROR_MSG[] = {
	 ""Unkown internal scanner error"", ""Error: could not match input"", ""Error: pushback value was too large"" }
	;
	 private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
	 private static final String ZZ_ATTRIBUTE_PACKED_0 = ""\2\0\7\11"";
	 private static int [] zzUnpackAttribute() {
		 int [] result = new int[9];
		 int offset = 0;
		 offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAttribute(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private java.io.Reader zzReader;
	 private int zzState;
	 private int zzLexicalState = YYINITIAL;
	 private char zzBuffer[] = new char[ZZ_BUFFERSIZE];
	 private int zzMarkedPos;
	 private int zzCurrentPos;
	 private int zzStartRead;
	 private int zzEndRead;
	 private int yyline;
	 private int yychar;
	 private int yycolumn;
	 private boolean zzAtBOL = true;
	 private boolean zzAtEOF;
	 private boolean zzEOFDone;
	 char[] zzBuffer() {
		 yyreset(null);
		 this.zzAtEOF = true;
		 int length = parser.end(range)-parser.start(range);
		 zzEndRead = length;
		 while (length > zzBuffer.length) zzBuffer = new char[zzBuffer.length*2];
		 if (length==0) error(EMPTY_SCHEME);
		 return zzBuffer;
	 }
	 LexerScheme(java.io.Reader in) {
		 this.zzReader = in;
	 }
	 LexerScheme(java.io.InputStream in) {
		 this(new java.io.InputStreamReader(in));
	 }
	 private static char [] zzUnpackCMap(String packed) {
		 char [] map = new char[0x10000];
		 int i = 0;
		 int j = 0;
		 while (i < 30) {
			 int count = packed.charAt(i++);
			 char value = packed.charAt(i++);
			 do map[j++] = value;
			 while (--count > 0);
		 }
		 return map;
	 }
	 private boolean zzRefill() throws java.io.IOException {
		 if (zzStartRead > 0) {
			 System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead-zzStartRead);
			 zzEndRead-= zzStartRead;
			 zzCurrentPos-= zzStartRead;
			 zzMarkedPos-= zzStartRead;
			 zzStartRead = 0;
		 }
		 if (zzCurrentPos >= zzBuffer.length) {
			 char newBuffer[] = new char[zzCurrentPos*2];
			 System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
			 zzBuffer = newBuffer;
		 }
		 int numRead = zzReader.read(zzBuffer, zzEndRead, zzBuffer.length-zzEndRead);
		 if (numRead > 0) {
			 zzEndRead+= numRead;
			 return false;
		 }
		 if (numRead == 0) {
			 int c = zzReader.read();
			 if (c == -1) {
				 return true;
			 }
			 else {
				 zzBuffer[zzEndRead++] = (char) c;
				 return false;
			 }
		 }
		 return true;
	 }
	 private final void yyclose() throws java.io.IOException {
		 zzAtEOF = true;
		 zzEndRead = zzStartRead;
		 if (zzReader != null) zzReader.close();
	 }
	 private final void yyreset(java.io.Reader reader) {
		 zzReader = reader;
		 zzAtBOL = true;
		 zzAtEOF = false;
		 zzEOFDone = false;
		 zzEndRead = zzStartRead = 0;
		 zzCurrentPos = zzMarkedPos = 0;
		 yyline = yychar = yycolumn = 0;
		 zzLexicalState = YYINITIAL;
	 }
	 private final int yystate() {
		 return zzLexicalState;
	 }
	 private final void yybegin(int newState) {
		 zzLexicalState = newState;
	 }
	 final String yytext() {
		 return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
	 }
	 private final char yycharat(int pos) {
		 return zzBuffer[zzStartRead+pos];
	 }
	 private final int yylength() {
		 return zzMarkedPos-zzStartRead;
	 }
	 private void zzScanError(int errorCode) {
		 String message;
		 try {
			 message = ZZ_ERROR_MSG[errorCode];
		 }
		 catch (ArrayIndexOutOfBoundsException e) {
			 message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
		 }
		 throw new Error(message);
	 }
	 public void yypushback(int number) {
		 if ( number > yylength() ) zzScanError(ZZ_PUSHBACK_2BIG);
		 zzMarkedPos -= number;
	 }
	public int yylex() throws java.io.IOException {
		 int zzInput;
		 int zzAction;
		 int zzCurrentPosL;
		 int zzMarkedPosL;
		 int zzEndReadL = zzEndRead;
		 char [] zzBufferL = zzBuffer;
		 char [] zzCMapL = ZZ_CMAP;
		 int [] zzTransL = ZZ_TRANS;
		 int [] zzRowMapL = ZZ_ROWMAP;
		 int [] zzAttrL = ZZ_ATTRIBUTE;
		 while (true) {
			 zzMarkedPosL = zzMarkedPos;
			 yychar+= zzMarkedPosL-zzStartRead;
			 if (zzMarkedPosL > zzStartRead) {
				 switch (zzBufferL[zzMarkedPosL-1]) {
					 case '\n': case '\u000B': case '\u000C': case '\u0085': case '\u2028': case '\u2029': zzAtBOL = true;
					 break;
					 case '\r': if (zzMarkedPosL < zzEndReadL) zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
					 else if (zzAtEOF) zzAtBOL = false;
					 else {
						 boolean eof = zzRefill();
						 zzMarkedPosL = zzMarkedPos;
						 zzEndReadL = zzEndRead;
						 zzBufferL = zzBuffer;
						 if (eof) zzAtBOL = false;
						 else zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
					 }
					 break;
					 default: zzAtBOL = false;
				 }
			 }
			 zzAction = -1;
			 zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
			 if (zzAtBOL) zzState = ZZ_LEXSTATE[zzLexicalState+1];
			 else zzState = ZZ_LEXSTATE[zzLexicalState];
			 zzForAction: {
				 while (true) {
					 if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++];
					 else if (zzAtEOF) {
						 zzInput = YYEOF;
						 break zzForAction;
					 }
					 else {
						 zzCurrentPos = zzCurrentPosL;
						 zzMarkedPos = zzMarkedPosL;
						 boolean eof = zzRefill();
						 zzCurrentPosL = zzCurrentPos;
						 zzMarkedPosL = zzMarkedPos;
						 zzBufferL = zzBuffer;
						 zzEndReadL = zzEndRead;
						 if (eof) {
							 zzInput = YYEOF;
							 break zzForAction;
						 }
						 else {
							 zzInput = zzBufferL[zzCurrentPosL++];
						 }
					 }
					 int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
					 if (zzNext == -1) break zzForAction;
					 zzState = zzNext;
					 int zzAttributes = zzAttrL[zzState];
					 if ( (zzAttributes & 1) == 1 ) {
						 zzAction = zzState;
						 zzMarkedPosL = zzCurrentPosL;
						 if ( (zzAttributes & 8) == 8 ) break zzForAction;
					 }
				 }
			 }
			 zzMarkedPos = zzMarkedPosL;
			 switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
				 case 5: {
					 rule(5);
					 error(SCHEME_INCLUDES_DASH);
				 }
				 case 8: break;
				 case 4: {
					 rule(6);
				 }
				 case 9: break;
				 case 1: {
					 rule(7);
					 error(ILLEGAL_CHARACTER);
				 }
				 case 10: break;
				 case 6: {
					 rule(3);
					 if (yychar==0) error(SCHEME_MUST_START_WITH_LETTER);
				 }
				 case 11: break;
				 case 7: {
					 rule(4);
					 if (yychar==0) error(SCHEME_MUST_START_WITH_LETTER);
					 error(SCHEME_INCLUDES_DASH);
				 }
				 case 12: break;
				 case 3: {
					 rule(2);
					 error(LOWERCASE_PREFERRED);
				 }
				 case 13: break;
				 case 2: {
					 rule(1);
				 }
				 case 14: break;
				 default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
					 zzAtEOF = true;
					 return YYEOF;
				 }
				 else {
					 zzScanError(ZZ_NO_MATCH);
				 }
			 }
		 }
	 }
}",1,0,0,0
"private int addMethodNameAndType(String name, String retType, String paras);",0,0,0,1
"public class RealRowResultSetStatistics extends RealNoPutResultSetStatistics{
	public int rowsReturned;
	 publicRealRowResultSetStatistics(int numOpens,int rowsSeen,int rowsFiltered,long constructorTime,long openTime,long nextTime,long closeTime,int resultSetNumber,int rowsReturned,double optimizerEstimatedRowCount,double optimizerEstimatedCost){
		super(numOpens,rowsSeen,rowsFiltered,constructorTime,openTime,nextTime,closeTime,resultSetNumber,optimizerEstimatedRowCount,optimizerEstimatedCost);
		this.rowsReturned = rowsReturned;
	}
	public String getStatementExecutionPlanText(int depth){
		initFormatInfo(depth);
		returnindent + MessageService.getTextMessage(SQLState.RTS_ROW_RS) +"":\n"" +indent + MessageService.getTextMessage(SQLState.RTS_NUM_OPENS) +"" = "" + numOpens + ""\n"" +indent + MessageService.getTextMessage(SQLState.RTS_ROWS_RETURNED) +"" = "" + rowsReturned + ""\n"" +dumpTimeStats(indent, subIndent) + ""\n"" +dumpEstimatedCosts(subIndent) + ""\n"";
	}
	public String getScanStatisticsText(String tableName, int depth){
		return """";
	}
	public String toString(){
		return getStatementExecutionPlanText(0);
	}
	 public String getNodeName(){
		 return MessageService.getTextMessage(SQLState.RTS_ROW_RS);
	 }
	 public void accept(XPLAINVisitor visitor) {
		 visitor.setNumberOfChildren(0);
		 visitor.visit(this);
	 }
	 public String getRSXplainType() {
		 return XPLAINUtil.OP_ROW;
	 }
	 public Object getResultSetDescriptor(Object rsID, Object parentID, Object scanID, Object sortID, Object stmtID, Object timingID) {
		 return new XPLAINResultSetDescriptor( (UUID)rsID, getRSXplainType(), getRSXplainDetails(), this.numOpens, null, null, null, (UUID)parentID, this.optimizerEstimatedRowCount, this.optimizerEstimatedCost, null, null, null, this.rowsSeen, null, this.rowsFiltered, this.rowsReturned, null, null, (UUID)scanID, (UUID)sortID, (UUID)stmtID, (UUID)timingID);
	 }
}",0,1,0,0
"public class TruncateVerbHandler implements IVerbHandler{
	 private static Logger logger = LoggerFactory.getLogger(TruncateVerbHandler.class);
	 public void doVerb(Message message, String id) {
		 byte[] bytes = message.getMessageBody();
		 ByteArrayInputStream buffer = new ByteArrayInputStream(bytes);
		 try {
			 Truncation t = Truncation.serializer().deserialize(new DataInputStream(buffer), message.getVersion());
			 logger.debug(""Applying {
			}
			"", t);
			 try {
				 ColumnFamilyStore cfs = Table.open(t.keyspace).getColumnFamilyStore(t.columnFamily);
				 cfs.truncate().get();
			 }
			 catch (Exception e) {
				 logger.error(""Error in truncation"", e);
				 respondError(t, message);
			 }
			 logger.debug(""Truncate operation succeeded at this host"");
			 TruncateResponse response = new TruncateResponse(t.keyspace, t.columnFamily, true);
			 Message responseMessage = TruncateResponse.makeTruncateResponseMessage(message, response);
			 logger.debug(""{
			}
			 applied. Sending response to {
			}
			@{
			}
			 "", new Object[]{
			 t, id, message.getFrom()}
			);
			 MessagingService.instance().sendReply(responseMessage, id, message.getFrom());
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
	 }
	 private static void respondError(Truncation t, Message truncateRequestMessage) throws IOException {
		 TruncateResponse response = new TruncateResponse(t.keyspace, t.columnFamily, false);
		 Message responseMessage = TruncateResponse.makeTruncateResponseMessage(truncateRequestMessage, response);
		 MessagingService.instance().sendOneWay(responseMessage, truncateRequestMessage.getFrom());
	 }
}",0,0,0,0
"public String getVMPassword(final GetVMPasswordCmd cmd) {
	 final Account caller = getCaller();
	 final UserVmVO vm = _userVmDao.findById(cmd.getId());
	 if (vm == null) {
		 final InvalidParameterValueException ex = new InvalidParameterValueException(""No VM with specified id found."");
		 ex.addProxyObject(cmd.getId().toString(), ""vmId"");
		 throw ex;
	 }
	 _accountMgr.checkAccess(caller, null, true, vm);
	 _userVmDao.loadDetails(vm);
	 final String password = vm.getDetail(""Encrypted.Password"");
	 if (password == null || password.equals("""")) {
		 final InvalidParameterValueException ex = new InvalidParameterValueException( ""No password for VM with specified id found. "" + ""If VM is created from password enabled template and SSH keypair is assigned to VM then only password can be retrieved."");
		 ex.addProxyObject(vm.getUuid(), ""vmId"");
		 throw ex;
	 }
	 return password;
 }",0,0,1,0
"public abstract class TestConfiguration {
	private String downloadUrl;
	private final String description;
	private TestSuite suite;
	public TestConfiguration(String description) {
		this.description = description;
	}
	public String getDownloadUrl() {
		return downloadUrl;
	}
	public void setDownloadUrl(String downloadUrl) {
		this.downloadUrl = downloadUrl;
	}
	public String getDescription() {
		return description;
	}
	public String toString() {
		return getClass().getSimpleName() + "" ["" + description + ""]"";
	}
	public TestSuite createSuite(TestSuite parentSuite) {
		suite = new TestSuite(""Testing on "" + getDescription());
		parentSuite.addTest(suite);
		suite.addTest(new Activation(""TestSuite: "" + getDescription(), true));
		return suite;
	}
	public void add(Class<? extends TestCase> clazz) {
		Assert.isNotNull(suite, ""Invoke createSuite() first"");
		suite.addTestSuite(clazz);
	}
	public void done() {
		Assert.isNotNull(suite, ""Invoke createSuite() first"");
		suite.addTest(new Activation(""done"", false));
		suite = null;
	}
	private final class Activation extends TestCase {
		private final boolean activate;
		private Activation(String name, boolean activate) {
			super(name);
			this.activate = activate;
		}
		protected void runTest() throws Throwable {
			if (activate) {
				activate();
			}
			else {
				getDefault().activate();
			}
		}
	}
	protected abstract TestConfiguration getDefault();
	public abstract void activate();
	public abstract TestHarness createHarness();
}",0,1,0,0
"public void setType(String strType) {
	 if (strType.equalsIgnoreCase(""open"")) {
		 type = Arc2D.OPEN;
	 }
	 else if (strType.equalsIgnoreCase(""pie"")) {
		 type = Arc2D.PIE;
	 }
	 else if (strType.equalsIgnoreCase(""chord"")) {
		 type = Arc2D.CHORD;
	 }
 }",0,0,0,0
"private static class PropertiesLookup extends StrLookup<Object> {
	 private static final Map<String, String> ENV = System.getenv();
	 public synchronized String lookup(final String key) {
		 String value = SystemInstance.get().getProperties().getProperty(key);
		 if (value != null) {
			 return value;
		 }
		 value = ENV.get(key);
		 if (value != null) {
			 return value;
		 }
		 return null;
	 }
	 public synchronized void reload() {
	 }
 }",0,0,0,0
"String genJavaWriteMethod(String fname, String tag) {
	 return "" a_.write""+mMethodSuffix+""(""+fname+"",\""""+tag+""\"");
	\n"";
 }",0,0,0,0
"public class JCRSQLParserimplements JCRSQLParserTreeConstants, JCRSQLParserConstants {
	 protected JJTJCRSQLParserState jjtree = new JJTJCRSQLParserState();
	 private String statement;
	 private NameResolver resolver;
	 public static void main(String args[]) throws ParseException {
		 JCRSQLParser parser = new JCRSQLParser(System.in);
		 parser.Query().dump("""");
	 }
	 public static ASTQuery parse(String statement, NameResolver resolver) throws ParseException {
		 java.io.StringReader sReader = new java.io.StringReader(statement);
		 JCRSQLParser parser = new JCRSQLParser(sReader);
		 parser.setNameResolver(resolver);
		 return parser.Query();
	 }
	 void setNameResolver(NameResolver resolver) {
		 this.resolver = resolver;
	 }
	 final public ASTQuery Query() throws ParseException {
		 ASTQuery jjtn000 = new ASTQuery(JJTQUERY);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(SELECT);
			 SelectList();
			 TableExpression();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ORDER: OrderByClause();
				 break;
				 default: jj_la1[0] = jj_gen;
				 ;
			 }
			 jj_consume_token(0);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 {
				if (true) return jjtn000;
			}
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
		 throw new Error(""Missing return statement in function"");
	 }
	 final public void SelectList() throws ParseException {
		 ASTSelectList jjtn000 = new ASTSelectList(JJTSELECTLIST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ASTERISK: jj_consume_token(ASTERISK);
				 break;
				 case BY: case IN: case OR: case IS: case AND: case LIKE: case NULL: case FROM: case ORDER: case WHERE: case SELECT: case BETWEEN: case EXCERPT: case REGULAR_IDENTIFIER: case DELIMITED_IDENTIFIER: SelectItem();
				 label_1: while (true) {
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case COMMA: ;
						 break;
						 default: jj_la1[1] = jj_gen;
						 break label_1;
					 }
					 jj_consume_token(COMMA);
					 SelectItem();
				 }
				 break;
				 default: jj_la1[2] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void SelectItem() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case EXCERPT: ExcerptFunction();
			 break;
			 case BY: case IN: case OR: case IS: case AND: case LIKE: case NULL: case FROM: case ORDER: case WHERE: case SELECT: case BETWEEN: case REGULAR_IDENTIFIER: case DELIMITED_IDENTIFIER: Identifier();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case PERIOD: jj_consume_token(PERIOD);
				 Identifier();
				 Node n = jjtree.popNode();
				 jjtree.popNode();
				 jjtree.pushNode(n);
				 break;
				 default: jj_la1[3] = jj_gen;
				 ;
			 }
			 break;
			 default: jj_la1[4] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void TableExpression() throws ParseException {
		 FromClause();
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case WHERE: WhereClause();
			 break;
			 default: jj_la1[5] = jj_gen;
			 ;
		 }
	 }
	 final public void FromClause() throws ParseException {
		 ASTFromClause jjtn000 = new ASTFromClause(JJTFROMCLAUSE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(FROM);
			 Identifier();
			 label_2: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case COMMA: ;
					 break;
					 default: jj_la1[6] = jj_gen;
					 break label_2;
				 }
				 jj_consume_token(COMMA);
				 Identifier();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void WhereClause() throws ParseException {
		 ASTWhereClause jjtn000 = new ASTWhereClause(JJTWHERECLAUSE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(WHERE);
			 SearchCondition();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Predicate() throws ParseException {
		 ASTPredicate jjtn000 = new ASTPredicate(JJTPREDICATE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		int operationType;
		 Name identifier;
		 String value;
		 String escapeString;
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BY: case IN: case OR: case IS: case AND: case LIKE: case NULL: case FROM: case LOWER: case ORDER: case UPPER: case WHERE: case SELECT: case BETWEEN: case REGULAR_IDENTIFIER: case DELIMITED_IDENTIFIER: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case BY: case IN: case OR: case IS: case AND: case LIKE: case NULL: case FROM: case ORDER: case WHERE: case SELECT: case BETWEEN: case REGULAR_IDENTIFIER: case DELIMITED_IDENTIFIER: identifier = Identifier();
					 jjtn000.setIdentifier(identifier);
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case PERIOD: jj_consume_token(PERIOD);
						 identifier = Identifier();
						 Node n = jjtree.popNode();
						 jjtree.popNode();
						 jjtree.pushNode(n);
						 jjtn000.setIdentifier(identifier);
						 break;
						 default: jj_la1[7] = jj_gen;
						 ;
					 }
					 break;
					 case LOWER: case UPPER: identifier = PropertyFunction();
					 jjtn000.setIdentifier(identifier);
					 break;
					 default: jj_la1[8] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case LT_OPERATOR: case EQ_OPERATOR: case GT_OPERATOR: case NE_OPERATOR: case GE_OPERATOR: case LE_OPERATOR: operationType = ComparisonOperation();
					 jjtn000.setOperationType(operationType);
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case EXACT_NUMERIC_LITERAL: case APPROXIMATE_NUMERIC_LITERAL: case DATETIME_LITERAL: case CHAR_STRING_LITERAL: Literal();
						 break;
						 case BY: case IN: case OR: case IS: case AND: case LIKE: case NULL: case FROM: case ORDER: case WHERE: case SELECT: case BETWEEN: case REGULAR_IDENTIFIER: case DELIMITED_IDENTIFIER: identifier = Identifier();
						 jjtn000.setIdentifier(identifier);
						 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
							 case PERIOD: jj_consume_token(PERIOD);
							 identifier = Identifier();
							 Node n = jjtree.popNode();
							 jjtree.popNode();
							 jjtree.pushNode(n);
							 jjtn000.setIdentifier(identifier);
							 break;
							 default: jj_la1[9] = jj_gen;
							 ;
						 }
						 break;
						 default: jj_la1[10] = jj_gen;
						 jj_consume_token(-1);
						 throw new ParseException();
					 }
					 break;
					 case NOT: case LIKE: case BETWEEN: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case NOT: jj_consume_token(NOT);
						 jjtn000.setNegate(true);
						 break;
						 default: jj_la1[11] = jj_gen;
						 ;
					 }
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case BETWEEN: jj_consume_token(BETWEEN);
						 jjtn000.setOperationType(QueryConstants.OPERATION_BETWEEN);
						 Literal();
						 jj_consume_token(AND);
						 Literal();
						 break;
						 case LIKE: jj_consume_token(LIKE);
						 jjtn000.setOperationType(QueryConstants.OPERATION_LIKE);
						 value = CharStringLiteral();
						 ASTLiteral s = new ASTLiteral(JJTLITERAL);
						 s.setType(QueryConstants.TYPE_STRING);
						 s.setValue(value);
						 jjtree.pushNode(s);
						 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
							 case ESCAPE: jj_consume_token(ESCAPE);
							 escapeString = CharStringLiteral();
							 jjtn000.setEscapeString(escapeString);
							 break;
							 default: jj_la1[12] = jj_gen;
							 ;
						 }
						 break;
						 default: jj_la1[13] = jj_gen;
						 jj_consume_token(-1);
						 throw new ParseException();
					 }
					 break;
					 case IS: jj_consume_token(IS);
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case NOT: jj_consume_token(NOT);
						 jjtn000.setNegate(true);
						 break;
						 default: jj_la1[14] = jj_gen;
						 ;
					 }
					 jj_consume_token(NULL);
					 jjtree.closeNodeScope(jjtn000, true);
					 jjtc000 = false;
					 jjtn000.setOperationType(jjtn000.isNegate() ? QueryConstants.OPERATION_NOT_NULL : QueryConstants.OPERATION_NULL);
					 break;
					 default: jj_la1[15] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 break;
				 case EXACT_NUMERIC_LITERAL: case APPROXIMATE_NUMERIC_LITERAL: case DATETIME_LITERAL: case CHAR_STRING_LITERAL: Literal();
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case NOT: jj_consume_token(NOT);
					 jjtn000.setNegate(true);
					 break;
					 default: jj_la1[16] = jj_gen;
					 ;
				 }
				 jj_consume_token(IN);
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case BY: case IN: case OR: case IS: case AND: case LIKE: case NULL: case FROM: case ORDER: case WHERE: case SELECT: case BETWEEN: case REGULAR_IDENTIFIER: case DELIMITED_IDENTIFIER: identifier = Identifier();
					 break;
					 case LOWER: case UPPER: identifier = PropertyFunction();
					 break;
					 default: jj_la1[17] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtn000.setIdentifier(identifier);
				 jjtn000.setOperationType(jjtn000.isNegate() ? QueryConstants.OPERATION_NE_GENERAL : QueryConstants.OPERATION_EQ_GENERAL);
				 break;
				 case SIMILAR: jj_consume_token(SIMILAR);
				 jj_consume_token(LEFT_PAREN);
				 jjtn000.setOperationType(QueryConstants.OPERATION_SIMILAR);
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case PERIOD: jj_consume_token(PERIOD);
					 break;
					 case BY: case IN: case OR: case IS: case AND: case LIKE: case NULL: case FROM: case ORDER: case WHERE: case SELECT: case BETWEEN: case REGULAR_IDENTIFIER: case DELIMITED_IDENTIFIER: identifier = Identifier();
					 jjtn000.setIdentifier(identifier);
					 break;
					 default: jj_la1[18] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 jj_consume_token(COMMA);
				 value = CharStringLiteral();
				 ASTLiteral s = new ASTLiteral(JJTLITERAL);
				 s.setType(QueryConstants.TYPE_STRING);
				 s.setValue(value);
				 jjtree.pushNode(s);
				 jj_consume_token(RIGHT_PAREN);
				 break;
				 case SPELLCHECK: jj_consume_token(SPELLCHECK);
				 jj_consume_token(LEFT_PAREN);
				 jjtn000.setOperationType(QueryConstants.OPERATION_SPELLCHECK);
				 value = CharStringLiteral();
				 ASTLiteral stmt = new ASTLiteral(JJTLITERAL);
				 stmt.setType(QueryConstants.TYPE_STRING);
				 stmt.setValue(value);
				 jjtree.pushNode(stmt);
				 jj_consume_token(RIGHT_PAREN);
				 break;
				 default: jj_la1[19] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public Name PropertyFunction() throws ParseException {
		 Name identifier;
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case LOWER: identifier = LowerFunction();
			 break;
			 case UPPER: identifier = UpperFunction();
			 break;
			 default: jj_la1[20] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
		 {
			if (true) return identifier;
		}
		 throw new Error(""Missing return statement in function"");
	 }
	 final public Name LowerFunction() throws ParseException {
		 ASTLowerFunction jjtn000 = new ASTLowerFunction(JJTLOWERFUNCTION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		Name identifier;
		 try {
			 jj_consume_token(LOWER);
			 jj_consume_token(LEFT_PAREN);
			 identifier = Identifier();
			 jj_consume_token(RIGHT_PAREN);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 {
				if (true) return identifier;
			}
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
		 throw new Error(""Missing return statement in function"");
	 }
	 final public Name UpperFunction() throws ParseException {
		 ASTUpperFunction jjtn000 = new ASTUpperFunction(JJTUPPERFUNCTION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		Name identifier;
		 try {
			 jj_consume_token(UPPER);
			 jj_consume_token(LEFT_PAREN);
			 identifier = Identifier();
			 jj_consume_token(RIGHT_PAREN);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 {
				if (true) return identifier;
			}
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
		 throw new Error(""Missing return statement in function"");
	 }
	 final public int ComparisonOperation() throws ParseException {
		 int operationType;
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case EQ_OPERATOR: jj_consume_token(EQ_OPERATOR);
			 operationType = QueryConstants.OPERATION_EQ_GENERAL;
			 break;
			 case NE_OPERATOR: jj_consume_token(NE_OPERATOR);
			 operationType = QueryConstants.OPERATION_NE_GENERAL;
			 break;
			 case LT_OPERATOR: jj_consume_token(LT_OPERATOR);
			 operationType = QueryConstants.OPERATION_LT_GENERAL;
			 break;
			 case GT_OPERATOR: jj_consume_token(GT_OPERATOR);
			 operationType = QueryConstants.OPERATION_GT_GENERAL;
			 break;
			 case LE_OPERATOR: jj_consume_token(LE_OPERATOR);
			 operationType = QueryConstants.OPERATION_LE_GENERAL;
			 break;
			 case GE_OPERATOR: jj_consume_token(GE_OPERATOR);
			 operationType = QueryConstants.OPERATION_GE_GENERAL;
			 break;
			 default: jj_la1[21] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
		 {
			if (true) return operationType;
		}
		 throw new Error(""Missing return statement in function"");
	 }
	 final public void SearchCondition() throws ParseException {
		 OrExpression();
	 }
	 final public void OrExpression() throws ParseException {
		 ASTOrExpression jjtn001 = new ASTOrExpression(JJTOREXPRESSION);
		 boolean jjtc001 = true;
		 jjtree.openNodeScope(jjtn001);
		 try {
			 AndExpression();
			 label_3: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case OR: ;
					 break;
					 default: jj_la1[22] = jj_gen;
					 break label_3;
				 }
				 jj_consume_token(OR);
				 AndExpression();
			 }
		 }
		 catch (Throwable jjte001) {
			 if (jjtc001) {
				 jjtree.clearNodeScope(jjtn001);
				 jjtc001 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte001 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte001;
				}
			 }
			 if (jjte001 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte001;
				}
			 }
			 {
				if (true) throw (Error)jjte001;
			}
		 }
		 finally {
			 if (jjtc001) {
				 jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void AndExpression() throws ParseException {
		 ASTAndExpression jjtn001 = new ASTAndExpression(JJTANDEXPRESSION);
		 boolean jjtc001 = true;
		 jjtree.openNodeScope(jjtn001);
		 try {
			 UnaryExpression();
			 label_4: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case AND: ;
					 break;
					 default: jj_la1[23] = jj_gen;
					 break label_4;
				 }
				 jj_consume_token(AND);
				 UnaryExpression();
			 }
		 }
		 catch (Throwable jjte001) {
			 if (jjtc001) {
				 jjtree.clearNodeScope(jjtn001);
				 jjtc001 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte001 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte001;
				}
			 }
			 if (jjte001 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte001;
				}
			 }
			 {
				if (true) throw (Error)jjte001;
			}
		 }
		 finally {
			 if (jjtc001) {
				 jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void UnaryExpression() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case NOT: ASTNotExpression jjtn001 = new ASTNotExpression(JJTNOTEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jj_consume_token(NOT);
				 UnaryExpression();
			 }
			 catch (Throwable jjte001) {
				 if (jjtc001) {
					 jjtree.clearNodeScope(jjtn001);
					 jjtc001 = false;
				 }
				 else {
					 jjtree.popNode();
				 }
				 if (jjte001 instanceof RuntimeException) {
					 {
						if (true) throw (RuntimeException)jjte001;
					}
				 }
				 if (jjte001 instanceof ParseException) {
					 {
						if (true) throw (ParseException)jjte001;
					}
				 }
				 {
					if (true) throw (Error)jjte001;
				}
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 break;
			 case BY: case IN: case OR: case IS: case AND: case LIKE: case NULL: case FROM: case LOWER: case ORDER: case UPPER: case WHERE: case SELECT: case BETWEEN: case SIMILAR: case CONTAINS: case SPELLCHECK: case LEFT_PAREN: case REGULAR_IDENTIFIER: case DELIMITED_IDENTIFIER: case EXACT_NUMERIC_LITERAL: case APPROXIMATE_NUMERIC_LITERAL: case DATETIME_LITERAL: case CHAR_STRING_LITERAL: PrimaryExpression();
			 break;
			 default: jj_la1[24] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void PrimaryExpression() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case BY: case IN: case OR: case IS: case AND: case LIKE: case NULL: case FROM: case LOWER: case ORDER: case UPPER: case WHERE: case SELECT: case BETWEEN: case SIMILAR: case SPELLCHECK: case REGULAR_IDENTIFIER: case DELIMITED_IDENTIFIER: case EXACT_NUMERIC_LITERAL: case APPROXIMATE_NUMERIC_LITERAL: case DATETIME_LITERAL: case CHAR_STRING_LITERAL: Predicate();
			 break;
			 case LEFT_PAREN: BracketExpression();
			 break;
			 case CONTAINS: ContainsExpression();
			 break;
			 default: jj_la1[25] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void BracketExpression() throws ParseException {
		 ASTBracketExpression jjtn000 = new ASTBracketExpression(JJTBRACKETEXPRESSION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(LEFT_PAREN);
			 SearchCondition();
			 jj_consume_token(RIGHT_PAREN);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void ContainsExpression() throws ParseException {
		 ASTContainsExpression jjtn000 = new ASTContainsExpression(JJTCONTAINSEXPRESSION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		Token t = null;
		 Name name = null;
		 try {
			 jj_consume_token(CONTAINS);
			 jj_consume_token(LEFT_PAREN);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ASTERISK: jj_consume_token(ASTERISK);
				 break;
				 case PERIOD: jj_consume_token(PERIOD);
				 break;
				 case BY: case IN: case OR: case IS: case AND: case LIKE: case NULL: case FROM: case ORDER: case WHERE: case SELECT: case BETWEEN: case REGULAR_IDENTIFIER: case DELIMITED_IDENTIFIER: name = Identifier();
				 jjtn000.setPropertyName(name);
				 break;
				 default: jj_la1[26] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 jj_consume_token(COMMA);
			 t = jj_consume_token(CHAR_STRING_LITERAL);
			 jjtn000.setQuery(t.image.substring(1, t.image.length() - 1).replaceAll(""''"", ""'""));
			 jj_consume_token(RIGHT_PAREN);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Literal() throws ParseException {
		 ASTLiteral jjtn000 = new ASTLiteral(JJTLITERAL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		Token t = null;
		 String value;
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case APPROXIMATE_NUMERIC_LITERAL: t = jj_consume_token(APPROXIMATE_NUMERIC_LITERAL);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtn000.setType(QueryConstants.TYPE_DOUBLE);
				 jjtn000.setValue(t.image);
				 break;
				 case EXACT_NUMERIC_LITERAL: t = jj_consume_token(EXACT_NUMERIC_LITERAL);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 if (t.image.indexOf('.') > -1) {
					 jjtn000.setType(QueryConstants.TYPE_DOUBLE);
				 }
				 else {
					 jjtn000.setType(QueryConstants.TYPE_LONG);
				 }
				 jjtn000.setValue(t.image);
				 break;
				 case CHAR_STRING_LITERAL: value = CharStringLiteral();
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtn000.setType(QueryConstants.TYPE_STRING);
				 jjtn000.setValue(value);
				 break;
				 case DATETIME_LITERAL: t = jj_consume_token(DATETIME_LITERAL);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 if (t.image.startsWith(""TIMESTAMP"")) {
					 jjtn000.setValue(t.image.substring(t.image.indexOf('\'') + 1, t.image.length() - 1));
					 if (jjtn000.getValue().indexOf("" "") == 10) {
						 StringBuffer tmp = new StringBuffer();
						 tmp.append(jjtn000.getValue().substring(0, 10));
						 tmp.append(""T"").append(jjtn000.getValue().substring(11));
						 jjtn000.setValue(tmp.toString());
					 }
					 jjtn000.setType(QueryConstants.TYPE_TIMESTAMP);
				 }
				 else {
					 jjtn000.setValue(t.image.substring(t.image.indexOf('\'') + 1, t.image.length() - 1));
					 jjtn000.setType(QueryConstants.TYPE_DATE);
				 }
				 break;
				 default: jj_la1[27] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public String CharStringLiteral() throws ParseException {
		 Token t;
		 String value = """";
		 t = jj_consume_token(CHAR_STRING_LITERAL);
		 value += t.image.substring(1, t.image.length() - 1);
		 label_5: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case CHAR_STRING_LITERAL: ;
				 break;
				 default: jj_la1[28] = jj_gen;
				 break label_5;
			 }
			 t = jj_consume_token(CHAR_STRING_LITERAL);
			 value += t.image.substring(1, t.image.length() - 1);
		 }
		 {
			if (true) return value.replaceAll(""''"", ""'"");
		}
		 throw new Error(""Missing return statement in function"");
	 }
	 final public Name Identifier() throws ParseException {
		 ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		Token t = null;
		 Name name = null;
		 boolean pseudoProperty = false;
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case REGULAR_IDENTIFIER: t = jj_consume_token(REGULAR_IDENTIFIER);
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case LEFT_PAREN: jj_consume_token(LEFT_PAREN);
					 jj_consume_token(RIGHT_PAREN);
					 pseudoProperty = true;
					 break;
					 default: jj_la1[29] = jj_gen;
					 ;
				 }
				 try {
					 String jcrName = t.image;
					 if (pseudoProperty) {
						 jcrName += ""()"";
					 }
					 jjtn000.setName(resolver.getQName(jcrName));
				 }
				 catch (NameException e) {
					 {
						if (true) throw new ParseException(e.getMessage());
					}
				 }
				 catch (NamespaceException e) {
					 {
						if (true) throw new ParseException(e.getMessage());
					}
				 }
				 break;
				 case DELIMITED_IDENTIFIER: t = jj_consume_token(DELIMITED_IDENTIFIER);
				 try {
					 jjtn000.setName(resolver.getQName(t.image.substring(1, t.image.length()-1)));
				 }
				 catch (NameException e) {
					 {
						if (true) throw new ParseException(e.getMessage());
					}
				 }
				 catch (NamespaceException e) {
					 {
						if (true) throw new ParseException(e.getMessage());
					}
				 }
				 break;
				 case BY: case IN: case OR: case IS: case AND: case LIKE: case NULL: case FROM: case ORDER: case WHERE: case SELECT: case BETWEEN: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case BY: t = jj_consume_token(BY);
					 break;
					 case IN: t = jj_consume_token(IN);
					 break;
					 case OR: t = jj_consume_token(OR);
					 break;
					 case IS: t = jj_consume_token(IS);
					 break;
					 case AND: t = jj_consume_token(AND);
					 break;
					 case LIKE: t = jj_consume_token(LIKE);
					 break;
					 case NULL: t = jj_consume_token(NULL);
					 break;
					 case FROM: t = jj_consume_token(FROM);
					 break;
					 case ORDER: t = jj_consume_token(ORDER);
					 break;
					 case WHERE: t = jj_consume_token(WHERE);
					 break;
					 case SELECT: t = jj_consume_token(SELECT);
					 break;
					 case BETWEEN: t = jj_consume_token(BETWEEN);
					 break;
					 default: jj_la1[30] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 try {
					 jjtn000.setName(resolver.getQName(t.image));
				 }
				 catch (NameException e) {
					 {
						if (true) throw new ParseException(e.getMessage());
					}
				 }
				 catch (NamespaceException e) {
					 {
						if (true) throw new ParseException(e.getMessage());
					}
				 }
				 break;
				 default: jj_la1[31] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 {
				if (true) return jjtn000.getName();
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
		 throw new Error(""Missing return statement in function"");
	 }
	 final public Name ExcerptFunction() throws ParseException {
		 ASTExcerptFunction jjtn000 = new ASTExcerptFunction(JJTEXCERPTFUNCTION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(EXCERPT);
			 jj_consume_token(LEFT_PAREN);
			 jj_consume_token(PERIOD);
			 jj_consume_token(RIGHT_PAREN);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 {
				if (true) return NameFactoryImpl.getInstance().create(Name.NS_REP_URI, ""excerpt(.)"");
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
		 throw new Error(""Missing return statement in function"");
	 }
	 final public void OrderByClause() throws ParseException {
		 ASTOrderByClause jjtn000 = new ASTOrderByClause(JJTORDERBYCLAUSE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(ORDER);
			 jj_consume_token(BY);
			 OrderSpec();
			 label_6: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case COMMA: ;
					 break;
					 default: jj_la1[32] = jj_gen;
					 break label_6;
				 }
				 jj_consume_token(COMMA);
				 OrderSpec();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void OrderSpec() throws ParseException {
		 ASTOrderSpec jjtn000 = new ASTOrderSpec(JJTORDERSPEC);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 Identifier();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ASC: case DESC: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case ASC: AscendingOrderSpec();
					 break;
					 case DESC: DescendingOrderSpec();
					 break;
					 default: jj_la1[33] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 break;
				 default: jj_la1[34] = jj_gen;
				 ;
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void AscendingOrderSpec() throws ParseException {
		 ASTAscendingOrderSpec jjtn000 = new ASTAscendingOrderSpec(JJTASCENDINGORDERSPEC);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(ASC);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DescendingOrderSpec() throws ParseException {
		 ASTDescendingOrderSpec jjtn000 = new ASTDescendingOrderSpec(JJTDESCENDINGORDERSPEC);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(DESC);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 public JCRSQLParserTokenManager token_source;
	 SimpleCharStream jj_input_stream;
	 public Token token, jj_nt;
	 private int jj_ntk;
	 private int jj_gen;
	 final private int[] jj_la1 = new int[35];
	 static private int[] jj_la1_0;
	 static private int[] jj_la1_1;
	 static private int[] jj_la1_2;
	 static private int[] jj_la1_3;
	 static {
		 jj_la1_0();
		 jj_la1_1();
		 jj_la1_2();
		 jj_la1_3();
	 }
	 private static void jj_la1_0() {
		 jj_la1_0 = new int[] {
		0x200000,0x0,0xeae3e00,0x0,0xeae3e00,0x800000,0x0,0x0,0x6fe3e00,0x0,0x6ae3e00,0x8000,0x1000000,0x4020000,0x8000,0x4029000,0x8000,0x6fe3e00,0x6ae3e00,0x56fe3e00,0x500000,0x0,0x800,0x2000,0x76febe00,0x76fe3e00,0x6ae3e00,0x0,0x0,0x0,0x6ae3e00,0x6ae3e00,0x0,0x14000,0x14000,}
		;
	 }
	 private static void jj_la1_1() {
		 jj_la1_1 = new int[] {
		0x0,0x4000,0x10001000,0x10000,0x10000000,0x0,0x4000,0x10000,0x10000000,0x10000,0x10000000,0x0,0x0,0x0,0x0,0x700000,0x0,0x10000000,0x10010000,0x10000000,0x0,0x700000,0x0,0x0,0x10000400,0x10000400,0x10011000,0x0,0x0,0x400,0x0,0x10000000,0x4000,0x0,0x0,}
		;
	 }
	 private static void jj_la1_2() {
		 jj_la1_2 = new int[] {
		0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x21401,0x0,0x0,0x0,0x0,0xe0,0x0,0x1,0x1,0x21401,0x0,0xe0,0x0,0x0,0x21401,0x21401,0x1,0x21400,0x0,0x0,0x0,0x1,0x0,0x0,0x0,}
		;
	 }
	 private static void jj_la1_3() {
		 jj_la1_3 = new int[] {
		0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x4,0x4,0x0,0x4,0x4,0x0,0x0,0x0,0x0,0x0,0x0,}
		;
	 }
	 public JCRSQLParser(java.io.InputStream stream) {
		 this(stream, null);
	 }
	 public JCRSQLParser(java.io.InputStream stream, String encoding) {
		 try {
			 jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
		 }
		 catch(java.io.UnsupportedEncodingException e) {
			 throw new RuntimeException(e);
		 }
		 token_source = new JCRSQLParserTokenManager(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jj_gen = 0;
		 for (int i = 0;
		 i < 35;
		 i++) jj_la1[i] = -1;
	 }
	 public void ReInit(java.io.InputStream stream) {
		 ReInit(stream, null);
	 }
	 public void ReInit(java.io.InputStream stream, String encoding) {
		 try {
			 jj_input_stream.ReInit(stream, encoding, 1, 1);
		 }
		 catch(java.io.UnsupportedEncodingException e) {
			 throw new RuntimeException(e);
		 }
		 token_source.ReInit(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jjtree.reset();
		 jj_gen = 0;
		 for (int i = 0;
		 i < 35;
		 i++) jj_la1[i] = -1;
	 }
	 public JCRSQLParser(java.io.Reader stream) {
		 jj_input_stream = new SimpleCharStream(stream, 1, 1);
		 token_source = new JCRSQLParserTokenManager(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jj_gen = 0;
		 for (int i = 0;
		 i < 35;
		 i++) jj_la1[i] = -1;
	 }
	 public void ReInit(java.io.Reader stream) {
		 jj_input_stream.ReInit(stream, 1, 1);
		 token_source.ReInit(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jjtree.reset();
		 jj_gen = 0;
		 for (int i = 0;
		 i < 35;
		 i++) jj_la1[i] = -1;
	 }
	 public JCRSQLParser(JCRSQLParserTokenManager tm) {
		 token_source = tm;
		 token = new Token();
		 jj_ntk = -1;
		 jj_gen = 0;
		 for (int i = 0;
		 i < 35;
		 i++) jj_la1[i] = -1;
	 }
	 public void ReInit(JCRSQLParserTokenManager tm) {
		 token_source = tm;
		 token = new Token();
		 jj_ntk = -1;
		 jjtree.reset();
		 jj_gen = 0;
		 for (int i = 0;
		 i < 35;
		 i++) jj_la1[i] = -1;
	 }
	 final private Token jj_consume_token(int kind) throws ParseException {
		 Token oldToken;
		 if ((oldToken = token).next != null) token = token.next;
		 else token = token.next = token_source.getNextToken();
		 jj_ntk = -1;
		 if (token.kind == kind) {
			 jj_gen++;
			 return token;
		 }
		 token = oldToken;
		 jj_kind = kind;
		 throw generateParseException();
	 }
	 final public Token getNextToken() {
		 if (token.next != null) token = token.next;
		 else token = token.next = token_source.getNextToken();
		 jj_ntk = -1;
		 jj_gen++;
		 return token;
	 }
	 final public Token getToken(int index) {
		 Token t = token;
		 for (int i = 0;
		 i < index;
		 i++) {
			 if (t.next != null) t = t.next;
			 else t = t.next = token_source.getNextToken();
		 }
		 return t;
	 }
	 final private int jj_ntk() {
		 if ((jj_nt=token.next) == null) return (jj_ntk = (token.next=token_source.getNextToken()).kind);
		 else return (jj_ntk = jj_nt.kind);
	 }
	 private java.util.Vector jj_expentries = new java.util.Vector();
	 private int[] jj_expentry;
	 private int jj_kind = -1;
	 public ParseException generateParseException() {
		 jj_expentries.removeAllElements();
		 boolean[] la1tokens = new boolean[101];
		 for (int i = 0;
		 i < 101;
		 i++) {
			 la1tokens[i] = false;
		 }
		 if (jj_kind >= 0) {
			 la1tokens[jj_kind] = true;
			 jj_kind = -1;
		 }
		 for (int i = 0;
		 i < 35;
		 i++) {
			 if (jj_la1[i] == jj_gen) {
				 for (int j = 0;
				 j < 32;
				 j++) {
					 if ((jj_la1_0[i] & (1<<j)) != 0) {
						 la1tokens[j] = true;
					 }
					 if ((jj_la1_1[i] & (1<<j)) != 0) {
						 la1tokens[32+j] = true;
					 }
					 if ((jj_la1_2[i] & (1<<j)) != 0) {
						 la1tokens[64+j] = true;
					 }
					 if ((jj_la1_3[i] & (1<<j)) != 0) {
						 la1tokens[96+j] = true;
					 }
				 }
			 }
		 }
		 for (int i = 0;
		 i < 101;
		 i++) {
			 if (la1tokens[i]) {
				 jj_expentry = new int[1];
				 jj_expentry[0] = i;
				 jj_expentries.addElement(jj_expentry);
			 }
		 }
		 int[][] exptokseq = new int[jj_expentries.size()][];
		 for (int i = 0;
		 i < jj_expentries.size();
		 i++) {
			 exptokseq[i] = (int[])jj_expentries.elementAt(i);
		 }
		 return new ParseException(token, exptokseq, tokenImage);
	 }
	 final public void enable_tracing() {
	 }
	 final public void disable_tracing() {
	 }
}",1,0,0,0
public XYDatasetTableModel(TableXYDataset dataset);,0,0,0,0
"public void showModal(MessageBox component) {
	lastFocusOwner = getMostRecentFocusOwner();
	System.out.println(""Last focus owner: ""+lastFocusOwner);
	modalPane.add(component);
	component.setVisible(true);
	modalPane.setVisible(true);
	revalidate();
	component.selectDefaultButton();
	startModal(component);
}",0,0,0,0
"public class SequenceFile {
	 public static final Log LOG = LogFactory.getLog(""org.apache.hadoop.io.SequenceFile"");
	 private SequenceFile() {
	}
	 private static final byte BLOCK_COMPRESS_VERSION = (byte)4;
	 private static final byte CUSTOM_COMPRESS_VERSION = (byte)5;
	 private static byte[] VERSION = new byte[] {
	 (byte)'S', (byte)'E', (byte)'Q', CUSTOM_COMPRESS_VERSION }
	;
	 private static final int SYNC_ESCAPE = -1;
	 private static final int SYNC_HASH_SIZE = 16;
	 private static final int SYNC_SIZE = 4+SYNC_HASH_SIZE;
	 public static final int SYNC_INTERVAL = 100*SYNC_SIZE;
	 public static enum CompressionType {
	 NONE, RECORD, BLOCK }
	 static public CompressionType getCompressionType(Configuration job) {
		 String name = job.get(""io.seqfile.compression.type"");
		 return name == null ? CompressionType.RECORD : CompressionType.valueOf(name);
	 }
	 static public void setCompressionType(Configuration job, CompressionType val) {
		 job.set(""io.seqfile.compression.type"", val.toString());
	 }
	 public static Writer createWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType) throws IOException {
		 Writer writer = null;
		 if (compressionType == CompressionType.NONE) {
			 writer = new Writer(fs, conf, name, keyClass, valClass);
		 }
		 else if (compressionType == CompressionType.RECORD) {
			 writer = new RecordCompressWriter(fs, conf, name, keyClass, valClass, new DefaultCodec());
		 }
		 else if (compressionType == CompressionType.BLOCK){
			 writer = new BlockCompressWriter(fs, conf, name, keyClass, valClass, new DefaultCodec());
		 }
		 return writer;
	 }
	 public static Writer createWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, Progressable progress) throws IOException {
		 Writer writer = null;
		 if (compressionType == CompressionType.NONE) {
			 writer = new Writer(fs, conf, name, keyClass, valClass, progress);
		 }
		 else if (compressionType == CompressionType.RECORD) {
			 writer = new RecordCompressWriter(fs, conf, name, keyClass, valClass, new DefaultCodec(), progress);
		 }
		 else if (compressionType == CompressionType.BLOCK){
			 writer = new BlockCompressWriter(fs, conf, name, keyClass, valClass, new DefaultCodec(), progress);
		 }
		 return writer;
	 }
	 public static Writer createWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, CompressionCodec codec) throws IOException {
		 Writer writer = null;
		 if (compressionType == CompressionType.NONE) {
			 writer = new Writer(fs, conf, name, keyClass, valClass);
		 }
		 else if (compressionType == CompressionType.RECORD) {
			 writer = new RecordCompressWriter(fs, conf, name, keyClass, valClass, codec);
		 }
		 else if (compressionType == CompressionType.BLOCK){
			 writer = new BlockCompressWriter(fs, conf, name, keyClass, valClass, codec);
		 }
		 return writer;
	 }
	 public static Writer createWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, CompressionCodec codec, Progressable progress) throws IOException {
		 Writer writer = null;
		 if (compressionType == CompressionType.NONE) {
			 writer = new Writer(fs, conf, name, keyClass, valClass, progress);
		 }
		 else if (compressionType == CompressionType.RECORD) {
			 writer = new RecordCompressWriter(fs, conf, name, keyClass, valClass, codec, progress);
		 }
		 else if (compressionType == CompressionType.BLOCK){
			 writer = new BlockCompressWriter(fs, conf, name, keyClass, valClass, codec, progress);
		 }
		 return writer;
	 }
	 private static Writer createWriter(FSDataOutputStream out, Class keyClass, Class valClass, boolean compress, boolean blockCompress, CompressionCodec codec) throws IOException {
		 Writer writer = null;
		 if (!compress) {
			 writer = new Writer(out, keyClass, valClass);
		 }
		 else if (compress && !blockCompress) {
			 writer = new RecordCompressWriter(out, keyClass, valClass, codec);
		 }
		 else {
			 writer = new BlockCompressWriter(out, keyClass, valClass, codec);
		 }
		 return writer;
	 }
	 public static interface ValueBytes {
		 public void writeUncompressedBytes(DataOutputStream outStream) throws IOException;
		 public void writeCompressedBytes(DataOutputStream outStream) throws IllegalArgumentException, IOException;
	 }
	 private static class UncompressedBytes implements ValueBytes {
		 private int dataSize;
		 private byte[] data;
		 private UncompressedBytes() {
			 data = null;
			 dataSize = 0;
		 }
		 private void reset(DataInputStream in, int length) throws IOException {
			 data = new byte[length];
			 dataSize = -1;
			 in.readFully(data);
			 dataSize = data.length;
		 }
		 public int getSize() {
			 return dataSize;
		 }
		 public void writeUncompressedBytes(DataOutputStream outStream) throws IOException {
			 outStream.write(data, 0, dataSize);
		 }
		 public void writeCompressedBytes(DataOutputStream outStream) throws IllegalArgumentException, IOException {
			 throw new IllegalArgumentException(""UncompressedBytes cannot be compressed!"");
		 }
	 }
	 private static class CompressedBytes implements ValueBytes {
		 private int dataSize;
		 private byte[] data;
		 DataInputBuffer rawData = null;
		 CompressionCodec codec = null;
		 CompressionInputStream decompressedStream = null;
		 private CompressedBytes(CompressionCodec codec) {
			 data = null;
			 dataSize = 0;
			 this.codec = codec;
		 }
		 private void reset(DataInputStream in, int length) throws IOException {
			 data = new byte[length];
			 dataSize = -1;
			 in.readFully(data);
			 dataSize = data.length;
		 }
		 public int getSize() {
			 return dataSize;
		 }
		 public void writeUncompressedBytes(DataOutputStream outStream) throws IOException {
			 if (decompressedStream == null) {
				 rawData = new DataInputBuffer();
				 decompressedStream = codec.createInputStream(rawData);
			 }
			 else {
				 decompressedStream.resetState();
			 }
			 rawData.reset(data, 0, dataSize);
			 byte[] buffer = new byte[8192];
			 int bytesRead = 0;
			 while ((bytesRead = decompressedStream.read(buffer, 0, 8192)) != -1) {
				 outStream.write(buffer, 0, bytesRead);
			 }
		 }
		 public void writeCompressedBytes(DataOutputStream outStream) throws IllegalArgumentException, IOException {
			 outStream.write(data, 0, dataSize);
		 }
	 }
	 public static class Writer {
		 FSDataOutputStream out;
		 DataOutputBuffer buffer = new DataOutputBuffer();
		 Path target = null;
		 Class keyClass;
		 Class valClass;
		 private boolean compress;
		 CompressionCodec codec = null;
		 CompressionOutputStream deflateFilter = null;
		 DataOutputStream deflateOut = null;
		 long lastSyncPos;
		 byte[] sync;
		 {
			 try {
				 MessageDigest digester = MessageDigest.getInstance(""MD5"");
				 digester.update((new UID()+""@""+InetAddress.getLocalHost()).getBytes());
				 sync = digester.digest();
			 }
			 catch (Exception e) {
				 throw new RuntimeException(e);
			 }
		 }
		 public Writer(FileSystem fs, String name, Class keyClass, Class valClass) throws IOException {
			 this(fs, new Path(name), keyClass, valClass, false);
		 }
		 Writer() {
		}
		 public Writer(FileSystem fs, Path name, Class keyClass, Class valClass) throws IOException {
			 this(fs, name, keyClass, valClass, false);
		 }
		 public Writer(FileSystem fs, Path name, Class keyClass, Class valClass, Progressable progress) throws IOException {
			 this(fs, name, keyClass, valClass, false, progress);
		 }
		 public Writer(FileSystem fs, Path name, Class keyClass, Class valClass, boolean compress) throws IOException {
			 init(name, fs.create(name), keyClass, valClass, compress, null);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 public Writer(FileSystem fs, Path name, Class keyClass, Class valClass, boolean compress, Progressable progress) throws IOException {
			 init(name, fs.create(name, progress), keyClass, valClass, compress, null);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 public Writer(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass) throws IOException {
			 this(fs, name, keyClass, valClass, false);
		 }
		 public Writer(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, Progressable progress) throws IOException {
			 this(fs, name, keyClass, valClass, false, progress);
		 }
		 private Writer(FSDataOutputStream out, Class keyClass, Class valClass) throws IOException {
			 init(null, out, keyClass, valClass, false, null);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 void initializeFileHeader() throws IOException{
			 out.write(VERSION);
		 }
		 void finalizeFileHeader() throws IOException{
			 out.write(sync);
			 out.flush();
		 }
		 boolean isCompressed() {
			 return compress;
		 }
		 boolean isBlockCompressed() {
			 return false;
		 }
		 void writeFileHeader() throws IOException {
			 Text.writeString(out, keyClass.getName());
			 Text.writeString(out, valClass.getName());
			 out.writeBoolean(this.isCompressed());
			 out.writeBoolean(this.isBlockCompressed());
			 if(this.isCompressed()) {
				 Text.writeString(out, (codec.getClass()).getName());
			 }
		 }
		 void init(Path name, FSDataOutputStream out, Class keyClass, Class valClass, boolean compress, CompressionCodec codec) throws IOException {
			 this.target = name;
			 this.out = out;
			 this.keyClass = keyClass;
			 this.valClass = valClass;
			 this.compress = compress;
			 this.codec = codec;
			 if(this.codec != null) {
				 this.deflateFilter = this.codec.createOutputStream(buffer);
				 this.deflateOut = new DataOutputStream(new BufferedOutputStream(deflateFilter));
			 }
		 }
		 public Class getKeyClass() {
			 return keyClass;
		 }
		 public Class getValueClass() {
			 return valClass;
		 }
		 public CompressionCodec getCompressionCodec() {
			 return codec;
		 }
		 public synchronized void close() throws IOException {
			 if (out != null) {
				 out.close();
				 out = null;
			 }
		 }
		 synchronized void checkAndWriteSync() throws IOException {
			 if (sync != null && out.getPos() >= lastSyncPos+SYNC_INTERVAL) {
				 lastSyncPos = out.getPos();
				 out.writeInt(SYNC_ESCAPE);
				 out.write(sync);
			 }
		 }
		 public synchronized void append(Writable key, Writable val) throws IOException {
			 if (key.getClass() != keyClass) throw new IOException(""wrong key class: ""+key+"" is not ""+keyClass);
			 if (val.getClass() != valClass) throw new IOException(""wrong value class: ""+val+"" is not ""+valClass);
			 buffer.reset();
			 key.write(buffer);
			 int keyLength = buffer.getLength();
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed: "" + key);
			 if (compress) {
				 deflateFilter.resetState();
				 val.write(deflateOut);
				 deflateOut.flush();
				 deflateFilter.finish();
			 }
			 else {
				 val.write(buffer);
			 }
			 checkAndWriteSync();
			 out.writeInt(buffer.getLength());
			 out.writeInt(keyLength);
			 out.write(buffer.getData(), 0, buffer.getLength());
		 }
		 public synchronized void append(byte[] data, int start, int length, int keyLength) throws IOException {
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed"");
			 checkAndWriteSync();
			 out.writeInt(length);
			 out.writeInt(keyLength);
			 out.write(data, start, length);
		 }
		 public synchronized void appendRaw( byte[] keyData, int keyOffset, int keyLength, ValueBytes val) throws IOException {
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed: "" + keyLength);
			 UncompressedBytes value = (UncompressedBytes)val;
			 int valLength = value.getSize();
			 checkAndWriteSync();
			 out.writeInt(keyLength+valLength);
			 out.writeInt(keyLength);
			 out.write(keyData, keyOffset, keyLength);
			 val.writeUncompressedBytes(out);
		 }
		 public synchronized long getLength() throws IOException {
			 return out.getPos();
		 }
	 }
	 static class RecordCompressWriter extends Writer {
		 public RecordCompressWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionCodec codec) throws IOException {
			 super.init(name, fs.create(name), keyClass, valClass, true, codec);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 public RecordCompressWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionCodec codec, Progressable progress) throws IOException {
			 super.init(name, fs.create(name, progress), keyClass, valClass, true, codec);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 private RecordCompressWriter(FSDataOutputStream out, Class keyClass, Class valClass, CompressionCodec codec) throws IOException {
			 super.init(null, out, keyClass, valClass, true, codec);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 boolean isCompressed() {
			 return true;
		 }
		 boolean isBlockCompressed() {
			 return false;
		 }
		 public synchronized void append(Writable key, Writable val) throws IOException {
			 if (key.getClass() != keyClass) throw new IOException(""wrong key class: ""+key+"" is not ""+keyClass);
			 if (val.getClass() != valClass) throw new IOException(""wrong value class: ""+val+"" is not ""+valClass);
			 buffer.reset();
			 key.write(buffer);
			 int keyLength = buffer.getLength();
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed: "" + key);
			 deflateFilter.resetState();
			 val.write(deflateOut);
			 deflateOut.flush();
			 deflateFilter.finish();
			 checkAndWriteSync();
			 out.writeInt(buffer.getLength());
			 out.writeInt(keyLength);
			 out.write(buffer.getData(), 0, buffer.getLength());
		 }
		 public synchronized void appendRaw( byte[] keyData, int keyOffset, int keyLength, ValueBytes val ) throws IOException {
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed"");
			 CompressedBytes value = (CompressedBytes)val;
			 int valLength = value.getSize();
			 checkAndWriteSync();
			 out.writeInt(keyLength+valLength);
			 out.writeInt(keyLength);
			 out.write(keyData, keyOffset, keyLength);
			 val.writeCompressedBytes(out);
		 }
	 }
	 static class BlockCompressWriter extends Writer {
		 private int noBufferedRecords = 0;
		 private DataOutputBuffer keyLenBuffer = new DataOutputBuffer();
		 private DataOutputBuffer keyBuffer = new DataOutputBuffer();
		 private DataOutputBuffer valLenBuffer = new DataOutputBuffer();
		 private DataOutputBuffer valBuffer = new DataOutputBuffer();
		 private int compressionBlockSize;
		 public BlockCompressWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionCodec codec) throws IOException {
			 super.init(name, fs.create(name), keyClass, valClass, true, codec);
			 init(conf.getInt(""io.seqfile.compress.blocksize"", 1000000));
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 public BlockCompressWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionCodec codec, Progressable progress) throws IOException {
			 super.init(name, fs.create(name, progress), keyClass, valClass, true, codec);
			 init(conf.getInt(""io.seqfile.compress.blocksize"", 1000000));
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 private BlockCompressWriter(FSDataOutputStream out, Class keyClass, Class valClass, CompressionCodec codec) throws IOException {
			 super.init(null, out, keyClass, valClass, true, codec);
			 init(1000000);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 boolean isCompressed() {
			 return true;
		 }
		 boolean isBlockCompressed() {
			 return true;
		 }
		 void init(int compressionBlockSize) {
			 this.compressionBlockSize = compressionBlockSize;
		 }
		 private synchronized void writeBuffer(DataOutputBuffer uncompressedDataBuffer) throws IOException {
			 deflateFilter.resetState();
			 buffer.reset();
			 deflateOut.write(uncompressedDataBuffer.getData(), 0, uncompressedDataBuffer.getLength());
			 deflateOut.flush();
			 deflateFilter.finish();
			 WritableUtils.writeVInt(out, buffer.getLength());
			 out.write(buffer.getData(), 0, buffer.getLength());
		 }
		 private synchronized void writeBlock() throws IOException {
			 if (noBufferedRecords > 0) {
				 if (sync != null) {
					 out.writeInt(SYNC_ESCAPE);
					 out.write(sync);
				 }
				 WritableUtils.writeVInt(out, noBufferedRecords);
				 writeBuffer(keyLenBuffer);
				 writeBuffer(keyBuffer);
				 writeBuffer(valLenBuffer);
				 writeBuffer(valBuffer);
				 out.flush();
				 keyLenBuffer.reset();
				 keyBuffer.reset();
				 valLenBuffer.reset();
				 valBuffer.reset();
				 noBufferedRecords = 0;
			 }
		 }
		 public synchronized void close() throws IOException {
			 if (out != null) {
				 writeBlock();
				 out.close();
				 out = null;
			 }
		 }
		 public synchronized void append(Writable key, Writable val) throws IOException {
			 if (key.getClass() != keyClass) throw new IOException(""wrong key class: ""+key+"" is not ""+keyClass);
			 if (val.getClass() != valClass) throw new IOException(""wrong value class: ""+val+"" is not ""+valClass);
			 int oldKeyLength = keyBuffer.getLength();
			 key.write(keyBuffer);
			 int keyLength = keyBuffer.getLength() - oldKeyLength;
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed: "" + key);
			 WritableUtils.writeVInt(keyLenBuffer, keyLength);
			 int oldValLength = valBuffer.getLength();
			 val.write(valBuffer);
			 int valLength = valBuffer.getLength() - oldValLength;
			 WritableUtils.writeVInt(valLenBuffer, valLength);
			 ++noBufferedRecords;
			 int currentBlockSize = keyBuffer.getLength() + valBuffer.getLength();
			 if (currentBlockSize >= compressionBlockSize) {
				 writeBlock();
			 }
		 }
		 public synchronized void appendRaw( byte[] keyData, int keyOffset, int keyLength, ValueBytes val ) throws IOException {
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed"");
			 UncompressedBytes value = (UncompressedBytes)val;
			 int valLength = value.getSize();
			 WritableUtils.writeVInt(keyLenBuffer, keyLength);
			 keyBuffer.write(keyData, keyOffset, keyLength);
			 WritableUtils.writeVInt(valLenBuffer, valLength);
			 val.writeUncompressedBytes(valBuffer);
			 ++noBufferedRecords;
			 int currentBlockSize = keyBuffer.getLength() + valBuffer.getLength();
			 if (currentBlockSize >= compressionBlockSize) {
				 writeBlock();
			 }
		 }
	 }
	 public static class Reader {
		 private Path file;
		 private FSDataInputStream in;
		 private DataOutputBuffer outBuf = new DataOutputBuffer();
		 private byte version;
		 private Class keyClass;
		 private Class valClass;
		 private CompressionCodec codec = null;
		 private byte[] sync = new byte[SYNC_HASH_SIZE];
		 private byte[] syncCheck = new byte[SYNC_HASH_SIZE];
		 private boolean syncSeen;
		 private long end;
		 private int keyLength;
		 private boolean decompress;
		 private boolean blockCompressed;
		 private Configuration conf;
		 private int noBufferedRecords = 0;
		 private boolean lazyDecompress = true;
		 private boolean valuesDecompressed = true;
		 private int noBufferedKeys = 0;
		 private int noBufferedValues = 0;
		 private DataInputBuffer keyLenBuffer = null;
		 private CompressionInputStream keyLenInFilter = null;
		 private DataInputStream keyLenIn = null;
		 private DataInputBuffer keyBuffer = null;
		 private CompressionInputStream keyInFilter = null;
		 private DataInputStream keyIn = null;
		 private DataInputBuffer valLenBuffer = null;
		 private CompressionInputStream valLenInFilter = null;
		 private DataInputStream valLenIn = null;
		 private DataInputBuffer valBuffer = null;
		 private CompressionInputStream valInFilter = null;
		 private DataInputStream valIn = null;
		 public Reader(FileSystem fs, String file, Configuration conf) throws IOException {
			 this(fs, new Path(file), conf);
		 }
		 public Reader(FileSystem fs, Path file, Configuration conf) throws IOException {
			 this(fs, file, conf.getInt(""io.file.buffer.size"", 4096), conf);
		 }
		 private Reader(FileSystem fs, Path name, int bufferSize, Configuration conf) throws IOException {
			 this.file = name;
			 this.in = fs.open(file, bufferSize);
			 this.end = fs.getLength(file);
			 this.conf = conf;
			 init();
		 }
		 private Reader(FileSystem fs, Path file, int bufferSize, long start, long length, Configuration conf) throws IOException {
			 this.file = file;
			 this.in = fs.open(file, bufferSize);
			 this.conf = conf;
			 seek(start);
			 this.end = in.getPos() + length;
			 init();
		 }
		 private void init() throws IOException {
			 byte[] versionBlock = new byte[VERSION.length];
			 in.readFully(versionBlock);
			 if ((versionBlock[0] != VERSION[0]) || (versionBlock[1] != VERSION[1]) || (versionBlock[2] != VERSION[2])) throw new IOException(file + "" not a SequenceFile"");
			 version = versionBlock[3];
			 if (version > VERSION[3]) throw new VersionMismatchException(VERSION[3], version);
			 if (version < BLOCK_COMPRESS_VERSION) {
				 UTF8 className = new UTF8();
				 className.readFields(in);
				 this.keyClass = WritableName.getClass(className.toString(), conf);
				 className.readFields(in);
				 this.valClass = WritableName.getClass(className.toString(), conf);
			 }
			 else {
				 this.keyClass = WritableName.getClass(Text.readString(in), conf);
				 this.valClass = WritableName.getClass(Text.readString(in), conf);
			 }
			 if (version > 2) {
				 this.decompress = in.readBoolean();
			 }
			 if (version >= BLOCK_COMPRESS_VERSION) {
				 this.blockCompressed = in.readBoolean();
			 }
			 if (version >= CUSTOM_COMPRESS_VERSION && this.decompress) {
				 try {
					 this.codec = (CompressionCodec) ReflectionUtils.newInstance(conf.getClassByName(Text.readString(in)), conf);
				 }
				 catch (ClassNotFoundException cnfe) {
					 cnfe.printStackTrace();
					 throw new IllegalArgumentException(""Unknown codec: "" + cnfe);
				 }
			 }
			 if (version > 1) {
				 in.readFully(sync);
			 }
			 valBuffer = new DataInputBuffer();
			 if (decompress) {
				 valInFilter = this.codec.createInputStream(valBuffer);
				 valIn = new DataInputStream(new BufferedInputStream(valInFilter));
			 }
			 else {
				 valIn = new DataInputStream(new BufferedInputStream(valBuffer));
			 }
			 if (blockCompressed) {
				 keyLenBuffer = new DataInputBuffer();
				 keyBuffer = new DataInputBuffer();
				 valLenBuffer = new DataInputBuffer();
				 keyLenInFilter = this.codec.createInputStream(keyLenBuffer);
				 keyLenIn = new DataInputStream(new BufferedInputStream(keyLenInFilter));
				 keyInFilter = this.codec.createInputStream(keyBuffer);
				 keyIn = new DataInputStream(new BufferedInputStream(keyInFilter));
				 valLenInFilter = this.codec.createInputStream(valLenBuffer);
				 valLenIn = new DataInputStream(new BufferedInputStream(valLenInFilter));
			 }
			 lazyDecompress = conf.getBoolean(""io.seqfile.lazydecompress"", true);
		 }
		 public synchronized void close() throws IOException {
			 in.close();
		 }
		 public Class getKeyClass() {
			 return keyClass;
		 }
		 public Class getValueClass() {
			 return valClass;
		 }
		 public boolean isCompressed() {
			 return decompress;
		 }
		 public boolean isBlockCompressed() {
			 return blockCompressed;
		 }
		 public CompressionCodec getCompressionCodec() {
			 return codec;
		 }
		 private synchronized void readBuffer(DataInputBuffer buffer, CompressionInputStream filter, boolean castAway) throws IOException {
			 DataOutputBuffer dataBuffer = new DataOutputBuffer();
			 int dataBufferLength = WritableUtils.readVInt(in);
			 dataBuffer.write(in, dataBufferLength);
			 if (false == castAway) {
				 filter.resetState();
				 buffer.reset(dataBuffer.getData(), 0, dataBuffer.getLength());
			 }
		 }
		 private synchronized void readBlock() throws IOException {
			 if (lazyDecompress && !valuesDecompressed) {
				 readBuffer(null, null, true);
				 readBuffer(null, null, true);
			 }
			 noBufferedKeys = 0;
			 noBufferedValues = 0;
			 noBufferedRecords = 0;
			 valuesDecompressed = false;
			 if (sync != null) {
				 in.readInt();
				 in.readFully(syncCheck);
				 if (!Arrays.equals(sync, syncCheck)) throw new IOException(""File is corrupt!"");
			 }
			 syncSeen = true;
			 noBufferedRecords = WritableUtils.readVInt(in);
			 readBuffer(keyLenBuffer, keyLenInFilter, false);
			 readBuffer(keyBuffer, keyInFilter, false);
			 noBufferedKeys = noBufferedRecords;
			 if (!lazyDecompress) {
				 readBuffer(valLenBuffer, valLenInFilter, false);
				 readBuffer(valBuffer, valInFilter, false);
				 noBufferedValues = noBufferedRecords;
				 valuesDecompressed = true;
			 }
		 }
		 private synchronized void seekToCurrentValue() throws IOException {
			 if (version < BLOCK_COMPRESS_VERSION || blockCompressed == false) {
				 if (decompress) {
					 valInFilter.resetState();
				 }
			 }
			 else {
				 if (lazyDecompress && !valuesDecompressed) {
					 readBuffer(valLenBuffer, valLenInFilter, false);
					 readBuffer(valBuffer, valInFilter, false);
					 noBufferedValues = noBufferedRecords;
					 valuesDecompressed = true;
				 }
				 int skipValBytes = 0;
				 int currentKey = noBufferedKeys + 1;
				 for (int i=noBufferedValues;
				 i > currentKey;
				 --i) {
					 skipValBytes += WritableUtils.readVInt(valLenIn);
					 --noBufferedValues;
				 }
				 if (skipValBytes > 0) {
					 if (valIn.skipBytes(skipValBytes) != skipValBytes) {
						 throw new IOException(""Failed to seek to "" + currentKey + ""(th) value!"");
					 }
				 }
			 }
		 }
		 public synchronized void getCurrentValue(Writable val) throws IOException {
			 if (val instanceof Configurable) {
				 ((Configurable) val).setConf(this.conf);
			 }
			 seekToCurrentValue();
			 if (version < BLOCK_COMPRESS_VERSION || blockCompressed == false) {
				 val.readFields(valIn);
				 if (valBuffer.getPosition() != valBuffer.getLength()) throw new IOException(val+"" read ""+(valBuffer.getPosition()-keyLength) + "" bytes, should read "" + (valBuffer.getLength()-keyLength));
			 }
			 else {
				 int valLength = WritableUtils.readVInt(valLenIn);
				 val.readFields(valIn);
				 --noBufferedValues;
				 if (valLength < 0) {
					 LOG.debug(val + "" is a zero-length value"");
				 }
			 }
		 }
		 public synchronized boolean next(Writable key) throws IOException {
			 if (key.getClass() != keyClass) throw new IOException(""wrong key class: ""+key+"" is not ""+keyClass);
			 if (version < BLOCK_COMPRESS_VERSION || blockCompressed == false) {
				 outBuf.reset();
				 keyLength = next(outBuf);
				 if (keyLength < 0) return false;
				 valBuffer.reset(outBuf.getData(), outBuf.getLength());
				 key.readFields(valBuffer);
				 if (valBuffer.getPosition() != keyLength) throw new IOException(key + "" read "" + valBuffer.getPosition() + "" bytes, should read "" + keyLength);
			 }
			 else {
				 syncSeen = false;
				 if (noBufferedKeys == 0) {
					 try {
						 readBlock();
					 }
					 catch (EOFException eof) {
						 return false;
					 }
				 }
				 int keyLength = WritableUtils.readVInt(keyLenIn);
				 if (keyLength < 0) {
					 return false;
				 }
				 key.readFields(keyIn);
				 --noBufferedKeys;
			 }
			 return true;
		 }
		 public synchronized boolean next(Writable key, Writable val) throws IOException {
			 if (val.getClass() != valClass) throw new IOException(""wrong value class: ""+val+"" is not ""+valClass);
			 boolean more = next(key);
			 if (more) {
				 getCurrentValue(val);
			 }
			 return more;
		 }
		 private synchronized int checkAndReadSync(int length) throws IOException {
			 if (version > 1 && sync != null && length == SYNC_ESCAPE) {
				 in.readFully(syncCheck);
				 if (!Arrays.equals(sync, syncCheck)) throw new IOException(""File is corrupt!"");
				 syncSeen = true;
				 length = in.readInt();
			 }
			 else {
				 syncSeen = false;
			 }
			 return length;
		 }
		 public synchronized int next(DataOutputBuffer buffer) throws IOException {
			 if (version >= BLOCK_COMPRESS_VERSION && blockCompressed) {
				 throw new IOException(""Unsupported call for block-compressed"" + "" SequenceFiles - use SequenceFile.Reader.next(DataOutputStream, ValueBytes)"");
			 }
			 if (in.getPos() >= end) return -1;
			 try {
				 int length = checkAndReadSync(in.readInt());
				 int keyLength = in.readInt();
				 buffer.write(in, length);
				 return keyLength;
			 }
			 catch (ChecksumException e) {
				 handleChecksumException(e);
				 return next(buffer);
			 }
		 }
		 public ValueBytes createValueBytes() {
			 ValueBytes val = null;
			 if (!decompress || blockCompressed) {
				 val = new UncompressedBytes();
			 }
			 else {
				 val = new CompressedBytes(codec);
			 }
			 return val;
		 }
		 public int nextRaw(DataOutputBuffer key, ValueBytes val) throws IOException {
			 if (version < BLOCK_COMPRESS_VERSION || blockCompressed == false) {
				 if (in.getPos() >= end) return -1;
				 int length = checkAndReadSync(in.readInt());
				 int keyLength = in.readInt();
				 int valLength = length - keyLength;
				 key.write(in, keyLength);
				 if (decompress) {
					 CompressedBytes value = (CompressedBytes)val;
					 value.reset(in, valLength);
				 }
				 else {
					 UncompressedBytes value = (UncompressedBytes)val;
					 value.reset(in, valLength);
				 }
				 return length;
			 }
			 else {
				 syncSeen = false;
				 if (noBufferedKeys == 0) {
					 if (in.getPos() >= end) return -1;
					 try {
						 readBlock();
					 }
					 catch (EOFException eof) {
						 return -1;
					 }
				 }
				 int keyLength = WritableUtils.readVInt(keyLenIn);
				 if (keyLength < 0) {
					 throw new IOException(""zero length key found!"");
				 }
				 key.write(keyIn, keyLength);
				 --noBufferedKeys;
				 seekToCurrentValue();
				 int valLength = WritableUtils.readVInt(valLenIn);
				 UncompressedBytes rawValue = (UncompressedBytes)val;
				 rawValue.reset(valIn, valLength);
				 --noBufferedValues;
				 return (keyLength+valLength);
			 }
		 }
		 private void handleChecksumException(ChecksumException e) throws IOException {
			 if (this.conf.getBoolean(""io.skip.checksum.errors"", false)) {
				 LOG.warn(""Bad checksum at ""+getPosition()+"". Skipping entries."");
				 sync(getPosition()+this.conf.getInt(""io.bytes.per.checksum"", 512));
			 }
			 else {
				 throw e;
			 }
		 }
		 public synchronized void seek(long position) throws IOException {
			 in.seek(position);
		 }
		 public synchronized void sync(long position) throws IOException {
			 if (position+SYNC_SIZE >= end) {
				 seek(end);
				 return;
			 }
			 try {
				 seek(position+4);
				 in.readFully(syncCheck);
				 int syncLen = sync.length;
				 for (int i = 0;
				 in.getPos() < end;
				 i++) {
					 int j = 0;
					 for (;
					 j < syncLen;
					 j++) {
						 if (sync[j] != syncCheck[(i+j)%syncLen]) break;
					 }
					 if (j == syncLen) {
						 in.seek(in.getPos() - SYNC_SIZE);
						 return;
					 }
					 syncCheck[i%syncLen] = in.readByte();
				 }
			 }
			 catch (ChecksumException e) {
				 handleChecksumException(e);
			 }
		 }
		 public boolean syncSeen() {
			 return syncSeen;
		 }
		 public synchronized long getPosition() throws IOException {
			 return in.getPos();
		 }
		 public String toString() {
			 return file.toString();
		 }
	 }
	 public static class Sorter {
		 private WritableComparator comparator;
		 private Path[] inFiles;
		 private Path outFile;
		 private int memory;
		 private int factor;
		 private FileSystem fs = null;
		 private Class keyClass;
		 private Class valClass;
		 private Configuration conf;
		 public Sorter(FileSystem fs, Class keyClass, Class valClass, Configuration conf) {
			 this(fs, new WritableComparator(keyClass), valClass, conf);
		 }
		 public Sorter(FileSystem fs, WritableComparator comparator, Class valClass, Configuration conf) {
			 this.fs = fs;
			 this.comparator = comparator;
			 this.keyClass = comparator.getKeyClass();
			 this.valClass = valClass;
			 this.memory = conf.getInt(""io.sort.mb"", 100) * 1024 * 1024;
			 this.factor = conf.getInt(""io.sort.factor"", 100);
			 this.conf = conf;
		 }
		 public void setFactor(int factor) {
			 this.factor = factor;
		 }
		 public int getFactor() {
			 return factor;
		 }
		 public void setMemory(int memory) {
			 this.memory = memory;
		 }
		 public int getMemory() {
			 return memory;
		 }
		 public void sort(Path[] inFiles, Path outFile, boolean deleteInput) throws IOException {
			 if (fs.exists(outFile)) {
				 throw new IOException(""already exists: "" + outFile);
			 }
			 this.inFiles = inFiles;
			 this.outFile = outFile;
			 int segments = sortPass(deleteInput);
			 int pass = 1;
			 while (segments > 1) {
				 segments = mergePass(pass, segments <= factor);
				 pass++;
			 }
			 for (int i=0;
			 i < pass;
			 ++i) {
				 fs.delete(new Path(outFile.toString() + ""."" + i));
				 fs.delete(new Path(outFile.toString() + ""."" + i + "".index""));
			 }
		 }
		 public void sort(Path inFile, Path outFile) throws IOException {
			 sort(new Path[]{
			inFile}
			, outFile, false);
		 }
		 private int sortPass(boolean deleteInput) throws IOException {
			 LOG.debug(""running sort pass"");
			 SortPass sortPass = new SortPass();
			 try {
				 return sortPass.run(deleteInput);
			 }
			 finally {
				 sortPass.close();
			 }
		 }
		 private class SortPass {
			 private int memoryLimit = memory/4;
			 private int recordLimit = 1000000;
			 private DataOutputBuffer rawKeys = new DataOutputBuffer();
			 private byte[] rawBuffer;
			 private int[] keyOffsets = new int[1024];
			 private int[] pointers = new int[keyOffsets.length];
			 private int[] pointersCopy = new int[keyOffsets.length];
			 private int[] keyLengths = new int[keyOffsets.length];
			 private ValueBytes[] rawValues = new ValueBytes[keyOffsets.length];
			 private ArrayList segmentLengths = new ArrayList();
			 private Reader in = null;
			 private FSDataOutputStream out = null;
			 private FSDataOutputStream indexOut = null;
			 private Path outName;
			 public int run(boolean deleteInput) throws IOException {
				 int segments = 0;
				 int currentFile = 0;
				 boolean atEof = (currentFile >= inFiles.length);
				 boolean isCompressed = false;
				 boolean isBlockCompressed = false;
				 CompressionCodec codec = null;
				 segmentLengths.clear();
				 if (atEof) {
					 return 0;
				 }
				 in = new Reader(fs, inFiles[currentFile], conf);
				 isCompressed = in.isCompressed();
				 isBlockCompressed = in.isBlockCompressed();
				 codec = in.getCompressionCodec();
				 for (int i=0;
				 i < rawValues.length;
				 ++i) {
					 rawValues[i] = null;
				 }
				 while (!atEof) {
					 int count = 0;
					 int bytesProcessed = 0;
					 rawKeys.reset();
					 while (!atEof && bytesProcessed < memoryLimit && count < recordLimit) {
						 int keyOffset = rawKeys.getLength();
						 ValueBytes rawValue = (count == keyOffsets.length || rawValues[count] == null) ? in.createValueBytes() : rawValues[count];
						 int recordLength = in.nextRaw(rawKeys, rawValue);
						 if (recordLength == -1) {
							 in.close();
							 if (deleteInput) {
								 fs.delete(inFiles[currentFile]);
							 }
							 currentFile += 1;
							 atEof = currentFile >= inFiles.length;
							 if (!atEof) {
								 in = new Reader(fs, inFiles[currentFile], conf);
							 }
							 else {
								 in = null;
							 }
							 continue;
						 }
						 int keyLength = rawKeys.getLength() - keyOffset;
						 if (count == keyOffsets.length) grow();
						 keyOffsets[count] = keyOffset;
						 pointers[count] = count;
						 keyLengths[count] = keyLength;
						 rawValues[count] = rawValue;
						 bytesProcessed += recordLength;
						 count++;
					 }
					 LOG.debug(""flushing segment "" + segments);
					 rawBuffer = rawKeys.getData();
					 sort(count);
					 flush(count, bytesProcessed, isCompressed, isBlockCompressed, codec, segments==0 && atEof);
					 segments++;
				 }
				 return segments;
			 }
			 public void close() throws IOException {
				 if (in != null) {
					 in.close();
				 }
				 if (out != null) {
					 out.close();
				 }
				 if (indexOut != null) {
					 indexOut.close();
				 }
			 }
			 private void grow() {
				 int newLength = keyOffsets.length * 3 / 2;
				 keyOffsets = grow(keyOffsets, newLength);
				 pointers = grow(pointers, newLength);
				 pointersCopy = new int[newLength];
				 keyLengths = grow(keyLengths, newLength);
				 rawValues = grow(rawValues, newLength);
			 }
			 private int[] grow(int[] old, int newLength) {
				 int[] result = new int[newLength];
				 System.arraycopy(old, 0, result, 0, old.length);
				 return result;
			 }
			 private ValueBytes[] grow(ValueBytes[] old, int newLength) {
				 ValueBytes[] result = new ValueBytes[newLength];
				 System.arraycopy(old, 0, result, 0, old.length);
				 for (int i=old.length;
				 i < newLength;
				 ++i) {
					 result[i] = null;
				 }
				 return result;
			 }
			 private void flush(int count, int bytesProcessed, boolean isCompressed, boolean isBlockCompressed, CompressionCodec codec, boolean done) throws IOException {
				 if (out == null) {
					 outName = done ? outFile : outFile.suffix("".0"");
					 out = fs.create(outName);
					 if (!done) {
						 indexOut = fs.create(outName.suffix("".index""));
					 }
				 }
				 long segmentStart = out.getPos();
				 Writer writer = createWriter(out, keyClass, valClass, isCompressed, isBlockCompressed, codec);
				 if (!done) {
					 writer.sync = null;
				 }
				 for (int i = 0;
				 i < count;
				 i++) {
					 int p = pointers[i];
					 writer.appendRaw(rawBuffer, keyOffsets[p], keyLengths[p], rawValues[p]);
				 }
				 if (writer instanceof SequenceFile.BlockCompressWriter) {
					 SequenceFile.BlockCompressWriter bcWriter = (SequenceFile.BlockCompressWriter) writer;
					 bcWriter.writeBlock();
				 }
				 writer.out.flush();
				 if (!done) {
					 WritableUtils.writeVLong(indexOut, segmentStart);
					 WritableUtils.writeVLong(indexOut, (writer.out.getPos()-segmentStart));
					 indexOut.flush();
				 }
			 }
			 private void sort(int count) {
				 System.arraycopy(pointers, 0, pointersCopy, 0, count);
				 mergeSort(pointersCopy, pointers, 0, count);
			 }
			 private int compare(int i, int j) {
				 return comparator.compare(rawBuffer, keyOffsets[i], keyLengths[i], rawBuffer, keyOffsets[j], keyLengths[j]);
			 }
			 private void mergeSort(int src[], int dest[], int low, int high) {
				 int length = high - low;
				 if (length < 7) {
					 for (int i=low;
					 i<high;
					 i++) for (int j=i;
					 j>low && compare(dest[j-1], dest[j])>0;
					 j--) swap(dest, j, j-1);
					 return;
				 }
				 int mid = (low + high) >> 1;
				 mergeSort(dest, src, low, mid);
				 mergeSort(dest, src, mid, high);
				 if (compare(src[mid-1], src[mid]) <= 0) {
					 System.arraycopy(src, low, dest, low, length);
					 return;
				 }
				 for (int i = low, p = low, q = mid;
				 i < high;
				 i++) {
					 if (q>=high || p<mid && compare(src[p], src[q]) <= 0) dest[i] = src[p++];
					 else dest[i] = src[q++];
				 }
			 }
			 private void swap(int x[], int a, int b) {
				 int t = x[a];
				 x[a] = x[b];
				 x[b] = t;
			 }
		 }
		 private int mergePass(int pass, boolean last) throws IOException {
			 LOG.debug(""running merge pass="" + pass);
			 MergePass mergePass = new MergePass(pass, last);
			 try {
				 return mergePass.run();
			 }
			 finally {
				 mergePass.close();
			 }
		 }
		 private class MergePass {
			 private boolean last;
			 private MergeQueue queue;
			 private FSDataInputStream in = null;
			 private Path inName;
			 private FSDataInputStream indexIn = null;
			 public MergePass(int pass, boolean last) throws IOException {
				 this.last = last;
				 this.queue = new MergeQueue(factor, last?outFile:outFile.suffix("".""+pass), last);
				 this.inName = outFile.suffix("".""+(pass-1));
				 this.in = fs.open(inName);
				 this.indexIn = fs.open(inName.suffix("".index""));
			 }
			 public void close() throws IOException {
				 in.close();
				 fs.delete(inName);
				 queue.close();
			 }
			 public int run() throws IOException {
				 int segments = 0;
				 long end = fs.getLength(inName);
				 while (in.getPos() < end) {
					 LOG.debug(""merging segment "" + segments);
					 long segmentStart = queue.out.getPos();
					 while (in.getPos() < end && queue.size() < factor) {
						 long segmentOffset = WritableUtils.readVLong(indexIn);
						 long segmentLength = WritableUtils.readVLong(indexIn);
						 Reader reader = new Reader(fs, inName, memory/(factor+1), segmentOffset, segmentLength, conf);
						 reader.sync = null;
						 MergeStream ms = new MergeStream(reader);
						 if (ms.next()) {
							 queue.put(ms);
						 }
						 in.seek(reader.end);
					 }
					 queue.merge();
					 if (!last) {
						 WritableUtils.writeVLong(queue.indexOut, segmentStart);
						 WritableUtils.writeVLong(queue.indexOut, (queue.out.getPos() - segmentStart));
					 }
					 segments++;
				 }
				 return segments;
			 }
		 }
		 public void merge(Path[] inFiles, Path outFile) throws IOException {
			 this.inFiles = inFiles;
			 this.outFile = outFile;
			 this.factor = inFiles.length;
			 if (fs.exists(outFile)) {
				 throw new IOException(""already exists: "" + outFile);
			 }
			 MergeFiles mergeFiles = new MergeFiles();
			 try {
				 mergeFiles.run();
			 }
			 finally {
				 mergeFiles.close();
			 }
		 }
		 private class MergeFiles {
			 private MergeQueue queue;
			 public MergeFiles() throws IOException {
				 this.queue = new MergeQueue(factor, outFile, true);
			 }
			 public void close() throws IOException {
				 queue.close();
			 }
			 public void run() throws IOException {
				 LOG.debug(""merging files="" + inFiles.length);
				 for (int i = 0;
				 i < inFiles.length;
				 i++) {
					 Path inFile = inFiles[i];
					 MergeStream ms = new MergeStream(new Reader(fs, inFile, memory/(factor+1), conf));
					 if (ms.next()) queue.put(ms);
				 }
				 queue.merge();
			 }
		 }
		 private class MergeStream {
			 private Reader in;
			 private DataOutputBuffer rawKey = null;
			 private ValueBytes rawValue = null;
			 public MergeStream(Reader reader) throws IOException {
				 if (reader.keyClass != keyClass) throw new IOException(""wrong key class: "" + reader.getKeyClass() + "" is not "" + keyClass);
				 if (reader.valClass != valClass) throw new IOException(""wrong value class: ""+reader.getValueClass()+ "" is not "" + valClass);
				 this.in = reader;
				 rawKey = new DataOutputBuffer();
				 rawValue = in.createValueBytes();
			 }
			 public boolean next() throws IOException {
				 rawKey.reset();
				 int recordLength = in.nextRaw(rawKey, rawValue);
				 return (recordLength >= 0);
			 }
		 }
		 private class MergeQueue extends PriorityQueue {
			 private Path outName;
			 private FSDataOutputStream out;
			 private FSDataOutputStream indexOut;
			 private boolean done;
			 private boolean compress;
			 private boolean blockCompress;
			 private CompressionCodec codec = null;
			 public void put(MergeStream stream) throws IOException {
				 if (size() == 0) {
					 compress = stream.in.isCompressed();
					 blockCompress = stream.in.isBlockCompressed();
					 codec = stream.in.getCompressionCodec();
				 }
				 else if (compress != stream.in.isCompressed() || blockCompress != stream.in.isBlockCompressed()) {
					 throw new IOException(""All merged files must be compressed or not."");
				 }
				 super.put(stream);
			 }
			 public MergeQueue(int size, Path outName, boolean done) throws IOException {
				 initialize(size);
				 this.outName = outName;
				 this.out = fs.create(this.outName, true, memory/(factor+1));
				 if (!done) {
					 this.indexOut = fs.create(outName.suffix("".index""), true, memory/(factor+1));
				 }
				 this.done = done;
			 }
			 protected boolean lessThan(Object a, Object b) {
				 MergeStream msa = (MergeStream)a;
				 MergeStream msb = (MergeStream)b;
				 return comparator.compare(msa.rawKey.getData(), 0, msa.rawKey.getLength(), msb.rawKey.getData(), 0, msb.rawKey.getLength()) < 0;
			 }
			 public void merge() throws IOException {
				 Writer writer = createWriter(out, keyClass, valClass, compress, blockCompress, codec);
				 if (!done) {
					 writer.sync = null;
				 }
				 while (size() != 0) {
					 MergeStream ms = (MergeStream)top();
					 writer.appendRaw(ms.rawKey.getData(), 0, ms.rawKey.getLength(), ms.rawValue);
					 if (ms.next()) {
						 adjustTop();
					 }
					 else {
						 pop();
						 ms.in.close();
					 }
				 }
				 if (writer instanceof SequenceFile.BlockCompressWriter) {
					 SequenceFile.BlockCompressWriter bcWriter = (SequenceFile.BlockCompressWriter) writer;
					 bcWriter.writeBlock();
				 }
				 out.flush();
			 }
			 public void close() throws IOException {
				 MergeStream ms;
				 while ((ms = (MergeStream)pop()) != null) {
					 ms.in.close();
				 }
				 out.close();
				 if (indexOut != null) {
					 indexOut.close();
				 }
			 }
		 }
	 }
 }",1,0,0,0
"public abstract class FormComponent<T> extends LabeledWebMarkupContainerimplementsIFormVisitorParticipant,IFormModelUpdateListener{
	private static final Logger logger = LoggerFactory.getLogger(FormComponent.class);
	public static abstract class AbstractVisitor implements IVisitor{
		public Object formComponent(IFormVisitorParticipant component){
			if (component instanceof FormComponent<?>){
				onFormComponent((FormComponent<?>)component);
			}
			return Component.IVisitor.CONTINUE_TRAVERSAL;
		}
		protected abstract void onFormComponent(FormComponent<?> formComponent);
	}
	public static interface IVisitor{
		public Object formComponent(IFormVisitorParticipant formComponent);
	}
	private class MessageSource implements IErrorMessageSource{
		private final Set<String> triedKeys = new LinkedHashSet<String>();
		public String getMessage(String key){
			final FormComponent<T> formComponent = FormComponent.this;
			final Localizer localizer = formComponent.getLocalizer();
			String prefix = formComponent.getValidatorKeyPrefix();
			String message = null;
			String resource = getId() + ""."" + prefix(prefix, key);
			message = getString(localizer, resource, formComponent);
			if (Strings.isEmpty(message) && Strings.isEmpty(prefix)){
				resource = getId() + ""."" + key;
				message = getString(localizer, resource, formComponent);
			}
			if (Strings.isEmpty(message)){
				resource = prefix(prefix, key);
				message = getString(localizer, resource, formComponent);
			}
			if (Strings.isEmpty(message)){
				message = getString(localizer, key, formComponent);
			}
			if (Strings.isEmpty(message)){
				message = null;
			}
			return message;
		}
		private String prefix(String prefix, String key){
			if (!Strings.isEmpty(prefix)){
				return prefix + ""."" + key;
			}
			else{
				return key;
			}
		}
		private String getString(Localizer localizer, String key, Component component){
			triedKeys.add(key);
			return localizer.getString(key, component, """");
		}
		public String substitute(String string, Map<String, Object> vars)throws IllegalStateException{
			return new MapVariableInterpolator(string, addDefaultVars(vars), Application.get().getResourceSettings().getThrowExceptionOnMissingResource()).toString();
		}
		private Map<String, Object> addDefaultVars(Map<String, Object> params){
			final HashMap<String, Object> fullParams;
			if (params == null){
				fullParams = new HashMap<String, Object>(6);
			}
			else{
				fullParams = new HashMap<String, Object>(params.size() + 6);
				fullParams.putAll(params);
			}
			if (!fullParams.containsKey(""input"")){
				fullParams.put(""input"", getInput());
			}
			if (!fullParams.containsKey(""name"")){
				fullParams.put(""name"", getId());
			}
			if (!fullParams.containsKey(""label"")){
				fullParams.put(""label"", getLabel());
			}
			return fullParams;
		}
		private String getLabel(){
			final FormComponent<T> fc = FormComponent.this;
			String label = null;
			if (fc.getLabel() != null){
				label = fc.getLabel().getObject();
			}
			if (label == null){
				label = fc.getDefaultLabel();
			}
			return label;
		}
	}
	private final class RequiredStateChange extends Change{
		private static final long serialVersionUID = 1L;
		private final boolean required = isRequired();
		public void undo(){
			setRequired(required);
		}
	}
	private class ValidatableAdapter implements IModelAwareValidatable<T>{
		public void error(IValidationError error){
			FormComponent.this.error(error);
		}
		public T getValue(){
			return getConvertedInput();
		}
		public boolean isValid(){
			return FormComponent.this.isValid();
		}
		public IModel<T> getModel(){
			return FormComponent.this.getModel();
		}
	}
	public static String VALUE_SEPARATOR = "";
	"";
	private static final String[] EMPTY_STRING_ARRAY = new String[] {
	 """" }
	;
	private static final short FLAG_PERSISTENT = FLAG_RESERVED2;
	private static final short FLAG_REQUIRED = FLAG_RESERVED3;
	private static final String NO_RAW_INPUT = ""[-NO-RAW-INPUT-]"";
	private static final long serialVersionUID = 1L;
	protected static final short FLAG_CONVERT_EMPTY_INPUT_STRING_TO_NULL = FLAG_RESERVED1;
	public static final void visitFormComponentsPostOrder(Component component,final FormComponent.IVisitor visitor){
		if (visitor == null){
			throw new IllegalArgumentException(""Argument `visitor` cannot be null"");
		}
		visitFormComponentsPostOrderHelper(component, visitor);
	}
	private static final Object visitFormComponentsPostOrderHelper(Component component,final FormComponent.IVisitor visitor){
		if (component instanceof MarkupContainer){
			final MarkupContainer container = (MarkupContainer)component;
			if (container.size() > 0){
				boolean visitChildren = true;
				if (container instanceof IFormVisitorParticipant){
					visitChildren = ((IFormVisitorParticipant)container).processChildren();
				}
				if (visitChildren){
					final Iterator<? extends Component> children = container.iterator();
					while (children.hasNext()){
						final Component child = children.next();
						Object value = visitFormComponentsPostOrderHelper(child, visitor);
						if (value == Component.IVisitor.STOP_TRAVERSAL){
							return value;
						}
					}
				}
			}
		}
		if (component instanceof FormComponent<?>){
			final FormComponent<?> fc = (FormComponent<?>)component;
			return visitor.formComponent(fc);
		}
		return null;
	}
	public static final void visitComponentsPostOrder(Component component,final Component.IVisitor<Component> visitor){
		if (visitor == null){
			throw new IllegalArgumentException(""Argument `visitor` cannot be null"");
		}
		visitComponentsPostOrderHelper(component, visitor);
	}
	private static final Object visitComponentsPostOrderHelper(Component component,final Component.IVisitor<Component> visitor){
		if (component instanceof MarkupContainer){
			final MarkupContainer container = (MarkupContainer)component;
			if (container.size() > 0){
				boolean visitChildren = true;
				if (container instanceof IFormVisitorParticipant){
					visitChildren = ((IFormVisitorParticipant)container).processChildren();
				}
				if (visitChildren){
					final Iterator<? extends Component> children = container.iterator();
					while (children.hasNext()){
						final Component child = children.next();
						Object value = visitComponentsPostOrderHelper(child, visitor);
						if (value == Component.IVisitor.STOP_TRAVERSAL){
							return value;
						}
						else if (value == Component.IVisitor.CONTINUE_TRAVERSAL){
						}
						else if (value == Component.IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER){
						}
						else{
							return value;
						}
					}
				}
			}
		}
		return visitor.component(component);
	}
	private transient T convertedInput;
	private String rawInput = NO_RAW_INPUT;
	private String typeName;
	private Object validators = null;
	public FormComponent(final String id){
		super(id);
		setVersioned(false);
	}
	public FormComponent(final String id, IModel<T> model){
		super(id, model);
		setVersioned(false);
	}
	public final String getDefaultLabel(){
		return getDefaultLabel(getId());
	}
	public final String getDefaultLabel(String defaultValue){
		return getLocalizer().getString(getId(), getParent(), defaultValue);
	}
	public final FormComponent<T> add(final IValidator<T> validator){
		if (validator == null){
			throw new IllegalArgumentException(""validator argument cannot be null"");
		}
		validators_add(validator);
		if (validator instanceof IValidatorAddListener){
			((IValidatorAddListener)validator).onAdded(this);
		}
		return this;
	}
	public final FormComponent<T> add(final IValidator<T>... validators){
		if (validators == null){
			throw new IllegalArgumentException(""validator argument cannot be null"");
		}
		for (IValidator<T> validator : validators){
			add(validator);
		}
		return this;
	}
	public boolean checkRequired(){
		if (isRequired()){
			final String input = getInput();
			if (input == null && !isInputNullable() && !isEnabledInHierarchy()){
				return true;
			}
			return !Strings.isEmpty(input);
		}
		return true;
	}
	public final void clearInput(){
		rawInput = NO_RAW_INPUT;
	}
	public void error(IValidationError error){
		if (error == null){
			throw new IllegalArgumentException(""Argument [[error]] cannot be null"");
		}
		MessageSource source = new MessageSource();
		String message = error.getErrorMessage(source);
		if (message == null){
			StringBuffer buffer = new StringBuffer();
			buffer.append(""Could not locate error message for component: "");
			buffer.append(Classes.simpleName(getClass()));
			buffer.append(""@"");
			buffer.append(getPageRelativePath());
			buffer.append("" and error: "");
			buffer.append(error.toString());
			buffer.append("". Tried keys: "");
			Iterator<String> keys = source.triedKeys.iterator();
			while (keys.hasNext()){
				buffer.append(keys.next());
				if (keys.hasNext()){
					buffer.append("", "");
				}
			}
			buffer.append(""."");
			message = buffer.toString();
			logger.warn(message);
		}
		error(new ValidationErrorFeedback(error, message));
	}
	public final T getConvertedInput(){
		return convertedInput;
	}
	public final void setConvertedInput(T convertedInput){
		this.convertedInput = convertedInput;
	}
	public Form<?> getForm(){
		Form<?> form = Form.findForm(this);
		if (form == null){
			throw new WicketRuntimeException(""Could not find Form parent for "" + this);
		}
		return form;
	}
	public String getInput(){
		String[] input = getInputAsArray();
		if (input == null || input.length == 0){
			return null;
		}
		else{
			return trim(input[0]);
		}
	}
	public String[] getInputAsArray(){
		String[] values = getRequest().getParameters(getInputName());
		if (!isInputNullable()){
			if (values != null && values.length == 1 && values[0] == null){
				return EMPTY_STRING_ARRAY;
			}
		}
		return values;
	}
	public String getInputName(){
		final String inputName = Form.getRootFormRelativeId(this);
		Form<?> form = findParent(Form.class);
		if (form != null){
			return form.getInputNamePrefix() + inputName;
		}
		else{
			return inputName;
		}
	}
	public final String getRawInput(){
		return NO_RAW_INPUT.equals(rawInput) ? null : rawInput;
	}
	public final Class<T> getType(){
		return typeName == null ? null : (Class<T>)Classes.resolveClass(typeName);
	}
	public String getValidatorKeyPrefix(){
		Form<?> form = findParent(Form.class);
		if (form != null){
			return getForm().getValidatorKeyPrefix();
		}
		return null;
	}
	public final List<IValidator<T>> getValidators(){
		final int size = validators_size();
		if (size == 0){
			return Collections.emptyList();
		}
		else{
			final List<IValidator<T>> list = new ArrayList<IValidator<T>>(size);
			for (int i = 0;
			 i < size;
			 i++){
				list.add(validators_get(i));
			}
			return Collections.unmodifiableList(list);
		}
	}
	public final String getValue(){
		if (NO_RAW_INPUT.equals(rawInput)){
			return getModelValue();
		}
		else{
			if (getEscapeModelStrings() && rawInput != null){
				return Strings.escapeMarkup(rawInput).toString();
			}
			return rawInput;
		}
	}
	public final boolean hasRawInput(){
		return !NO_RAW_INPUT.equals(rawInput);
	}
	public final void inputChanged(){
		if (isVisibleInHierarchy() && isEnabledInHierarchy()){
			final String[] input = getInputAsArray();
			if (input != null && input.length > 0 && input[0] != null){
				rawInput = StringList.valueOf(input).join(VALUE_SEPARATOR);
			}
			else if (isInputNullable()){
				rawInput = null;
			}
			else{
				rawInput = NO_RAW_INPUT;
			}
		}
	}
	public final void invalid(){
		onInvalid();
	}
	public boolean isInputNullable(){
		return true;
	}
	public boolean isMultiPart(){
		return false;
	}
	public final boolean isPersistent(){
		return supportsPersistence() && getFlag(FLAG_PERSISTENT);
	}
	public boolean isRequired(){
		return getFlag(FLAG_REQUIRED);
	}
	public final boolean isValid(){
		class IsValidVisitor implements IVisitor{
			boolean valid = true;
			public Object formComponent(IFormVisitorParticipant formComponent){
				final FormComponent<?> fc = (FormComponent<?>)formComponent;
				if (fc.hasErrorMessage()){
					valid = false;
					return Component.IVisitor.STOP_TRAVERSAL;
				}
				return Component.IVisitor.CONTINUE_TRAVERSAL;
			}
		}
		IsValidVisitor tmp = new IsValidVisitor();
		visitFormComponentsPostOrder(this, tmp);
		return tmp.valid;
	}
	public boolean processChildren(){
		return true;
	}
	public final void processInput(){
		inputChanged();
		validate();
		if (hasErrorMessage()){
			invalid();
		}
		else{
			valid();
			updateModel();
		}
	}
	public FormComponent<T> setLabel(IModel<String> labelModel){
		setLabelInternal(labelModel);
		return this;
	}
	public void setModelValue(final String value){
		setModelValue(value.split(VALUE_SEPARATOR));
	}
	public void setModelValue(final String[] value){
		convertedInput = convertValue(value);
		updateModel();
	}
	public final FormComponent<T> setPersistent(final boolean persistent){
		if (supportsPersistence()){
			setFlag(FLAG_PERSISTENT, persistent);
		}
		else{
			throw new UnsupportedOperationException(""FormComponent "" + getClass() +"" does not support cookies"");
		}
		return this;
	}
	public final FormComponent<T> setRequired(final boolean required){
		if (!required && getType() != null && getType().isPrimitive()){
			throw new WicketRuntimeException(""FormComponent can't be not required when the type is primitive class: "" + this);
		}
		if (required != isRequired()){
			addStateChange(new RequiredStateChange());
		}
		setFlag(FLAG_REQUIRED, required);
		return this;
	}
	public final FormComponent<T> setType(Class<?> type){
		typeName = type == null ? null : type.getName();
		if (type != null && type.isPrimitive()){
			setRequired(true);
		}
		return this;
	}
	public void updateModel(){
		setDefaultModelObject(getConvertedInput());
	}
	public final void valid(){
		clearInput();
		onValid();
	}
	public void validate(){
		validateRequired();
		if (isValid()){
			convertInput();
			if (isValid()){
				if (isRequired() && getConvertedInput() == null && isInputNullable()){
					reportRequiredError();
				}
				else{
					validateValidators();
				}
			}
		}
	}
	private void validators_add(final IValidator<T> validator){
		if (validators == null){
			validators = validator;
		}
		else{
			final int size = validators_size();
			final IValidator<T>[] validators = new IValidator[size + 1];
			for (int i = 0;
			 i < size;
			 i++){
				validators[i] = validators_get(i);
			}
			validators[size] = validator;
			this.validators = validators;
		}
	}
	private IValidator<T> validators_get(int index){
		if (validators == null){
			throw new IndexOutOfBoundsException();
		}
		if (validators instanceof IValidator[]){
			return ((IValidator[])validators)[index];
		}
		return (IValidator<T>)validators;
	}
	private int validators_size(){
		if (validators == null){
			return 0;
		}
		if (validators instanceof IValidator<?>[]){
			return ((IValidator[])validators).length;
		}
		return 1;
	}
	protected void convertInput(){
		if (typeName == null){
			try{
				convertedInput = convertValue(getInputAsArray());
			}
			catch (ConversionException e){
				ValidationError error = new ValidationError();
				if (e.getResourceKey() != null){
					error.addMessageKey(e.getResourceKey());
				}
				if (e.getTargetType() != null){
					error.addMessageKey(""ConversionError."" + Classes.simpleName(e.getTargetType()));
				}
				error.addMessageKey(""ConversionError"");
				reportValidationError(e, error);
			}
		}
		else{
			final IConverter converter = getConverter(getType());
			try{
				convertedInput = (T)converter.convertToObject(getInput(), getLocale());
			}
			catch (ConversionException e){
				ValidationError error = new ValidationError();
				if (e.getResourceKey() != null){
					error.addMessageKey(e.getResourceKey());
				}
				String simpleName = Classes.simpleName(getType());
				error.addMessageKey(""IConverter."" + simpleName);
				error.addMessageKey(""IConverter"");
				error.setVariable(""type"", simpleName);
				reportValidationError(e, error);
			}
		}
	}
	private void reportValidationError(ConversionException e, ValidationError error){
		final Locale locale = e.getLocale();
		if (locale != null){
			error.setVariable(""locale"", locale);
		}
		error.setVariable(""exception"", e);
		Format format = e.getFormat();
		if (format instanceof SimpleDateFormat){
			error.setVariable(""format"", ((SimpleDateFormat)format).toLocalizedPattern());
		}
		Map<String, Object> variables = e.getVariables();
		if (variables != null){
			error.getVariables().putAll(variables);
		}
		error(error);
	}
	protected T convertValue(String[] value) throws ConversionException{
		return (T)(value != null && value.length > 0 && value[0] != null ? trim(value[0]) : null);
	}
	protected String getModelValue(){
		return getDefaultModelObjectAsString();
	}
	protected final int inputAsInt(){
		final String string = getInput();
		try{
			return Integer.parseInt(string);
		}
		catch (NumberFormatException e){
			throw new IllegalArgumentException(exceptionMessage(""Internal error. Request string '"" + string +""' not a valid integer""));
		}
	}
	protected final int inputAsInt(final int defaultValue){
		final String string = getInput();
		if (string != null){
			try{
				return Integer.parseInt(string);
			}
			catch (NumberFormatException e){
				throw new IllegalArgumentException(exceptionMessage(""Request string '"" + string +""' is not a valid integer""));
			}
		}
		else{
			return defaultValue;
		}
	}
	protected final int[] inputAsIntArray(){
		final String[] strings = getInputAsArray();
		if (strings != null){
			final int[] ints = new int[strings.length];
			for (int i = 0;
			 i < strings.length;
			 i++){
				ints[i] = Integer.parseInt(strings[i]);
			}
			return ints;
		}
		return null;
	}
	protected void internalOnModelChanged(){
		valid();
	}
	protected void onComponentTag(final ComponentTag tag){
		tag.put(""name"", getInputName());
		if (!isEnabledInHierarchy()){
			onDisabled(tag);
		}
		super.onComponentTag(tag);
	}
	protected void onDetach(){
		super.onDetach();
		for (IValidator<?> validator : getValidators()){
			if (validator != null && (validator instanceof IDetachable)){
				((IDetachable)validator).detach();
			}
		}
		convertedInput = null;
	}
	protected void onDisabled(final ComponentTag tag){
		tag.put(""disabled"", ""disabled"");
	}
	protected void onInvalid(){
	}
	protected void onValid(){
	}
	protected boolean shouldTrimInput(){
		return true;
	}
	protected final String trim(String string){
		String trimmed = string;
		if (trimmed != null && shouldTrimInput()){
			trimmed = trimmed.trim();
		}
		return trimmed;
	}
	protected boolean supportsPersistence(){
		return false;
	}
	protected final void validateRequired(){
		if (!checkRequired()){
			reportRequiredError();
		}
	}
	private void reportRequiredError(){
		error(new ValidationError().addMessageKey(""Required""));
	}
	protected final void validateValidators(){
		final int size = validators_size();
		final IValidatable<T> validatable = newValidatable();
		int i = 0;
		IValidator<T> validator = null;
		boolean isNull = getConvertedInput() == null;
		try{
			for (i = 0;
			 i < size;
			 i++){
				validator = validators_get(i);
				if (isNull == false || validator instanceof INullAcceptingValidator<?>){
					validator.validate(validatable);
				}
				if (!isValid()){
					break;
				}
			}
		}
		catch (Exception e){
			throw new WicketRuntimeException(""Exception '"" + e + ""' occurred during validation "" +validator.getClass().getName() + "" on component "" + getPath(), e);
		}
	}
	public final IValidatable<T> newValidatable(){
		return new ValidatableAdapter();
	}
	public final IModel<T> getModel(){
		return (IModel<T>)getDefaultModel();
	}
	public final void setModel(IModel<T> model){
		setDefaultModel(model);
	}
	public final T getModelObject(){
		return (T)getDefaultModelObject();
	}
	public final void setModelObject(T object){
		setDefaultModelObject(object);
	}
}",1,0,0,0
"public class BitwiseORExpressionElements extends AbstractParserRuleElementFinder {
	private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), ""org.eclipse.n4js.N4JS.BitwiseORExpression"");
	private final Group cGroup = (Group)rule.eContents().get(1);
	private final RuleCall cBitwiseXORExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
	private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
	private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
	private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
	private final Action cBinaryBitwiseExpressionLhsAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
	private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
	private final RuleCall cOpBitwiseOROperatorParserRuleCall_1_0_0_1_0 = (RuleCall)cOpAssignment_1_0_0_1.eContents().get(0);
	private final Assignment cRhsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
	private final RuleCall cRhsBitwiseXORExpressionParserRuleCall_1_1_0 = (RuleCall)cRhsAssignment_1_1.eContents().get(0);
	 public ParserRule getRule() {
		 return rule;
	 }
	public Group getGroup() {
		 return cGroup;
	 }
	public RuleCall getBitwiseXORExpressionParserRuleCall_0() {
		 return cBitwiseXORExpressionParserRuleCall_0;
	 }
	public Group getGroup_1() {
		 return cGroup_1;
	 }
	public Group getGroup_1_0() {
		 return cGroup_1_0;
	 }
	public Group getGroup_1_0_0() {
		 return cGroup_1_0_0;
	 }
	public Action getBinaryBitwiseExpressionLhsAction_1_0_0_0() {
		 return cBinaryBitwiseExpressionLhsAction_1_0_0_0;
	 }
	public Assignment getOpAssignment_1_0_0_1() {
		 return cOpAssignment_1_0_0_1;
	 }
	public RuleCall getOpBitwiseOROperatorParserRuleCall_1_0_0_1_0() {
		 return cOpBitwiseOROperatorParserRuleCall_1_0_0_1_0;
	 }
	public Assignment getRhsAssignment_1_1() {
		 return cRhsAssignment_1_1;
	 }
	public RuleCall getRhsBitwiseXORExpressionParserRuleCall_1_1_0() {
		 return cRhsBitwiseXORExpressionParserRuleCall_1_1_0;
	 }
}",1,1,0,0
"public void log(final int level, final Object obj1, final Object obj2, final Object obj3);",0,0,0,1
"public class AddColumnFamily extends Migration{
	 private CFMetaData cfm;
	 protected AddColumnFamily() {
	 }
	 public AddColumnFamily(CFMetaData cfm) throws ConfigurationException, IOException {
		 super(UUIDGen.makeType1UUIDFromHost(FBUtilities.getLocalAddress()), DatabaseDescriptor.getDefsVersion());
		 this.cfm = cfm;
		 KSMetaData ksm = DatabaseDescriptor.getTableDefinition(cfm.ksName);
		 if (ksm == null) throw new ConfigurationException(""No such keyspace: "" + cfm.ksName);
		 else if (ksm.cfMetaData().containsKey(cfm.cfName)) throw new ConfigurationException(String.format(""%s already exists in keyspace %s"", cfm.cfName, cfm.ksName));
		 else if (!Migration.isLegalName(cfm.cfName)) throw new ConfigurationException(""Invalid column family name: "" + cfm.cfName);
		 for (Map.Entry<ByteBuffer, ColumnDefinition> entry : cfm.getColumn_metadata().entrySet()) {
			 String indexName = entry.getValue().getIndexName();
			 if (indexName != null && !Migration.isLegalName(indexName)) throw new ConfigurationException(""Invalid index name: "" + indexName);
		 }
		 KSMetaData newKsm = makeNewKeyspaceDefinition(ksm);
		 rm = Migration.makeDefinitionMutation(newKsm, null, newVersion);
	 }
	 private KSMetaData makeNewKeyspaceDefinition(KSMetaData ksm) {
		 List<CFMetaData> newCfs = new ArrayList<CFMetaData>(ksm.cfMetaData().values());
		 newCfs.add(cfm);
		 return new KSMetaData(ksm.name, ksm.strategyClass, ksm.strategyOptions, newCfs.toArray(new CFMetaData[newCfs.size()]));
	 }
	 public void applyModels() throws IOException {
		 KSMetaData ksm = DatabaseDescriptor.getTableDefinition(cfm.ksName);
		 ksm = makeNewKeyspaceDefinition(ksm);
		 try {
			 CFMetaData.map(cfm);
		 }
		 catch (ConfigurationException ex) {
			 throw new IOException(ex);
		 }
		 Table.open(cfm.ksName);
		 DatabaseDescriptor.setTableDefinition(ksm, newVersion);
		 CFMetaData.fixMaxId();
		 if (!StorageService.instance.isClientMode()) Table.open(ksm.name).initCf(cfm.cfId, cfm.cfName);
	 }
	 public void subdeflate(org.apache.cassandra.db.migration.avro.Migration mi) {
		 org.apache.cassandra.db.migration.avro.AddColumnFamily acf = new org.apache.cassandra.db.migration.avro.AddColumnFamily();
		 acf.cf = cfm.deflate();
		 mi.migration = acf;
	 }
	 public void subinflate(org.apache.cassandra.db.migration.avro.Migration mi) {
		 org.apache.cassandra.db.migration.avro.AddColumnFamily acf = (org.apache.cassandra.db.migration.avro.AddColumnFamily)mi.migration;
		 cfm = CFMetaData.inflate(acf.cf);
	 }
	 public String toString() {
		 return ""Add column family: "" + cfm.toString();
	 }
}",0,0,0,0
"public void insertNodeInto(MutableTreeNode newChild,MutableTreeNode parent,int index);",0,0,0,0
"class WindmillStateReader {
	 public static final long MAX_BAG_BYTES = 8L << 20;
	 public static final long MAX_KEY_BYTES = 16L << 20;
	 private static class StateTag {
		 private enum Kind {
			 VALUE, BAG, WATERMARK;
		 }
		 private final Kind kind;
		 private final ByteString tag;
		 private final String stateFamily;
		 private final Long requestPosition;
		 private StateTag( Kind kind, ByteString tag, String stateFamily, Long requestPosition) {
			 this.kind = kind;
			 this.tag = tag;
			 this.stateFamily = Preconditions.checkNotNull(stateFamily);
			 this.requestPosition = requestPosition;
		 }
		 private StateTag(Kind kind, ByteString tag, String stateFamily) {
			 this(kind, tag, stateFamily, null);
		 }
		 public boolean equals(Object obj) {
			 if (this == obj) {
				 return true;
			 }
			 if (!(obj instanceof StateTag)) {
				 return false;
			 }
			 StateTag that = (StateTag) obj;
			 return Objects.equal(this.kind, that.kind) && Objects.equal(this.tag, that.tag) && Objects.equal(this.stateFamily, that.stateFamily) && Objects.equal(this.requestPosition, that.requestPosition);
		 }
		 public int hashCode() {
			 return Objects.hashCode(kind, tag, stateFamily, requestPosition);
		 }
		 public String toString() {
			 return ""Tag("" + kind + "","" + tag.toStringUtf8() + "","" + stateFamily + (requestPosition == null ? """" : ("","" + requestPosition.toString())) + "")"";
		 }
	 }
	 private static class ValuesAndContPosition<T> {
		 private final List<T> values;
		 private final Long continuationPosition;
		 public ValuesAndContPosition(List<T> values, Long continuationPosition) {
			 this.values = values;
			 this.continuationPosition = continuationPosition;
		 }
	 }
	 private final String computation;
	 private final ByteString key;
	 private final long shardingKey;
	 private final long workToken;
	 private final MetricTrackingWindmillServerStub server;
	 private long bytesRead = 0L;
	 public WindmillStateReader( MetricTrackingWindmillServerStub server, String computation, ByteString key, long shardingKey, long workToken) {
		 this.server = server;
		 this.computation = computation;
		 this.key = key;
		 this.shardingKey = shardingKey;
		 this.workToken = workToken;
	 }
	 private static final class CoderAndFuture<ElemT, FutureT> {
		 private Coder<ElemT> coder;
		 private final SettableFuture<FutureT> future;
		 private CoderAndFuture(Coder<ElemT> coder, SettableFuture<FutureT> future) {
			 this.coder = coder;
			 this.future = future;
		 }
		 private SettableFuture<FutureT> getFuture() {
			 return future;
		 }
		 private SettableFuture<FutureT> getNonDoneFuture(StateTag stateTag) {
			 if (future.isDone()) {
				 throw new IllegalStateException(""Future for "" + stateTag + "" is already done"");
			 }
			 return future;
		 }
		 private Coder<ElemT> getAndClearCoder() {
			 if (coder == null) {
				 throw new IllegalStateException(""Coder has already been cleared from cache"");
			 }
			 Coder<ElemT> result = coder;
			 coder = null;
			 return result;
		 }
		 private void checkNoCoder() {
			 if (coder != null) {
				 throw new IllegalStateException(""Unexpected coder"");
			 }
		 }
	 }
	 ConcurrentLinkedQueue<StateTag> pendingLookups = new ConcurrentLinkedQueue<>();
	 private ConcurrentHashMap<StateTag, CoderAndFuture<?, ?>> waiting = new ConcurrentHashMap<>();
	 private <ElemT, FutureT> Future<FutureT> stateFuture( StateTag stateTag, Coder<ElemT> coder) {
		 CoderAndFuture<ElemT, FutureT> coderAndFuture = new CoderAndFuture<>(coder, SettableFuture.<FutureT>create());
		 CoderAndFuture<?, ?> existingCoderAndFutureWildcard = waiting.putIfAbsent(stateTag, coderAndFuture);
		 if (existingCoderAndFutureWildcard == null) {
			 pendingLookups.add(stateTag);
		 }
		 else {
			 CoderAndFuture<ElemT, FutureT> existingCoderAndFuture = (CoderAndFuture<ElemT, FutureT>) existingCoderAndFutureWildcard;
			 coderAndFuture = existingCoderAndFuture;
		 }
		 return wrappedFuture(coderAndFuture.getFuture());
	 }
	 private <ElemT, FutureT> CoderAndFuture<ElemT, FutureT> getWaiting( StateTag stateTag, boolean shouldRemove) {
		 CoderAndFuture<?, ?> coderAndFutureWildcard;
		 if (shouldRemove) {
			 coderAndFutureWildcard = waiting.remove(stateTag);
		 }
		 else {
			 coderAndFutureWildcard = waiting.get(stateTag);
		 }
		 if (coderAndFutureWildcard == null) {
			 throw new IllegalStateException(""Missing future for "" + stateTag);
		 }
		 CoderAndFuture<ElemT, FutureT> coderAndFuture = (CoderAndFuture<ElemT, FutureT>) coderAndFutureWildcard;
		 return coderAndFuture;
	 }
	 public Future<Instant> watermarkFuture(ByteString encodedTag, String stateFamily) {
		 return stateFuture(new StateTag(StateTag.Kind.WATERMARK, encodedTag, stateFamily), null);
	 }
	 public <T> Future<T> valueFuture(ByteString encodedTag, String stateFamily, Coder<T> coder) {
		 return stateFuture(new StateTag(StateTag.Kind.VALUE, encodedTag, stateFamily), coder);
	 }
	 public <T> Future<Iterable<T>> bagFuture( ByteString encodedTag, String stateFamily, Coder<T> elemCoder) {
		 StateTag stateTag = new StateTag(StateTag.Kind.BAG, encodedTag, stateFamily);
		 return valuesToPagingIterableFuture( stateTag, elemCoder, this.<T, ValuesAndContPosition<T>>stateFuture(stateTag, elemCoder));
	 }
	 private <T> Future<ValuesAndContPosition<T>> continuationBagFuture( StateTag contStateTag, Coder<T> elemCoder) {
		 if (contStateTag.requestPosition == null) {
			 return null;
		 }
		 return stateFuture(contStateTag, elemCoder);
	 }
	 private static class WrappedFuture<T> extends ForwardingFuture.SimpleForwardingFuture<T> {
		 private WindmillStateReader reader;
		 public WrappedFuture(WindmillStateReader reader, Future<T> delegate) {
			 super(delegate);
			 this.reader = reader;
		 }
		 public T get() throws InterruptedException, ExecutionException {
			 if (!delegate().isDone() && reader != null) {
				 reader.startBatchAndBlock();
			 }
			 reader = null;
			 return super.get();
		 }
		 public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
			 if (!delegate().isDone() && reader != null) {
				 reader.startBatchAndBlock();
			 }
			 reader = null;
			 return super.get(timeout, unit);
		 }
	 }
	 private <T> Future<T> wrappedFuture(final Future<T> future) {
		 if (future.isDone()) {
			 return future;
		 }
		 else {
			 return new WrappedFuture<>(this, future);
		 }
	 }
	 private static class ToIterableFunction<T> implements Function<ValuesAndContPosition<T>, Iterable<T>> {
		 private WindmillStateReader reader;
		 private final StateTag stateTag;
		 private final Coder<T> elemCoder;
		 public ToIterableFunction(WindmillStateReader reader, StateTag stateTag, Coder<T> elemCoder) {
			 this.reader = reader;
			 this.stateTag = stateTag;
			 this.elemCoder = elemCoder;
		 }
		 public Iterable<T> apply(ValuesAndContPosition<T> valuesAndContPosition) {
			 if (valuesAndContPosition.continuationPosition == null) {
				 reader = null;
				 return valuesAndContPosition.values;
			 }
			 else {
				 StateTag contStateTag = new StateTag( stateTag.kind, stateTag.tag, stateTag.stateFamily, valuesAndContPosition.continuationPosition);
				 return new BagPagingIterable<>( reader, valuesAndContPosition.values, contStateTag, elemCoder);
			 }
		 }
	 }
	 private <T> Future<Iterable<T>> valuesToPagingIterableFuture( final StateTag stateTag, final Coder<T> elemCoder, final Future<ValuesAndContPosition<T>> future) {
		 return Futures.lazyTransform(future, new ToIterableFunction<T>(this, stateTag, elemCoder));
	 }
	 public void startBatchAndBlock() {
		 HashSet<StateTag> toFetch = new HashSet<>();
		 while (!pendingLookups.isEmpty()) {
			 StateTag stateTag = pendingLookups.poll();
			 if (stateTag == null) {
				 break;
			 }
			 if (!toFetch.add(stateTag)) {
				 throw new IllegalStateException(""Duplicate tags being fetched."");
			 }
		 }
		 if (toFetch.isEmpty()) {
			 return;
		 }
		 Windmill.KeyedGetDataRequest request = createRequest(toFetch);
		 Windmill.KeyedGetDataResponse response = server.getStateData(computation, request);
		 if (response == null) {
			 throw new RuntimeException(""Windmill unexpectedly returned null for request "" + request);
		 }
		 consumeResponse(request, response, toFetch);
	 }
	 public long getBytesRead() {
		 return bytesRead;
	 }
	 private Windmill.KeyedGetDataRequest createRequest(Iterable<StateTag> toFetch) {
		 Windmill.KeyedGetDataRequest.Builder keyedDataBuilder = Windmill.KeyedGetDataRequest.newBuilder() .setKey(key) .setShardingKey(shardingKey) .setWorkToken(workToken);
		 for (StateTag stateTag : toFetch) {
			 switch (stateTag.kind) {
				 case BAG: TagBag.Builder bag = keyedDataBuilder .addBagsToFetchBuilder() .setTag(stateTag.tag) .setStateFamily(stateTag.stateFamily) .setFetchMaxBytes(MAX_BAG_BYTES);
				 if (stateTag.requestPosition != null) {
					 bag.setRequestPosition(stateTag.requestPosition);
				 }
				 break;
				 case WATERMARK: keyedDataBuilder .addWatermarkHoldsToFetchBuilder() .setTag(stateTag.tag) .setStateFamily(stateTag.stateFamily);
				 break;
				 case VALUE: keyedDataBuilder .addValuesToFetchBuilder() .setTag(stateTag.tag) .setStateFamily(stateTag.stateFamily);
				 break;
				 default: throw new RuntimeException(""Unknown kind of tag requested: "" + stateTag.kind);
			 }
		 }
		 keyedDataBuilder.setMaxBytes(MAX_KEY_BYTES);
		 return keyedDataBuilder.build();
	 }
	 private void consumeResponse( Windmill.KeyedGetDataRequest request, Windmill.KeyedGetDataResponse response, Set<StateTag> toFetch) {
		 bytesRead += response.getSerializedSize();
		 if (response.getFailed()) {
			 KeyTokenInvalidException keyTokenInvalidException = new KeyTokenInvalidException(key.toStringUtf8());
			 for (StateTag stateTag : toFetch) {
				 waiting.get(stateTag).future.setException(keyTokenInvalidException);
			 }
			 return;
		 }
		 if (!key.equals(response.getKey())) {
			 throw new RuntimeException(""Expected data for key "" + key + "" but was "" + response.getKey());
		 }
		 for (Windmill.TagBag bag : response.getBagsList()) {
			 StateTag stateTag = new StateTag( StateTag.Kind.BAG, bag.getTag(), bag.getStateFamily(), bag.hasRequestPosition() ? bag.getRequestPosition() : null);
			 if (!toFetch.remove(stateTag)) {
				 throw new IllegalStateException( ""Received response for unrequested tag "" + stateTag + "". Pending tags: "" + toFetch);
			 }
			 consumeBag(bag, stateTag);
		 }
		 for (Windmill.WatermarkHold hold : response.getWatermarkHoldsList()) {
			 StateTag stateTag = new StateTag(StateTag.Kind.WATERMARK, hold.getTag(), hold.getStateFamily());
			 if (!toFetch.remove(stateTag)) {
				 throw new IllegalStateException( ""Received response for unrequested tag "" + stateTag + "". Pending tags: "" + toFetch);
			 }
			 consumeWatermark(hold, stateTag);
		 }
		 for (Windmill.TagValue value : response.getValuesList()) {
			 StateTag stateTag = new StateTag(StateTag.Kind.VALUE, value.getTag(), value.getStateFamily());
			 if (!toFetch.remove(stateTag)) {
				 throw new IllegalStateException( ""Received response for unrequested tag "" + stateTag + "". Pending tags: "" + toFetch);
			 }
			 consumeTagValue(value, stateTag);
		 }
		 if (!toFetch.isEmpty()) {
			 throw new IllegalStateException( ""Didn't receive responses for all pending fetches. Missing: "" + toFetch);
		 }
	 }
	 static class WeightedList<T> extends ForwardingList<T> implements Weighted {
		 private List<T> delegate;
		 long weight;
		 WeightedList(List<T> delegate) {
			 this.delegate = delegate;
			 this.weight = 0;
		 }
		 protected List<T> delegate() {
			 return delegate;
		 }
		 public boolean add(T elem) {
			 throw new UnsupportedOperationException(""Must use AddWeighted()"");
		 }
		 public long getWeight() {
			 return weight;
		 }
		 public void addWeighted(T elem, long weight) {
			 delegate.add(elem);
			 this.weight += weight;
		 }
	 }
	 private <T> List<T> bagPageValues(TagBag bag, Coder<T> elemCoder) {
		 if (bag.getValuesCount() == 0) {
			 return new WeightedList<T>(Collections.<T>emptyList());
		 }
		 WeightedList<T> valueList = new WeightedList<>(new ArrayList<T>(bag.getValuesCount()));
		 for (ByteString value : bag.getValuesList()) {
			 try {
				 valueList.addWeighted( elemCoder.decode(value.newInput(), Coder.Context.OUTER), value.size());
			 }
			 catch (IOException e) {
				 throw new IllegalStateException(""Unable to decode tag list using "" + elemCoder, e);
			 }
		 }
		 return valueList;
	 }
	 private <T> void consumeBag(TagBag bag, StateTag stateTag) {
		 boolean shouldRemove;
		 if (stateTag.requestPosition == null) {
			 shouldRemove = false;
		 }
		 else {
			 shouldRemove = true;
		 }
		 CoderAndFuture<T, ValuesAndContPosition<T>> coderAndFuture = getWaiting(stateTag, shouldRemove);
		 SettableFuture<ValuesAndContPosition<T>> future = coderAndFuture.getNonDoneFuture(stateTag);
		 Coder<T> coder = coderAndFuture.getAndClearCoder();
		 List<T> values = this.<T>bagPageValues(bag, coder);
		 future.set( new ValuesAndContPosition<T>( values, bag.hasContinuationPosition() ? bag.getContinuationPosition() : null));
	 }
	 private void consumeWatermark(Windmill.WatermarkHold watermarkHold, StateTag stateTag) {
		 CoderAndFuture<Void, Instant> coderAndFuture = getWaiting(stateTag, false);
		 SettableFuture<Instant> future = coderAndFuture.getNonDoneFuture(stateTag);
		 coderAndFuture.checkNoCoder();
		 Instant hold = null;
		 for (long timestamp : watermarkHold.getTimestampsList()) {
			 Instant instant = new Instant(TimeUnit.MICROSECONDS.toMillis(timestamp));
			 if (instant.isBefore(BoundedWindow.TIMESTAMP_MAX_VALUE) && (hold == null || instant.isBefore(hold))) {
				 hold = instant;
			 }
		 }
		 future.set(hold);
	 }
	 private <T> void consumeTagValue(TagValue tagValue, StateTag stateTag) {
		 CoderAndFuture<T, T> coderAndFuture = getWaiting(stateTag, false);
		 SettableFuture<T> future = coderAndFuture.getNonDoneFuture(stateTag);
		 Coder<T> coder = coderAndFuture.getAndClearCoder();
		 if (tagValue.hasValue() && tagValue.getValue().hasData() && !tagValue.getValue().getData().isEmpty()) {
			 InputStream inputStream = tagValue.getValue().getData().newInput();
			 try {
				 T value = coder.decode(inputStream, Coder.Context.OUTER);
				 future.set(value);
			 }
			 catch (IOException e) {
				 throw new IllegalStateException(""Unable to decode value using "" + coder, e);
			 }
		 }
		 else {
			 future.set(null);
		 }
	 }
	 private static class BagPagingIterable<T> implements Iterable<T> {
		 private final WindmillStateReader reader;
		 private final List<T> firstPage;
		 private final StateTag secondPagePos;
		 private final Coder<T> elemCoder;
		 private BagPagingIterable( WindmillStateReader reader, List<T> firstPage, StateTag secondPagePos, Coder<T> elemCoder) {
			 this.reader = reader;
			 this.firstPage = firstPage;
			 this.secondPagePos = secondPagePos;
			 this.elemCoder = elemCoder;
		 }
		 public Iterator<T> iterator() {
			 return new AbstractIterator<T>() {
				 private Iterator<T> currentPage = firstPage.iterator();
				 private StateTag nextPagePos = secondPagePos;
				 private Future<ValuesAndContPosition<T>> pendingNextPage = reader.continuationBagFuture(nextPagePos, elemCoder);
				 protected T computeNext() {
					 while (true) {
						 if (currentPage.hasNext()) {
							 return currentPage.next();
						 }
						 if (pendingNextPage == null) {
							 return endOfData();
						 }
						 ValuesAndContPosition<T> valuesAndContPosition;
						 try {
							 valuesAndContPosition = pendingNextPage.get();
						 }
						 catch (InterruptedException | ExecutionException e) {
							 if (e instanceof InterruptedException) {
								 Thread.currentThread().interrupt();
							 }
							 throw new RuntimeException(""Unable to read value from state"", e);
						 }
						 currentPage = valuesAndContPosition.values.iterator();
						 nextPagePos = new StateTag( nextPagePos.kind, nextPagePos.tag, nextPagePos.stateFamily, valuesAndContPosition.continuationPosition);
						 pendingNextPage = reader.continuationBagFuture(nextPagePos, elemCoder);
					 }
				 }
			 }
			;
		 }
	 }
}",1,0,0,0
"public void unlock(Object lockId, Object owner, long timeout) throws LockNotReleasedException, ChannelException;",0,0,0,0
"public ByteBuffer decompose(Long value) {
	 return JdbcLong.instance.decompose(value);
 }",0,0,0,0
"public class VmDiskStatisticsDaoImpl extends GenericDaoBase<VmDiskStatisticsVO, Long> implements VmDiskStatisticsDao {
	 private static final Logger s_logger = Logger.getLogger(VmDiskStatisticsDaoImpl.class);
	 private static final String ACTIVE_AND_RECENTLY_DELETED_SEARCH = ""SELECT bcf.id, bcf.data_center_id, bcf.account_id, bcf.vm_id, bcf.volume_id, bcf.agg_io_read, bcf.agg_io_write, bcf.agg_bytes_read, bcf.agg_bytes_write "" + ""FROM vm_disk_statistics bcf, account a "" + ""WHERE bcf.account_id = a.id AND (a.removed IS NULL OR a.removed >= ?) "" + ""ORDER BY bcf.id"";
	 private static final String UPDATED_VM_NETWORK_STATS_SEARCH = ""SELECT id, current_io_read, current_io_write, net_io_read, net_io_write, agg_io_read, agg_io_write, "" + ""current_bytes_read, current_bytes_write, net_bytes_read, net_bytes_write, agg_bytes_read, agg_bytes_write "" + ""from vm_disk_statistics "" + ""where (agg_io_read < net_io_read + current_io_read) OR (agg_io_write < net_io_write + current_io_write) OR "" + ""(agg_bytes_read < net_bytes_read + current_bytes_read) OR (agg_bytes_write < net_bytes_write + current_bytes_write)"";
	 private final SearchBuilder<VmDiskStatisticsVO> AllFieldsSearch;
	 private final SearchBuilder<VmDiskStatisticsVO> AccountSearch;
	 public VmDiskStatisticsDaoImpl() {
		 AccountSearch = createSearchBuilder();
		 AccountSearch.and(""account"", AccountSearch.entity().getAccountId(), SearchCriteria.Op.EQ);
		 AccountSearch.done();
		 AllFieldsSearch = createSearchBuilder();
		 AllFieldsSearch.and(""account"", AllFieldsSearch.entity().getAccountId(), SearchCriteria.Op.EQ);
		 AllFieldsSearch.and(""dc"", AllFieldsSearch.entity().getDataCenterId(), SearchCriteria.Op.EQ);
		 AllFieldsSearch.and(""volume"", AllFieldsSearch.entity().getVolumeId(), SearchCriteria.Op.EQ);
		 AllFieldsSearch.and(""vm"", AllFieldsSearch.entity().getVmId(), SearchCriteria.Op.EQ);
		 AllFieldsSearch.done();
	 }
	 public VmDiskStatisticsVO findBy(long accountId, long dcId, long vmId, long volumeId) {
		 SearchCriteria<VmDiskStatisticsVO> sc = AllFieldsSearch.create();
		 sc.setParameters(""account"", accountId);
		 sc.setParameters(""dc"", dcId);
		 sc.setParameters(""volume"", volumeId);
		 sc.setParameters(""vm"", vmId);
		 return findOneBy(sc);
	 }
	 public VmDiskStatisticsVO lock(long accountId, long dcId, long vmId, long volumeId) {
		 SearchCriteria<VmDiskStatisticsVO> sc = AllFieldsSearch.create();
		 sc.setParameters(""account"", accountId);
		 sc.setParameters(""dc"", dcId);
		 sc.setParameters(""volume"", volumeId);
		 sc.setParameters(""vm"", vmId);
		 return lockOneRandomRow(sc, true);
	 }
	 public List<VmDiskStatisticsVO> listBy(long accountId) {
		 SearchCriteria<VmDiskStatisticsVO> sc = AccountSearch.create();
		 sc.setParameters(""account"", accountId);
		 return search(sc, null);
	 }
	 public List<VmDiskStatisticsVO> listActiveAndRecentlyDeleted(Date minRemovedDate, int startIndex, int limit) {
		 List<VmDiskStatisticsVO> vmDiskStats = new ArrayList<VmDiskStatisticsVO>();
		 if (minRemovedDate == null) return vmDiskStats;
		 TransactionLegacy txn = TransactionLegacy.currentTxn();
		 try {
			 String sql = ACTIVE_AND_RECENTLY_DELETED_SEARCH + "" LIMIT "" + startIndex + "","" + limit;
			 PreparedStatement pstmt = null;
			 pstmt = txn.prepareAutoCloseStatement(sql);
			 pstmt.setString(1, DateUtil.getDateDisplayString(TimeZone.getTimeZone(""GMT""), minRemovedDate));
			 ResultSet rs = pstmt.executeQuery();
			 while (rs.next()) {
				 vmDiskStats.add(toEntityBean(rs, false));
			 }
		 }
		 catch (Exception ex) {
			 s_logger.error(""error saving vm disk stats to cloud_usage db"", ex);
		 }
		 return vmDiskStats;
	 }
	 public List<VmDiskStatisticsVO> listUpdatedStats() {
		 List<VmDiskStatisticsVO> vmDiskStats = new ArrayList<VmDiskStatisticsVO>();
		 TransactionLegacy txn = TransactionLegacy.currentTxn();
		 try {
			 PreparedStatement pstmt = null;
			 pstmt = txn.prepareAutoCloseStatement(UPDATED_VM_NETWORK_STATS_SEARCH);
			 ResultSet rs = pstmt.executeQuery();
			 while (rs.next()) {
				 vmDiskStats.add(toEntityBean(rs, false));
			 }
		 }
		 catch (Exception ex) {
			 s_logger.error(""error lisitng updated vm disk stats"", ex);
		 }
		 return vmDiskStats;
	 }
}",0,0,0,0
"private static class CreateProxiedFileSystemFromProperties implements Callable<FileSystem> {
	 private final String userNameToProxyAs;
	 private final Properties properties;
	 private final URI uri;
	 private final Configuration configuration;
	 private final FileSystem referenceFS;
	 public FileSystem call() throws Exception {
		 FileSystem fs = ProxiedFileSystemUtils.createProxiedFileSystem(this.userNameToProxyAs, this.properties, this.uri, this.configuration);
		 if (this.referenceFS != null) {
			 return decorateFilesystemFromReferenceFS(fs, this.referenceFS);
		 }
		 return fs;
	 }
 }",0,0,0,0
"public int showDialog(Account from, Account to, long fromA, long toA);",0,0,0,1
"public class Mapper extends DataType implements Cloneable {
	 protected MapperType type = null;
	 protected String classname = null;
	 protected Path classpath = null;
	 protected String from = null;
	 protected String to = null;
	 private ContainerMapper container = null;
	 public Mapper(Project p) {
		 setProject(p);
	 }
	 public void setType(MapperType type) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.type = type;
	 }
	 public void addConfigured(FileNameMapper fileNameMapper) {
		 add(fileNameMapper);
	 }
	 public void add(FileNameMapper fileNameMapper) {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 if (container == null) {
			 if (type == null && classname == null) {
				 container = new CompositeMapper();
			 }
			 else {
				 FileNameMapper m = getImplementation();
				 if (m instanceof ContainerMapper) {
					 container = (ContainerMapper) m;
				 }
				 else {
					 throw new BuildException(String.valueOf(m) + "" mapper implementation does not support nested mappers!"");
				 }
			 }
		 }
		 container.add(fileNameMapper);
	 }
	 public void addConfiguredMapper(Mapper mapper) {
		 add(mapper.getImplementation());
	 }
	 public void setClassname(String classname) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.classname = classname;
	 }
	 public void setClasspath(Path classpath) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 if (this.classpath == null) {
			 this.classpath = classpath;
		 }
		 else {
			 this.classpath.append(classpath);
		 }
	 }
	 public Path createClasspath() {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 if (this.classpath == null) {
			 this.classpath = new Path(getProject());
		 }
		 return this.classpath.createPath();
	 }
	 public void setClasspathRef(Reference ref) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 createClasspath().setRefid(ref);
	 }
	 public void setFrom(String from) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.from = from;
	 }
	 public void setTo(String to) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.to = to;
	 }
	 public void setRefid(Reference r) throws BuildException {
		 if (type != null || from != null || to != null) {
			 throw tooManyAttributes();
		 }
		 super.setRefid(r);
	 }
	 public FileNameMapper getImplementation() throws BuildException {
		 if (isReference()) {
			 dieOnCircularReference();
			 Reference r = getRefid();
			 Object o = r.getReferencedObject(getProject());
			 if (o instanceof FileNameMapper) {
				 return (FileNameMapper) o;
			 }
			 if (o instanceof Mapper) {
				 return ((Mapper) o).getImplementation();
			 }
			 String od = o == null ? ""null"" : o.getClass().getName();
			 throw new BuildException(od + "" at reference '"" + r.getRefId() + ""' is not a valid mapper reference."");
		 }
		 if (type == null && classname == null && container == null) {
			 throw new BuildException( ""nested mapper or "" + ""one of the attributes type or classname is required"");
		 }
		 if (container != null) {
			 return container;
		 }
		 if (type != null && classname != null) {
			 throw new BuildException( ""must not specify both type and classname attribute"");
		 }
		 try {
			 FileNameMapper m = (FileNameMapper) (getImplementationClass().newInstance());
			 final Project p = getProject();
			 if (p != null) {
				 p.setProjectReference(m);
			 }
			 m.setFrom(from);
			 m.setTo(to);
			 return m;
		 }
		 catch (BuildException be) {
			 throw be;
		 }
		 catch (Throwable t) {
			 throw new BuildException(t);
		 }
	 }
	 protected Class getImplementationClass() throws ClassNotFoundException {
		 String cName = this.classname;
		 if (type != null) {
			 cName = type.getImplementation();
		 }
		 ClassLoader loader = (classpath == null) ? getClass().getClassLoader() : getProject().createClassLoader(classpath);
		 return Class.forName(cName, true, loader);
	 }
	 protected Mapper getRef() {
		 return (Mapper) getCheckedRef();
	 }
	 public static class MapperType extends EnumeratedAttribute {
		 private Properties implementations;
		 public MapperType() {
			 implementations = new Properties();
			 implementations.put(""identity"", ""org.apache.tools.ant.util.IdentityMapper"");
			 implementations.put(""flatten"", ""org.apache.tools.ant.util.FlatFileNameMapper"");
			 implementations.put(""glob"", ""org.apache.tools.ant.util.GlobPatternMapper"");
			 implementations.put(""merge"", ""org.apache.tools.ant.util.MergingMapper"");
			 implementations.put(""regexp"", ""org.apache.tools.ant.util.RegexpPatternMapper"");
			 implementations.put(""package"", ""org.apache.tools.ant.util.PackageNameMapper"");
			 implementations.put(""unpackage"", ""org.apache.tools.ant.util.UnPackageNameMapper"");
		 }
		 public String[] getValues() {
			 return new String[] {
			""identity"", ""flatten"", ""glob"", ""merge"", ""regexp"", ""package"", ""unpackage""}
			;
		 }
		 public String getImplementation() {
			 return implementations.getProperty(getValue());
		 }
	 }
}",0,0,0,0
"public AccrualException(String string, Throwable throwable);",0,0,0,0
"public class MainActivity extends FragmentActivity {
	 private static final String TAG = ""MainActivity"";
	 private static final String INAPP_PURCHASE_DATA = ""INAPP_PURCHASE_DATA"";
	 static final int RPS = 0;
	 static final int SETTINGS = 1;
	 static final int CONTENT = 2;
	 static final int FRAGMENT_COUNT = CONTENT +1;
	 private Fragment[] fragments = new Fragment[FRAGMENT_COUNT];
	 private MenuItem settings;
	 private MenuItem challenge;
	 private MenuItem share;
	 private MenuItem message;
	 private boolean isResumed = false;
	 private boolean hasNativeLink = false;
	 private CallbackManager callbackManager;
	 private GameRequestDialog gameRequestDialog;
	 private AccessTokenTracker accessTokenTracker;
	 public void onCreate(Bundle savedInstanceState) {
		 FacebookSdk.addLoggingBehavior(LoggingBehavior.APP_EVENTS);
		 FacebookSdk.setIsDebugEnabled(true);
		 super.onCreate(savedInstanceState);
		 accessTokenTracker = new AccessTokenTracker() {
			 protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken, AccessToken currentAccessToken) {
				 if (isResumed) {
					 if (currentAccessToken == null) {
						 showFragment(RPS, false);
					 }
				 }
			 }
		 }
		;
		 setContentView(R.layout.main);
		 FragmentManager fm = getSupportFragmentManager();
		 fragments[RPS] = fm.findFragmentById(R.id.rps_fragment);
		 fragments[SETTINGS] = fm.findFragmentById(R.id.settings_fragment);
		 fragments[CONTENT] = fm.findFragmentById(R.id.content_fragment);
		 FragmentTransaction transaction = fm.beginTransaction();
		 for(int i = 0;
		 i < fragments.length;
		 i++) {
			 transaction.hide(fragments[i]);
		 }
		 transaction.commit();
		 hasNativeLink = handleNativeLink();
		 gameRequestDialog = new GameRequestDialog(this);
		 callbackManager = CallbackManager.Factory.create();
		 gameRequestDialog.registerCallback( callbackManager, new FacebookCallback<GameRequestDialog.Result>() {
			 public void onCancel() {
				 Log.d(TAG, ""Canceled"");
			 }
			 public void onError(FacebookException error) {
				 Log.d(TAG, String.format(""Error: %s"", error.toString()));
			 }
			 public void onSuccess(GameRequestDialog.Result result) {
				 Log.d(TAG, ""Success!"");
				 Log.d(TAG, ""Request id: "" + result.getRequestId());
				 Log.d(TAG, ""Recipients:"");
				 for (String recipient : result.getRequestRecipients()) {
					 Log.d(TAG, recipient);
				 }
			 }
		 }
		);
	 }
	 public void onResume() {
		 super.onResume();
		 isResumed = true;
	 }
	 public void onPause() {
		 super.onPause();
		 isResumed = false;
	 }
	 public void onActivityResult(int requestCode, int resultCode, Intent data) {
		 callbackManager.onActivityResult(requestCode, resultCode, data);
		 super.onActivityResult(requestCode, resultCode, data);
		 if (requestCode == RpsFragment.IN_APP_PURCHASE_RESULT) {
			 String purchaseData = data.getStringExtra(INAPP_PURCHASE_DATA);
			 if (resultCode == RESULT_OK) {
				 RpsFragment fragment = (RpsFragment) fragments[RPS];
				 try {
					 JSONObject jo = new JSONObject(purchaseData);
					 fragment.onInAppPurchaseSuccess(jo);
				 }
				 catch (JSONException e) {
					 Log.e(TAG, ""In app purchase invalid json."", e);
				 }
			 }
		 }
	 }
	 public void onDestroy() {
		 super.onDestroy();
		 accessTokenTracker.stopTracking();
	 }
	 protected void onResumeFragments() {
		 super.onResumeFragments();
		 if (hasNativeLink) {
			 showFragment(CONTENT, false);
			 hasNativeLink = false;
		 }
		 else {
			 showFragment(RPS, false);
		 }
	 }
	 public boolean onPrepareOptionsMenu(Menu menu) {
		 if (fragments[RPS].isVisible()) {
			 if (menu.size() == 0) {
				 share = menu.add(R.string.share_on_facebook);
				 message = menu.add(R.string.send_with_messenger);
				 challenge = menu.add(R.string.challenge_friends);
				 settings = menu.add(R.string.check_settings);
			 }
			 return true;
		 }
		 else {
			 menu.clear();
			 settings = null;
		 }
		 return false;
	 }
	 public boolean onOptionsItemSelected(MenuItem item) {
		 if (item.equals(settings)) {
			 showFragment(SETTINGS, true);
			 return true;
		 }
		 else if (item.equals(challenge)) {
			 GameRequestContent newGameRequestContent = new GameRequestContent.Builder() .setTitle(getString(R.string.challenge_dialog_title)) .setMessage(getString(R.string.challenge_dialog_message)) .build();
			 gameRequestDialog.show(this, newGameRequestContent);
			 return true;
		 }
		 else if (item.equals(share)) {
			 RpsFragment fragment = (RpsFragment) fragments[RPS];
			 fragment.shareUsingAutomaticDialog();
			 return true;
		 }
		 else if (item.equals(message)) {
			 RpsFragment fragment = (RpsFragment) fragments[RPS];
			 fragment.shareUsingMessengerDialog();
			 return true;
		 }
		 return false;
	 }
	 private boolean handleNativeLink() {
		 if (!AccessToken.isCurrentAccessTokenActive()) {
			 AccessToken.createFromNativeLinkingIntent(getIntent(), FacebookSdk.getApplicationId(), new AccessToken.AccessTokenCreationCallback(){
				 public void onSuccess(AccessToken token) {
					 AccessToken.setCurrentAccessToken(token);
				 }
				 public void onError(FacebookException error) {
				 }
			 }
			);
		 }
		 int appLinkGesture = getAppLinkGesture(getIntent());
		 if (appLinkGesture != INVALID_CHOICE) {
			 ContentFragment fragment = (ContentFragment) fragments[CONTENT];
			 fragment.setContentIndex(appLinkGesture);
			 return true;
		 }
		 return false;
	 }
	 private int getAppLinkGesture(Intent intent) {
		 Uri targetURI = AppLinks.getTargetUrlFromInboundIntent(this, intent);
		 if (targetURI == null) {
			 return INVALID_CHOICE;
		 }
		 String gesture = targetURI.getQueryParameter(""gesture"");
		 if (gesture != null) {
			 if (gesture.equalsIgnoreCase(getString(R.string.rock))) {
				 return RpsGameUtils.ROCK;
			 }
			 else if (gesture.equalsIgnoreCase(getString(R.string.paper))) {
				 return RpsGameUtils.PAPER;
			 }
			 else if (gesture.equalsIgnoreCase(getString(R.string.scissors))) {
				 return RpsGameUtils.SCISSORS;
			 }
		 }
		 return INVALID_CHOICE;
	 }
	 void showFragment(int fragmentIndex, boolean addToBackStack) {
		 FragmentManager fm = getSupportFragmentManager();
		 FragmentTransaction transaction = fm.beginTransaction();
		 if (addToBackStack) {
			 transaction.addToBackStack(null);
		 }
		 else {
			 int backStackSize = fm.getBackStackEntryCount();
			 for (int i = 0;
			 i < backStackSize;
			 i++) {
				 fm.popBackStack();
			 }
		 }
		 for (int i = 0;
		 i < fragments.length;
		 i++) {
			 if (i == fragmentIndex) {
				 transaction.show(fragments[i]);
			 }
			 else {
				 transaction.hide(fragments[i]);
			 }
		 }
		 transaction.commit();
	 }
}",1,0,0,0
"public void updateCanvas() {
	 Graphics2D g2 = canvas.createGraphics();
	 g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
	 g2.setPaint(getColor());
	 if (tool == 1) {
		 g2.fillOval(currentX - ((int) value / 2), currentY - ((int) value / 2), (int) value, (int) value);
	 }
	 else if (tool == 2) {
		 g2.setStroke(new BasicStroke((float) value, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
		 g2.drawLine(oldX, oldY, currentX, currentY);
		 g2.setStroke(new BasicStroke(1.0f));
	 }
	 repaint();
 }",0,0,0,0
"public class ActionOutput extends Output {
	 private Map renderParameters = new HashMap();
	 private PortletMode nextMode;
	 private WindowState nextState;
	 private byte[] portletState;
	 public Map getRenderParameters() {
		 return renderParameters;
	 }
	 public void setRenderParameters(Map renderParameters) {
		 this.renderParameters = renderParameters;
	 }
	 public void setRenderParameter(String key, String value) {
		 renderParameters.put(key, new String[] {
		value}
		);
	 }
	 public void setRenderParameters(String key, String[] values) {
		 renderParameters.put(key, values);
	 }
	 public PortletMode getNextMode() {
		 return nextMode;
	 }
	 public void setNextMode(PortletMode nextMode) {
		 this.nextMode = nextMode;
	 }
	 public WindowState getNextState() {
		 return nextState;
	 }
	 public void setNextState(WindowState nextState) {
		 this.nextState = nextState;
	 }
	 public byte[] getPortletState() {
		 return portletState;
	 }
	 public void setPortletState(byte[] portletState) {
		 this.portletState = portletState;
	 }
}",0,1,0,0
"public class MessageLoadedEvent {
	 LoadMessageThread source;
	 int type;
	 int loadedMessageCount = 0;
	 int numMessages = 0;
	 public static int LOADING_STARTING = 0;
	 public static int LOADING_COMPLETE = 1;
	 public static int MESSAGES_LOADED = 2;
	 public MessageLoadedEvent(LoadMessageThread sourceThread, int eventType, int count, int max) {
		 source = sourceThread;
		 type = eventType;
		 loadedMessageCount = count;
		 numMessages = max;
	 }
	 public LoadMessageThread getSource() {
		 return source;
	 }
	 public int getType() {
		 return type;
	 }
	 public int getLoadedMessageCount() {
		 return loadedMessageCount;
	 }
	 public int getNumMessages() {
		 return numMessages;
	 }
}",0,1,0,0
"private static void usage() {
	 System.err.println(""SegmentReader [-fix] [-dump] [-dumpsort] [-list] [-nocontent] [-noparsedata] [-noparsetext] (-dir segments | seg1 seg2 ...)"");
	 System.err.println(""\tNOTE: at least one segment dir name is required, or '-dir' option."");
	 System.err.println(""\t-fix\t\tautomatically fix corrupted segments"");
	 System.err.println(""\t-dump\t\tdump segment data in human-readable format"");
	 System.err.println(""\t-dumpsort\tdump segment data in human-readable format, sorted by URL"");
	 System.err.println(""\t-list\t\tprint useful information about segments"");
	 System.err.println(""\t-nocontent\tignore content data"");
	 System.err.println(""\t-noparsedata\tignore parse_data data"");
	 System.err.println(""\t-nocontent\tignore parse_text data"");
	 System.err.println(""\t-dir segments\tdirectory containing multiple segments"");
	 System.err.println(""\tseg1 seg2 ...\tsegment directories\n"");
 }",0,0,0,0
"public static void transferSSTables(StreamOutSession session, Collection<SSTableReader> sstables, Collection<Range> ranges) throws IOException {
	 List<PendingFile> pending = createPendingFiles(sstables, ranges);
	 if (pending.size() > 0) {
		 session.addFilesToStream(pending);
		 session.begin();
	 }
	 else {
		 session.close();
	 }
 }",0,0,0,0
"public class AntSoundPlayer implements LineListener, BuildListener {
	 private File fileSuccess = null;
	 private int loopsSuccess = 0;
	 private Long durationSuccess = null;
	 private File fileFail = null;
	 private int loopsFail = 0;
	 private Long durationFail = null;
	 public AntSoundPlayer() {
	 }
	 public void addBuildSuccessfulSound(File file, int loops, Long duration) {
		 this.fileSuccess = file;
		 this.loopsSuccess = loops;
		 this.durationSuccess = duration;
	 }
	 public void addBuildFailedSound(File fileFail, int loopsFail, Long durationFail) {
		 this.fileFail = fileFail;
		 this.loopsFail = loopsFail;
		 this.durationFail = durationFail;
	 }
	 private void play(Project project, File file, int loops, Long duration) {
		 Clip audioClip = null;
		 AudioInputStream audioInputStream = null;
		 try {
			 audioInputStream = AudioSystem.getAudioInputStream(file);
		 }
		 catch (UnsupportedAudioFileException uafe) {
			 project.log(""Audio format is not yet supported: "" + uafe.getMessage());
		 }
		 catch (IOException ioe) {
			 ioe.printStackTrace();
		 }
		 if (audioInputStream != null) {
			 AudioFormat format = audioInputStream.getFormat();
			 DataLine.Info info = new DataLine.Info(Clip.class, format, AudioSystem.NOT_SPECIFIED);
			 try {
				 audioClip = (Clip) AudioSystem.getLine(info);
				 audioClip.addLineListener(this);
				 audioClip.open(audioInputStream);
			 }
			 catch (LineUnavailableException e) {
				 project.log(""The sound device is currently unavailable"");
				 return;
			 }
			 catch (IOException e) {
				 e.printStackTrace();
			 }
			 if (duration != null) {
				 playClip(audioClip, duration.longValue());
			 }
			 else {
				 playClip(audioClip, loops);
			 }
			 audioClip.drain();
			 audioClip.close();
		 }
		 else {
			 project.log(""Can't get data from file "" + file.getName());
		 }
	 }
	 private void playClip(Clip clip, int loops) {
		 clip.loop(loops);
		 do {
			 try {
				 long timeLeft = (clip.getMicrosecondLength() - clip.getMicrosecondPosition()) / 1000;
				 if (timeLeft > 0) {
					 Thread.sleep(timeLeft);
				 }
			 }
			 catch (InterruptedException e) {
				 break;
			 }
		 }
		 while (clip.isRunning());
		 if (clip.isRunning()) {
			 clip.stop();
		 }
	 }
	 private void playClip(Clip clip, long duration) {
		 clip.loop(Clip.LOOP_CONTINUOUSLY);
		 try {
			 Thread.sleep(duration);
		 }
		 catch (InterruptedException e) {
		 }
		 clip.stop();
	 }
	 public void update(LineEvent event) {
		 if (event.getType().equals(LineEvent.Type.STOP)) {
			 Line line = event.getLine();
			 line.close();
		 }
	 }
	 public void buildStarted(BuildEvent event) {
	 }
	 public void buildFinished(BuildEvent event) {
		 if (event.getException() == null && fileSuccess != null) {
			 play(event.getProject(), fileSuccess, loopsSuccess, durationSuccess);
		 }
		 else if (event.getException() != null && fileFail != null) {
			 play(event.getProject(), fileFail, loopsFail, durationFail);
		 }
	 }
	 public void targetStarted(BuildEvent event) {
	 }
	 public void targetFinished(BuildEvent event) {
	 }
	 public void taskStarted(BuildEvent event) {
	 }
	 public void taskFinished(BuildEvent event) {
	 }
	 public void messageLogged(BuildEvent event) {
	 }
}",0,0,0,0
"public class JGraphCoordinateAssignment implements JGraphHierarchicalLayoutStep {
	protected double intraCellSpacing = 30.0;
	protected double interRankCellSpacing = 30.0;
	protected double parallelEdgeSpacing = 10.0;
	protected int maxIterations = 8;
	protected int orientation = SwingConstants.NORTH;
	protected double initialX;
	protected double limitX;
	protected double currentXDelta;
	protected int widestRank;
	protected double widestRankValue;
	protected double[] rankWidths;
	protected double[] rankY;
	protected boolean fineTuning = true;
	protected boolean compactLayout = false;
	protected JGraphAbstractHierarchyCell[][] nextLayerConnectedCache;
	protected JGraphAbstractHierarchyCell[][] previousLayerConnectedCache;
	private static Logger logger = Logger.getLogger(""com.jgraph.layout.hierarchical.JGraphCoordinateAssignment"");
	public JGraphCoordinateAssignment(double intraCellSpacing,double interRankCellSpacing, int orientation,boolean compactLayout, double initialX, double parallelEdgeSpacing) {
		this.intraCellSpacing = intraCellSpacing;
		this.interRankCellSpacing = interRankCellSpacing;
		this.orientation = orientation;
		this.compactLayout = compactLayout;
		this.initialX = initialX;
		this.parallelEdgeSpacing = parallelEdgeSpacing;
		setLoggerLevel(Level.OFF);
	}
	public JGraphHierarchyModel run(JGraphFacade facade,JGraphHierarchyModel model) {
		currentXDelta = 0.0;
		initialise(model);
		initialCoords(facade, model);
		if (fineTuning) {
			minNode(model);
		}
		double bestXDelta = 100000000.0;
		if (fineTuning) {
			for (int i = 0;
			 i < maxIterations;
			 i++) {
				if (i != 0) {
					medianPos(i, model);
					minNode(model);
				}
				if (currentXDelta < bestXDelta) {
					for (int j = 0;
					 j < model.ranks.size();
					 j++) {
						JGraphHierarchyRank rank = (JGraphHierarchyRank) model.ranks.get(new Integer(j));
						Iterator iter = rank.iterator();
						while (iter.hasNext()) {
							JGraphAbstractHierarchyCell cell = (JGraphAbstractHierarchyCell) iter.next();
							cell.setX(j, cell.getGeneralPurposeVariable(j));
						}
					}
					bestXDelta = currentXDelta;
				}
				 else {
					for (int j = 0;
					 j < model.ranks.size();
					 j++) {
						JGraphHierarchyRank rank = (JGraphHierarchyRank) model.ranks.get(new Integer(j));
						Iterator iter = rank.iterator();
						while (iter.hasNext()) {
							JGraphAbstractHierarchyCell cell = (JGraphAbstractHierarchyCell) iter.next();
							cell.setGeneralPurposeVariable(j, (int) cell.getX(j));
						}
					}
				}
				currentXDelta = 0;
			}
		}
		if (compactLayout) {
		}
		setCellLocations(facade, model);
		return model;
	}
	private void minNode(JGraphHierarchyModel model) {
		LinkedList nodeList = new LinkedList();
		Map map = new Hashtable();
		Object[][] rank = new Object[model.maxRank + 1][];
		for (int i = 0;
		 i <= model.maxRank;
		 i++) {
			JGraphHierarchyRank rankSet = (JGraphHierarchyRank) model.ranks.get(new Integer(i));
			rank[i] = rankSet.toArray();
			for (int j = 0;
			 j < rank[i].length;
			 j++) {
				JGraphAbstractHierarchyCell cell = (JGraphAbstractHierarchyCell) rank[i][j];
				WeightedCellSorter cellWrapper = new WeightedCellSorter(cell, i);
				cellWrapper.rankIndex = j;
				cellWrapper.visited = true;
				nodeList.add(cellWrapper);
				map.put(cell, cellWrapper);
			}
		}
		int maxTries = nodeList.size() * 10;
		int count = 0;
		int tolerance = 1;
		while (!nodeList.isEmpty() && count <= maxTries) {
			WeightedCellSorter cellWrapper = (WeightedCellSorter) nodeList.getFirst();
			JGraphAbstractHierarchyCell cell = cellWrapper.cell;
			int rankValue = cellWrapper.weightedValue;
			int rankIndex = cellWrapper.rankIndex;
			Object[] nextLayerConnectedCells = cell.getNextLayerConnectedCells(rankValue).toArray();
			Object[] previousLayerConnectedCells = cell.getPreviousLayerConnectedCells(rankValue).toArray();
			int numNextLayerConnected = nextLayerConnectedCells.length;
			int numPreviousLayerConnected = previousLayerConnectedCells.length;
			int medianNextLevel = medianXValue(nextLayerConnectedCells,rankValue + 1);
			int medianPreviousLevel = medianXValue(previousLayerConnectedCells,rankValue - 1);
			int numConnectedNeighbours = numNextLayerConnected+ numPreviousLayerConnected;
			int currentPosition = cell.getGeneralPurposeVariable(rankValue);
			double cellMedian = currentPosition;
			if (numConnectedNeighbours > 0) {
				cellMedian = (medianNextLevel * numNextLayerConnected + medianPreviousLevel/ numConnectedNeighbours;
			}
			boolean positionChanged = false;
			if (cellMedian < currentPosition - tolerance) {
				if (rankIndex == 0) {
					cell.setGeneralPurposeVariable(rankValue, (int) cellMedian);
					positionChanged = true;
				}
				 else {
					JGraphAbstractHierarchyCell leftCell = (JGraphAbstractHierarchyCell) rank[rankValue][rankIndex - 1];
					int leftLimit = leftCell.getGeneralPurposeVariable(rankValue);
					leftLimit = leftLimit + (int) leftCell.width / 2+ (int) intraCellSpacing + (int) cell.width / 2;
					if (leftLimit < cellMedian) {
						cell.setGeneralPurposeVariable(rankValue,(int) cellMedian);
						positionChanged = true;
					}
					 else if (leftLimit < cell.getGeneralPurposeVariable(rankValue)- tolerance) {
						cell.setGeneralPurposeVariable(rankValue, leftLimit);
						positionChanged = true;
					}
				}
			}
			 else if (cellMedian > currentPosition + tolerance) {
				int rankSize = rank[rankValue].length;
				if (rankIndex == rankSize - 1) {
					cell.setGeneralPurposeVariable(rankValue, (int) cellMedian);
					positionChanged = true;
				}
				 else {
					JGraphAbstractHierarchyCell rightCell = (JGraphAbstractHierarchyCell) rank[rankValue][rankIndex + 1];
					int rightLimit = rightCell.getGeneralPurposeVariable(rankValue);
					rightLimit = rightLimit - (int) rightCell.width / 2- (int) intraCellSpacing - (int) cell.width / 2;
					if (rightLimit > cellMedian) {
						cell.setGeneralPurposeVariable(rankValue,(int) cellMedian);
						positionChanged = true;
					}
					 else if (rightLimit > cell.getGeneralPurposeVariable(rankValue)+ tolerance) {
						cell.setGeneralPurposeVariable(rankValue, rightLimit);
						positionChanged = true;
					}
				}
			}
			if (positionChanged) {
				for (int i = 0;
				 i < nextLayerConnectedCells.length;
				 i++) {
					JGraphAbstractHierarchyCell connectedCell = (JGraphAbstractHierarchyCell) nextLayerConnectedCells[i];
					WeightedCellSorter connectedCellWrapper = (WeightedCellSorter) map.get(connectedCell);
					if (connectedCellWrapper != null) {
						if (connectedCellWrapper.visited == false) {
							connectedCellWrapper.visited = true;
							nodeList.add(connectedCellWrapper);
						}
					}
				}
				for (int i = 0;
				 i < previousLayerConnectedCells.length;
				 i++) {
					JGraphAbstractHierarchyCell connectedCell = (JGraphAbstractHierarchyCell) previousLayerConnectedCells[i];
					WeightedCellSorter connectedCellWrapper = (WeightedCellSorter) map.get(connectedCell);
					if (connectedCellWrapper != null) {
						if (connectedCellWrapper.visited == false) {
							connectedCellWrapper.visited = true;
							nodeList.add(connectedCellWrapper);
						}
					}
				}
			}
			nodeList.removeFirst();
			cellWrapper.visited = false;
			count++;
		}
	}
	private void medianPos(int i, JGraphHierarchyModel model) {
		boolean downwardSweep = (i % 2 == 0);
		if (downwardSweep) {
			for (int j = model.maxRank;
			 j > 0;
			 j--) {
				rankMedianPosition(j - 1, model, j);
			}
		}
		 else {
			for (int j = 0;
			 j < model.maxRank - 1;
			 j++) {
				rankMedianPosition(j + 1, model, j);
			}
		}
	}
	protected void rankMedianPosition(int rankValue,JGraphHierarchyModel model, int nextRankValue) {
		JGraphHierarchyRank rankSet = (JGraphHierarchyRank) model.ranks.get(new Integer(rankValue));
		Object[] rank = rankSet.toArray();
		WeightedCellSorter[] weightedValues = new WeightedCellSorter[rank.length];
		Map cellMap = new Hashtable(rank.length);
		for (int i = 0;
		 i < rank.length;
		 i++) {
			JGraphAbstractHierarchyCell currentCell = (JGraphAbstractHierarchyCell) rank[i];
			weightedValues[i] = new WeightedCellSorter();
			weightedValues[i].cell = currentCell;
			weightedValues[i].rankIndex = i;
			cellMap.put(currentCell, weightedValues[i]);
			Collection nextLayerConnectedCells = null;
			if (nextRankValue < rankValue) {
				nextLayerConnectedCells = currentCell.getPreviousLayerConnectedCells(rankValue);
			}
			 else {
				nextLayerConnectedCells = currentCell.getNextLayerConnectedCells(rankValue);
			}
			weightedValues[i].weightedValue = calculatedWeightedValue(currentCell, nextLayerConnectedCells);
		}
		Arrays.sort(weightedValues);
		for (int i = 0;
		 i < weightedValues.length;
		 i++) {
			int numConnectionsNextLevel = 0;
			JGraphAbstractHierarchyCell cell = weightedValues[i].cell;
			Object[] nextLayerConnectedCells = null;
			int medianNextLevel = 0;
			if (nextRankValue < rankValue) {
				nextLayerConnectedCells = cell.getPreviousLayerConnectedCells(rankValue).toArray();
			}
			 else {
				nextLayerConnectedCells = cell.getNextLayerConnectedCells(rankValue).toArray();
			}
			if (nextLayerConnectedCells != null) {
				numConnectionsNextLevel = nextLayerConnectedCells.length;
				if (numConnectionsNextLevel > 0) {
					medianNextLevel = medianXValue(nextLayerConnectedCells,nextRankValue);
				}
				 else {
					medianNextLevel = cell.getGeneralPurposeVariable(rankValue);
				}
			}
			double leftBuffer = 0.0;
			double leftLimit = -100000000.0;
			for (int j = weightedValues[i].rankIndex - 1;
			 j >= 0;
			) {
				WeightedCellSorter weightedValue = (WeightedCellSorter) cellMap.get(rank[j]);
				if (weightedValue != null) {
					JGraphAbstractHierarchyCell leftCell = weightedValue.cell;
					if (weightedValue.visited) {
						leftLimit = leftCell.getGeneralPurposeVariable(rankValue)+ leftCell.width/ 2.0+ intraCellSpacing+ leftBuffer + cell.width / 2.0;
						;
						j = -1;
					}
					 else {
						leftBuffer += leftCell.width + intraCellSpacing;
						j--;
					}
				}
			}
			double rightBuffer = 0.0;
			double rightLimit = 100000000.0;
			for (int j = weightedValues[i].rankIndex + 1;
			 j < weightedValues.length;
			) {
				WeightedCellSorter weightedValue = (WeightedCellSorter) cellMap.get(rank[j]);
				if (weightedValue != null) {
					JGraphAbstractHierarchyCell rightCell = weightedValue.cell;
					if (weightedValue.visited) {
						rightLimit = rightCell.getGeneralPurposeVariable(rankValue)- rightCell.width/ 2.0- intraCellSpacing- rightBuffer - cell.width / 2.0;
						j = weightedValues.length;
					}
					 else {
						rightBuffer += rightCell.width + intraCellSpacing;
						j++;
					}
				}
			}
			if (medianNextLevel >= leftLimit && medianNextLevel <= rightLimit) {
				cell.setGeneralPurposeVariable(rankValue,(int) medianNextLevel);
			}
			 else if (medianNextLevel < leftLimit) {
				cell.setGeneralPurposeVariable(rankValue, (int) leftLimit);
				currentXDelta += leftLimit - medianNextLevel;
			}
			 else if (medianNextLevel > rightLimit) {
				cell.setGeneralPurposeVariable(rankValue, (int) rightLimit);
				currentXDelta += medianNextLevel - rightLimit;
			}
			weightedValues[i].visited = true;
		}
	}
	private int calculatedWeightedValue(JGraphAbstractHierarchyCell currentCell, Collection collection) {
		int totalWeight = 0;
		Iterator iter = collection.iterator();
		while (iter.hasNext()) {
			JGraphAbstractHierarchyCell cell = (JGraphAbstractHierarchyCell) iter.next();
			if (currentCell.isVertex() && cell.isVertex()) {
				totalWeight++;
			}
			 else if (currentCell.isEdge() && cell.isEdge()) {
				totalWeight += 8;
			}
			 else {
				totalWeight += 2;
			}
		}
		return totalWeight;
	}
	private int medianXValue(Object[] connectedCells, int rankValue) {
		if (connectedCells.length == 0) {
			return 0;
		}
		int[] medianValues = new int[connectedCells.length];
		for (int i = 0;
		 i < connectedCells.length;
		 i++) {
			medianValues[i] = ((JGraphAbstractHierarchyCell) connectedCells[i]).getGeneralPurposeVariable(rankValue);
		}
		Arrays.sort(medianValues);
		if (connectedCells.length % 2 == 1) {
			return medianValues[connectedCells.length / 2];
		}
		 else {
			int medianPoint = connectedCells.length / 2;
			int leftMedian = medianValues[medianPoint - 1];
			int rightMedian = medianValues[medianPoint];
			return ((leftMedian + rightMedian) / 2);
		}
	}
	private void initialise(JGraphHierarchyModel model) {
	}
	private void initialCoords(JGraphFacade facade, JGraphHierarchyModel model) {
		calculateWidestRank(facade, model);
		for (int i = widestRank;
		 i >= 0;
		 i--) {
			if (i < model.maxRank) {
				rankCoordinates(i, facade, model);
			}
		}
		for (int i = widestRank + 1;
		 i <= model.maxRank;
		 i++) {
			if (i > 0) {
				rankCoordinates(i, facade, model);
			}
		}
	}
	protected void rankCoordinates(int rankValue, JGraphFacade facade,JGraphHierarchyModel model) {
		JGraphHierarchyRank rank = (JGraphHierarchyRank) model.ranks.get(new Integer(rankValue));
		double extraCellSpacing = (widestRankValue - rankWidths[rankValue]) / (rank.size() + 1);
		double localIntraCellSpacing = intraCellSpacing + extraCellSpacing;
		if (extraCellSpacing * (rank.size() + 1) + rankWidths[rankValue] > widestRankValue) {
			localIntraCellSpacing = intraCellSpacing;
		}
		double maxY = 0.0;
		double localX = initialX + extraCellSpacing;
		Iterator iter = rank.iterator();
		boolean boundsWarning = false;
		while (iter.hasNext()) {
			JGraphAbstractHierarchyCell cell = (JGraphAbstractHierarchyCell) iter.next();
			if (cell.isVertex()) {
				JGraphHierarchyNode node = (JGraphHierarchyNode) cell;
				Rectangle2D bounds = facade.getBounds(node.cell);
				if (bounds != null) {
					if (orientation == SwingConstants.NORTH|| orientation == SwingConstants.SOUTH) {
						cell.width = bounds.getWidth();
						cell.height = bounds.getHeight();
					}
					 else {
						cell.width = bounds.getHeight();
						cell.height = bounds.getWidth();
					}
				}
				 else {
					boundsWarning = true;
				}
				maxY = Math.max(maxY, cell.height);
			}
			 else if (cell.isEdge()) {
				JGraphHierarchyEdge edge = (JGraphHierarchyEdge) cell;
				int numEdges = 1;
				if (edge.edges != null) {
					numEdges = edge.edges.size();
				}
				 else {
					logger.info(""edge.edges is null"");
				}
				cell.width = (numEdges - 1) * parallelEdgeSpacing;
			}
			localX += cell.width / 2.0;
			cell.setX(rankValue, localX);
			cell.setGeneralPurposeVariable(rankValue, (int) localX);
			localX += cell.width / 2.0;
			localX += localIntraCellSpacing;
		}
		if (boundsWarning == true) {
			logger.info(""At least one cell has no bounds"");
		}
	}
	protected void calculateWidestRank(JGraphFacade facade,JGraphHierarchyModel model) {
		double y = -interRankCellSpacing;
		double lastRankMaxCellHeight = 0.0;
		rankWidths = new double[model.maxRank + 1];
		rankY = new double[model.maxRank + 1];
		for (int rankValue = model.maxRank;
		 rankValue >= 0;
		 rankValue--) {
			double maxCellHeight = 0.0;
			JGraphHierarchyRank rank = (JGraphHierarchyRank) model.ranks.get(new Integer(rankValue));
			double localX = initialX;
			Iterator iter = rank.iterator();
			boolean boundsWarning = false;
			while (iter.hasNext()) {
				JGraphAbstractHierarchyCell cell = (JGraphAbstractHierarchyCell) iter.next();
				if (cell.isVertex()) {
					JGraphHierarchyNode node = (JGraphHierarchyNode) cell;
					Rectangle2D bounds = facade.getBounds(node.cell);
					if (bounds != null) {
						if (orientation == SwingConstants.NORTH|| orientation == SwingConstants.SOUTH) {
							cell.width = bounds.getWidth();
							cell.height = bounds.getHeight();
						}
						 else {
							cell.width = bounds.getHeight();
							cell.height = bounds.getWidth();
						}
					}
					 else {
						boundsWarning = true;
					}
					maxCellHeight = Math.max(maxCellHeight, cell.height);
				}
				 else if (cell.isEdge()) {
					JGraphHierarchyEdge edge = (JGraphHierarchyEdge) cell;
					int numEdges = 1;
					if (edge.edges != null) {
						numEdges = edge.edges.size();
					}
					 else {
						logger.info(""edge.edges is null"");
					}
					cell.width = (numEdges - 1) * parallelEdgeSpacing;
				}
				localX += cell.width / 2.0;
				cell.setX(rankValue, localX);
				cell.setGeneralPurposeVariable(rankValue, (int) localX);
				localX += cell.width / 2.0;
				localX += intraCellSpacing;
				if (localX > widestRankValue) {
					widestRankValue = localX;
					widestRank = rankValue;
				}
				rankWidths[rankValue] = localX;
			}
			if (boundsWarning == true) {
				logger.info(""At least one cell has no bounds"");
			}
			rankY[rankValue] = y;
			double distanceToNextRank = maxCellHeight / 2.0+ lastRankMaxCellHeight / 2.0 + interRankCellSpacing;
			lastRankMaxCellHeight = maxCellHeight;
			if (orientation == SwingConstants.NORTH|| orientation == SwingConstants.WEST) {
				y += distanceToNextRank;
			}
			 else {
				y -= distanceToNextRank;
			}
			iter = rank.iterator();
			while (iter.hasNext()) {
				JGraphAbstractHierarchyCell cell = (JGraphAbstractHierarchyCell) iter.next();
				cell.setY(rankValue, y);
			}
		}
	}
	private void setCellLocations(JGraphFacade facade,JGraphHierarchyModel model) {
		double contextTranslation = 0.0;
		List vertices = new ArrayList();
		for (int cellType = 0;
		 cellType < 2;
		 cellType++) {
			for (int i = 0;
			 i < model.ranks.size();
			 i++) {
				JGraphHierarchyRank rank = (JGraphHierarchyRank) model.ranks.get(new Integer(i));
				Iterator iter = rank.iterator();
				while (iter.hasNext()) {
					JGraphAbstractHierarchyCell cell = (JGraphAbstractHierarchyCell) iter.next();
					if (cellType == 0 && cell.isVertex()) {
						JGraphHierarchyNode node = (JGraphHierarchyNode) cell;
						Object realCell = node.cell;
						vertices.add(realCell);
						double positionX = node.x[0] - node.width / 2;
						double positionY = node.y[0] - node.height / 2;
						if (orientation == SwingConstants.NORTH|| orientation == SwingConstants.SOUTH) {
							facade.setLocation(realCell, positionX, positionY);
						}
						 else {
							facade.setLocation(realCell, positionY, positionX);
						}
						limitX = Math.max(limitX, positionX + node.width);
						if (positionX + 1 < initialX) {
							contextTranslation = initialX - positionX;
						}
					}
					 else if (cellType == 1 && cell.isEdge()) {
						JGraphHierarchyEdge edge = (JGraphHierarchyEdge) cell;
						Iterator parallelEdges = edge.edges.iterator();
						double offsetX = 0.0;
						if (edge.temp[0] != 101207) {
							while (parallelEdges.hasNext()) {
								Object realEdge = parallelEdges.next();
								List oldPoints = facade.getPoints(realEdge);
								List newPoints = new ArrayList((edge.x.length) + 2);
								newPoints.add(oldPoints.get(0));
								if (edge.isReversed()) {
									for (int j = 0;
									 j < edge.x.length;
									 j++) {
										double positionX = edge.x[j] + offsetX+ contextTranslation;
										if (orientation == SwingConstants.NORTH|| orientation == SwingConstants.SOUTH) {
											newPoints.add(new Point2D.Double(positionX, edge.y[j]));
										}
										 else {
											newPoints.add(new Point2D.Double(edge.y[j], positionX));
										}
										limitX = Math.max(limitX, positionX);
									}
									processReversedEdge(edge, realEdge);
								}
								 else {
									for (int j = edge.x.length - 1;
									 j >= 0;
									 j--) {
										double positionX = edge.x[j] + offsetX+ contextTranslation;
										if (orientation == SwingConstants.NORTH|| orientation == SwingConstants.SOUTH) {
											newPoints.add(new Point2D.Double(positionX, edge.y[j]));
										}
										 else {
											newPoints.add(new Point2D.Double(edge.y[j], positionX));
										}
										limitX = Math.max(limitX, positionX);
									}
								}
								newPoints.add(oldPoints.get(oldPoints.size() - 1));
								facade.setPoints(realEdge, newPoints);
								facade.disableRouting(realEdge);
								if (offsetX == 0.0) {
									offsetX = parallelEdgeSpacing;
								}
								 else if (offsetX > 0) {
									offsetX = -offsetX;
								}
								 else {
									offsetX = -offsetX + parallelEdgeSpacing;
								}
							}
							edge.temp[0] = 101207;
						}
					}
				}
			}
		}
		if (contextTranslation >= 1.0) {
			if (orientation == SwingConstants.NORTH || orientation == SwingConstants.SOUTH) {
				facade.translateCells(vertices, contextTranslation, 0);
			}
			 else if (orientation == SwingConstants.EAST || orientation == SwingConstants.WEST) {
				facade.translateCells(vertices, 0, contextTranslation);
			}
		}
		limitX += contextTranslation;
	}
	private void processReversedEdge(JGraphHierarchyEdge edge, Object realEdge) {
	}
	protected class WeightedCellSorter implements Comparable {
		public int weightedValue = 0;
		public boolean nudge = false;
		public boolean visited = false;
		public int rankIndex;
		public JGraphAbstractHierarchyCell cell = null;
		public WeightedCellSorter() {
			this(null, 0);
		}
		public WeightedCellSorter(JGraphAbstractHierarchyCell cell,int weightedValue) {
			this.cell = cell;
			this.weightedValue = weightedValue;
		}
		public int compareTo(Object arg0) {
			if (arg0 instanceof WeightedCellSorter) {
				if (weightedValue > ((WeightedCellSorter) arg0).weightedValue) {
					return -1;
				}
				 else if (weightedValue < ((WeightedCellSorter) arg0).weightedValue) {
					return 1;
				}
				 else {
					if (nudge) {
						return -1;
					}
					 else {
						return 1;
					}
				}
			}
			 else {
				return 0;
			}
		}
	}
	protected class AreaSpatialCache extends Rectangle2D.Double {
		public Set cells = new HashSet();
	}
	public double getInterRankCellSpacing() {
		return interRankCellSpacing;
	}
	public void setInterRankCellSpacing(double interRankCellSpacing) {
		this.interRankCellSpacing = interRankCellSpacing;
	}
	public double getIntraCellSpacing() {
		return intraCellSpacing;
	}
	public void setIntraCellSpacing(double intraCellSpacing) {
		this.intraCellSpacing = intraCellSpacing;
	}
	public int getOrientation() {
		return orientation;
	}
	public void setOrientation(int orientation) {
		this.orientation = orientation;
	}
	public double getLimitX() {
		return limitX;
	}
	public void setLimitX(double limitX) {
		this.limitX = limitX;
	}
	public boolean isFineTuning() {
		return fineTuning;
	}
	public void setFineTuning(boolean fineTuning) {
		this.fineTuning = fineTuning;
	}
	public boolean isCompactLayout() {
		return compactLayout;
	}
	public void setCompactLayout(boolean compactLayout) {
		this.compactLayout = compactLayout;
	}
	public void setLoggerLevel(Level level) {
		try {
			logger.setLevel(level);
		}
		 catch (SecurityException e) {
		}
	}
}",1,0,0,0
"public void readFields(DataInput in) throws IOException {
	 startToken = in.readUTF();
	 endToken = in.readUTF();
	 int numOfEndpoints = in.readInt();
	 dataNodes = new String[numOfEndpoints];
	 for(int i = 0;
	 i < numOfEndpoints;
	 i++) {
		 dataNodes[i] = in.readUTF();
	 }
 }",0,0,0,0
"public void setSubSystem(String v) {
	 this.subSystem = v;
 }",0,0,0,0
"public class ViewUpdateGenerator{
	 private final View view;
	 private final int nowInSec;
	 private final TableMetadata baseMetadata;
	 private final DecoratedKey baseDecoratedKey;
	 private final ByteBuffer[] basePartitionKey;
	 private final TableMetadata viewMetadata;
	 private final boolean baseEnforceStrictLiveness;
	 private final Map<DecoratedKey, PartitionUpdate.Builder> updates = new HashMap<>();
	 private final ByteBuffer[] currentViewEntryPartitionKey;
	 private final Row.Builder currentViewEntryBuilder;
	 private enum UpdateAction {
	 NONE, NEW_ENTRY, DELETE_OLD, UPDATE_EXISTING, SWITCH_ENTRY }
	 public ViewUpdateGenerator(View view, DecoratedKey basePartitionKey, int nowInSec) {
		 this.view = view;
		 this.nowInSec = nowInSec;
		 this.baseMetadata = view.getDefinition().baseTableMetadata();
		 this.baseEnforceStrictLiveness = baseMetadata.enforceStrictLiveness();
		 this.baseDecoratedKey = basePartitionKey;
		 this.basePartitionKey = extractKeyComponents(basePartitionKey, baseMetadata.partitionKeyType);
		 this.viewMetadata = Schema.instance.getTableMetadata(view.getDefinition().metadata.id);
		 this.currentViewEntryPartitionKey = new ByteBuffer[viewMetadata.partitionKeyColumns().size()];
		 this.currentViewEntryBuilder = BTreeRow.sortedBuilder();
	 }
	 private static ByteBuffer[] extractKeyComponents(DecoratedKey partitionKey, AbstractType<?> type) {
		 return type instanceof CompositeType ? ((CompositeType)type).split(partitionKey.getKey()) : new ByteBuffer[]{
		 partitionKey.getKey() }
		;
	 }
	 public void addBaseTableUpdate(Row existingBaseRow, Row mergedBaseRow) {
		 switch (updateAction(existingBaseRow, mergedBaseRow)) {
			 case NONE: return;
			 case NEW_ENTRY: createEntry(mergedBaseRow);
			 return;
			 case DELETE_OLD: deleteOldEntry(existingBaseRow, mergedBaseRow);
			 return;
			 case UPDATE_EXISTING: updateEntry(existingBaseRow, mergedBaseRow);
			 return;
			 case SWITCH_ENTRY: createEntry(mergedBaseRow);
			 deleteOldEntry(existingBaseRow, mergedBaseRow);
			 return;
		 }
	 }
	 public Collection<PartitionUpdate> generateViewUpdates() {
		 return updates.values().stream().map(PartitionUpdate.Builder::build).collect(Collectors.toList());
	 }
	 public void clear() {
		 updates.clear();
	 }
	 private UpdateAction updateAction(Row existingBaseRow, Row mergedBaseRow) {
		 assert !mergedBaseRow.isEmpty();
		 if (baseMetadata.isCompactTable()) {
			 Clustering clustering = mergedBaseRow.clustering();
			 for (int i = 0;
			 i < clustering.size();
			 i++) {
				 if (clustering.get(i) == null) return UpdateAction.NONE;
			 }
		 }
		 assert view.baseNonPKColumnsInViewPK.size() <= 1 : ""We currently only support one base non-PK column in the view PK"";
		 if (view.baseNonPKColumnsInViewPK.isEmpty()) {
			 boolean existingHasLiveData = existingBaseRow != null && existingBaseRow.hasLiveData(nowInSec, baseEnforceStrictLiveness);
			 boolean mergedHasLiveData = mergedBaseRow.hasLiveData(nowInSec, baseEnforceStrictLiveness);
			 return existingHasLiveData ? (mergedHasLiveData ? UpdateAction.UPDATE_EXISTING : UpdateAction.DELETE_OLD) : (mergedHasLiveData ? UpdateAction.NEW_ENTRY : UpdateAction.NONE);
		 }
		 ColumnMetadata baseColumn = view.baseNonPKColumnsInViewPK.get(0);
		 assert !baseColumn.isComplex() : ""A complex column couldn't be part of the view PK"";
		 Cell before = existingBaseRow == null ? null : existingBaseRow.getCell(baseColumn);
		 Cell after = mergedBaseRow.getCell(baseColumn);
		 if (before == after) return isLive(before) ? UpdateAction.UPDATE_EXISTING : UpdateAction.NONE;
		 if (!isLive(before)) return isLive(after) ? UpdateAction.NEW_ENTRY : UpdateAction.NONE;
		 if (!isLive(after)) {
			 return UpdateAction.DELETE_OLD;
		 }
		 return baseColumn.cellValueType().compare(before.value(), after.value()) == 0 ? UpdateAction.UPDATE_EXISTING : UpdateAction.SWITCH_ENTRY;
	 }
	 private boolean matchesViewFilter(Row baseRow) {
		 return view.matchesViewFilter(baseDecoratedKey, baseRow, nowInSec);
	 }
	 private boolean isLive(Cell cell) {
		 return cell != null && cell.isLive(nowInSec);
	 }
	 private void createEntry(Row baseRow) {
		 if (!matchesViewFilter(baseRow)) return;
		 startNewUpdate(baseRow);
		 currentViewEntryBuilder.addPrimaryKeyLivenessInfo(computeLivenessInfoForEntry(baseRow));
		 currentViewEntryBuilder.addRowDeletion(baseRow.deletion());
		 for (ColumnData data : baseRow) {
			 ColumnMetadata viewColumn = view.getViewColumn(data.column());
			 if (viewColumn == null || viewColumn.isPrimaryKeyColumn()) continue;
			 addColumnData(viewColumn, data);
		 }
		 submitUpdate();
	 }
	 private void updateEntry(Row existingBaseRow, Row mergedBaseRow) {
		 if (!matchesViewFilter(existingBaseRow)) {
			 createEntry(mergedBaseRow);
			 return;
		 }
		 if (!matchesViewFilter(mergedBaseRow)) {
			 deleteOldEntryInternal(existingBaseRow, mergedBaseRow);
			 return;
		 }
		 startNewUpdate(mergedBaseRow);
		 currentViewEntryBuilder.addPrimaryKeyLivenessInfo(computeLivenessInfoForEntry(mergedBaseRow));
		 currentViewEntryBuilder.addRowDeletion(mergedBaseRow.deletion());
		 addDifferentCells(existingBaseRow, mergedBaseRow);
		 submitUpdate();
	 }
	 private void addDifferentCells(Row existingBaseRow, Row mergedBaseRow) {
		 PeekingIterator<ColumnData> existingIter = Iterators.peekingIterator(existingBaseRow.iterator());
		 for (ColumnData mergedData : mergedBaseRow) {
			 ColumnMetadata baseColumn = mergedData.column();
			 ColumnMetadata viewColumn = view.getViewColumn(baseColumn);
			 if (viewColumn == null || viewColumn.isPrimaryKeyColumn()) continue;
			 ColumnData existingData = null;
			 while (existingIter.hasNext()) {
				 int cmp = baseColumn.compareTo(existingIter.peek().column());
				 if (cmp < 0) break;
				 ColumnData next = existingIter.next();
				 if (cmp == 0) {
					 existingData = next;
					 break;
				 }
			 }
			 if (existingData == null) {
				 addColumnData(viewColumn, mergedData);
				 continue;
			 }
			 if (mergedData == existingData) continue;
			 if (baseColumn.isComplex()) {
				 ComplexColumnData mergedComplexData = (ComplexColumnData)mergedData;
				 ComplexColumnData existingComplexData = (ComplexColumnData)existingData;
				 if (mergedComplexData.complexDeletion().supersedes(existingComplexData.complexDeletion())) currentViewEntryBuilder.addComplexDeletion(viewColumn, mergedComplexData.complexDeletion());
				 PeekingIterator<Cell> existingCells = Iterators.peekingIterator(existingComplexData.iterator());
				 for (Cell mergedCell : mergedComplexData) {
					 Cell existingCell = null;
					 while (existingCells.hasNext()) {
						 int cmp = baseColumn.cellPathComparator().compare(mergedCell.path(), existingCells.peek().path());
						 if (cmp > 0) break;
						 Cell next = existingCells.next();
						 if (cmp == 0) {
							 existingCell = next;
							 break;
						 }
					 }
					 if (mergedCell != existingCell) addCell(viewColumn, mergedCell);
				 }
			 }
			 else {
				 addCell(viewColumn, (Cell)mergedData);
			 }
		 }
	 }
	 private void deleteOldEntry(Row existingBaseRow, Row mergedBaseRow) {
		 if (!matchesViewFilter(existingBaseRow)) return;
		 deleteOldEntryInternal(existingBaseRow, mergedBaseRow);
	 }
	 private void deleteOldEntryInternal(Row existingBaseRow, Row mergedBaseRow) {
		 startNewUpdate(existingBaseRow);
		 long timestamp = computeTimestampForEntryDeletion(existingBaseRow, mergedBaseRow);
		 long rowDeletion = mergedBaseRow.deletion().time().markedForDeleteAt();
		 assert timestamp >= rowDeletion;
		 if (timestamp > rowDeletion) {
			 LivenessInfo info = LivenessInfo.withExpirationTime(timestamp, LivenessInfo.EXPIRED_LIVENESS_TTL, nowInSec);
			 currentViewEntryBuilder.addPrimaryKeyLivenessInfo(info);
		 }
		 currentViewEntryBuilder.addRowDeletion(mergedBaseRow.deletion());
		 addDifferentCells(existingBaseRow, mergedBaseRow);
		 submitUpdate();
	 }
	 private void startNewUpdate(Row baseRow) {
		 ByteBuffer[] clusteringValues = new ByteBuffer[viewMetadata.clusteringColumns().size()];
		 for (ColumnMetadata viewColumn : viewMetadata.primaryKeyColumns()) {
			 ColumnMetadata baseColumn = view.getBaseColumn(viewColumn);
			 ByteBuffer value = getValueForPK(baseColumn, baseRow);
			 if (viewColumn.isPartitionKey()) currentViewEntryPartitionKey[viewColumn.position()] = value;
			 else clusteringValues[viewColumn.position()] = value;
		 }
		 currentViewEntryBuilder.newRow(Clustering.make(clusteringValues));
	 }
	 private LivenessInfo computeLivenessInfoForEntry(Row baseRow) {
		 assert view.baseNonPKColumnsInViewPK.size() <= 1;
		 LivenessInfo baseLiveness = baseRow.primaryKeyLivenessInfo();
		 if (view.baseNonPKColumnsInViewPK.isEmpty()) {
			 if (view.getDefinition().includeAllColumns) return baseLiveness;
			 long timestamp = baseLiveness.timestamp();
			 boolean hasNonExpiringLiveCell = false;
			 Cell biggestExpirationCell = null;
			 for (Cell cell : baseRow.cells()) {
				 if (view.getViewColumn(cell.column()) != null) continue;
				 if (!isLive(cell)) continue;
				 timestamp = Math.max(timestamp, cell.maxTimestamp());
				 if (!cell.isExpiring()) hasNonExpiringLiveCell = true;
				 else {
					 if (biggestExpirationCell == null) biggestExpirationCell = cell;
					 else if (cell.localDeletionTime() > biggestExpirationCell.localDeletionTime()) biggestExpirationCell = cell;
				 }
			 }
			 if (baseLiveness.isLive(nowInSec) && !baseLiveness.isExpiring()) return LivenessInfo.create(timestamp, nowInSec);
			 if (hasNonExpiringLiveCell) return LivenessInfo.create(timestamp, nowInSec);
			 if (biggestExpirationCell == null) return baseLiveness;
			 if (biggestExpirationCell.localDeletionTime() > baseLiveness.localExpirationTime() || !baseLiveness.isLive(nowInSec)) return LivenessInfo.withExpirationTime(timestamp, biggestExpirationCell.ttl(), biggestExpirationCell.localDeletionTime());
			 return baseLiveness;
		 }
		 Cell cell = baseRow.getCell(view.baseNonPKColumnsInViewPK.get(0));
		 assert isLive(cell) : ""We shouldn't have got there if the base row had no associated entry"";
		 return LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime());
	 }
	 private long computeTimestampForEntryDeletion(Row existingBaseRow, Row mergedBaseRow) {
		 DeletionTime deletion = mergedBaseRow.deletion().time();
		 if (view.hasSamePrimaryKeyColumnsAsBaseTable()) {
			 long timestamp = Math.max(deletion.markedForDeleteAt(), existingBaseRow.primaryKeyLivenessInfo().timestamp());
			 if (view.getDefinition().includeAllColumns) return timestamp;
			 for (Cell cell : existingBaseRow.cells()) {
				 if (view.getViewColumn(cell.column()) != null) continue;
				 timestamp = Math.max(timestamp, cell.maxTimestamp());
			 }
			 return timestamp;
		 }
		 Cell before = existingBaseRow.getCell(view.baseNonPKColumnsInViewPK.get(0));
		 assert isLive(before) : ""We shouldn't have got there if the base row had no associated entry"";
		 return deletion.deletes(before) ? deletion.markedForDeleteAt() : before.timestamp();
	 }
	 private void addColumnData(ColumnMetadata viewColumn, ColumnData baseTableData) {
		 assert viewColumn.isComplex() == baseTableData.column().isComplex();
		 if (!viewColumn.isComplex()) {
			 addCell(viewColumn, (Cell)baseTableData);
			 return;
		 }
		 ComplexColumnData complexData = (ComplexColumnData)baseTableData;
		 currentViewEntryBuilder.addComplexDeletion(viewColumn, complexData.complexDeletion());
		 for (Cell cell : complexData) addCell(viewColumn, cell);
	 }
	 private void addCell(ColumnMetadata viewColumn, Cell baseTableCell) {
		 assert !viewColumn.isPrimaryKeyColumn();
		 currentViewEntryBuilder.addCell(baseTableCell.withUpdatedColumn(viewColumn));
	 }
	 private void submitUpdate() {
		 Row row = currentViewEntryBuilder.build();
		 if (row.isEmpty()) return;
		 DecoratedKey partitionKey = makeCurrentPartitionKey();
		 PartitionUpdate.Builder update = updates.computeIfAbsent(partitionKey, k -> new PartitionUpdate.Builder(viewMetadata, partitionKey, viewMetadata.regularAndStaticColumns(), 4));
		 update.add(row);
	 }
	 private DecoratedKey makeCurrentPartitionKey() {
		 ByteBuffer rawKey = viewMetadata.partitionKeyColumns().size() == 1 ? currentViewEntryPartitionKey[0] : CompositeType.build(currentViewEntryPartitionKey);
		 return viewMetadata.partitioner.decorateKey(rawKey);
	 }
	 private ByteBuffer getValueForPK(ColumnMetadata column, Row row) {
		 switch (column.kind) {
			 case PARTITION_KEY: return basePartitionKey[column.position()];
			 case CLUSTERING: return row.clustering().get(column.position());
			 default: return row.getCell(column).value();
		 }
	 }
}",0,0,0,0
"protected void process(InputSource is) throws SAXException, IOException, ParseException, XPathException, ClassNotFoundException {
	 Document document = docBuilder.parse(is);
	 NodeList deleteJobGroupNodes = (NodeList) xpath.evaluate( ""/q:job-scheduling-data/q:pre-processing-commands/q:delete-jobs-in-group"", document, XPathConstants.NODESET);
	 log.debug(""Found "" + deleteJobGroupNodes.getLength() + "" delete job group commands."");
	 for (int i = 0;
	 i < deleteJobGroupNodes.getLength();
	 i++) {
		 Node node = deleteJobGroupNodes.item(i);
		 String t = node.getTextContent();
		 if(t == null || (t = t.trim()).length() == 0) continue;
		 jobGroupsToDelete.add(t);
	 }
	 NodeList deleteTriggerGroupNodes = (NodeList) xpath.evaluate( ""/q:job-scheduling-data/q:pre-processing-commands/q:delete-triggers-in-group"", document, XPathConstants.NODESET);
	 log.debug(""Found "" + deleteTriggerGroupNodes.getLength() + "" delete trigger group commands."");
	 for (int i = 0;
	 i < deleteTriggerGroupNodes.getLength();
	 i++) {
		 Node node = deleteTriggerGroupNodes.item(i);
		 String t = node.getTextContent();
		 if(t == null || (t = t.trim()).length() == 0) continue;
		 triggerGroupsToDelete.add(t);
	 }
	 NodeList deleteJobNodes = (NodeList) xpath.evaluate( ""/q:job-scheduling-data/q:pre-processing-commands/q:delete-job"", document, XPathConstants.NODESET);
	 log.debug(""Found "" + deleteJobNodes.getLength() + "" delete job commands."");
	 for (int i = 0;
	 i < deleteJobNodes.getLength();
	 i++) {
		 Node node = deleteJobNodes.item(i);
		 String name = getTrimmedToNullString(xpath, ""q:name"", node);
		 String group = getTrimmedToNullString(xpath, ""q:group"", node);
		 if(name == null) throw new ParseException(""Encountered a 'delete-job' command without a name specified."", -1);
		 jobsToDelete.add(new Key(name, group));
	 }
	 NodeList deleteTriggerNodes = (NodeList) xpath.evaluate( ""/q:job-scheduling-data/q:pre-processing-commands/q:delete-trigger"", document, XPathConstants.NODESET);
	 log.debug(""Found "" + deleteTriggerNodes.getLength() + "" delete trigger commands."");
	 for (int i = 0;
	 i < deleteTriggerNodes.getLength();
	 i++) {
		 Node node = deleteTriggerNodes.item(i);
		 String name = getTrimmedToNullString(xpath, ""q:name"", node);
		 String group = getTrimmedToNullString(xpath, ""q:group"", node);
		 if(name == null) throw new ParseException(""Encountered a 'delete-trigger' command without a name specified."", -1);
		 triggersToDelete.add(new Key(name, group));
	 }
	 Boolean overWrite = getBoolean(xpath, ""/q:job-scheduling-data/q:processing-directives/q:overwrite-existing-data"", document);
	 if(overWrite == null) {
		 log.debug(""Directive 'overwrite-existing-data' not specified, defaulting to "" + isOverWriteExistingData());
	 }
	 else {
		 log.debug(""Directive 'overwrite-existing-data' specified as: "" + overWrite);
		 setOverWriteExistingData(overWrite);
	 }
	 Boolean ignoreDupes = getBoolean(xpath, ""/q:job-scheduling-data/q:processing-directives/q:ignore-duplicates"", document);
	 if(ignoreDupes == null) {
		 log.debug(""Directive 'ignore-duplicates' not specified, defaulting to "" + isIgnoreDuplicates());
	 }
	 else {
		 log.debug(""Directive 'ignore-duplicates' specified as: "" + ignoreDupes);
		 setIgnoreDuplicates(ignoreDupes);
	 }
	 NodeList jobNodes = (NodeList) xpath.evaluate(""/q:job-scheduling-data/q:schedule/q:job"", document, XPathConstants.NODESET);
	 log.debug(""Found "" + jobNodes.getLength() + "" job definitions."");
	 for (int i = 0;
	 i < jobNodes.getLength();
	 i++) {
		 Node jobDetailNode = jobNodes.item(i);
		 String t = null;
		 String jobName = getTrimmedToNullString(xpath, ""q:name"", jobDetailNode);
		 String jobGroup = getTrimmedToNullString(xpath, ""q:group"", jobDetailNode);
		 String jobDescription = getTrimmedToNullString(xpath, ""q:description"", jobDetailNode);
		 String jobClassName = getTrimmedToNullString(xpath, ""q:job-class"", jobDetailNode);
		 t = getTrimmedToNullString(xpath, ""q:volatility"", jobDetailNode);
		 boolean jobVolatility = (t != null) && t.equals(""true"");
		 t = getTrimmedToNullString(xpath, ""q:durability"", jobDetailNode);
		 boolean jobDurability = (t != null) && t.equals(""true"");
		 t = getTrimmedToNullString(xpath, ""q:recover"", jobDetailNode);
		 boolean jobRecoveryRequested = (t != null) && t.equals(""true"");
		 Class jobClass = classLoadHelper.loadClass(jobClassName);
		 JobDetail jobDetail = new JobDetail(jobName, jobGroup, jobClass, jobVolatility, jobDurability, jobRecoveryRequested);
		 jobDetail.setDescription(jobDescription);
		 NodeList jobListenerEntries = (NodeList) xpath.evaluate( ""q:job-listener-ref"", jobDetailNode, XPathConstants.NODESET);
		 for (int j = 0;
		 j < jobListenerEntries.getLength();
		 j++) {
			 Node listenerRefNode = jobListenerEntries.item(j);
			 String ref = listenerRefNode.getTextContent();
			 if(ref != null && (ref = ref.trim()).length() == 0) ref = null;
			 if(ref == null) continue;
			 jobDetail.addJobListener(ref);
		 }
		 NodeList jobDataEntries = (NodeList) xpath.evaluate( ""q:job-data-map/q:entry"", jobDetailNode, XPathConstants.NODESET);
		 for (int k = 0;
		 k < jobDataEntries.getLength();
		 k++) {
			 Node entryNode = jobDataEntries.item(k);
			 String key = getTrimmedToNullString(xpath, ""q:key"", entryNode);
			 String value = getTrimmedToNullString(xpath, ""q:value"", entryNode);
			 jobDetail.getJobDataMap().put(key, value);
		 }
		 if(log.isDebugEnabled()) log.debug(""Parsed job definition: "" + jobDetail);
		 addJobToSchedule(jobDetail);
	 }
	 NodeList triggerEntries = (NodeList) xpath.evaluate( ""/q:job-scheduling-data/q:schedule/q:trigger/*"", document, XPathConstants.NODESET);
	 log.debug(""Found "" + triggerEntries.getLength() + "" trigger definitions."");
	 for (int j = 0;
	 j < triggerEntries.getLength();
	 j++) {
		 Node triggerNode = triggerEntries.item(j);
		 String triggerName = getTrimmedToNullString(xpath, ""q:name"", triggerNode);
		 String triggerGroup = getTrimmedToNullString(xpath, ""q:group"", triggerNode);
		 String triggerDescription = getTrimmedToNullString(xpath, ""q:description"", triggerNode);
		 String triggerMisfireInstructionConst = getTrimmedToNullString(xpath, ""q:misfire-instruction"", triggerNode);
		 String triggerCalendarRef = getTrimmedToNullString(xpath, ""q:calendar-name"", triggerNode);
		 String triggerJobName = getTrimmedToNullString(xpath, ""q:job-name"", triggerNode);
		 String triggerJobGroup = getTrimmedToNullString(xpath, ""q:job-group"", triggerNode);
		 String t = getTrimmedToNullString(xpath, ""q:volatility"", triggerNode);
		 boolean triggerVolatility = (t != null) && t.equals(""true"");
		 String startTimeString = getTrimmedToNullString(xpath, ""q:start-time"", triggerNode);
		 String endTimeString = getTrimmedToNullString(xpath, ""q:end-time"", triggerNode);
		 Date triggerStartTime = startTimeString == null || startTimeString.length() == 0 ? new Date() : dateFormat.parse(startTimeString);
		 Date triggerEndTime = endTimeString == null || endTimeString.length() == 0 ? null : dateFormat.parse(endTimeString);
		 Trigger trigger = null;
		 if (triggerNode.getNodeName().equals(""simple"")) {
			 String repeatCountString = getTrimmedToNullString(xpath, ""q:repeat-count"", triggerNode);
			 String repeatIntervalString = getTrimmedToNullString(xpath, ""q:repeat-interval"", triggerNode);
			 int repeatCount = repeatCountString == null ? SimpleTrigger.REPEAT_INDEFINITELY : Integer.parseInt(repeatCountString);
			 long repeatInterval = repeatIntervalString == null ? 0 : Long.parseLong(repeatIntervalString);
			 trigger = new SimpleTrigger(triggerName, triggerGroup, triggerJobName, triggerJobGroup, triggerStartTime, triggerEndTime, repeatCount, repeatInterval);
		 }
		 else if (triggerNode.getNodeName().equals(""cron"")) {
			 String cronExpression = getTrimmedToNullString(xpath, ""q:cron-expression"", triggerNode);
			 String timezoneString = getTrimmedToNullString(xpath, ""q:time-zone"", triggerNode);
			 TimeZone tz = timezoneString == null ? null : TimeZone.getTimeZone(timezoneString);
			 trigger = new CronTrigger(triggerName, triggerGroup, triggerJobName, triggerJobGroup, triggerStartTime, triggerEndTime, cronExpression, tz);
		 }
		 else {
			 throw new ParseException(""Unknown trigger type: "" + triggerNode.getNodeName(), -1);
		 }
		 trigger.setVolatility(triggerVolatility);
		 trigger.setDescription(triggerDescription);
		 trigger.setCalendarName(triggerCalendarRef);
		 if (triggerMisfireInstructionConst != null && triggerMisfireInstructionConst.length() != 0) {
			 Class clazz = trigger.getClass();
			 java.lang.reflect.Field field;
			 try {
				 field = clazz.getField(triggerMisfireInstructionConst);
				 int misfireInst = field.getInt(trigger);
				 trigger.setMisfireInstruction(misfireInst);
			 }
			 catch (Exception e) {
				 throw new ParseException(""Unexpected/Unhandlable Misfire Instruction encountered '"" + triggerMisfireInstructionConst + ""', for trigger: "" + trigger.getFullName(), -1);
			 }
		 }
		 NodeList jobDataEntries = (NodeList) xpath.evaluate( ""q:job-data-map/q:entry"", triggerNode, XPathConstants.NODESET);
		 for (int k = 0;
		 k < jobDataEntries.getLength();
		 k++) {
			 Node entryNode = jobDataEntries.item(k);
			 String key = getTrimmedToNullString(xpath, ""q:key"", entryNode);
			 String value = getTrimmedToNullString(xpath, ""q:value"", entryNode);
			 trigger.getJobDataMap().put(key, value);
		 }
		 if(log.isDebugEnabled()) log.debug(""Parsed trigger definition: "" + trigger);
		 addTriggerToSchedule(trigger);
	 }
 }",0,0,1,0
"public void advertiseTokenRemoved(InetAddress endpoint, Token token) {
	 EndpointState epState = endpointStateMap.get(endpoint);
	 epState.updateTimestamp();
	 epState.getHeartBeatState().forceNewerGenerationUnsafe();
	 epState.addApplicationState(ApplicationState.STATUS, StorageService.instance.valueFactory.removedNonlocal(token,computeExpireTime()));
	 logger.info(""Completing removal of "" + endpoint);
	 endpointStateMap.put(endpoint, epState);
	 try {
		 Thread.sleep(intervalInMillis * 2);
	 }
	 catch (InterruptedException e) {
		 throw new AssertionError(e);
	 }
 }",0,0,0,0
"public class FTPTaskMirrorImpl implements FTPTaskMirror {
	 private static final int CODE_521 = 521;
	 private static final int CODE_550 = 550;
	 private static final int CODE_553 = 553;
	 private static final SimpleDateFormat TIMESTAMP_LOGGING_SDF = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private final FTPTask task;
	 private Set dirCache = new HashSet();
	 private int transferred = 0;
	 private int skipped = 0;
	 public FTPTaskMirrorImpl(FTPTask task) {
		 this.task = task;
	 }
	 protected static class FTPFileProxy extends File {
		 private final FTPFile file;
		 private final String[] parts;
		 private final String name;
		 public FTPFileProxy(FTPFile file) {
			 super(file.getName());
			 name = file.getName();
			 this.file = file;
			 parts = FileUtils.getPathStack(name);
		 }
		 public FTPFileProxy(String completePath) {
			 super(completePath);
			 file = null;
			 name = completePath;
			 parts = FileUtils.getPathStack(completePath);
		 }
		 public boolean exists() {
			 return true;
		 }
		 public String getAbsolutePath() {
			 return name;
		 }
		 public String getName() {
			 return parts.length > 0 ? parts[parts.length - 1] : name;
		 }
		 public String getParent() {
			 String result = """";
			 for(int i = 0;
			 i < parts.length - 1;
			 i++){
				 result += File.separatorChar + parts[i];
			 }
			 return result;
		 }
		 public String getPath() {
			 return name;
		 }
		 public boolean isAbsolute() {
			 return true;
		 }
		 public boolean isDirectory() {
			 return file == null;
		 }
		 public boolean isFile() {
			 return file != null;
		 }
		 public boolean isHidden() {
			 return false;
		 }
		 public long lastModified() {
			 if (file != null) {
				 return file.getTimestamp().getTimeInMillis();
			 }
			 return 0;
		 }
		 public long length() {
			 if (file != null) {
				 return file.getSize();
			 }
			 return 0;
		 }
	 }
	 protected class FTPDirectoryScanner extends DirectoryScanner {
		 protected FTPClient ftp = null;
		 private String rootPath = null;
		 private boolean remoteSystemCaseSensitive = false;
		 private boolean remoteSensitivityChecked = false;
		 public FTPDirectoryScanner(FTPClient ftp) {
			 super();
			 this.ftp = ftp;
			 this.setFollowSymlinks(false);
		 }
		 public void scan() {
			 if (includes == null) {
				 includes = new String[1];
				 includes[0] = ""**"";
			 }
			 if (excludes == null) {
				 excludes = new String[0];
			 }
			 filesIncluded = new VectorSet();
			 filesNotIncluded = new Vector();
			 filesExcluded = new VectorSet();
			 dirsIncluded = new VectorSet();
			 dirsNotIncluded = new Vector();
			 dirsExcluded = new VectorSet();
			 try {
				 String cwd = ftp.printWorkingDirectory();
				 forceRemoteSensitivityCheck();
				 checkIncludePatterns();
				 clearCaches();
				 ftp.changeWorkingDirectory(cwd);
			 }
			 catch (IOException e) {
				 throw new BuildException(""Unable to scan FTP server: "", e);
			 }
		 }
		 private void checkIncludePatterns() {
			 Hashtable newroots = new Hashtable();
			 for (int icounter = 0;
			 icounter < includes.length;
			 icounter++) {
				 String newpattern = SelectorUtils.rtrimWildcardTokens(includes[icounter]);
				 newroots.put(newpattern, includes[icounter]);
			 }
			 if (task.getRemotedir() == null) {
				 try {
					 task.setRemotedir(ftp.printWorkingDirectory());
				 }
				 catch (IOException e) {
					 throw new BuildException(""could not read current ftp directory"", task.getLocation());
				 }
			 }
			 AntFTPFile baseFTPFile = new AntFTPRootFile(ftp, task.getRemotedir());
			 rootPath = baseFTPFile.getAbsolutePath();
			 if (newroots.containsKey("""")) {
				 scandir(rootPath, """", true);
			 }
			 else {
				 Enumeration enum2 = newroots.keys();
				 while (enum2.hasMoreElements()) {
					 String currentelement = (String) enum2.nextElement();
					 String originalpattern = (String) newroots.get(currentelement);
					 AntFTPFile myfile = new AntFTPFile(baseFTPFile, currentelement);
					 boolean isOK = true;
					 boolean traversesSymlinks = false;
					 String path = null;
					 if (myfile.exists()) {
						 forceRemoteSensitivityCheck();
						 if (remoteSensitivityChecked && remoteSystemCaseSensitive && isFollowSymlinks()) {
							 path = myfile.getFastRelativePath();
						 }
						 else {
							 try {
								 path = myfile.getRelativePath();
								 traversesSymlinks = myfile.isTraverseSymlinks();
							 }
							 catch (IOException be) {
								 throw new BuildException(be, task.getLocation());
							 }
							 catch (BuildException be) {
								 isOK = false;
							 }
						 }
					 }
					 else {
						 isOK = false;
					 }
					 if (isOK) {
						 currentelement = path.replace(task.getSeparator().charAt(0), File.separatorChar);
						 if (!isFollowSymlinks() && traversesSymlinks) {
							 continue;
						 }
						 if (myfile.isDirectory()) {
							 if (isIncluded(currentelement) && currentelement.length() > 0) {
								 accountForIncludedDir(currentelement, myfile, true);
							 }
							 else {
								 if (currentelement.length() > 0) {
									 if (currentelement.charAt(currentelement .length() - 1) != File.separatorChar) {
										 currentelement = currentelement + File.separatorChar;
									 }
								 }
								 scandir(myfile.getAbsolutePath(), currentelement, true);
							 }
						 }
						 else {
							 if (isCaseSensitive && originalpattern.equals(currentelement)) {
								 accountForIncludedFile(currentelement);
							 }
							 else if (!isCaseSensitive && originalpattern .equalsIgnoreCase(currentelement)) {
								 accountForIncludedFile(currentelement);
							 }
						 }
					 }
				 }
			 }
		 }
		 protected void scandir(String dir, String vpath, boolean fast) {
			 if (fast && hasBeenScanned(vpath)) {
				 return;
			 }
			 try {
				 if (!ftp.changeWorkingDirectory(dir)) {
					 return;
				 }
				 String completePath = null;
				 if (!vpath.equals("""")) {
					 completePath = rootPath + task.getSeparator() + vpath.replace(File.separatorChar, task.getSeparator().charAt(0));
				 }
				 else {
					 completePath = rootPath;
				 }
				 FTPFile[] newfiles = listFiles(completePath, false);
				 if (newfiles == null) {
					 ftp.changeToParentDirectory();
					 return;
				 }
				 for (int i = 0;
				 i < newfiles.length;
				 i++) {
					 FTPFile file = newfiles[i];
					 if (file != null && !file.getName().equals(""."") && !file.getName().equals("".."")) {
						 String name = vpath + file.getName();
						 scannedDirs.put(name, new FTPFileProxy(file));
						 if (isFunctioningAsDirectory(ftp, dir, file)) {
							 boolean slowScanAllowed = true;
							 if (!isFollowSymlinks() && file.isSymbolicLink()) {
								 dirsExcluded.addElement(name);
								 slowScanAllowed = false;
							 }
							 else if (isIncluded(name)) {
								 accountForIncludedDir(name, new AntFTPFile(ftp, file, completePath) , fast);
							 }
							 else {
								 dirsNotIncluded.addElement(name);
								 if (fast && couldHoldIncluded(name)) {
									 scandir(file.getName(), name + File.separator, fast);
								 }
							 }
							 if (!fast && slowScanAllowed) {
								 scandir(file.getName(), name + File.separator, fast);
							 }
						 }
						 else {
							 if (!isFollowSymlinks() && file.isSymbolicLink()) {
								 filesExcluded.addElement(name);
							 }
							 else if (isFunctioningAsFile(ftp, dir, file)) {
								 accountForIncludedFile(name);
							 }
						 }
					 }
				 }
				 ftp.changeToParentDirectory();
			 }
			 catch (IOException e) {
				 throw new BuildException(""Error while communicating with FTP "" + ""server: "", e);
			 }
		 }
		 private void accountForIncludedFile(String name) {
			 if (!filesIncluded.contains(name) && !filesExcluded.contains(name)) {
				 if (isIncluded(name)) {
					 if (!isExcluded(name) && isSelected(name, (File) scannedDirs.get(name))) {
						 filesIncluded.addElement(name);
					 }
					 else {
						 filesExcluded.addElement(name);
					 }
				 }
				 else {
					 filesNotIncluded.addElement(name);
				 }
			 }
		 }
		 private void accountForIncludedDir(String name, AntFTPFile file, boolean fast) {
			 if (!dirsIncluded.contains(name) && !dirsExcluded.contains(name)) {
				 if (!isExcluded(name)) {
					 if (fast) {
						 if (file.isSymbolicLink()) {
							 try {
								 file.getClient().changeWorkingDirectory(file.curpwd);
							 }
							 catch (IOException ioe) {
								 throw new BuildException(""could not change directory to curpwd"");
							 }
							 scandir(file.getLink(), name + File.separator, fast);
						 }
						 else {
							 try {
								 file.getClient().changeWorkingDirectory(file.curpwd);
							 }
							 catch (IOException ioe) {
								 throw new BuildException(""could not change directory to curpwd"");
							 }
							 scandir(file.getName(), name + File.separator, fast);
						 }
					 }
					 dirsIncluded.addElement(name);
				 }
				 else {
					 dirsExcluded.addElement(name);
					 if (fast && couldHoldIncluded(name)) {
						 try {
							 file.getClient().changeWorkingDirectory(file.curpwd);
						 }
						 catch (IOException ioe) {
							 throw new BuildException(""could not change directory to curpwd"");
						 }
						 scandir(file.getName(), name + File.separator, fast);
					 }
				 }
			 }
		 }
		 private Map fileListMap = new HashMap();
		 private Map scannedDirs = new HashMap();
		 private boolean hasBeenScanned(String vpath) {
			 return scannedDirs.containsKey(vpath);
		 }
		 private void clearCaches() {
			 fileListMap.clear();
			 scannedDirs.clear();
		 }
		 public FTPFile[] listFiles(String directory, boolean changedir) {
			 String currentPath = directory;
			 if (changedir) {
				 try {
					 boolean result = ftp.changeWorkingDirectory(directory);
					 if (!result) {
						 return null;
					 }
					 currentPath = ftp.printWorkingDirectory();
				 }
				 catch (IOException ioe) {
					 throw new BuildException(ioe, task.getLocation());
				 }
			 }
			 if (fileListMap.containsKey(currentPath)) {
				 task.log(""filelist map used in listing files"", Project.MSG_DEBUG);
				 return ((FTPFile[]) fileListMap.get(currentPath));
			 }
			 FTPFile[] result = null;
			 try {
				 result = ftp.listFiles();
			 }
			 catch (IOException ioe) {
				 throw new BuildException(ioe, task.getLocation());
			 }
			 fileListMap.put(currentPath, result);
			 if (!remoteSensitivityChecked) {
				 checkRemoteSensitivity(result, directory);
			 }
			 return result;
		 }
		 private void forceRemoteSensitivityCheck() {
			 if (!remoteSensitivityChecked) {
				 try {
					 checkRemoteSensitivity(ftp.listFiles(), ftp.printWorkingDirectory());
				 }
				 catch (IOException ioe) {
					 throw new BuildException(ioe, task.getLocation());
				 }
			 }
		 }
		 public FTPFile[] listFiles(String directory) {
			 return listFiles(directory, true);
		 }
		 private void checkRemoteSensitivity(FTPFile[] array, String directory) {
			 if (array == null) {
				 return;
			 }
			 boolean candidateFound = false;
			 String target = null;
			 for (int icounter = 0;
			 icounter < array.length;
			 icounter++) {
				 if (array[icounter] != null && array[icounter].isDirectory()) {
					 if (!array[icounter].getName().equals(""."") && !array[icounter].getName().equals("".."")) {
						 candidateFound = true;
						 target = fiddleName(array[icounter].getName());
						 task.log(""will try to cd to "" + target + "" where a directory called "" + array[icounter].getName() + "" exists"", Project.MSG_DEBUG);
						 for (int pcounter = 0;
						 pcounter < array.length;
						 pcounter++) {
							 if (array[pcounter] != null && pcounter != icounter && target.equals(array[pcounter].getName())) {
								 candidateFound = false;
							 }
						 }
						 if (candidateFound) {
							 break;
						 }
					 }
				 }
			 }
			 if (candidateFound) {
				 try {
					 task.log(""testing case sensitivity, attempting to cd to "" + target, Project.MSG_DEBUG);
					 remoteSystemCaseSensitive = !ftp.changeWorkingDirectory(target);
				 }
				 catch (IOException ioe) {
					 remoteSystemCaseSensitive = true;
				 }
				 finally {
					 try {
						 ftp.changeWorkingDirectory(directory);
					 }
					 catch (IOException ioe) {
						 throw new BuildException(ioe, task.getLocation());
					 }
				 }
				 task.log(""remote system is case sensitive : "" + remoteSystemCaseSensitive, Project.MSG_VERBOSE);
				 remoteSensitivityChecked = true;
			 }
		 }
		 private String fiddleName(String origin) {
			 StringBuffer result = new StringBuffer();
			 for (int icounter = 0;
			 icounter < origin.length();
			 icounter++) {
				 if (Character.isLowerCase(origin.charAt(icounter))) {
					 result.append(Character.toUpperCase(origin.charAt(icounter)));
				 }
				 else if (Character.isUpperCase(origin.charAt(icounter))) {
					 result.append(Character.toLowerCase(origin.charAt(icounter)));
				 }
				 else {
					 result.append(origin.charAt(icounter));
				 }
			 }
			 return result.toString();
		 }
		 protected class AntFTPFile {
			 private FTPClient client;
			 private String curpwd;
			 private FTPFile ftpFile;
			 private AntFTPFile parent = null;
			 private boolean relativePathCalculated = false;
			 private boolean traversesSymlinks = false;
			 private String relativePath = """";
			 public AntFTPFile(FTPClient client, FTPFile ftpFile, String curpwd) {
				 this.client = client;
				 this.ftpFile = ftpFile;
				 this.curpwd = curpwd;
			 }
			 public AntFTPFile(AntFTPFile parent, String path) {
				 this.parent = parent;
				 this.client = parent.client;
				 Vector pathElements = SelectorUtils.tokenizePath(path);
				 try {
					 boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath());
					 if (!result) {
						 return;
					 }
					 this.curpwd = parent.getAbsolutePath();
				 }
				 catch (IOException ioe) {
					 throw new BuildException(""could not change working dir to "" + parent.curpwd);
				 }
				 final int size = pathElements.size();
				 for (int fcount = 0;
				 fcount < size - 1;
				 fcount++) {
					 String currentPathElement = (String) pathElements.elementAt(fcount);
					 try {
						 boolean result = this.client.changeWorkingDirectory(currentPathElement);
						 if (!result && !isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) {
							 currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement);
							 if (currentPathElement == null) {
								 return;
							 }
						 }
						 else if (!result) {
							 return;
						 }
						 this.curpwd = getCurpwdPlusFileSep() + currentPathElement;
					 }
					 catch (IOException ioe) {
						 throw new BuildException(""could not change working dir to "" + (String) pathElements.elementAt(fcount) + "" from "" + this.curpwd);
					 }
				 }
				 String lastpathelement = (String) pathElements.elementAt(size - 1);
				 FTPFile [] theFiles = listFiles(this.curpwd);
				 this.ftpFile = getFile(theFiles, lastpathelement);
			 }
			 private String findPathElementCaseUnsensitive(String parentPath, String soughtPathElement) {
				 FTPFile[] theFiles = listFiles(parentPath, false);
				 if (theFiles == null) {
					 return null;
				 }
				 for (int icounter = 0;
				 icounter < theFiles.length;
				 icounter++) {
					 if (theFiles[icounter] != null && theFiles[icounter].getName().equalsIgnoreCase(soughtPathElement)) {
						 return theFiles[icounter].getName();
					 }
				 }
				 return null;
			 }
			 public boolean exists() {
				 return (ftpFile != null);
			 }
			 public String getLink() {
				 return ftpFile.getLink();
			 }
			 public String getName() {
				 return ftpFile.getName();
			 }
			 public String getAbsolutePath() {
				 return getCurpwdPlusFileSep() + ftpFile.getName();
			 }
			 public String getFastRelativePath() {
				 String absPath = getAbsolutePath();
				 if (absPath.indexOf(rootPath + task.getSeparator()) == 0) {
					 return absPath.substring(rootPath.length() + task.getSeparator().length());
				 }
				 return null;
			 }
			 public String getRelativePath() throws IOException, BuildException {
				 if (!relativePathCalculated) {
					 if (parent != null) {
						 traversesSymlinks = parent.isTraverseSymlinks();
						 relativePath = getRelativePath(parent.getAbsolutePath(), parent.getRelativePath());
					 }
					 else {
						 relativePath = getRelativePath(rootPath, """");
						 relativePathCalculated = true;
					 }
				 }
				 return relativePath;
			 }
			 private String getRelativePath(String currentPath, String currentRelativePath) {
				 Vector pathElements = SelectorUtils.tokenizePath(getAbsolutePath(), task.getSeparator());
				 Vector pathElements2 = SelectorUtils.tokenizePath(currentPath, task.getSeparator());
				 String relPath = currentRelativePath;
				 final int size = pathElements.size();
				 for (int pcount = pathElements2.size();
				 pcount < size;
				 pcount++) {
					 String currentElement = (String) pathElements.elementAt(pcount);
					 FTPFile[] theFiles = listFiles(currentPath);
					 FTPFile theFile = null;
					 if (theFiles != null) {
						 theFile = getFile(theFiles, currentElement);
					 }
					 if (!relPath.equals("""")) {
						 relPath = relPath + task.getSeparator();
					 }
					 if (theFile == null) {
						 relPath = relPath + currentElement;
						 currentPath = currentPath + task.getSeparator() + currentElement;
						 task.log(""Hidden file "" + relPath + "" assumed to not be a symlink."", Project.MSG_VERBOSE);
					 }
					 else {
						 traversesSymlinks = traversesSymlinks || theFile.isSymbolicLink();
						 relPath = relPath + theFile.getName();
						 currentPath = currentPath + task.getSeparator() + theFile.getName();
					 }
				 }
				 return relPath;
			 }
			 public FTPFile getFile(FTPFile[] theFiles, String lastpathelement) {
				 if (theFiles == null) {
					 return null;
				 }
				 for (int fcount = 0;
				 fcount < theFiles.length;
				 fcount++) {
					 if (theFiles[fcount] != null) {
						 if (theFiles[fcount].getName().equals(lastpathelement)) {
							 return theFiles[fcount];
						 }
						 else if (!isCaseSensitive() && theFiles[fcount].getName().equalsIgnoreCase( lastpathelement)) {
							 return theFiles[fcount];
						 }
					 }
				 }
				 return null;
			 }
			 public boolean isDirectory() {
				 return ftpFile.isDirectory();
			 }
			 public boolean isSymbolicLink() {
				 return ftpFile.isSymbolicLink();
			 }
			 protected FTPClient getClient() {
				 return client;
			 }
			 protected void setCurpwd(String curpwd) {
				 this.curpwd = curpwd;
			 }
			 public String getCurpwd() {
				 return curpwd;
			 }
			 public String getCurpwdPlusFileSep() {
				 String sep = task.getSeparator();
				 return curpwd.endsWith(sep) ? curpwd : curpwd + sep;
			 }
			 public boolean isTraverseSymlinks() throws IOException, BuildException {
				 if (!relativePathCalculated) {
					 getRelativePath();
				 }
				 return traversesSymlinks;
			 }
			 public String toString() {
				 return ""AntFtpFile: "" + curpwd + ""%"" + ftpFile;
			 }
		 }
		 protected class AntFTPRootFile extends AntFTPFile {
			 private String remotedir;
			 public AntFTPRootFile(FTPClient aclient, String remotedir) {
				 super(aclient, null, remotedir);
				 this.remotedir = remotedir;
				 try {
					 this.getClient().changeWorkingDirectory(this.remotedir);
					 this.setCurpwd(this.getClient().printWorkingDirectory());
				 }
				 catch (IOException ioe) {
					 throw new BuildException(ioe, task.getLocation());
				 }
			 }
			 public String getAbsolutePath() {
				 return this.getCurpwd();
			 }
			 public String getRelativePath() throws BuildException, IOException {
				 return """";
			 }
		 }
	 }
	 private boolean isFunctioningAsDirectory(FTPClient ftp, String dir, FTPFile file) {
		 boolean result = false;
		 String currentWorkingDir = null;
		 if (file.isDirectory()) {
			 return true;
		 }
		 else if (file.isFile()) {
			 return false;
		 }
		 try {
			 currentWorkingDir = ftp.printWorkingDirectory();
		 }
		 catch (IOException ioe) {
			 task.log(""could not find current working directory "" + dir + "" while checking a symlink"", Project.MSG_DEBUG);
		 }
		 if (currentWorkingDir != null) {
			 try {
				 result = ftp.changeWorkingDirectory(file.getLink());
			 }
			 catch (IOException ioe) {
				 task.log(""could not cd to "" + file.getLink() + "" while checking a symlink"", Project.MSG_DEBUG);
			 }
			 if (result) {
				 boolean comeback = false;
				 try {
					 comeback = ftp.changeWorkingDirectory(currentWorkingDir);
				 }
				 catch (IOException ioe) {
					 task.log(""could not cd back to "" + dir + "" while checking a symlink"", Project.MSG_ERR);
				 }
				 finally {
					 if (!comeback) {
						 throw new BuildException(""could not cd back to "" + dir + "" while checking a symlink"");
					 }
				 }
			 }
		 }
		 return result;
	 }
	 private boolean isFunctioningAsFile(FTPClient ftp, String dir, FTPFile file) {
		 if (file.isDirectory()) {
			 return false;
		 }
		 else if (file.isFile()) {
			 return true;
		 }
		 return !isFunctioningAsDirectory(ftp, dir, file);
	 }
	 protected void executeRetryable(RetryHandler h, Retryable r, String descr) throws IOException {
		 h.execute(r, descr);
	 }
	 protected int transferFiles(final FTPClient ftp, FileSet fs) throws IOException, BuildException {
		 DirectoryScanner ds;
		 if (task.getAction() == FTPTask.SEND_FILES) {
			 ds = fs.getDirectoryScanner(task.getProject());
		 }
		 else {
			 ds = new FTPDirectoryScanner(ftp);
			 fs.setupDirectoryScanner(ds, task.getProject());
			 ds.setFollowSymlinks(fs.isFollowSymlinks());
			 ds.scan();
		 }
		 String[] dsfiles = null;
		 if (task.getAction() == FTPTask.RM_DIR) {
			 dsfiles = ds.getIncludedDirectories();
		 }
		 else {
			 dsfiles = ds.getIncludedFiles();
		 }
		 String dir = null;
		 if ((ds.getBasedir() == null) && ((task.getAction() == FTPTask.SEND_FILES) || (task.getAction() == FTPTask.GET_FILES))) {
			 throw new BuildException(""the dir attribute must be set for send "" + ""and get actions"");
		 }
		 else {
			 if ((task.getAction() == FTPTask.SEND_FILES) || (task.getAction() == FTPTask.GET_FILES)) {
				 dir = ds.getBasedir().getAbsolutePath();
			 }
		 }
		 BufferedWriter bw = null;
		 try {
			 if (task.getAction() == FTPTask.LIST_FILES) {
				 File pd = task.getListing().getParentFile();
				 if (!pd.exists()) {
					 pd.mkdirs();
				 }
				 bw = new BufferedWriter(new FileWriter(task.getListing()));
			 }
			 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
			 if (task.getAction() == FTPTask.RM_DIR) {
				 for (int i = dsfiles.length - 1;
				 i >= 0;
				 i--) {
					 final String dsfile = dsfiles[i];
					 executeRetryable(h, new Retryable() {
						 public void execute() throws IOException {
							 rmDir(ftp, dsfile);
						 }
					 }
					, dsfile);
				 }
			 }
			 else {
				 final BufferedWriter fbw = bw;
				 final String fdir = dir;
				 if (task.isNewer()) {
					 task.setGranularityMillis(task.getTimestampGranularity() .getMilliseconds(task.getAction()));
				 }
				 for (int i = 0;
				 i < dsfiles.length;
				 i++) {
					 final String dsfile = dsfiles[i];
					 executeRetryable(h, new Retryable() {
						 public void execute() throws IOException {
							 switch (task.getAction()) {
								 case FTPTask.SEND_FILES: sendFile(ftp, fdir, dsfile);
								 break;
								 case FTPTask.GET_FILES: getFile(ftp, fdir, dsfile);
								 break;
								 case FTPTask.DEL_FILES: delFile(ftp, dsfile);
								 break;
								 case FTPTask.LIST_FILES: listFile(ftp, fbw, dsfile);
								 break;
								 case FTPTask.CHMOD: doSiteCommand(ftp, ""chmod "" + task.getChmod() + "" "" + resolveFile(dsfile));
								 transferred++;
								 break;
								 default: throw new BuildException(""unknown ftp action "" + task.getAction());
							 }
						 }
					 }
					, dsfile);
				 }
			 }
		 }
		 finally {
			 if (bw != null) {
				 bw.close();
			 }
		 }
		 return dsfiles.length;
	 }
	 protected void transferFiles(FTPClient ftp) throws IOException, BuildException {
		 transferred = 0;
		 skipped = 0;
		 if (task.getFilesets().size() == 0) {
			 throw new BuildException(""at least one fileset must be specified."");
		 }
		 else {
			 final int size = task.getFilesets().size();
			 for (int i = 0;
			 i < size;
			 i++) {
				 FileSet fs = (FileSet) task.getFilesets().elementAt(i);
				 if (fs != null) {
					 transferFiles(ftp, fs);
				 }
			 }
		 }
		 task.log(transferred + "" "" + FTPTask.ACTION_TARGET_STRS[task.getAction()] + "" "" + FTPTask.COMPLETED_ACTION_STRS[task.getAction()]);
		 if (skipped != 0) {
			 task.log(skipped + "" "" + FTPTask.ACTION_TARGET_STRS[task.getAction()] + "" were not successfully "" + FTPTask.COMPLETED_ACTION_STRS[task.getAction()]);
		 }
	 }
	 protected String resolveFile(String file) {
		 return file.replace(System.getProperty(""file.separator"").charAt(0), task.getSeparator().charAt(0));
	 }
	 protected void createParents(FTPClient ftp, String filename) throws IOException, BuildException {
		 File dir = new File(filename);
		 if (dirCache.contains(dir)) {
			 return;
		 }
		 Vector parents = new Vector();
		 String dirname;
		 while ((dirname = dir.getParent()) != null) {
			 File checkDir = new File(dirname);
			 if (dirCache.contains(checkDir)) {
				 break;
			 }
			 dir = checkDir;
			 parents.addElement(dir);
		 }
		 int i = parents.size() - 1;
		 if (i >= 0) {
			 String cwd = ftp.printWorkingDirectory();
			 String parent = dir.getParent();
			 if (parent != null) {
				 if (!ftp.changeWorkingDirectory(resolveFile(parent))) {
					 throw new BuildException(""could not change to "" + ""directory: "" + ftp.getReplyString());
				 }
			 }
			 while (i >= 0) {
				 dir = (File) parents.elementAt(i--);
				 if (!ftp.changeWorkingDirectory(dir.getName())) {
					 task.log(""creating remote directory "" + resolveFile(dir.getPath()), Project.MSG_VERBOSE);
					 if (!ftp.makeDirectory(dir.getName())) {
						 handleMkDirFailure(ftp);
					 }
					 if (!ftp.changeWorkingDirectory(dir.getName())) {
						 throw new BuildException(""could not change to "" + ""directory: "" + ftp.getReplyString());
					 }
				 }
				 dirCache.add(dir);
			 }
			 ftp.changeWorkingDirectory(cwd);
		 }
	 }
	 private long getTimeDiff(FTPClient ftp) {
		 long returnValue = 0;
		 File tempFile = findFileName(ftp);
		 try {
			 FILE_UTILS.createNewFile(tempFile);
			 long localTimeStamp = tempFile.lastModified();
			 BufferedInputStream instream = new BufferedInputStream(new FileInputStream(tempFile));
			 ftp.storeFile(tempFile.getName(), instream);
			 instream.close();
			 boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
			 if (success) {
				 FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName());
				 if (ftpFiles.length == 1) {
					 long remoteTimeStamp = ftpFiles[0].getTimestamp().getTime().getTime();
					 returnValue = localTimeStamp - remoteTimeStamp;
				 }
				 ftp.deleteFile(ftpFiles[0].getName());
			 }
			 Delete mydelete = new Delete();
			 mydelete.bindToOwner(task);
			 mydelete.setFile(tempFile.getCanonicalFile());
			 mydelete.execute();
		 }
		 catch (Exception e) {
			 throw new BuildException(e, task.getLocation());
		 }
		 return returnValue;
	 }
	 private File findFileName(FTPClient ftp) {
		 FTPFile [] theFiles = null;
		 final int maxIterations = 1000;
		 for (int counter = 1;
		 counter < maxIterations;
		 counter++) {
			 File localFile = FILE_UTILS.createTempFile( ""ant"" + Integer.toString(counter), "".tmp"", null, false, false);
			 String fileName = localFile.getName();
			 boolean found = false;
			 try {
				 if (theFiles == null) {
					 theFiles = ftp.listFiles();
				 }
				 for (int counter2 = 0;
				 counter2 < theFiles.length;
				 counter2++) {
					 if (theFiles[counter2] != null && theFiles[counter2].getName().equals(fileName)) {
						 found = true;
						 break;
					 }
				 }
			 }
			 catch (IOException ioe) {
				 throw new BuildException(ioe, task.getLocation());
			 }
			 if (!found) {
				 localFile.deleteOnExit();
				 return localFile;
			 }
		 }
		 return null;
	 }
	 protected boolean isUpToDate(FTPClient ftp, File localFile, String remoteFile) throws IOException, BuildException {
		 task.log(""checking date for "" + remoteFile, Project.MSG_VERBOSE);
		 FTPFile[] files = ftp.listFiles(remoteFile);
		 if (files == null || files.length == 0) {
			 if (task.getAction() == FTPTask.SEND_FILES) {
				 task.log(""Could not date test remote file: "" + remoteFile + ""assuming out of date."", Project.MSG_VERBOSE);
				 return false;
			 }
			 else {
				 throw new BuildException(""could not date test remote file: "" + ftp.getReplyString());
			 }
		 }
		 long remoteTimestamp = files[0].getTimestamp().getTime().getTime();
		 long localTimestamp = localFile.lastModified();
		 long adjustedRemoteTimestamp = remoteTimestamp + task.getTimeDiffMillis() + task.getGranularityMillis();
		 StringBuffer msg;
		 synchronized(TIMESTAMP_LOGGING_SDF) {
			 msg = new StringBuffer("" ["") .append(TIMESTAMP_LOGGING_SDF.format(new Date(localTimestamp))) .append(""] local"");
		 }
		 task.log(msg.toString(), Project.MSG_VERBOSE);
		 synchronized(TIMESTAMP_LOGGING_SDF) {
			 msg = new StringBuffer("" ["") .append(TIMESTAMP_LOGGING_SDF.format(new Date(adjustedRemoteTimestamp))) .append(""] remote"");
		 }
		 if (remoteTimestamp != adjustedRemoteTimestamp) {
			 synchronized(TIMESTAMP_LOGGING_SDF) {
				 msg.append("" - (raw: "") .append(TIMESTAMP_LOGGING_SDF.format(new Date(remoteTimestamp))) .append("")"");
			 }
		 }
		 task.log(msg.toString(), Project.MSG_VERBOSE);
		 if (task.getAction() == FTPTask.SEND_FILES) {
			 return adjustedRemoteTimestamp >= localTimestamp;
		 }
		 else {
			 return localTimestamp >= adjustedRemoteTimestamp;
		 }
	 }
	 protected void doSiteCommand(FTPClient ftp, String theCMD) throws IOException, BuildException {
		 boolean rc;
		 String[] myReply = null;
		 task.log(""Doing Site Command: "" + theCMD, Project.MSG_VERBOSE);
		 rc = ftp.sendSiteCommand(theCMD);
		 if (!rc) {
			 task.log(""Failed to issue Site Command: "" + theCMD, Project.MSG_WARN);
		 }
		 else {
			 myReply = ftp.getReplyStrings();
			 for (int x = 0;
			 x < myReply.length;
			 x++) {
				 if (myReply[x].indexOf(""200"") == -1) {
					 task.log(myReply[x], Project.MSG_WARN);
				 }
			 }
		 }
	 }
	 protected void sendFile(FTPClient ftp, String dir, String filename) throws IOException, BuildException {
		 InputStream instream = null;
		 try {
			 File file = task.getProject().resolveFile(new File(dir, filename).getPath());
			 if (task.isNewer() && isUpToDate(ftp, file, resolveFile(filename))) {
				 return;
			 }
			 if (task.isVerbose()) {
				 task.log(""transferring "" + file.getAbsolutePath());
			 }
			 instream = new BufferedInputStream(new FileInputStream(file));
			 createParents(ftp, filename);
			 ftp.storeFile(resolveFile(filename), instream);
			 boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
			 if (!success) {
				 String s = ""could not put file: "" + ftp.getReplyString();
				 if (task.isSkipFailedTransfers()) {
					 task.log(s, Project.MSG_WARN);
					 skipped++;
				 }
				 else {
					 throw new BuildException(s);
				 }
			 }
			 else {
				 if (task.getChmod() != null) {
					 doSiteCommand(ftp, ""chmod "" + task.getChmod() + "" "" + resolveFile(filename));
				 }
				 task.log(""File "" + file.getAbsolutePath() + "" copied to "" + task.getServer(), Project.MSG_VERBOSE);
				 transferred++;
			 }
		 }
		 finally {
			 if (instream != null) {
				 try {
					 instream.close();
				 }
				 catch (IOException ex) {
				 }
			 }
		 }
	 }
	 protected void delFile(FTPClient ftp, String filename) throws IOException, BuildException {
		 if (task.isVerbose()) {
			 task.log(""deleting "" + filename);
		 }
		 if (!ftp.deleteFile(resolveFile(filename))) {
			 String s = ""could not delete file: "" + ftp.getReplyString();
			 if (task.isSkipFailedTransfers()) {
				 task.log(s, Project.MSG_WARN);
				 skipped++;
			 }
			 else {
				 throw new BuildException(s);
			 }
		 }
		 else {
			 task.log(""File "" + filename + "" deleted from "" + task.getServer(), Project.MSG_VERBOSE);
			 transferred++;
		 }
	 }
	 protected void rmDir(FTPClient ftp, String dirname) throws IOException, BuildException {
		 if (task.isVerbose()) {
			 task.log(""removing "" + dirname);
		 }
		 if (!ftp.removeDirectory(resolveFile(dirname))) {
			 String s = ""could not remove directory: "" + ftp.getReplyString();
			 if (task.isSkipFailedTransfers()) {
				 task.log(s, Project.MSG_WARN);
				 skipped++;
			 }
			 else {
				 throw new BuildException(s);
			 }
		 }
		 else {
			 task.log(""Directory "" + dirname + "" removed from "" + task.getServer(), Project.MSG_VERBOSE);
			 transferred++;
		 }
	 }
	 protected void getFile(FTPClient ftp, String dir, String filename) throws IOException, BuildException {
		 OutputStream outstream = null;
		 try {
			 File file = task.getProject().resolveFile(new File(dir, filename).getPath());
			 if (task.isNewer() && isUpToDate(ftp, file, resolveFile(filename))) {
				 return;
			 }
			 if (task.isVerbose()) {
				 task.log(""transferring "" + filename + "" to "" + file.getAbsolutePath());
			 }
			 File pdir = file.getParentFile();
			 if (!pdir.exists()) {
				 pdir.mkdirs();
			 }
			 outstream = new BufferedOutputStream(new FileOutputStream(file));
			 ftp.retrieveFile(resolveFile(filename), outstream);
			 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
				 String s = ""could not get file: "" + ftp.getReplyString();
				 if (task.isSkipFailedTransfers()) {
					 task.log(s, Project.MSG_WARN);
					 skipped++;
				 }
				 else {
					 throw new BuildException(s);
				 }
			 }
			 else {
				 task.log( ""File "" + file.getAbsolutePath() + "" copied from "" + task.getServer(), Project.MSG_VERBOSE);
				 transferred++;
				 if (task.isPreserveLastModified()) {
					 outstream.close();
					 outstream = null;
					 FTPFile[] remote = ftp.listFiles(resolveFile(filename));
					 if (remote.length > 0) {
						 FILE_UTILS.setFileLastModified(file, remote[0].getTimestamp() .getTime().getTime());
					 }
				 }
			 }
		 }
		 finally {
			 if (outstream != null) {
				 try {
					 outstream.close();
				 }
				 catch (IOException ex) {
				 }
			 }
		 }
	 }
	 protected void listFile(FTPClient ftp, BufferedWriter bw, String filename) throws IOException, BuildException {
		 if (task.isVerbose()) {
			 task.log(""listing "" + filename);
		 }
		 FTPFile[] ftpfiles = ftp.listFiles(resolveFile(filename));
		 if (ftpfiles != null && ftpfiles.length > 0) {
			 bw.write(ftpfiles[0].toString());
			 bw.newLine();
			 transferred++;
		 }
	 }
	 protected void makeRemoteDir(FTPClient ftp, String dir) throws IOException, BuildException {
		 String workingDirectory = ftp.printWorkingDirectory();
		 if (task.isVerbose()) {
			 if (dir.indexOf(""/"") == 0 || workingDirectory == null) {
				 task.log(""Creating directory: "" + dir + "" in /"");
			 }
			 else {
				 task.log(""Creating directory: "" + dir + "" in "" + workingDirectory);
			 }
		 }
		 if (dir.indexOf(""/"") == 0) {
			 ftp.changeWorkingDirectory(""/"");
		 }
		 String subdir = """";
		 StringTokenizer st = new StringTokenizer(dir, ""/"");
		 while (st.hasMoreTokens()) {
			 subdir = st.nextToken();
			 task.log(""Checking "" + subdir, Project.MSG_DEBUG);
			 if (!ftp.changeWorkingDirectory(subdir)) {
				 if (!ftp.makeDirectory(subdir)) {
					 int rc = ftp.getReplyCode();
					 if (!(task.isIgnoreNoncriticalErrors() && (rc == CODE_550 || rc == CODE_553 || rc == CODE_521))) {
						 throw new BuildException(""could not create directory: "" + ftp.getReplyString());
					 }
					 if (task.isVerbose()) {
						 task.log(""Directory already exists"");
					 }
				 }
				 else {
					 if (task.isVerbose()) {
						 task.log(""Directory created OK"");
					 }
					 ftp.changeWorkingDirectory(subdir);
				 }
			 }
		 }
		 if (workingDirectory != null) {
			 ftp.changeWorkingDirectory(workingDirectory);
		 }
	 }
	 private void handleMkDirFailure(FTPClient ftp) throws BuildException {
		 int rc = ftp.getReplyCode();
		 if (!(task.isIgnoreNoncriticalErrors() && (rc == CODE_550 || rc == CODE_553 || rc == CODE_521))) {
			 throw new BuildException(""could not create directory: "" + ftp.getReplyString());
		 }
	 }
	 public void doFTP() throws BuildException {
		 FTPClient ftp = null;
		 try {
			 task.log(""Opening FTP connection to "" + task.getServer(), Project.MSG_VERBOSE);
			 ftp = new FTPClient();
			 if (task.isConfigurationSet()) {
				 ftp = FTPConfigurator.configure(ftp, task);
			 }
			 ftp.setRemoteVerificationEnabled(task.getEnableRemoteVerification());
			 ftp.connect(task.getServer(), task.getPort());
			 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
				 throw new BuildException(""FTP connection failed: "" + ftp.getReplyString());
			 }
			 task.log(""connected"", Project.MSG_VERBOSE);
			 task.log(""logging in to FTP server"", Project.MSG_VERBOSE);
			 if ((task.getAccount() != null && !ftp.login(task.getUserid(), task.getPassword(), task.getAccount())) || (task.getAccount() == null && !ftp.login(task.getUserid(), task.getPassword()))) {
				 throw new BuildException(""Could not login to FTP server"");
			 }
			 task.log(""login succeeded"", Project.MSG_VERBOSE);
			 if (task.isBinary()) {
				 ftp.setFileType(org.apache.commons.net.ftp.FTP.BINARY_FILE_TYPE);
				 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
					 throw new BuildException(""could not set transfer type: "" + ftp.getReplyString());
				 }
			 }
			 else {
				 ftp.setFileType(org.apache.commons.net.ftp.FTP.ASCII_FILE_TYPE);
				 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
					 throw new BuildException(""could not set transfer type: "" + ftp.getReplyString());
				 }
			 }
			 if (task.isPassive()) {
				 task.log(""entering passive mode"", Project.MSG_VERBOSE);
				 ftp.enterLocalPassiveMode();
				 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
					 throw new BuildException(""could not enter into passive "" + ""mode: "" + ftp.getReplyString());
				 }
			 }
			 if (task.getInitialSiteCommand() != null) {
				 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
				 final FTPClient lftp = ftp;
				 executeRetryable(h, new Retryable() {
					 public void execute() throws IOException {
						 doSiteCommand(lftp, task.getInitialSiteCommand());
					 }
				 }
				, ""initial site command: "" + task.getInitialSiteCommand());
			 }
			 if (task.getUmask() != null) {
				 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
				 final FTPClient lftp = ftp;
				 executeRetryable(h, new Retryable() {
					 public void execute() throws IOException {
						 doSiteCommand(lftp, ""umask "" + task.getUmask());
					 }
				 }
				, ""umask "" + task.getUmask());
			 }
			 if (task.getAction() == FTPTask.MK_DIR) {
				 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
				 final FTPClient lftp = ftp;
				 executeRetryable(h, new Retryable() {
					 public void execute() throws IOException {
						 makeRemoteDir(lftp, task.getRemotedir());
					 }
				 }
				, task.getRemotedir());
			 }
			 else if (task.getAction() == FTPTask.SITE_CMD) {
				 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
				 final FTPClient lftp = ftp;
				 executeRetryable(h, new Retryable() {
					 public void execute() throws IOException {
						 doSiteCommand(lftp, task.getSiteCommand());
					 }
				 }
				, ""Site Command: "" + task.getSiteCommand());
			 }
			 else {
				 if (task.getRemotedir() != null) {
					 task.log(""changing the remote directory"", Project.MSG_VERBOSE);
					 ftp.changeWorkingDirectory(task.getRemotedir());
					 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
						 throw new BuildException(""could not change remote "" + ""directory: "" + ftp.getReplyString());
					 }
				 }
				 if (task.isNewer() && task.isTimeDiffAuto()) {
					 task.setTimeDiffMillis(getTimeDiff(ftp));
				 }
				 task.log(FTPTask.ACTION_STRS[task.getAction()] + "" "" + FTPTask.ACTION_TARGET_STRS[task.getAction()]);
				 transferFiles(ftp);
			 }
		 }
		 catch (IOException ex) {
			 throw new BuildException(""error during FTP transfer: "" + ex, ex);
		 }
		 finally {
			 if (ftp != null && ftp.isConnected()) {
				 try {
					 task.log(""disconnecting"", Project.MSG_VERBOSE);
					 ftp.logout();
					 ftp.disconnect();
				 }
				 catch (IOException ex) {
				 }
			 }
		 }
	 }
}",1,0,0,0
"public static void configureClient(HttpClient httpClient, String url) throws DavMailException {
	 setClientHost(httpClient, url);
	 if (Settings.getBooleanProperty(""davmail.enableKerberos"", false)) {
		 AuthPolicy.registerAuthScheme(""Negotiate"", SpNegoScheme.class);
		 ArrayList<String> authPrefs = new ArrayList<String>();
		 authPrefs.add(""Negotiate"");
		 httpClient.getParams().setParameter(AuthPolicy.AUTH_SCHEME_PRIORITY, authPrefs);
	 }
	 else if (!needNTLM) {
		 ArrayList<String> authPrefs = new ArrayList<String>();
		 authPrefs.add(AuthPolicy.DIGEST);
		 authPrefs.add(AuthPolicy.BASIC);
		 httpClient.getParams().setParameter(AuthPolicy.AUTH_SCHEME_PRIORITY, authPrefs);
	 }
	 boolean enableProxy = Settings.getBooleanProperty(""davmail.enableProxy"");
	 boolean useSystemProxies = Settings.getBooleanProperty(""davmail.useSystemProxies"", Boolean.FALSE);
	 String proxyHost = null;
	 int proxyPort = 0;
	 String proxyUser = null;
	 String proxyPassword = null;
	 try {
		 java.net.URI uri = new java.net.URI(url);
		 if (isNoProxyFor(uri)) {
			 LOGGER.debug(""no proxy for "" + uri.getHost());
		 }
		 else if (useSystemProxies) {
			 System.setProperty(""java.net.useSystemProxies"", ""true"");
			 List<Proxy> proxyList = getProxyForURI(uri);
			 if (!proxyList.isEmpty() && proxyList.get(0).address() != null) {
				 InetSocketAddress inetSocketAddress = (InetSocketAddress) proxyList.get(0).address();
				 proxyHost = inetSocketAddress.getHostName();
				 proxyPort = inetSocketAddress.getPort();
				 proxyUser = Settings.getProperty(""davmail.proxyUser"");
				 proxyPassword = Settings.getProperty(""davmail.proxyPassword"");
			 }
		 }
		 else if (enableProxy) {
			 proxyHost = Settings.getProperty(""davmail.proxyHost"");
			 proxyPort = Settings.getIntProperty(""davmail.proxyPort"");
			 proxyUser = Settings.getProperty(""davmail.proxyUser"");
			 proxyPassword = Settings.getProperty(""davmail.proxyPassword"");
		 }
	 }
	 catch (URISyntaxException e) {
		 throw new DavMailException(""LOG_INVALID_URL"", url);
	 }
	 if (proxyHost != null && proxyHost.length() > 0) {
		 httpClient.getHostConfiguration().setProxy(proxyHost, proxyPort);
		 if (proxyUser != null && proxyUser.length() > 0) {
			 AuthScope authScope = new AuthScope(proxyHost, proxyPort, AuthScope.ANY_REALM);
			 int backslashindex = proxyUser.indexOf('\\');
			 if (backslashindex > 0) {
				 httpClient.getState().setProxyCredentials(authScope, new NTCredentials(proxyUser.substring(backslashindex + 1), proxyPassword, ""UNKNOWN"", proxyUser.substring(0, backslashindex)));
			 }
			 else {
				 httpClient.getState().setProxyCredentials(authScope, new NTCredentials(proxyUser, proxyPassword, ""UNKNOWN"", """"));
			 }
		 }
	 }
 }",0,0,1,0
"public class SplitTableRegionProcedure extends AbstractStateMachineRegionProcedure<SplitTableRegionState> {
	 private static final Logger LOG = LoggerFactory.getLogger(SplitTableRegionProcedure.class);
	 private Boolean traceEnabled = null;
	 private RegionInfo daughter_1_RI;
	 private RegionInfo daughter_2_RI;
	 private byte[] bestSplitRow;
	 private RegionSplitPolicy splitPolicy;
	 public SplitTableRegionProcedure() {
	 }
	 public SplitTableRegionProcedure(final MasterProcedureEnv env, final RegionInfo regionToSplit, final byte[] splitRow) throws IOException {
		 super(env, regionToSplit);
		 preflightChecks(env, true);
		 checkOnline(env, regionToSplit);
		 this.bestSplitRow = splitRow;
		 checkSplittable(env, regionToSplit, bestSplitRow);
		 final TableName table = regionToSplit.getTable();
		 final long rid = getDaughterRegionIdTimestamp(regionToSplit);
		 this.daughter_1_RI = RegionInfoBuilder.newBuilder(table) .setStartKey(regionToSplit.getStartKey()) .setEndKey(bestSplitRow) .setSplit(false) .setRegionId(rid) .build();
		 this.daughter_2_RI = RegionInfoBuilder.newBuilder(table) .setStartKey(bestSplitRow) .setEndKey(regionToSplit.getEndKey()) .setSplit(false) .setRegionId(rid) .build();
		 TableDescriptor htd = env.getMasterServices().getTableDescriptors().get(getTableName());
		 if(htd.getRegionSplitPolicyClassName() != null) {
			 Class<? extends RegionSplitPolicy> clazz = RegionSplitPolicy.getSplitPolicyClass(htd, env.getMasterConfiguration());
			 this.splitPolicy = ReflectionUtils.newInstance(clazz, env.getMasterConfiguration());
		 }
	 }
	 protected LockState acquireLock(final MasterProcedureEnv env) {
		 if (env.getProcedureScheduler().waitRegions(this, getTableName(), getParentRegion(), daughter_1_RI, daughter_2_RI)) {
			 try {
				 LOG.debug(LockState.LOCK_EVENT_WAIT + "" "" + env.getProcedureScheduler().dumpLocks());
			 }
			 catch (IOException e) {
			 }
			 return LockState.LOCK_EVENT_WAIT;
		 }
		 return LockState.LOCK_ACQUIRED;
	 }
	 protected void releaseLock(final MasterProcedureEnv env) {
		 env.getProcedureScheduler().wakeRegions(this, getTableName(), getParentRegion(), daughter_1_RI, daughter_2_RI);
	 }
	 private void checkSplittable(final MasterProcedureEnv env, final RegionInfo regionToSplit, final byte[] splitRow) throws IOException {
		 if(regionToSplit.getReplicaId() != RegionInfo.DEFAULT_REPLICA_ID) {
			 throw new IllegalArgumentException (""Can't invoke split on non-default regions directly"");
		 }
		 RegionStateNode node = env.getAssignmentManager().getRegionStates().getRegionStateNode(getParentRegion());
		 IOException splittableCheckIOE = null;
		 boolean splittable = false;
		 if (node != null) {
			 try {
				 if (bestSplitRow == null || bestSplitRow.length == 0) {
					 LOG .info(""splitKey isn't explicitly specified, will try to find a best split key from RS"");
				 }
				 GetRegionInfoResponse response = AssignmentManagerUtil.getRegionInfoResponse(env, node.getRegionLocation(), node.getRegionInfo(), true);
				 if(bestSplitRow == null || bestSplitRow.length == 0) {
					 bestSplitRow = response.hasBestSplitRow() ? response.getBestSplitRow().toByteArray() : null;
				 }
				 splittable = response.hasSplittable() && response.getSplittable();
				 if (LOG.isDebugEnabled()) {
					 LOG.debug(""Splittable="" + splittable + "" "" + node.toShortString());
				 }
			 }
			 catch (IOException e) {
				 splittableCheckIOE = e;
			 }
		 }
		 if (!splittable) {
			 IOException e = new DoNotRetryIOException(regionToSplit.getShortNameToLog() + "" NOT splittable"");
			 if (splittableCheckIOE != null) {
				 e.initCause(splittableCheckIOE);
			 }
			 throw e;
		 }
		 if (bestSplitRow == null || bestSplitRow.length == 0) {
			 throw new DoNotRetryIOException(""Region not splittable because bestSplitPoint = null, "" + ""maybe table is too small for auto split. For force split, try specifying split row"");
		 }
		 if (Bytes.equals(regionToSplit.getStartKey(), bestSplitRow)) {
			 throw new DoNotRetryIOException( ""Split row is equal to startkey: "" + Bytes.toStringBinary(splitRow));
		 }
		 if (!regionToSplit.containsRow(bestSplitRow)) {
			 throw new DoNotRetryIOException(""Split row is not inside region key range splitKey:"" + Bytes.toStringBinary(splitRow) + "" region: "" + regionToSplit);
		 }
	 }
	 private static long getDaughterRegionIdTimestamp(final RegionInfo hri) {
		 long rid = EnvironmentEdgeManager.currentTime();
		 if (rid < hri.getRegionId()) {
			 LOG.warn(""Clock skew;
			 parent regions id is "" + hri.getRegionId() + "" but current time here is "" + rid);
			 rid = hri.getRegionId() + 1;
		 }
		 return rid;
	 }
	 private void removeNonDefaultReplicas(MasterProcedureEnv env) throws IOException {
		 AssignmentManagerUtil.removeNonDefaultReplicas(env, Stream.of(getParentRegion()), getRegionReplication(env));
	 }
	 private void checkClosedRegions(MasterProcedureEnv env) throws IOException {
		 AssignmentManagerUtil.checkClosedRegion(env, getParentRegion());
	 }
	 protected Flow executeFromState(MasterProcedureEnv env, SplitTableRegionState state) throws InterruptedException {
		 LOG.trace(""{
		}
		 execute state={
		}
		"", this, state);
		 try {
			 switch (state) {
				 case SPLIT_TABLE_REGION_PREPARE: if (prepareSplitRegion(env)) {
					 setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_PRE_OPERATION);
					 break;
				 }
				 else {
					 return Flow.NO_MORE_STATE;
				 }
				 case SPLIT_TABLE_REGION_PRE_OPERATION: preSplitRegion(env);
				 setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_CLOSE_PARENT_REGION);
				 break;
				 case SPLIT_TABLE_REGION_CLOSE_PARENT_REGION: addChildProcedure(createUnassignProcedures(env));
				 setNextState(SplitTableRegionState.SPLIT_TABLE_REGIONS_CHECK_CLOSED_REGIONS);
				 break;
				 case SPLIT_TABLE_REGIONS_CHECK_CLOSED_REGIONS: checkClosedRegions(env);
				 setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_CREATE_DAUGHTER_REGIONS);
				 break;
				 case SPLIT_TABLE_REGION_CREATE_DAUGHTER_REGIONS: removeNonDefaultReplicas(env);
				 createDaughterRegions(env);
				 setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_WRITE_MAX_SEQUENCE_ID_FILE);
				 break;
				 case SPLIT_TABLE_REGION_WRITE_MAX_SEQUENCE_ID_FILE: writeMaxSequenceIdFile(env);
				 setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_PRE_OPERATION_BEFORE_META);
				 break;
				 case SPLIT_TABLE_REGION_PRE_OPERATION_BEFORE_META: preSplitRegionBeforeMETA(env);
				 setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_UPDATE_META);
				 break;
				 case SPLIT_TABLE_REGION_UPDATE_META: updateMeta(env);
				 setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_PRE_OPERATION_AFTER_META);
				 break;
				 case SPLIT_TABLE_REGION_PRE_OPERATION_AFTER_META: preSplitRegionAfterMETA(env);
				 setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_OPEN_CHILD_REGIONS);
				 break;
				 case SPLIT_TABLE_REGION_OPEN_CHILD_REGIONS: addChildProcedure(createAssignProcedures(env));
				 setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_POST_OPERATION);
				 break;
				 case SPLIT_TABLE_REGION_POST_OPERATION: postSplitRegion(env);
				 return Flow.NO_MORE_STATE;
				 default: throw new UnsupportedOperationException(this + "" unhandled state="" + state);
			 }
		 }
		 catch (IOException e) {
			 String msg = ""Splitting "" + getParentRegion().getEncodedName() + "", "" + this;
			 if (!isRollbackSupported(state)) {
				 LOG.warn(msg, e);
			 }
			 else {
				 LOG.error(msg, e);
				 setFailure(""master-split-regions"", e);
			 }
		 }
		 return Flow.HAS_MORE_STATE;
	 }
	 protected void rollbackState(final MasterProcedureEnv env, final SplitTableRegionState state) throws IOException, InterruptedException {
		 if (isTraceEnabled()) {
			 LOG.trace(this + "" rollback state="" + state);
		 }
		 try {
			 switch (state) {
				 case SPLIT_TABLE_REGION_POST_OPERATION: case SPLIT_TABLE_REGION_OPEN_CHILD_REGIONS: case SPLIT_TABLE_REGION_PRE_OPERATION_AFTER_META: case SPLIT_TABLE_REGION_UPDATE_META: throw new UnsupportedOperationException(this + "" unhandled state="" + state);
				 case SPLIT_TABLE_REGION_PRE_OPERATION_BEFORE_META: break;
				 case SPLIT_TABLE_REGION_CREATE_DAUGHTER_REGIONS: case SPLIT_TABLE_REGION_WRITE_MAX_SEQUENCE_ID_FILE: break;
				 case SPLIT_TABLE_REGIONS_CHECK_CLOSED_REGIONS: break;
				 case SPLIT_TABLE_REGION_CLOSE_PARENT_REGION: openParentRegion(env);
				 break;
				 case SPLIT_TABLE_REGION_PRE_OPERATION: postRollBackSplitRegion(env);
				 break;
				 case SPLIT_TABLE_REGION_PREPARE: break;
				 default: throw new UnsupportedOperationException(this + "" unhandled state="" + state);
			 }
		 }
		 catch (IOException e) {
			 LOG.warn(""pid="" + getProcId() + "" failed rollback attempt step "" + state + "" for splitting the region "" + getParentRegion().getEncodedName() + "" in table "" + getTableName(), e);
			 throw e;
		 }
	 }
	 protected boolean isRollbackSupported(final SplitTableRegionState state) {
		 switch (state) {
			 case SPLIT_TABLE_REGION_POST_OPERATION: case SPLIT_TABLE_REGION_OPEN_CHILD_REGIONS: case SPLIT_TABLE_REGION_PRE_OPERATION_AFTER_META: case SPLIT_TABLE_REGION_UPDATE_META: return false;
			 default: break;
		 }
		 return true;
	 }
	 protected SplitTableRegionState getState(final int stateId) {
		 return SplitTableRegionState.forNumber(stateId);
	 }
	 protected int getStateId(final SplitTableRegionState state) {
		 return state.getNumber();
	 }
	 protected SplitTableRegionState getInitialState() {
		 return SplitTableRegionState.SPLIT_TABLE_REGION_PREPARE;
	 }
	 protected void serializeStateData(ProcedureStateSerializer serializer) throws IOException {
		 super.serializeStateData(serializer);
		 final MasterProcedureProtos.SplitTableRegionStateData.Builder splitTableRegionMsg = MasterProcedureProtos.SplitTableRegionStateData.newBuilder() .setUserInfo(MasterProcedureUtil.toProtoUserInfo(getUser())) .setParentRegionInfo(ProtobufUtil.toRegionInfo(getRegion())) .addChildRegionInfo(ProtobufUtil.toRegionInfo(daughter_1_RI)) .addChildRegionInfo(ProtobufUtil.toRegionInfo(daughter_2_RI));
		 serializer.serialize(splitTableRegionMsg.build());
	 }
	 protected void deserializeStateData(ProcedureStateSerializer serializer) throws IOException {
		 super.deserializeStateData(serializer);
		 final MasterProcedureProtos.SplitTableRegionStateData splitTableRegionsMsg = serializer.deserialize(MasterProcedureProtos.SplitTableRegionStateData.class);
		 setUser(MasterProcedureUtil.toUserInfo(splitTableRegionsMsg.getUserInfo()));
		 setRegion(ProtobufUtil.toRegionInfo(splitTableRegionsMsg.getParentRegionInfo()));
		 assert(splitTableRegionsMsg.getChildRegionInfoCount() == 2);
		 daughter_1_RI = ProtobufUtil.toRegionInfo(splitTableRegionsMsg.getChildRegionInfo(0));
		 daughter_2_RI = ProtobufUtil.toRegionInfo(splitTableRegionsMsg.getChildRegionInfo(1));
	 }
	 public void toStringClassDetails(StringBuilder sb) {
		 sb.append(getClass().getSimpleName());
		 sb.append("" table="");
		 sb.append(getTableName());
		 sb.append("", parent="");
		 sb.append(getParentRegion().getShortNameToLog());
		 sb.append("", daughterA="");
		 sb.append(daughter_1_RI.getShortNameToLog());
		 sb.append("", daughterB="");
		 sb.append(daughter_2_RI.getShortNameToLog());
	 }
	 private RegionInfo getParentRegion() {
		 return getRegion();
	 }
	 public TableOperationType getTableOperationType() {
		 return TableOperationType.REGION_SPLIT;
	 }
	 protected ProcedureMetrics getProcedureMetrics(MasterProcedureEnv env) {
		 return env.getAssignmentManager().getAssignmentManagerMetrics().getSplitProcMetrics();
	 }
	 private byte[] getSplitRow() {
		 return daughter_2_RI.getStartKey();
	 }
	 private static final State[] EXPECTED_SPLIT_STATES = new State[] {
	 State.OPEN, State.CLOSED }
	;
	 public boolean prepareSplitRegion(final MasterProcedureEnv env) throws IOException {
		 if (env.getMasterServices().getSnapshotManager() .isTakingSnapshot(getParentRegion().getTable())) {
			 setFailure(new IOException(""Skip splitting region "" + getParentRegion().getShortNameToLog() + "", because we are taking snapshot for the table "" + getParentRegion().getTable()));
			 return false;
		 }
		 RegionStateNode node = env.getAssignmentManager().getRegionStates().getRegionStateNode(getParentRegion());
		 if (node == null) {
			 throw new UnknownRegionException(getParentRegion().getRegionNameAsString());
		 }
		 RegionInfo parentHRI = node.getRegionInfo();
		 if (parentHRI == null) {
			 LOG.info(""Unsplittable;
			 parent region is null;
			 node={
			}
			"", node);
			 return false;
		 }
		 if (node.isInState(State.SPLIT)) {
			 LOG.info(""Split of "" + parentHRI + "" skipped;
			 state is already SPLIT"");
			 return false;
		 }
		 if (parentHRI.isSplit() || parentHRI.isOffline()) {
			 LOG.info(""Split of "" + parentHRI + "" skipped because offline/split."");
			 return false;
		 }
		 if (!node.isInState(EXPECTED_SPLIT_STATES)) {
			 setFailure(new IOException(""Split "" + parentHRI.getRegionNameAsString() + "" FAILED because state="" + node.getState() + "";
			 expected "" + Arrays.toString(EXPECTED_SPLIT_STATES)));
			 return false;
		 }
		 if (!env.getMasterServices().isSplitOrMergeEnabled(MasterSwitchType.SPLIT)) {
			 LOG.warn(""pid="" + getProcId() + "" split switch is off! skip split of "" + parentHRI);
			 setFailure(new IOException(""Split region "" + parentHRI.getRegionNameAsString() + "" failed due to split switch off""));
			 return false;
		 }
		 if (!env.getMasterServices().getTableDescriptors().get(getTableName()).isSplitEnabled()) {
			 LOG.warn(""pid={
			}
			, split is disabled for the table! Skipping split of {
			}
			"", getProcId(), parentHRI);
			 setFailure(new IOException(""Split region "" + parentHRI.getRegionNameAsString() + "" failed as region split is disabled for the table""));
			 return false;
		 }
		 node.setState(State.SPLITTING);
		 return true;
	 }
	 private void preSplitRegion(final MasterProcedureEnv env) throws IOException, InterruptedException {
		 final MasterCoprocessorHost cpHost = env.getMasterCoprocessorHost();
		 if (cpHost != null) {
			 cpHost.preSplitRegionAction(getTableName(), getSplitRow(), getUser());
		 }
		 try {
			 env.getMasterServices().getMasterQuotaManager().onRegionSplit(this.getParentRegion());
		 }
		 catch (QuotaExceededException e) {
			 env.getMasterServices().getRegionNormalizer().planSkipped(this.getParentRegion(), NormalizationPlan.PlanType.SPLIT);
			 throw e;
		 }
	 }
	 private void postRollBackSplitRegion(final MasterProcedureEnv env) throws IOException {
		 final MasterCoprocessorHost cpHost = env.getMasterCoprocessorHost();
		 if (cpHost != null) {
			 cpHost.postRollBackSplitRegionAction(getUser());
		 }
	 }
	 private void openParentRegion(MasterProcedureEnv env) throws IOException {
		 AssignmentManagerUtil.reopenRegionsForRollback(env, Collections.singletonList((getParentRegion())), getRegionReplication(env), getParentRegionServerName(env));
	 }
	 public void createDaughterRegions(final MasterProcedureEnv env) throws IOException {
		 final MasterFileSystem mfs = env.getMasterServices().getMasterFileSystem();
		 final Path tabledir = FSUtils.getTableDir(mfs.getRootDir(), getTableName());
		 final FileSystem fs = mfs.getFileSystem();
		 HRegionFileSystem regionFs = HRegionFileSystem.openRegionFromFileSystem( env.getMasterConfiguration(), fs, tabledir, getParentRegion(), false);
		 regionFs.createSplitsDir();
		 Pair<Integer, Integer> expectedReferences = splitStoreFiles(env, regionFs);
		 assertReferenceFileCount(fs, expectedReferences.getFirst(), regionFs.getSplitsDir(daughter_1_RI));
		 regionFs.commitDaughterRegion(daughter_1_RI);
		 assertReferenceFileCount(fs, expectedReferences.getFirst(), new Path(tabledir, daughter_1_RI.getEncodedName()));
		 assertReferenceFileCount(fs, expectedReferences.getSecond(), regionFs.getSplitsDir(daughter_2_RI));
		 regionFs.commitDaughterRegion(daughter_2_RI);
		 assertReferenceFileCount(fs, expectedReferences.getSecond(), new Path(tabledir, daughter_2_RI.getEncodedName()));
	 }
	 private Pair<Integer, Integer> splitStoreFiles(final MasterProcedureEnv env, final HRegionFileSystem regionFs) throws IOException {
		 final MasterFileSystem mfs = env.getMasterServices().getMasterFileSystem();
		 final Configuration conf = env.getMasterConfiguration();
		 int nbFiles = 0;
		 final Map<String, Collection<StoreFileInfo>> files = new HashMap<String, Collection<StoreFileInfo>>(regionFs.getFamilies().size());
		 for (String family: regionFs.getFamilies()) {
			 Collection<StoreFileInfo> sfis = regionFs.getStoreFiles(family);
			 if (sfis == null) continue;
			 Collection<StoreFileInfo> filteredSfis = null;
			 for (StoreFileInfo sfi: sfis) {
				 if (sfi.isReference()) {
					 LOG.info(""Skipping split of "" + sfi + "";
					 presuming ready for archiving."");
					 continue;
				 }
				 if (filteredSfis == null) {
					 filteredSfis = new ArrayList<StoreFileInfo>(sfis.size());
					 files.put(family, filteredSfis);
				 }
				 filteredSfis.add(sfi);
				 nbFiles++;
			 }
		 }
		 if (nbFiles == 0) {
			 return new Pair<Integer, Integer>(0,0);
		 }
		 int maxThreads = Math.min( conf.getInt(HConstants.REGION_SPLIT_THREADS_MAX, conf.getInt(HStore.BLOCKING_STOREFILES_KEY, HStore.DEFAULT_BLOCKING_STOREFILE_COUNT)), nbFiles);
		 LOG.info(""pid="" + getProcId() + "" splitting "" + nbFiles + "" storefiles, region="" + getParentRegion().getShortNameToLog() + "", threads="" + maxThreads);
		 final ExecutorService threadPool = Executors.newFixedThreadPool( maxThreads, Threads.getNamedThreadFactory(""StoreFileSplitter-%1$d""));
		 final List<Future<Pair<Path,Path>>> futures = new ArrayList<Future<Pair<Path,Path>>>(nbFiles);
		 TableDescriptor htd = env.getMasterServices().getTableDescriptors().get(getTableName());
		 for (Map.Entry<String, Collection<StoreFileInfo>> e : files.entrySet()) {
			 byte[] familyName = Bytes.toBytes(e.getKey());
			 final ColumnFamilyDescriptor hcd = htd.getColumnFamily(familyName);
			 final Collection<StoreFileInfo> storeFiles = e.getValue();
			 if (storeFiles != null && storeFiles.size() > 0) {
				 for (StoreFileInfo storeFileInfo : storeFiles) {
					 StoreFileSplitter sfs = new StoreFileSplitter(regionFs, familyName, new HStoreFile(mfs.getFileSystem(), storeFileInfo, conf, CacheConfig.DISABLED, hcd.getBloomFilterType(), true));
					 futures.add(threadPool.submit(sfs));
				 }
			 }
		 }
		 threadPool.shutdown();
		 long fileSplitTimeout = conf.getLong(""hbase.master.fileSplitTimeout"", conf.getLong(""hbase.regionserver.fileSplitTimeout"", 600000));
		 try {
			 boolean stillRunning = !threadPool.awaitTermination(fileSplitTimeout, TimeUnit.MILLISECONDS);
			 if (stillRunning) {
				 threadPool.shutdownNow();
				 while (!threadPool.isTerminated()) {
					 Thread.sleep(50);
				 }
				 throw new IOException(""Took too long to split the"" + "" files and create the references, aborting split"");
			 }
		 }
		 catch (InterruptedException e) {
			 throw (InterruptedIOException)new InterruptedIOException().initCause(e);
		 }
		 int daughterA = 0;
		 int daughterB = 0;
		 for (Future<Pair<Path, Path>> future : futures) {
			 try {
				 Pair<Path, Path> p = future.get();
				 daughterA += p.getFirst() != null ? 1 : 0;
				 daughterB += p.getSecond() != null ? 1 : 0;
			 }
			 catch (InterruptedException e) {
				 throw (InterruptedIOException) new InterruptedIOException().initCause(e);
			 }
			 catch (ExecutionException e) {
				 throw new IOException(e);
			 }
		 }
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""pid="" + getProcId() + "" split storefiles for region "" + getParentRegion().getShortNameToLog() + "" Daughter A: "" + daughterA + "" storefiles, Daughter B: "" + daughterB + "" storefiles."");
		 }
		 return new Pair<Integer, Integer>(daughterA, daughterB);
	 }
	 private void assertReferenceFileCount(final FileSystem fs, final int expectedReferenceFileCount, final Path dir) throws IOException {
		 if (expectedReferenceFileCount != 0 && expectedReferenceFileCount != FSUtils.getRegionReferenceFileCount(fs, dir)) {
			 throw new IOException(""Failing split. Expected reference file count isn't equal."");
		 }
	 }
	 private Pair<Path, Path> splitStoreFile(HRegionFileSystem regionFs, byte[] family, HStoreFile sf) throws IOException {
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""pid="" + getProcId() + "" splitting started for store file: "" + sf.getPath() + "" for region: "" + getParentRegion().getShortNameToLog());
		 }
		 final byte[] splitRow = getSplitRow();
		 final String familyName = Bytes.toString(family);
		 final Path path_first = regionFs.splitStoreFile(this.daughter_1_RI, familyName, sf, splitRow, false, splitPolicy);
		 final Path path_second = regionFs.splitStoreFile(this.daughter_2_RI, familyName, sf, splitRow, true, splitPolicy);
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""pid="" + getProcId() + "" splitting complete for store file: "" + sf.getPath() + "" for region: "" + getParentRegion().getShortNameToLog());
		 }
		 return new Pair<Path,Path>(path_first, path_second);
	 }
	 private class StoreFileSplitter implements Callable<Pair<Path,Path>> {
		 private final HRegionFileSystem regionFs;
		 private final byte[] family;
		 private final HStoreFile sf;
		 public StoreFileSplitter(HRegionFileSystem regionFs, byte[] family, HStoreFile sf) {
			 this.regionFs = regionFs;
			 this.sf = sf;
			 this.family = family;
		 }
		 public Pair<Path,Path> call() throws IOException {
			 return splitStoreFile(regionFs, family, sf);
		 }
	 }
	 private void preSplitRegionBeforeMETA(final MasterProcedureEnv env) throws IOException, InterruptedException {
		 final List<Mutation> metaEntries = new ArrayList<Mutation>();
		 final MasterCoprocessorHost cpHost = env.getMasterCoprocessorHost();
		 if (cpHost != null) {
			 cpHost.preSplitBeforeMETAAction(getSplitRow(), metaEntries, getUser());
			 try {
				 for (Mutation p : metaEntries) {
					 RegionInfo.parseRegionName(p.getRow());
				 }
			 }
			 catch (IOException e) {
				 LOG.error(""pid="" + getProcId() + "" row key of mutation from coprocessor not parsable as "" + ""region name."" + ""Mutations from coprocessor should only for hbase:meta table."");
				 throw e;
			 }
		 }
	 }
	 private void updateMeta(final MasterProcedureEnv env) throws IOException {
		 env.getAssignmentManager().markRegionAsSplit(getParentRegion(), getParentRegionServerName(env), daughter_1_RI, daughter_2_RI);
	 }
	 private void preSplitRegionAfterMETA(final MasterProcedureEnv env) throws IOException, InterruptedException {
		 final MasterCoprocessorHost cpHost = env.getMasterCoprocessorHost();
		 if (cpHost != null) {
			 cpHost.preSplitAfterMETAAction(getUser());
		 }
	 }
	 private void postSplitRegion(final MasterProcedureEnv env) throws IOException {
		 final MasterCoprocessorHost cpHost = env.getMasterCoprocessorHost();
		 if (cpHost != null) {
			 cpHost.postCompletedSplitRegionAction(daughter_1_RI, daughter_2_RI, getUser());
		 }
	 }
	 private ServerName getParentRegionServerName(final MasterProcedureEnv env) {
		 return env.getMasterServices().getAssignmentManager().getRegionStates() .getRegionServerOfRegion(getParentRegion());
	 }
	 private TransitRegionStateProcedure[] createUnassignProcedures(MasterProcedureEnv env) throws IOException {
		 return AssignmentManagerUtil.createUnassignProceduresForSplitOrMerge(env, Stream.of(getParentRegion()), getRegionReplication(env));
	 }
	 private TransitRegionStateProcedure[] createAssignProcedures(MasterProcedureEnv env) throws IOException {
		 List<RegionInfo> hris = new ArrayList<RegionInfo>(2);
		 hris.add(daughter_1_RI);
		 hris.add(daughter_2_RI);
		 return AssignmentManagerUtil.createAssignProceduresForOpeningNewRegions(env, hris, getRegionReplication(env), getParentRegionServerName(env));
	 }
	 private int getRegionReplication(final MasterProcedureEnv env) throws IOException {
		 final TableDescriptor htd = env.getMasterServices().getTableDescriptors().get(getTableName());
		 return htd.getRegionReplication();
	 }
	 private void writeMaxSequenceIdFile(MasterProcedureEnv env) throws IOException {
		 FileSystem walFS = env.getMasterServices().getMasterWalManager().getFileSystem();
		 long maxSequenceId = WALSplitter.getMaxRegionSequenceId(walFS, getWALRegionDir(env, getParentRegion()));
		 if (maxSequenceId > 0) {
			 WALSplitter.writeRegionSequenceIdFile(walFS, getWALRegionDir(env, daughter_1_RI), maxSequenceId);
			 WALSplitter.writeRegionSequenceIdFile(walFS, getWALRegionDir(env, daughter_2_RI), maxSequenceId);
		 }
	 }
	 private boolean isTraceEnabled() {
		 if (traceEnabled == null) {
			 traceEnabled = LOG.isTraceEnabled();
		 }
		 return traceEnabled;
	 }
	 protected boolean abort(MasterProcedureEnv env) {
		 return isRollbackSupported(getCurrentState())? super.abort(env): false;
	 }
}",1,0,0,0
"public class HandleConfigDriveIsoCommand extends Command {
	 private String isoData;
	 private String isoFile;
	 private boolean create = false;
	 private DataStoreTO destStore;
	 public HandleConfigDriveIsoCommand(String isoFile, String isoData, DataStoreTO destStore, boolean create) {
		 this.isoFile = isoFile;
		 this.isoData = isoData;
		 this.destStore = destStore;
		 this.create = create;
	 }
	 public boolean executeInSequence() {
		 return false;
	 }
	 public String getIsoData() {
		 return isoData;
	 }
	 public boolean isCreate() {
		 return create;
	 }
	 public DataStoreTO getDestStore() {
		 return destStore;
	 }
	 public String getIsoFile() {
		 return isoFile;
	 }
}",0,1,0,0
"public class MethodSecurityInterceptor extends AbstractSecurityInterceptor implementsMethodInterceptor {
	private MethodSecurityMetadataSource securityMetadataSource;
	public Class<?> getSecureObjectClass() {
		return MethodInvocation.class;
	}
	public Object invoke(MethodInvocation mi) throws Throwable {
		InterceptorStatusToken token = super.beforeInvocation(mi);
		Object result;
		try {
			result = mi.proceed();
		}
		finally {
			super.finallyInvocation(token);
		}
		return super.afterInvocation(token, result);
	}
	public MethodSecurityMetadataSource getSecurityMetadataSource() {
		return this.securityMetadataSource;
	}
	public SecurityMetadataSource obtainSecurityMetadataSource() {
		return this.securityMetadataSource;
	}
	public void setSecurityMetadataSource(MethodSecurityMetadataSource newSource) {
		this.securityMetadataSource = newSource;
	}
}",0,1,0,0
"public static Instances convertNeurophToWekaDataset(DataSet neurophDataset) {
	 Map<double[], String> classValues = getClassValues(neurophDataset);
	 Instances instances = createEmptyWekaDataSet(neurophDataset.getInputSize(), neurophDataset.size(), classValues);
	 int numInputs = neurophDataset.getInputSize();
	 int numOutputs = 1;
	 instances.setClassIndex(numInputs);
	 Iterator<DataSetRow> iterator = neurophDataset.iterator();
	 while(iterator.hasNext()) {
		 DataSetRow row = iterator.next();
		 if (numOutputs> 0) {
			 Instance instance = new DenseInstance(numInputs + numOutputs);
			 for(int i=0;
			 i< numInputs;
			 i++) {
				 instance.setValue(i, row.getInput()[i] );
			 }
			 instance.setDataset(instances);
			 for(Map.Entry<double[], String> entry : classValues.entrySet()){
				 if(entry.getValue().equals(row.getLabel())){
					 instance.setValue(numInputs, entry.getValue());
					 double[] rowDouble = row.getDesiredOutput();
					 for(int i = 0;
					 i < rowDouble.length;
					 i++){
						 if(rowDouble[i] == 1){
							 instance.setValue(numInputs, i);
						 }
						 break;
					 }
					 break;
				 }
			 }
			 instances.add(instance);
		 }
		 else {
			 Instance instance = new DenseInstance(numInputs);
			 for(int i=0;
			 i< numInputs;
			 i++) {
				 instance.setValue(i, row.getInput()[i] );
			 }
			 instance.setDataset(instances);
			 instances.add(instance);
		 }
	 }
	 return instances;
 }",0,0,1,0
"public static final class Result {
	 public enum Outcome {
	 OK, WARNING, ERROR }
	 private final int code;
	 private final String description;
	 private final Outcome outcome;
	 private Result(int code, String description) {
		 this.code = code;
		 this.description = description;
		 if (2000 <= code && code <= 2099) {
			 this.outcome = Outcome.OK;
		 }
		 else if (3500 <= code && code <= 3699) {
			 this.outcome = Outcome.WARNING;
		 }
		 else if (4500 <= code && code <= 4699) {
			 this.outcome = Outcome.ERROR;
		 }
		 else {
			 throw new IllegalArgumentException(""Invalid DN result code: "" + code);
		 }
	 }
	 public int getCode() {
		 return code;
	 }
	 public String getDescription() {
		 return description;
	 }
	 public Outcome getOutcome() {
		 return outcome;
	 }
	 public String toString() {
		 return toStringHelper(this) .add(""code"", code) .add(""outcome"", outcome) .add(""description"", description) .toString();
	 }
 }",0,1,0,0
"public class ExpiringColumn extends Column{
	 private final int localExpirationTime;
	 private final int timeToLive;
	 public ExpiringColumn(ByteBuffer name, ByteBuffer value, long timestamp, int timeToLive) {
		 this(name, value, timestamp, timeToLive, (int) (System.currentTimeMillis() / 1000) + timeToLive);
	 }
	 public ExpiringColumn(ByteBuffer name, ByteBuffer value, long timestamp, int timeToLive, int localExpirationTime) {
		 super(name, value, timestamp);
		 assert timeToLive > 0 : timeToLive;
		 assert localExpirationTime > 0 : localExpirationTime;
		 this.timeToLive = timeToLive;
		 this.localExpirationTime = localExpirationTime;
	 }
	 public int getTimeToLive() {
		 return timeToLive;
	 }
	 public boolean isMarkedForDelete() {
		 return (int) (System.currentTimeMillis() / 1000 ) > localExpirationTime;
	 }
	 public int size() {
		 return super.size() + DBConstants.intSize_ + DBConstants.intSize_;
	 }
	 public void updateDigest(MessageDigest digest) {
		 digest.update(name.duplicate());
		 digest.update(value.duplicate());
		 DataOutputBuffer buffer = new DataOutputBuffer();
		 try {
			 buffer.writeLong(timestamp);
			 buffer.writeByte(serializationFlags());
			 buffer.writeInt(timeToLive);
		 }
		 catch (IOException e) {
			 throw new RuntimeException(e);
		 }
		 digest.update(buffer.getData(), 0, buffer.getLength());
	 }
	 public int getLocalDeletionTime() {
		 return localExpirationTime;
	 }
	 public IColumn localCopy(ColumnFamilyStore cfs) {
		 return new ExpiringColumn(cfs.internOrCopy(name), ByteBufferUtil.clone(value), timestamp, timeToLive, localExpirationTime);
	 }
	 public String getString(AbstractType comparator) {
		 StringBuilder sb = new StringBuilder();
		 sb.append(super.getString(comparator));
		 sb.append(""!"");
		 sb.append(timeToLive);
		 return sb.toString();
	 }
	 public long getMarkedForDeleteAt() {
		 if (isMarkedForDelete()) {
			 return timestamp;
		 }
		 else {
			 throw new IllegalStateException(""column is not marked for delete"");
		 }
	 }
	 public int serializationFlags() {
		 return ColumnSerializer.EXPIRATION_MASK;
	 }
	 public void validateFields(CFMetaData metadata) throws MarshalException {
		 super.validateFields(metadata);
		 if (timeToLive <= 0) throw new MarshalException(""A column TTL should be > 0"");
		 if (localExpirationTime < 0) throw new MarshalException(""The local expiration time should not be negative"");
	 }
}",0,0,0,0
"public long exportTo(final ContentClaim claim, final Path destination, final boolean append, final long offset, final long length) throws IOException {
	 if (claim == null) {
		 if (append) {
			 return 0L;
		 }
		 Files.createFile(destination);
		 return 0L;
	 }
	 final StandardOpenOption openOption = append ? StandardOpenOption.APPEND : StandardOpenOption.CREATE;
	 try (final InputStream in = read(claim);
	 final OutputStream destinationStream = Files.newOutputStream(destination, openOption)) {
		 if (offset > 0) {
			 StreamUtils.skip(in, offset);
		 }
		 StreamUtils.copy(in, destinationStream, length);
		 return length;
	 }
 }",0,0,1,0
"public int compare(IColumn c1, IColumn c2) {
	 return comparator.compare(c1.name(), c2.name());
 }",0,0,0,0
"public class SectionCutterAction extends ConfigurableServiceableAction implements ThreadSafe {
	 Vector sections = new Vector();
	 public void configure(Configuration conf) throws ConfigurationException {
		 try {
			 Configuration[] sectionConfigurations;
			 sectionConfigurations = conf.getChildren(""section"");
			 for (int i = 0;
			 i < sectionConfigurations.length;
			 i++) {
				 try {
					 if (getLogger().isDebugEnabled()) {
						 getLogger().debug(""Creating one section"");
					 }
					 sections.add(new Section(sectionConfigurations[i]));
				 }
				 catch (Exception e) {
					 getLogger().error(""Failed configuring section"", e);
					 if (getLogger().isDebugEnabled()) {
						 throw (e);
					 }
				 }
			 }
		 }
		 catch (Exception e) {
			 throw new ConfigurationException(""Cannot configure action"", e);
		 }
	 }
	 public Map act(Redirector redirector, SourceResolver resolver, Map objectModel, String src, Parameters par) throws Exception {
		 Request request = ObjectModelHelper.getRequest(objectModel);
		 Map results = new HashMap();
		 if (request != null) {
			 boolean hasMatched = false;
			 if (getLogger().isDebugEnabled()) {
				 getLogger().debug(""Matching against '"" + request.getSitemapURI() + ""'"");
			 }
			 for (Enumeration sectionsEnum = sections.elements();
			 sectionsEnum.hasMoreElements() && !hasMatched;
			 ) {
				 Section section = (Section) sectionsEnum.nextElement();
				 if (section.matches(request.getSitemapURI())) {
					 if (getLogger().isDebugEnabled()) {
						 getLogger().debug(""Matched '"" + section.matchExpression + ""'"");
					 }
					 section.fillMap(results);
					 hasMatched = true;
				 }
			 }
		 }
		 else {
			 getLogger().warn(""Request was null"");
		 }
		 return Collections.unmodifiableMap(results);
	 }
	 static class Section extends Object {
		 String matchExpression;
		 Dictionary mapVars = new Hashtable();
		 public Section(Configuration conf) throws Exception {
			 matchExpression = conf.getAttribute(""pattern"");
			 Configuration[] variables;
			 variables = conf.getChildren(""set-var"");
			 for (int i = 0;
			 i < variables.length;
			 i++) {
				 mapVars.put(variables[i].getAttribute(""name""), variables[i].getAttribute(""value""));
			 }
		 }
		 public boolean matches(String expression) {
			 return expression.startsWith(matchExpression);
		 }
		 public void fillMap(Map map) {
			 for (Enumeration keys = mapVars.keys();
			 keys.hasMoreElements();
			 ) {
				 Object key = keys.nextElement();
				 Object value = mapVars.get(key);
				 map.put(key, value);
			 }
		 }
	 }
}",0,0,0,0
"public abstract class DefBase extends AntlibDefinition {
	 private ClassLoader createdLoader;
	 private ClasspathUtils.Delegate cpDelegate;
	 protected boolean hasCpDelegate() {
		 return cpDelegate != null;
	 }
	 public void setReverseLoader(boolean reverseLoader) {
		 getDelegate().setReverseLoader(reverseLoader);
		 log(""The reverseloader attribute is DEPRECATED. It will be removed"", Project.MSG_WARN);
	 }
	 public Path getClasspath() {
		 return getDelegate().getClasspath();
	 }
	 public boolean isReverseLoader() {
		 return getDelegate().isReverseLoader();
	 }
	 public String getLoaderId() {
		 return getDelegate().getClassLoadId();
	 }
	 public String getClasspathId() {
		 return getDelegate().getClassLoadId();
	 }
	 public void setClasspath(Path classpath) {
		 getDelegate().setClasspath(classpath);
	 }
	 public Path createClasspath() {
		 return getDelegate().createClasspath();
	 }
	 public void setClasspathRef(Reference r) {
		 getDelegate().setClasspathref(r);
	 }
	 public void setLoaderRef(Reference r) {
		 getDelegate().setLoaderRef(r);
	 }
	 protected ClassLoader createLoader() {
		 if (getAntlibClassLoader() != null && cpDelegate == null) {
			 return getAntlibClassLoader();
		 }
		 if (createdLoader == null) {
			 createdLoader = getDelegate().getClassLoader();
			 ((AntClassLoader) createdLoader) .addSystemPackageRoot(""org.apache.tools.ant"");
		 }
		 return createdLoader;
	 }
	 public void init() throws BuildException {
		 super.init();
	 }
	 private ClasspathUtils.Delegate getDelegate() {
		 if (cpDelegate == null) {
			 cpDelegate = ClasspathUtils.getDelegate(this);
		 }
		 return cpDelegate;
	 }
}",0,0,0,0
"private static final class Reference {
	 private final Tree tree;
	 private final PropertyState property;
	 private Reference(Tree tree, String propertyName) {
		 this.tree = tree;
		 this.property = tree.getProperty(propertyName);
	 }
	 private boolean isMultiple() {
		 return property.isArray();
	 }
	 private void setProperty(String newValue) {
		 PropertyState prop = PropertyStates.createProperty(property.getName(), newValue, property.getType().tag());
		 tree.setProperty(prop);
	 }
	 private void setProperty(Iterable<String> newValues) {
		 PropertyState prop = PropertyStates.createProperty(property.getName(), newValues, property.getType());
		 tree.setProperty(prop);
	 }
 }",1,1,0,0
"public double calculateDaycountFraction(Calendar startCalendar,Calendar endCalendar, Calendar periodStartCalendar,Calendar periodEndCalendar) throws DaycountException;",0,0,0,1
"public class HDFSTextLineReader {
	 private static final int DEFAULT_BUFFER_SIZE = 32 * 1024;
	 private int bufferSize = DEFAULT_BUFFER_SIZE;
	 private FSDataInputStream reader;
	 private byte[] buffer;
	 private int bufferLength = 0;
	 private int bufferPosn = 0;
	 private long currentFilePos = 0L;
	 private static final byte CR = '\r';
	 private static final byte LF = '\n';
	 public static final String KEY_BUFFER_SIZE = ""io.file.buffer.size"";
	 public HDFSTextLineReader(FSDataInputStream in) throws IOException {
		 this(in, DEFAULT_BUFFER_SIZE);
	 }
	 public HDFSTextLineReader(FSDataInputStream in, int bufferSize) throws IOException {
		 this.reader = in;
		 this.bufferSize = bufferSize;
		 this.buffer = new byte[this.bufferSize];
		 currentFilePos = in.getPos();
	 }
	 public HDFSTextLineReader() throws IOException {
		 this.bufferSize = DEFAULT_BUFFER_SIZE;
		 this.buffer = new byte[this.bufferSize];
	 }
	 public HDFSTextLineReader(FSDataInputStream in, Configuration conf) throws IOException {
		 this(in, conf.getInt(KEY_BUFFER_SIZE, DEFAULT_BUFFER_SIZE));
	 }
	 public int readLine(Text str, int maxLineLength, int maxBytesToConsume) throws IOException {
		 str.clear();
		 int txtLength = 0;
		 int newlineLength = 0;
		 boolean prevCharCR = false;
		 long bytesConsumed = 0;
		 do {
			 int startPosn = bufferPosn;
			 if (bufferPosn >= bufferLength) {
				 startPosn = bufferPosn = 0;
				 if (prevCharCR) ++bytesConsumed;
				 bufferLength = reader.read(buffer);
				 if (bufferLength <= 0) break;
			 }
			 for (;
			 bufferPosn < bufferLength;
			 ++bufferPosn) {
				 if (buffer[bufferPosn] == LF) {
					 newlineLength = (prevCharCR) ? 2 : 1;
					 ++bufferPosn;
					 break;
				 }
				 if (prevCharCR) {
					 newlineLength = 1;
					 break;
				 }
				 prevCharCR = (buffer[bufferPosn] == CR);
			 }
			 int readLength = bufferPosn - startPosn;
			 if (prevCharCR && newlineLength == 0) --readLength;
			 bytesConsumed += readLength;
			 int appendLength = readLength - newlineLength;
			 if (appendLength > maxLineLength - txtLength) {
				 appendLength = maxLineLength - txtLength;
			 }
			 if (appendLength > 0) {
				 str.append(buffer, startPosn, appendLength);
				 txtLength += appendLength;
			 }
		 }
		 while (newlineLength == 0 && bytesConsumed < maxBytesToConsume);
		 if (bytesConsumed > Integer.MAX_VALUE) throw new IOException(""Too many bytes before newline: "" + bytesConsumed);
		 currentFilePos = reader.getPos() - bufferLength + bufferPosn;
		 return (int) bytesConsumed;
	 }
	 public int readLine(Text str, int maxLineLength) throws IOException {
		 return readLine(str, maxLineLength, Integer.MAX_VALUE);
	 }
	 public int readLine(Text str) throws IOException {
		 return readLine(str, Integer.MAX_VALUE, Integer.MAX_VALUE);
	 }
	 public void seek(long desired) throws IOException {
		 if (reader.getPos() <= desired || currentFilePos > desired) {
			 reader.seek(desired);
			 bufferLength = 0;
			 bufferPosn = 0;
			 currentFilePos = desired;
		 }
		 else if (currentFilePos < desired) {
			 int difference = (int) (desired - currentFilePos);
			 bufferPosn += difference;
			 currentFilePos = desired;
		 }
	 }
	 public FSDataInputStream getReader() {
		 return reader;
	 }
	 public void resetReader(FSDataInputStream reader) throws IOException {
		 this.reader = reader;
		 bufferLength = 0;
		 bufferPosn = 0;
		 currentFilePos = reader.getPos();
	 }
	 public void close() throws IOException {
		 reader.close();
	 }
}",1,0,0,0
"public abstract class AbstractGroupingProperty {
	 protected Set<LogicalVariable> columnSet;
	 public AbstractGroupingProperty(Set<LogicalVariable> columnSet) {
		 this.columnSet = columnSet;
	 }
	 public Set<LogicalVariable> getColumnSet() {
		 return columnSet;
	 }
	 protected Set<LogicalVariable> normalizeAndReduceGroupingColumns(Set<LogicalVariable> columns, Map<LogicalVariable, EquivalenceClass> equivalenceClasses, List<FunctionalDependency> fds) {
		 Set<LogicalVariable> normalizedColumnSet = getNormalizedColumnsAccordingToEqClasses(columns, equivalenceClasses);
		 reduceGroupingColumns(normalizedColumnSet, fds);
		 return normalizedColumnSet;
	 }
	 private Set<LogicalVariable> getNormalizedColumnsAccordingToEqClasses(Set<LogicalVariable> columns, Map<LogicalVariable, EquivalenceClass> equivalenceClasses) {
		 Set<LogicalVariable> normalizedColumns = new ListSet<>();
		 if (equivalenceClasses == null || equivalenceClasses.isEmpty()) {
			 normalizedColumns.addAll(columns);
			 return normalizedColumns;
		 }
		 for (LogicalVariable v : columns) {
			 EquivalenceClass ec = equivalenceClasses.get(v);
			 if (ec == null) {
				 normalizedColumns.add(v);
			 }
			 else {
				 if (ec.representativeIsConst()) {
				 }
				 else {
					 normalizedColumns.add(ec.getVariableRepresentative());
				 }
			 }
		 }
		 return normalizedColumns;
	 }
	 private void reduceGroupingColumns(Set<LogicalVariable> columnSet, List<FunctionalDependency> fds) {
		 if (fds == null || fds.isEmpty()) {
			 return;
		 }
		 Set<LogicalVariable> norm = new ListSet<>();
		 for (LogicalVariable v : columnSet) {
			 boolean isImpliedByAnFD = false;
			 for (FunctionalDependency fdep : fds) {
				 if (columnSet.containsAll(fdep.getHead()) && fdep.getTail().contains(v)) {
					 isImpliedByAnFD = true;
					 norm.addAll(fdep.getHead());
					 break;
				 }
			 }
			 if (!isImpliedByAnFD) {
				 norm.add(v);
			 }
		 }
		 columnSet.retainAll(norm);
	 }
}",1,1,0,0
"public class MetricsTag implements MetricsInfo {
	 private final MetricsInfo info;
	 private final String value;
	 public MetricsTag(MetricsInfo info, String value) {
		 this.info = checkNotNull(info, ""tag info"");
		 this.value = value;
	 }
	 public String name() {
		 return info.name();
	 }
	 public String description() {
		 return info.description();
	 }
	 public MetricsInfo info() {
		 return info;
	 }
	 public String value() {
		 return value;
	 }
	 public boolean equals(Object obj) {
		 if (obj instanceof MetricsTag) {
			 final MetricsTag other = (MetricsTag) obj;
			 return Objects.equal(info, other.info()) && Objects.equal(value, other.value());
		 }
		 return false;
	 }
	 public int hashCode() {
		 return Objects.hashCode(info, value);
	 }
	 public String toString() {
		 return Objects.toStringHelper(this) .add(""info"", info) .add(""value"", value()) .toString();
	 }
}",0,1,0,0
"public class ZooKeeperMesosServices extends AbstractMesosServices {
	private final ZooKeeperUtilityFactory zooKeeperUtilityFactory;
	public ZooKeeperMesosServices(ActorSystem actorSystem, MesosArtifactServer artifactServer, ZooKeeperUtilityFactory zooKeeperUtilityFactory) {
		super(actorSystem, artifactServer);
		this.zooKeeperUtilityFactory = Preconditions.checkNotNull(zooKeeperUtilityFactory);
	}
	public MesosWorkerStore createMesosWorkerStore(Configuration configuration, Executor executor) throws Exception {
		RetrievableStateStorageHelper<MesosWorkerStore.Worker> stateStorageHelper =ZooKeeperUtils.createFileSystemStateStorage(configuration, ""mesosWorkerStore"");
		ZooKeeperStateHandleStore<MesosWorkerStore.Worker> zooKeeperStateHandleStore = zooKeeperUtilityFactory.createZooKeeperStateHandleStore(""/workers"",stateStorageHelper);
		ZooKeeperSharedValue frameworkId = zooKeeperUtilityFactory.createSharedValue(""/frameworkId"", new byte[0]);
		ZooKeeperSharedCount totalTaskCount = zooKeeperUtilityFactory.createSharedCount(""/taskCount"", 0);
		return new ZooKeeperMesosWorkerStore(zooKeeperStateHandleStore,frameworkId,totalTaskCount);
	}
	public void close(boolean cleanup) throws Exception {
		Throwable exception = null;
		try {
			zooKeeperUtilityFactory.close(cleanup);
		}
		 catch (Throwable t) {
			exception = ExceptionUtils.firstOrSuppressed(t, exception);
		}
		try {
			super.close(cleanup);
		}
		 catch (Throwable t) {
			exception = ExceptionUtils.firstOrSuppressed(t, exception);
		}
		if (exception != null) {
			throw new FlinkException(""Could not properly shut down the Mesos services."", exception);
		}
	}
}",0,0,0,0
"public Control createPageArea(Composite parent) {
	 Composite top = new Composite(parent, SWT.NONE);
	 top.setLayout(new GridLayout());
	 Composite composite = new Composite(top, SWT.NONE);
	 GridLayout layout = new GridLayout(3, false);
	 layout.marginHeight = 0;
	 layout.marginWidth = 0;
	 composite.setLayout(layout);
	 composite.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
	 usejar = new Button(composite, SWT.CHECK);
	 usejar.setText(""Use embedded JAR"");
	 usejar.addSelectionListener(LISTENER_USEJAR);
	 GridData grid = new GridData(GridData.FILL);
	 grid.horizontalSpan = 3;
	 usejar.setLayoutData(grid);
	 Label label = new Label(composite, SWT.NONE);
	 label.setText(""JAR location:"");
	 grid = new GridData(GridData.FILL);
	 label.setLayoutData(grid);
	 jar = new Text(composite, SWT.BORDER);
	 grid = new GridData(GridData.FILL_HORIZONTAL);
	 grid.widthHint = 250;
	 jar.setLayoutData(grid);
	 jar.addModifyListener(new ModifyListener() {
		 public void modifyText(ModifyEvent e) {
			 setModelJar(jar.getText());
		 }
	 }
	);
	 setjar = new Button(composite, SWT.NONE);
	 setjar.setText(""Browse..."");
	 setjar.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 FileDialog dialog = new FileDialog(getShell(), SWT.SAVE);
			 dialog.setText(""JAR Location"");
			 String file = dialog.open();
			 if (file != null) jar.setText(file);
			 setModelJar(file);
		 }
	 }
	);
	 grid = new GridData(GridData.FILL);
	 grid.widthHint = 100;
	 setjar.setLayoutData(grid);
	 label = new Label(composite, SWT.SEPARATOR | SWT.HORIZONTAL);
	 grid = new GridData(GridData.FILL_HORIZONTAL);
	 grid.horizontalSpan = 3;
	 label.setLayoutData(grid);
	 label = new Label(composite, SWT.NONE);
	 label.setText(""Main class:"");
	 grid = new GridData(GridData.FILL);
	 label.setLayoutData(grid);
	 mainclass = new Text(composite, SWT.BORDER);
	 grid = new GridData(GridData.FILL_HORIZONTAL);
	 grid.widthHint = 250;
	 mainclass.setLayoutData(grid);
	 mainclass.addModifyListener(new ModifyListener() {
		 public void modifyText(ModifyEvent e) {
			 setModelMainclass(mainclass.getText());
		 }
	 }
	);
	 new Label(composite, SWT.NONE);
	 label = new Label(composite, SWT.NONE);
	 label.setText(""Arguments:"");
	 grid = new GridData(GridData.FILL);
	 label.setLayoutData(grid);
	 args = new Text(composite, SWT.BORDER);
	 grid = new GridData(GridData.FILL_HORIZONTAL);
	 grid.widthHint = 250;
	 args.setLayoutData(grid);
	 args.addModifyListener(new ModifyListener() {
		 public void modifyText(ModifyEvent e) {
			 setModelArguments(args.getText());
		 }
	 }
	);
	 new Label(composite, SWT.NONE);
	 Group group = new Group(top, SWT.NONE);
	 group.setText(""Classpath"");
	 group.setLayout(new GridLayout());
	 grid = new GridData(GridData.FILL_HORIZONTAL);
	 grid.horizontalSpan = 3;
	 group.setLayoutData(grid);
	 group.setLayout(new GridLayout(2, false));
	 classpath = new List(group, SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL | SWT.MULTI);
	 grid = new GridData(GridData.FILL_BOTH);
	 grid.widthHint = 250;
	 grid.heightHint = classpath.getItemHeight() * 10;
	 classpath.setLayoutData(grid);
	 classpath.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 updateRemoveButton();
		 }
	 }
	);
	 composite = new Composite(group, SWT.NONE);
	 composite.setLayoutData(new GridData(GridData.FILL_VERTICAL));
	 layout = new GridLayout();
	 layout.marginHeight = 0;
	 layout.marginWidth = 2;
	 composite.setLayout(layout);
	 addjar = new Button(composite, SWT.NONE);
	 addjar.setText(""Add JAR File..."");
	 addjar.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 FileDialog dialog = new FileDialog(getShell(), SWT.OPEN | SWT.MULTI);
			 dialog.setText(""JAR File"");
			 String choice = dialog.open();
			 if (choice != null) {
				 String path = dialog.getFilterPath();
				 String[] filenames = dialog.getFileNames();
				 ArrayList files = new ArrayList();
				 for (int i = 0;
				 i < filenames.length;
				 i++) {
					 files.add(path + File.separator + filenames[i]);
				 }
				 addClasspathItems((String[]) files.toArray(new String[0]));
			 }
		 }
	 }
	);
	 grid = new GridData(GridData.FILL_HORIZONTAL);
	 grid.widthHint = 130;
	 addjar.setLayoutData(grid);
	 addfolder = new Button(composite, SWT.NONE);
	 addfolder.setText(""Add Class Folder..."");
	 addfolder.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 DirectoryDialog dialog = new DirectoryDialog(getShell(), SWT.SAVE);
			 dialog.setText(""Class Folder"");
			 String folder = dialog.open();
			 if (folder != null) addClasspathItems(new String[]{
			folder}
			);
		 }
	 }
	);
	 grid = new GridData(GridData.FILL_HORIZONTAL);
	 grid.widthHint = 130;
	 addfolder.setLayoutData(grid);
	 remove = new Button(composite, SWT.NONE);
	 remove.setText(""Remove"");
	 remove.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 removeItem();
		 }
	 }
	);
	 grid = new GridData(GridData.FILL_HORIZONTAL);
	 grid.widthHint = 130;
	 remove.setLayoutData(grid);
	 updateRemoveButton();
	 updateUsejarWidgets();
	 return top;
 }",0,0,1,0
"private void lockSourceAndCopy(File sourceFile, File copyFile) {
	 sourceFile.opened();
	 ReadWriteLock sourceLock = sourceFile.contentLock();
	 if (sourceLock != null) {
		 sourceLock.readLock().lock();
	 }
	 ReadWriteLock copyLock = copyFile.contentLock();
	 if (copyLock != null) {
		 copyLock.writeLock().lock();
	 }
 }",0,0,0,0
"public String getHeader(String name){
	String nameLower = name.toLowerCase();
	List headerValueList = (List)headerNameToValueListMap.get(nameLower);
	if (null == headerValueList){
		return null;
	}
	return (String)headerValueList.get(0);
}",0,0,0,0
"class MeteredFlusher implements Runnable{
	 private static Logger logger = LoggerFactory.getLogger(MeteredFlusher.class);
	 public void run() {
		 Memtable activelyMeasuring = Memtable.activelyMeasuring;
		 long flushingBytes = activelyMeasuring == null ? 0 : activelyMeasuring.getLiveSize();
		 flushingBytes += countFlushingBytes();
		 long liveBytes = 0;
		 try {
			 for (ColumnFamilyStore cfs : ColumnFamilyStore.all()) {
				 long size = cfs.getTotalMemtableLiveSize();
				 int maxInFlight = (int) Math.ceil((double) (1 + 1 + DatabaseDescriptor.getFlushWriters() + DatabaseDescriptor.getFlushQueueSize()) / (1 + cfs.getIndexedColumns().size()));
				 if (size > (DatabaseDescriptor.getTotalMemtableSpaceInMB() * 1048576L - flushingBytes) / maxInFlight) {
					 logger.info(""flushing high-traffic column family {
					}
					"", cfs);
					 cfs.forceFlush();
				 }
				 else {
					 liveBytes += size;
				 }
			 }
			 if (flushingBytes + liveBytes <= DatabaseDescriptor.getTotalMemtableSpaceInMB() * 1048576L) return;
			 logger.info(""estimated {
			}
			 bytes used by all memtables pre-flush"", liveBytes);
			 List<ColumnFamilyStore> sorted = new ArrayList<ColumnFamilyStore>();
			 Iterables.addAll(sorted, ColumnFamilyStore.all());
			 Collections.sort(sorted, new Comparator<ColumnFamilyStore>() {
				 public int compare(ColumnFamilyStore o1, ColumnFamilyStore o2) {
					 long size1 = o1.getTotalMemtableLiveSize();
					 long size2 = o2.getTotalMemtableLiveSize();
					 if (size1 < size2) return -1;
					 if (size1 > size2) return 1;
					 return 0;
				 }
			 }
			);
			 while (true) {
				 flushingBytes = countFlushingBytes();
				 if (liveBytes + flushingBytes <= DatabaseDescriptor.getTotalMemtableSpaceInMB() * 1048576L || sorted.isEmpty()) break;
				 ColumnFamilyStore cfs = sorted.remove(sorted.size() - 1);
				 long size = cfs.getTotalMemtableLiveSize();
				 logger.info(""flushing {
				}
				 to free up {
				}
				 bytes"", cfs, size);
				 liveBytes -= size;
				 cfs.forceFlush();
			 }
		 }
		 finally {
			 logger.trace(""memtable memory usage is {
			}
			 bytes with {
			}
			 live"", liveBytes + flushingBytes, liveBytes);
		 }
	 }
	 private long countFlushingBytes() {
		 long flushingBytes = 0;
		 for (ColumnFamilyStore cfs : ColumnFamilyStore.all()) {
			 for (Memtable memtable : cfs.getMemtablesPendingFlush()) flushingBytes += memtable.getLiveSize();
		 }
		 return flushingBytes;
	 }
}",0,0,0,0
"private void downloadVideo() {
	for (int index : table.getSelectedRows()) {
		YdlVideo video = (YdlVideo) model.getValueAt(index, 0);
		YdlMediaFormat fmt = video.mediaFormats.get(video.index);
		String title = video.title;
		System.out.println(title + "" "" + title + fmt.type);
		String file = XDMUtils.getFileName(title) + ""."" + fmt.ext;
		switch (fmt.type) {
			case YdlResponse.DASH_HTTP:DashMetadata dm = new DashMetadata();
			dm.setYdlUrl(txtURL.getText());
			dm.setUrl(fmt.videoSegments[0]);
			dm.setUrl2(fmt.audioSegments[0]);
			for (HttpHeader header : fmt.headers) {
				dm.getHeaders().addHeader(header);
			}
			for (HttpHeader header : fmt.headers2) {
				dm.getHeaders2().addHeader(header);
			}
			XDMApp.getInstance().addVideo(dm, file);
			break;
			case YdlResponse.HLS:HlsMetadata md = new HlsMetadata();
			md.setYdlUrl(txtURL.getText());
			md.setUrl(fmt.url);
			for (HttpHeader header : fmt.headers) {
				md.getHeaders().addHeader(header);
			}
			XDMApp.getInstance().addVideo(md, file);
			break;
			case YdlResponse.HDS:HdsMetadata hm = new HdsMetadata();
			hm.setYdlUrl(txtURL.getText());
			hm.setUrl(fmt.url);
			for (HttpHeader header : fmt.headers) {
				hm.getHeaders().addHeader(header);
			}
			XDMApp.getInstance().addVideo(hm, file);
			break;
			case YdlResponse.HTTP:HttpMetadata ht = new HttpMetadata();
			ht.setYdlUrl(txtURL.getText());
			ht.setUrl(fmt.url);
			for (HttpHeader header : fmt.headers) {
				ht.getHeaders().addHeader(header);
			}
			XDMApp.getInstance().addVideo(ht, file);
			break;
		}
	}
}",0,0,1,0
"public static void updateLoggingConfig() {
	 String logFilePath = getLogFilePath();
	 try {
		 if (logFilePath != null && logFilePath.length() > 0) {
			 File logFile = new File(logFilePath);
			 File logFileDir = logFile.getParentFile();
			 if (logFileDir != null && !logFileDir.exists()) {
				 if (!logFileDir.mkdirs()) {
					 DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_CREATE_LOG_FILE_DIR""));
					 throw new IOException();
				 }
			 }
		 }
		 else {
			 logFilePath = ""davmail.log"";
		 }
		 synchronized (Logger.getRootLogger()) {
			 FileAppender fileAppender = (FileAppender) Logger.getRootLogger().getAppender(""FileAppender"");
			 if (fileAppender == null) {
				 String logFileSize = Settings.getProperty(""davmail.logFileSize"");
				 if (logFileSize == null || logFileSize.length() == 0) {
					 logFileSize = ""1MB"";
				 }
				 if (""0"".equals(logFileSize)) {
					 fileAppender = new FileAppender();
				 }
				 else {
					 fileAppender = new RollingFileAppender();
					 ((RollingFileAppender) fileAppender).setMaxBackupIndex(2);
					 ((RollingFileAppender) fileAppender).setMaxFileSize(logFileSize);
				 }
				 fileAppender.setName(""FileAppender"");
				 fileAppender.setEncoding(""UTF-8"");
				 fileAppender.setLayout(new PatternLayout(""%d{
				ISO8601}
				 %-5p [%t] %c %x - %m%n""));
			 }
			 fileAppender.setFile(logFilePath, true, false, 8192);
			 Logger.getRootLogger().addAppender(fileAppender);
		 }
		 if (!Settings.getBooleanProperty(""davmail.server"")) {
			 ConsoleAppender consoleAppender = (ConsoleAppender) Logger.getRootLogger().getAppender(""ConsoleAppender"");
			 if (consoleAppender != null) {
				 consoleAppender.setThreshold(Level.OFF);
			 }
		 }
	 }
	 catch (IOException e) {
		 DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_SET_LOG_FILE_PATH""));
	 }
	 Settings.setLoggingLevel(""rootLogger"", Settings.getLoggingLevel(""rootLogger""));
	 Settings.setLoggingLevel(""davmail"", Settings.getLoggingLevel(""davmail""));
	 Settings.setLoggingLevel(""httpclient.wire"", Settings.getLoggingLevel(""httpclient.wire""));
	 Settings.setLoggingLevel(""org.apache.commons.httpclient"", Settings.getLoggingLevel(""org.apache.commons.httpclient""));
 }",0,0,1,0
"public class Client {
	 public static final Log LOG = LogFactory.getLog(""org.apache.hadoop.ipc.Client"");
	 private Hashtable connections = new Hashtable();
	 private Class valueClass;
	 private int timeout ;
	 private int counter;
	 private boolean running = true;
	 private Configuration conf;
	 private int maxIdleTime;
	 private int maxRetries;
	 private class Call {
		 int id;
		 Writable param;
		 Writable value;
		 RemoteException error;
		 long lastActivity;
		 boolean done;
		 protected Call(Writable param) {
			 this.param = param;
			 synchronized (Client.this) {
				 this.id = counter++;
			 }
			 touch();
		 }
		 public synchronized void callComplete() {
			 notify();
		 }
		 public synchronized void touch() {
			 lastActivity = System.currentTimeMillis();
		 }
		 public synchronized void setResult(Writable value, RemoteException error) {
			 this.value = value;
			 this.error = error;
			 this.done = true;
		 }
	 }
	 private class Connection extends Thread {
		 private InetSocketAddress address;
		 private Socket socket = null;
		 private DataInputStream in;
		 private DataOutputStream out;
		 private Hashtable calls = new Hashtable();
		 private Call readingCall;
		 private Call writingCall;
		 private int inUse = 0;
		 private long lastActivity = 0;
		 private boolean shouldCloseConnection = false;
		 public Connection(InetSocketAddress address) throws IOException {
			 if (address.isUnresolved()) {
				 throw new UnknownHostException(""unknown host: "" + address.getHostName());
			 }
			 this.address = address;
			 this.setName(""IPC Client connection to "" + address.toString());
			 this.setDaemon(true);
		 }
		 public synchronized void setupIOstreams() throws IOException {
			 if (socket != null) {
				 notify();
				 return;
			 }
			 short failures = 0;
			 while (true) {
				 try {
					 this.socket = new Socket();
					 this.socket.connect(address, FSConstants.READ_TIMEOUT);
					 break;
				 }
				 catch (IOException ie) {
					 if (failures == maxRetries) {
						 inUse = 0;
						 throw ie;
					 }
					 failures++;
					 LOG.info(""Retrying connect to server: "" + address + "". Already tried "" + failures + "" time(s)."");
					 try {
						 Thread.sleep(1000);
					 }
					 catch (InterruptedException iex){
					 }
				 }
			 }
			 socket.setSoTimeout(timeout);
			 this.in = new DataInputStream (new BufferedInputStream (new FilterInputStream(socket.getInputStream()) {
				 public int read(byte[] buf, int off, int len) throws IOException {
					 int value = super.read(buf, off, len);
					 if (readingCall != null) {
						 readingCall.touch();
					 }
					 return value;
				 }
			 }
			));
			 this.out = new DataOutputStream (new BufferedOutputStream (new FilterOutputStream(socket.getOutputStream()) {
				 public void write(byte[] buf, int o, int len) throws IOException {
					 out.write(buf, o, len);
					 if (writingCall != null) {
						 writingCall.touch();
					 }
				 }
			 }
			));
			 notify();
		 }
		 private synchronized boolean waitForWork() {
			 while ((inUse == 0 || socket == null) && !shouldCloseConnection) {
				 try {
					 wait();
				 }
				 catch (InterruptedException e) {
				}
			 }
			 return !shouldCloseConnection;
		 }
		 private synchronized void incrementRef() {
			 inUse++;
		 }
		 private synchronized void decrementRef() {
			 lastActivity = System.currentTimeMillis();
			 inUse--;
		 }
		 public synchronized boolean isIdle() {
			 if (inUse != 0) return false;
			 long currTime = System.currentTimeMillis();
			 if (currTime - lastActivity > maxIdleTime) return true;
			 return false;
		 }
		 public InetSocketAddress getRemoteAddress() {
			 return address;
		 }
		 public void setCloseConnection() {
			 shouldCloseConnection = true;
		 }
		 public void run() {
			 if (LOG.isDebugEnabled()) LOG.debug(getName() + "": starting"");
			 try {
				 while (running) {
					 int id;
					 if (waitForWork() == false) break;
					 try {
						 id = in.readInt();
					 }
					 catch (SocketTimeoutException e) {
						 continue;
					 }
					 if (LOG.isDebugEnabled()) LOG.debug(getName() + "" got value #"" + id);
					 Call call = (Call)calls.remove(new Integer(id));
					 boolean isError = in.readBoolean();
					 if (isError) {
						 RemoteException ex = new RemoteException(WritableUtils.readString(in), WritableUtils.readString(in));
						 call.setResult(null, ex);
					 }
					 else {
						 Writable value = makeValue();
						 try {
							 readingCall = call;
							 if(value instanceof Configurable) {
								 ((Configurable) value).setConf(conf);
							 }
							 value.readFields(in);
						 }
						 finally {
							 readingCall = null;
						 }
						 call.setResult(value, null);
					 }
					 call.callComplete();
					 decrementRef();
				 }
			 }
			 catch (EOFException eof) {
			 }
			 catch (Exception e) {
				 LOG.info(getName() + "" caught: "" + e, e);
			 }
			 finally {
				 synchronized (connections) {
					 if (connections.get(address) == this) {
						 connections.remove(address);
					 }
				 }
				 close();
			 }
		 }
		 public void sendParam(Call call) throws IOException {
			 boolean error = true;
			 try {
				 calls.put(new Integer(call.id), call);
				 synchronized (out) {
					 if (LOG.isDebugEnabled()) LOG.debug(getName() + "" sending #"" + call.id);
					 try {
						 writingCall = call;
						 DataOutputBuffer d = new DataOutputBuffer();
						 d.writeInt(call.id);
						 call.param.write(d);
						 byte[] data = d.getData();
						 int dataLength = d.getLength();
						 out.writeInt(dataLength);
						 out.write(data, 0, dataLength);
						 out.flush();
					 }
					 finally {
						 writingCall = null;
					 }
				 }
				 error = false;
			 }
			 finally {
				 if (error) {
					 synchronized (connections) {
						 if (connections.get(address) == this) connections.remove(address);
					 }
					 close();
				 }
			 }
		 }
		 public void close() {
			 if (socket == null) return;
			 try {
				 socket.close();
			 }
			 catch (IOException e) {
			}
			 if (LOG.isDebugEnabled()) LOG.debug(getName() + "": closing"");
		 }
	 }
	 private class ParallelCall extends Call {
		 private ParallelResults results;
		 private int index;
		 public ParallelCall(Writable param, ParallelResults results, int index) {
			 super(param);
			 this.results = results;
			 this.index = index;
		 }
		 public void callComplete() {
			 results.callComplete(this);
		 }
	 }
	 private static class ParallelResults {
		 private Writable[] values;
		 private int size;
		 private int count;
		 public ParallelResults(int size) {
			 this.values = new Writable[size];
			 this.size = size;
		 }
		 public synchronized void callComplete(ParallelCall call) {
			 values[call.index] = call.value;
			 count++;
			 if (count == size) notify();
		 }
	 }
	 private class ConnectionCuller extends Thread {
		 public static final int MIN_SLEEP_TIME = 1000;
		 public void run() {
			 LOG.info(getName() + "": starting"");
			 while (running) {
				 try {
					 Thread.sleep(MIN_SLEEP_TIME);
				 }
				 catch (InterruptedException ie) {
				}
				 synchronized (connections) {
					 Iterator i = connections.values().iterator();
					 while (i.hasNext()) {
						 Connection c = (Connection)i.next();
						 if (c.isIdle()) {
							 i.remove();
							 synchronized (c) {
								 c.setCloseConnection();
								 c.notify();
							 }
						 }
					 }
				 }
			 }
		 }
	 }
	 public Client(Class valueClass, Configuration conf) {
		 this.valueClass = valueClass;
		 this.timeout = conf.getInt(""ipc.client.timeout"",10000);
		 this.maxIdleTime = conf.getInt(""ipc.client.connection.maxidletime"",1000);
		 this.maxRetries = conf.getInt(""ipc.client.connect.max.retries"", 10);
		 this.conf = conf;
		 Thread t = new ConnectionCuller();
		 t.setDaemon(true);
		 t.setName(valueClass.getName() + "" Connection Culler"");
		 LOG.info(valueClass.getName() + ""Connection culler maxidletime= "" + maxIdleTime + ""ms"");
		 t.start();
	 }
	 public void stop() {
		 LOG.info(""Stopping client"");
		 running = false;
	 }
	 public void setTimeout(int timeout) {
		 this.timeout = timeout;
	 }
	 public Writable call(Writable param, InetSocketAddress address) throws IOException {
		 Connection connection = getConnection(address);
		 Call call = new Call(param);
		 synchronized (call) {
			 connection.sendParam(call);
			 long wait = timeout;
			 do {
				 try {
					 call.wait(wait);
				 }
				 catch (InterruptedException e) {
				}
				 wait = timeout - (System.currentTimeMillis() - call.lastActivity);
			 }
			 while (!call.done && wait > 0);
			 if (call.error != null) {
				 throw call.error;
			 }
			 else if (!call.done) {
				 throw new SocketTimeoutException(""timed out waiting for rpc response"");
			 }
			 else {
				 return call.value;
			 }
		 }
	 }
	 public Writable[] call(Writable[] params, InetSocketAddress[] addresses) throws IOException {
		 if (addresses.length == 0) return new Writable[0];
		 ParallelResults results = new ParallelResults(params.length);
		 synchronized (results) {
			 for (int i = 0;
			 i < params.length;
			 i++) {
				 ParallelCall call = new ParallelCall(params[i], results, i);
				 try {
					 Connection connection = getConnection(addresses[i]);
					 connection.sendParam(call);
				 }
				 catch (IOException e) {
					 LOG.info(""Calling ""+addresses[i]+"" caught: "" + e);
					 results.size--;
				 }
			 }
			 try {
				 results.wait(timeout);
			 }
			 catch (InterruptedException e) {
			}
			 if (results.count == 0) {
				 throw new IOException(""no responses"");
			 }
			 else {
				 return results.values;
			 }
		 }
	 }
	 private Connection getConnection(InetSocketAddress address) throws IOException {
		 Connection connection;
		 synchronized (connections) {
			 connection = (Connection)connections.get(address);
			 if (connection == null) {
				 connection = new Connection(address);
				 connections.put(address, connection);
				 connection.start();
			 }
			 connection.incrementRef();
		 }
		 connection.setupIOstreams();
		 return connection;
	 }
	 private Writable makeValue() {
		 Writable value;
		 try {
			 value = (Writable)valueClass.newInstance();
		 }
		 catch (InstantiationException e) {
			 throw new RuntimeException(e.toString());
		 }
		 catch (IllegalAccessException e) {
			 throw new RuntimeException(e.toString());
		 }
		 return value;
	 }
}",0,0,0,0
"public static class Builder {
	 final SystemModuleFinder systemModulePath;
	 final Set<String> rootModules = new HashSet<>();
	 final List<Archive> initialArchives = new ArrayList<>();
	 final List<Path> paths = new ArrayList<>();
	 final List<Path> classPaths = new ArrayList<>();
	 ModuleFinder upgradeModulePath;
	 ModuleFinder appModulePath;
	 boolean addAllApplicationModules;
	 boolean addAllDefaultModules;
	 boolean addAllSystemModules;
	 boolean allModules;
	 Runtime.Version version;
	 public Builder() {
		 this.systemModulePath = new SystemModuleFinder();
	 }
	 public Builder(String javaHome) throws IOException {
		 this.systemModulePath = SystemModuleFinder.JAVA_HOME.equals(javaHome) ? new SystemModuleFinder() : new SystemModuleFinder(javaHome);
	 }
	 public Builder upgradeModulePath(String upgradeModulePath) {
		 this.upgradeModulePath = createModulePathFinder(upgradeModulePath);
		 return this;
	 }
	 public Builder appModulePath(String modulePath) {
		 this.appModulePath = createModulePathFinder(modulePath);
		 return this;
	 }
	 public Builder addmods(Set<String> addmods) {
		 for (String mn : addmods) {
			 switch (mn) {
				 case ALL_MODULE_PATH: this.addAllApplicationModules = true;
				 break;
				 case ALL_DEFAULT: this.addAllDefaultModules = true;
				 break;
				 case ALL_SYSTEM: this.addAllSystemModules = true;
				 break;
				 default: this.rootModules.add(mn);
			 }
		 }
		 return this;
	 }
	 public Builder allModules() {
		 this.allModules = true;
		 return this;
	 }
	 public Builder multiRelease(Runtime.Version version) {
		 this.version = version;
		 return this;
	 }
	 public Builder addRoot(Path path) {
		 Archive archive = Archive.getInstance(path, version);
		 if (archive.contains(MODULE_INFO)) {
			 paths.add(path);
		 }
		 else {
			 initialArchives.add(archive);
		 }
		 return this;
	 }
	 public Builder addClassPath(String classPath) {
		 this.classPaths.addAll(getClassPaths(classPath));
		 return this;
	 }
	 public JdepsConfiguration build() throws IOException {
		 ModuleFinder finder = systemModulePath;
		 if (upgradeModulePath != null) {
			 finder = ModuleFinder.compose(upgradeModulePath, systemModulePath);
		 }
		 if (appModulePath != null) {
			 finder = ModuleFinder.compose(finder, appModulePath);
		 }
		 if (!paths.isEmpty()) {
			 ModuleFinder otherModulePath = ModuleFinder.of(paths.toArray(new Path[0]));
			 finder = ModuleFinder.compose(finder, otherModulePath);
			 otherModulePath.findAll().stream() .map(mref -> mref.descriptor().name()) .forEach(rootModules::add);
		 }
		 if ((addAllApplicationModules || allModules) && appModulePath != null) {
			 appModulePath.findAll().stream() .map(mref -> mref.descriptor().name()) .forEach(rootModules::add);
		 }
		 if (addAllSystemModules && rootModules.isEmpty() && initialArchives.isEmpty() && classPaths.isEmpty()) {
			 systemModulePath.findAll() .stream() .map(mref -> mref.descriptor().name()) .forEach(rootModules::add);
		 }
		 return new JdepsConfiguration(systemModulePath, finder, rootModules, classPaths, initialArchives, addAllDefaultModules, allModules, version);
	 }
	 private static ModuleFinder createModulePathFinder(String mpaths) {
		 if (mpaths == null) {
			 return null;
		 }
		 else {
			 String[] dirs = mpaths.split(File.pathSeparator);
			 Path[] paths = new Path[dirs.length];
			 int i = 0;
			 for (String dir : dirs) {
				 paths[i++] = Paths.get(dir);
			 }
			 return ModuleFinder.of(paths);
		 }
	 }
	 private List<Path> getClassPaths(String cpaths) {
		 if (cpaths.isEmpty()) {
			 return Collections.emptyList();
		 }
		 List<Path> paths = new ArrayList<>();
		 for (String p : cpaths.split(File.pathSeparator)) {
			 if (p.length() > 0) {
				 int i = p.lastIndexOf("".*"");
				 if (i > 0) {
					 Path dir = Paths.get(p.substring(0, i));
					 try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, ""*.jar"")) {
						 for (Path entry : stream) {
							 paths.add(entry);
						 }
					 }
					 catch (IOException e) {
						 throw new UncheckedIOException(e);
					 }
				 }
				 else {
					 paths.add(Paths.get(p));
				 }
			 }
		 }
		 return paths;
	 }
 }",1,0,0,0
"public BufferedImage extraxtLetter(BufferedImage image, boolean[][] visited, int startX, int startY) {
	 int gapWidth = cropWidth / 5 * 2;
	 int gapHeight = cropHeight / 5 * 2;
	 LinkedList<String> queue = new LinkedList<String>();
	 BufferedImage letter = new BufferedImage(cropWidth, cropHeight, image.getType());
	 Color white = Color.WHITE;
	 Color black = Color.BLACK;
	 for (int i = 0;
	 i < cropHeight;
	 i++) {
		 for (int j = 0;
		 j < cropWidth;
		 j++) {
			 letter.setRGB(j, i, white.getRGB());
		 }
	 }
	 int countPixels = 0;
	 String positions = startX + "" "" + startY;
	 visited[startX][startY] = true;
	 queue.addLast(positions);
	 while (!queue.isEmpty()) {
		 String pos = queue.removeFirst();
		 String[] posArray = pos.split("" "");
		 int H = Integer.parseInt(posArray[0]);
		 int W = Integer.parseInt(posArray[1]);
		 visited[H][W] = true;
		 int posW = W - startY + gapWidth;
		 int posH = H - startX + gapHeight;
		 countPixels++;
		 letter.setRGB(posW, posH, black.getRGB());
		 int color;
		 int blackInt = 0;
		 for (int i = H - 1;
		 i <= H + 1;
		 i++) {
			 for (int j = W - 1;
			 j <= W + 1;
			 j++) {
				 if (i >= 0 && j >= 0 && i < image.getHeight() && j < image.getWidth()) {
					 if (!visited[i][j]) {
						 color = new Color(image.getRGB(j, i)).getRed();
						 if (color == blackInt) {
							 visited[i][j] = true;
							 String tmpPos = i + "" "" + j;
							 queue.addLast(tmpPos);
						 }
					 }
				 }
			 }
		 }
	 }
	 if (countPixels < trashSize) {
		 return null;
	 }
	 return letter;
 }",0,0,1,0
"public class WarningMessage extends ConsoleMessage {
	public WarningMessage(String content) {
		super(content, ConsoleMessage.WARNING, ConsoleMessage.WARNING_STYLE);
	}
}",0,0,0,0
"class XmlInputArchive implements InputArchive {
	 static private class Value {
		 private String type;
		 private StringBuffer sb;
		 public Value(String t) {
			 type = t;
			 sb = new StringBuffer();
		 }
		 public void addChars(char[] buf, int offset, int len) {
			 sb.append(buf, offset, len);
		 }
		 public String getValue() {
			 return sb.toString();
		 }
		 public String getType() {
			 return type;
		 }
	 }
	 private class XMLParser extends DefaultHandler {
		 private boolean charsValid = false;
		 private ArrayList valList;
		 private XMLParser(ArrayList vlist) {
			 valList = vlist;
		 }
		 public void startDocument() throws SAXException {
		}
		 public void endDocument() throws SAXException {
		}
		 public void startElement(String ns, String sname, String qname, Attributes attrs) throws SAXException {
			 charsValid = false;
			 if (""boolean"".equals(qname) || ""i4"".equals(qname) || ""int"".equals(qname) || ""string"".equals(qname) || ""double"".equals(qname) || ""ex:i1"".equals(qname) || ""ex:i8"".equals(qname) || ""ex:float"".equals(qname)) {
				 charsValid = true;
				 valList.add(new Value(qname));
			 }
			 else if (""struct"".equals(qname) || ""array"".equals(qname)) {
				 valList.add(new Value(qname));
			 }
		 }
		 public void endElement(String ns, String sname, String qname) throws SAXException {
			 charsValid = false;
			 if (""struct"".equals(qname) || ""array"".equals(qname)) {
				 valList.add(new Value(""/""+qname));
			 }
		 }
		 public void characters(char buf[], int offset, int len) throws SAXException {
			 if (charsValid) {
				 Value v = (Value) valList.get(valList.size()-1);
				 v.addChars(buf, offset,len);
			 }
		 }
	 }
	 private class XmlIndex implements Index {
		 public boolean done() {
			 Value v = (Value) valList.get(vIdx);
			 if (""/array"".equals(v.getType())) {
				 valList.set(vIdx, null);
				 vIdx++;
				 return true;
			 }
			 else {
				 return false;
			 }
		 }
		 public void incr() {
		}
	 }
	 private ArrayList valList;
	 private int vLen;
	 private int vIdx;
	 private Value next() throws IOException {
		 if (vIdx < vLen) {
			 Value v = (Value) valList.get(vIdx);
			 valList.set(vIdx, null);
			 vIdx++;
			 return v;
		 }
		 else {
			 throw new IOException(""Error in deserialization."");
		 }
	 }
	 static XmlInputArchive getArchive(InputStream strm) throws ParserConfigurationException, SAXException, IOException {
		 return new XmlInputArchive(strm);
	 }
	 public XmlInputArchive(InputStream in) throws ParserConfigurationException, SAXException, IOException {
		 valList = new ArrayList();
		 DefaultHandler handler = new XMLParser(valList);
		 SAXParserFactory factory = SAXParserFactory.newInstance();
		 SAXParser parser = factory.newSAXParser();
		 parser.parse(in, handler);
		 vLen = valList.size();
		 vIdx = 0;
	 }
	 public byte readByte(String tag) throws IOException {
		 Value v = next();
		 if (!""ex:i1"".equals(v.getType())) {
			 throw new IOException(""Error deserializing ""+tag+""."");
		 }
		 return Byte.parseByte(v.getValue());
	 }
	 public boolean readBool(String tag) throws IOException {
		 Value v = next();
		 if (!""boolean"".equals(v.getType())) {
			 throw new IOException(""Error deserializing ""+tag+""."");
		 }
		 return ""1"".equals(v.getValue());
	 }
	 public int readInt(String tag) throws IOException {
		 Value v = next();
		 if (!""i4"".equals(v.getType()) && !""int"".equals(v.getType())) {
			 throw new IOException(""Error deserializing ""+tag+""."");
		 }
		 return Integer.parseInt(v.getValue());
	 }
	 public long readLong(String tag) throws IOException {
		 Value v = next();
		 if (!""ex:i8"".equals(v.getType())) {
			 throw new IOException(""Error deserializing ""+tag+""."");
		 }
		 return Long.parseLong(v.getValue());
	 }
	 public float readFloat(String tag) throws IOException {
		 Value v = next();
		 if (!""ex:float"".equals(v.getType())) {
			 throw new IOException(""Error deserializing ""+tag+""."");
		 }
		 return Float.parseFloat(v.getValue());
	 }
	 public double readDouble(String tag) throws IOException {
		 Value v = next();
		 if (!""double"".equals(v.getType())) {
			 throw new IOException(""Error deserializing ""+tag+""."");
		 }
		 return Double.parseDouble(v.getValue());
	 }
	 public Text readString(String tag) throws IOException {
		 Value v = next();
		 if (!""string"".equals(v.getType())) {
			 throw new IOException(""Error deserializing ""+tag+""."");
		 }
		 return Utils.fromXMLString(v.getValue());
	 }
	 public ByteArrayOutputStream readBuffer(String tag) throws IOException {
		 Value v = next();
		 if (!""string"".equals(v.getType())) {
			 throw new IOException(""Error deserializing ""+tag+""."");
		 }
		 return Utils.fromXMLBuffer(v.getValue());
	 }
	 public void readRecord(Record r, String tag) throws IOException {
		 r.deserialize(this, tag);
	 }
	 public void startRecord(String tag) throws IOException {
		 Value v = next();
		 if (!""struct"".equals(v.getType())) {
			 throw new IOException(""Error deserializing ""+tag+""."");
		 }
	 }
	 public void endRecord(String tag) throws IOException {
		 Value v = next();
		 if (!""/struct"".equals(v.getType())) {
			 throw new IOException(""Error deserializing ""+tag+""."");
		 }
	 }
	 public Index startVector(String tag) throws IOException {
		 Value v = next();
		 if (!""array"".equals(v.getType())) {
			 throw new IOException(""Error deserializing ""+tag+""."");
		 }
		 return new XmlIndex();
	 }
	 public void endVector(String tag) throws IOException {
	}
	 public Index startMap(String tag) throws IOException {
		 return startVector(tag);
	 }
	 public void endMap(String tag) throws IOException {
		 endVector(tag);
	 }
}",0,0,0,0
"public final class RenderingHintsKeyExt {
	 public static final int KEY_BASE;
	 public static final RenderingHints.Key KEY_TRANSCODING;
	 public static final String VALUE_TRANSCODING_PRINTING = new String(""Printing"");
	 public static final RenderingHints.Key KEY_AREA_OF_INTEREST;
	 public static final RenderingHints.Key KEY_BUFFERED_IMAGE;
	 public static final RenderingHints.Key KEY_COLORSPACE;
	 static {
		 int base = 10100;
		 RenderingHints.Key trans=null, aoi=null, bi=null, cs=null;
		 while (true) {
			 int val = base;
			 try {
				 trans = new TranscodingHintKey (val++);
				 aoi = new AreaOfInterestHintKey(val++);
				 bi = new BufferedImageHintKey (val++);
				 cs = new ColorSpaceHintKey (val++);
			 }
			 catch (Exception e) {
				 System.err.println (""You have loaded the Batik jar files more than once\n"" + ""in the same JVM this is likely a problem with the\n"" + ""way you are loading the Batik jar files."");
				 base = (int)(Math.random()*2000000);
				 continue;
			 }
			 break;
		 }
		 KEY_BASE = base;
		 KEY_TRANSCODING = trans;
		 KEY_AREA_OF_INTEREST = aoi;
		 KEY_BUFFERED_IMAGE = bi;
		 KEY_COLORSPACE = cs;
	 }
	 private RenderingHintsKeyExt(){
	 }
}",0,0,0,0
"public Option[] getOptions() {
	 return new Option[] {
		 OptionBuilder .withArgName(""HOST"") .hasArg() .isRequired(false) .withDescription(""Address of the Zookeeper ensemble;
	 defaults to: ""+ZK_HOST) .create(""zkHost""), OptionBuilder .withArgName(""CONFIG"") .hasArg() .isRequired(false) .withDescription(""Autoscaling config file, defaults to the one deployed in the cluster."") .withLongOpt(""config"") .create(""a""), OptionBuilder .withDescription(""Show calculated suggestions"") .withLongOpt(""suggestions"") .create(""s""), OptionBuilder .withDescription(""Show ClusterState (collections layout)"") .withLongOpt(""clusterState"") .create(""c""), OptionBuilder .withDescription(""Show calculated diagnostics"") .withLongOpt(""diagnostics"") .create(""d""), OptionBuilder .withDescription(""Show sorted nodes with diagnostics"") .withLongOpt(""sortedNodes"") .create(""n""), OptionBuilder .withDescription(""Redact node and collection names (original names will be consistently randomized)"") .withLongOpt(""redact"") .create(""r""), OptionBuilder .withDescription(""Show summarized collection & node statistics."") .create(""stats""), OptionBuilder .withDescription(""Turn on all options to get all available information."") .create(""all"") }
	;
 }",0,0,1,0
"public IPageVersionManager newVersionManager(Page page){
	return new UndoPageVersionManager(page, 20);
}",0,0,0,0
"public interface ApproxEqualsDetector<T> {
	 public boolean areObjectsApproxEquals(final T lhs, final T rhs);
	 public Tolerance getDefaultTolerance();
	 public T convertStringToObject(final String string) throws SmartUriException;
	 public Class<?> getTypeClass();
	 public IRI getXmlSchemaUri();
	 public default boolean areApproxEquals(final String lhs, final String rhs) throws SmartUriException {
		 final T object1 = convertStringToObject(lhs);
		 final T object2 = convertStringToObject(rhs);
		 return areObjectsApproxEquals(object1, object2);
	 }
}",0,0,0,0
"public static final class SecretKeyEntry implements Entry {
	 private final SecretKey sKey;
	 public SecretKeyEntry(SecretKey secretKey) {
		 if (secretKey == null) {
			 throw new NullPointerException(""invalid null input"");
		 }
		 this.sKey = secretKey;
	 }
	 public SecretKey getSecretKey() {
		 return sKey;
	 }
	 public String toString() {
		 return ""Secret key entry with algorithm "" + sKey.getAlgorithm();
	 }
 }",0,1,0,0
"public class CompoundAuthorizationStrategy implements IAuthorizationStrategy{
	private final List<IAuthorizationStrategy> strategies = new ArrayList<IAuthorizationStrategy>();
	public final void add(IAuthorizationStrategy strategy){
		if (strategy == null){
			throw new IllegalArgumentException(""Strategy argument cannot be null"");
		}
		strategies.add(strategy);
	}
	public final <T extends Component> boolean isInstantiationAuthorized(Class<T> componentClass){
		int size = strategies.size();
		for (int i = 0;
		 i < size;
		 i++){
			IAuthorizationStrategy strategy = strategies.get(i);
			if (!strategy.isInstantiationAuthorized(componentClass)){
				return false;
			}
		}
		return true;
	}
	public final boolean isActionAuthorized(Component component, Action action){
		int size = strategies.size();
		for (int i = 0;
		 i < size;
		 i++){
			IAuthorizationStrategy strategy = strategies.get(i);
			if (!strategy.isActionAuthorized(component, action)){
				return false;
			}
		}
		return true;
	}
}",0,0,0,0
"public class ExactKeyMatcher implements NodeMatcher<Operator, OperatorPlan<Operator>> {
	 public Map<OperatorKey, OperatorKey> match(OperatorPlan<Operator> plan1, OperatorPlan<Operator> plan2, StringBuilder messages) {
		 int diff1 = diffKeys(plan1, plan2, messages, ""plan2"") ;
		 int diff2 = diffKeys(plan2, plan1, messages, ""plan1"") ;
		 if ( (diff1 != 0) || (diff2 != 0) ) {
			 return null ;
		 }
		 Iterator<Operator> iter = plan1.getKeys().values().iterator() ;
		 Map<OperatorKey, OperatorKey> outputMap = new HashMap<OperatorKey, OperatorKey>() ;
		 while(iter.hasNext()) {
			 Operator op = iter.next() ;
			 outputMap.put(op.getOperatorKey(), op.getOperatorKey()) ;
		 }
		 return outputMap;
	 }
	 private int diffKeys(OperatorPlan<Operator> plan1, OperatorPlan<Operator> plan2, StringBuilder messages, String plan2Name) {
		 int count = 0 ;
		 Map<OperatorKey, Operator> keyList = plan1.getKeys() ;
		 Iterator<OperatorKey> iter = keyList.keySet().iterator() ;
		 while(iter.hasNext()) {
			 OperatorKey key = iter.next() ;
			 if (plan2.getOperator(key) == null) {
				 Operator op1 = plan1.getOperator(key) ;
				 if (messages != null) {
					 messages.append(op1.getClass().getSimpleName()) ;
					 appendOpKey(op1.getOperatorKey(), messages) ;
					 messages.append("" doesn't exist"") ;
					 if (plan2Name != null) {
						 messages.append("" in "") ;
						 messages.append(plan2Name) ;
						 messages.append(""\n"") ;
					 }
				 }
				 count++ ;
			 }
		 }
		 return count ;
	 }
	 protected void appendOpKey(OperatorKey operatorKey, StringBuilder sb) {
		 sb.append(""("") ;
		 sb.append(operatorKey.toString()) ;
		 sb.append("")"") ;
	 }
}",1,0,0,0
"public abstract class BaseFragListBuilder implements FragListBuilder {
	 public static final int MARGIN_DEFAULT = 6;
	 public static final int MIN_FRAG_CHAR_SIZE_FACTOR = 3;
	 final int margin;
	 final int minFragCharSize;
	 public BaseFragListBuilder( int margin ){
		 if( margin < 0 ) throw new IllegalArgumentException( ""margin("" + margin + "") is too small. It must be 0 or higher."" );
		 this.margin = margin;
		 this.minFragCharSize = Math.max( 1, margin * MIN_FRAG_CHAR_SIZE_FACTOR );
	 }
	 public BaseFragListBuilder(){
		 this( MARGIN_DEFAULT );
	 }
	 protected FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, FieldFragList fieldFragList, int fragCharSize ){
		 if( fragCharSize < minFragCharSize ) throw new IllegalArgumentException( ""fragCharSize("" + fragCharSize + "") is too small. It must be "" + minFragCharSize + "" or higher."" );
		 List<WeightedPhraseInfo> wpil = new ArrayList<>();
		 IteratorQueue<WeightedPhraseInfo> queue = new IteratorQueue<>(fieldPhraseList.getPhraseList().iterator());
		 WeightedPhraseInfo phraseInfo = null;
		 int startOffset = 0;
		 while((phraseInfo = queue.top()) != null){
			 if( phraseInfo.getStartOffset() < startOffset ) {
				 queue.removeTop();
				 continue;
			 }
			 wpil.clear();
			 final int currentPhraseStartOffset = phraseInfo.getStartOffset();
			 int currentPhraseEndOffset = phraseInfo.getEndOffset();
			 int spanStart = Math.max(currentPhraseStartOffset - margin, startOffset);
			 int spanEnd = Math.max(currentPhraseEndOffset, spanStart + fragCharSize);
			 if (acceptPhrase(queue.removeTop(), currentPhraseEndOffset - currentPhraseStartOffset, fragCharSize)) {
				 wpil.add(phraseInfo);
			 }
			 while((phraseInfo = queue.top()) != null) {
				 if (phraseInfo.getEndOffset() <= spanEnd) {
					 currentPhraseEndOffset = phraseInfo.getEndOffset();
					 if (acceptPhrase(queue.removeTop(), currentPhraseEndOffset - currentPhraseStartOffset, fragCharSize)) {
						 wpil.add(phraseInfo);
					 }
				 }
				 else {
					 break;
				 }
			 }
			 if (wpil.isEmpty()) {
				 continue;
			 }
			 final int matchLen = currentPhraseEndOffset - currentPhraseStartOffset;
			 final int newMargin = Math.max(0, (fragCharSize-matchLen)/2);
			 spanStart = currentPhraseStartOffset - newMargin;
			 if (spanStart < startOffset) {
				 spanStart = startOffset;
			 }
			 spanEnd = spanStart + Math.max(matchLen, fragCharSize);
			 startOffset = spanEnd;
			 fieldFragList.add(spanStart, spanEnd, wpil);
		 }
		 return fieldFragList;
	 }
	 protected boolean acceptPhrase(WeightedPhraseInfo info, int matchLength, int fragCharSize) {
		 return info.getTermsOffsets().size() <= 1 || matchLength <= fragCharSize;
	 }
	 private static final class IteratorQueue<T> {
		 private final Iterator<T> iter;
		 private T top;
		 public IteratorQueue(Iterator<T> iter) {
			 this.iter = iter;
			 T removeTop = removeTop();
			 assert removeTop == null;
		 }
		 public T top() {
			 return top;
		 }
		 public T removeTop() {
			 T currentTop = top;
			 if (iter.hasNext()) {
				 top = iter.next();
			 }
			 else {
				 top = null;
			 }
			 return currentTop;
		 }
	 }
}",0,0,0,0
"private boolean r_prelude() {
	 int among_var;
	 int v_1;
	 int v_2;
	 int v_3;
	 int v_4;
	 int v_5;
	 v_1 = cursor;
	 replab0: while(true) {
		 v_2 = cursor;
		 lab1: do {
			 bra = cursor;
			 among_var = find_among(a_0, 7);
			 if (among_var == 0) {
				 break lab1;
			 }
			 ket = cursor;
			 switch(among_var) {
				 case 0: break lab1;
				 case 1: slice_from(""\u00E0"");
				 break;
				 case 2: slice_from(""\u00E8"");
				 break;
				 case 3: slice_from(""\u00EC"");
				 break;
				 case 4: slice_from(""\u00F2"");
				 break;
				 case 5: slice_from(""\u00F9"");
				 break;
				 case 6: slice_from(""qU"");
				 break;
				 case 7: if (cursor >= limit) {
					 break lab1;
				 }
				 cursor++;
				 break;
			 }
			 continue replab0;
		 }
		 while (false);
		 cursor = v_2;
		 break replab0;
	 }
	 cursor = v_1;
	 replab2: while(true) {
		 v_3 = cursor;
		 lab3: do {
			 golab4: while(true) {
				 v_4 = cursor;
				 lab5: do {
					 if (!(in_grouping(g_v, 97, 249))) {
						 break lab5;
					 }
					 bra = cursor;
					 lab6: do {
						 v_5 = cursor;
						 lab7: do {
							 if (!(eq_s(1, ""u""))) {
								 break lab7;
							 }
							 ket = cursor;
							 if (!(in_grouping(g_v, 97, 249))) {
								 break lab7;
							 }
							 slice_from(""U"");
							 break lab6;
						 }
						 while (false);
						 cursor = v_5;
						 if (!(eq_s(1, ""i""))) {
							 break lab5;
						 }
						 ket = cursor;
						 if (!(in_grouping(g_v, 97, 249))) {
							 break lab5;
						 }
						 slice_from(""I"");
					 }
					 while (false);
					 cursor = v_4;
					 break golab4;
				 }
				 while (false);
				 cursor = v_4;
				 if (cursor >= limit) {
					 break lab3;
				 }
				 cursor++;
			 }
			 continue replab2;
		 }
		 while (false);
		 cursor = v_3;
		 break replab2;
	 }
	 return true;
 }",0,0,1,0
"public static IVersionedSerializer<EndpointState> serializer() {
	 return serializer;
 }",0,0,0,0
"public abstract class DataView<T> extends DataViewBase<T>{
	private static final long serialVersionUID = 1L;
	protected DataView(String id, IDataProvider<T> dataProvider){
		super(id, dataProvider);
	}
	protected DataView(String id, IDataProvider<T> dataProvider, long itemsPerPage){
		super(id, dataProvider);
		setItemsPerPage(itemsPerPage);
	}
	public IDataProvider<T> getDataProvider(){
		return internalGetDataProvider();
	}
}",0,0,0,0
"protected void drawVerticalItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset dataset, int row, int column);",0,0,0,1
"public class BinaryMemtable implements IFlushable{
	 private static final Logger logger = LoggerFactory.getLogger(BinaryMemtable.class);
	 private final int threshold = DatabaseDescriptor.getBMTThreshold() * 1024 * 1024;
	 private final AtomicInteger currentSize = new AtomicInteger(0);
	 private boolean isFrozen = false;
	 private final Map<DecoratedKey, ByteBuffer> columnFamilies = new NonBlockingHashMap<DecoratedKey, ByteBuffer>();
	 private final Lock lock = new ReentrantLock();
	 Condition condition;
	 private final IPartitioner partitioner = StorageService.getPartitioner();
	 private final ColumnFamilyStore cfs;
	 public BinaryMemtable(ColumnFamilyStore cfs) {
		 this.cfs = cfs;
		 condition = lock.newCondition();
	 }
	 boolean isThresholdViolated() {
		 return currentSize.get() >= threshold;
	 }
	 void put(DecoratedKey key, ByteBuffer buffer) {
		 if (isThresholdViolated()) {
			 lock.lock();
			 try {
				 if (!isFrozen) {
					 isFrozen = true;
					 cfs.submitFlush(this, new CountDownLatch(1), null);
					 cfs.switchBinaryMemtable(key, buffer);
				 }
				 else {
					 cfs.applyBinary(key, buffer);
				 }
			 }
			 finally {
				 lock.unlock();
			 }
		 }
		 else {
			 resolve(key, buffer);
		 }
	 }
	 public boolean isClean() {
		 return columnFamilies.isEmpty();
	 }
	 private void resolve(DecoratedKey key, ByteBuffer buffer) {
		 columnFamilies.put(key, buffer);
		 currentSize.addAndGet(buffer.remaining() + key.key.remaining());
	 }
	 private List<DecoratedKey> getSortedKeys() {
		 assert !columnFamilies.isEmpty();
		 logger.info(""Sorting "" + this);
		 List<DecoratedKey> keys = new ArrayList<DecoratedKey>(columnFamilies.keySet());
		 Collections.sort(keys);
		 return keys;
	 }
	 private SSTableReader writeSortedContents(List<DecoratedKey> sortedKeys, ReplayPosition context) throws IOException {
		 logger.info(""Writing "" + this);
		 SSTableWriter writer = cfs.createFlushWriter(sortedKeys.size(), DatabaseDescriptor.getBMTThreshold(), context);
		 for (DecoratedKey key : sortedKeys) {
			 ByteBuffer bytes = columnFamilies.get(key);
			 assert bytes.remaining() > 0;
			 writer.append(key, bytes);
		 }
		 SSTableReader sstable = writer.closeAndOpenReader();
		 logger.info(""Completed flushing "" + writer.getFilename());
		 return sstable;
	 }
	 public void flushAndSignal(final CountDownLatch latch, ExecutorService sorter, final ExecutorService writer, final ReplayPosition context) {
		 sorter.execute(new Runnable() {
			 public void run() {
				 final List<DecoratedKey> sortedKeys = getSortedKeys();
				 writer.execute(new WrappedRunnable() {
					 public void runMayThrow() throws IOException {
						 cfs.addSSTable(writeSortedContents(sortedKeys, context));
						 latch.countDown();
					 }
				 }
				);
			 }
		 }
		);
	 }
}",0,0,0,0
"public MuxMessageDispatcher(short scopeId, Channel channel, MessageListener messageListener, MembershipListener membershipListener, RequestHandler handler);",0,0,0,1
"private static void simpleGenericNameOf( StringBuilder sb, Type type ) {
	 if( type instanceof Class ) {
		 sb.append( ( (Class) type ).getSimpleName() );
	 }
	 else if( type instanceof ParameterizedType ) {
		 ParameterizedType pt = (ParameterizedType) type;
		 simpleGenericNameOf( sb, pt.getRawType() );
		 sb.append( ""<"" );
		 boolean atLeastOne = false;
		 for( Type typeArgument : pt.getActualTypeArguments() ) {
			 if( atLeastOne ) {
				 sb.append( "", "" );
			 }
			 simpleGenericNameOf( sb, typeArgument );
			 atLeastOne = true;
		 }
		 sb.append( "">"" );
	 }
	 else if( type instanceof GenericArrayType ) {
		 GenericArrayType gat = (GenericArrayType) type;
		 simpleGenericNameOf( sb, gat.getGenericComponentType() );
		 sb.append( ""[]"" );
	 }
	 else if( type instanceof TypeVariable ) {
		 TypeVariable tv = (TypeVariable) type;
		 sb.append( tv.getName() );
	 }
	 else if( type instanceof WildcardType ) {
		 WildcardType wt = (WildcardType) type;
		 sb.append( ""? extends "" );
		 boolean atLeastOne = false;
		 for( Type typeArgument : wt.getUpperBounds() ) {
			 if( atLeastOne ) {
				 sb.append( "", "" );
			 }
			 simpleGenericNameOf( sb, typeArgument );
			 atLeastOne = true;
		 }
	 }
	 else {
		 throw new IllegalArgumentException( ""Don't know how to deal with type:"" + type );
	 }
 }",0,0,1,0
"public void addImage(Image image, float a, float b, float c, float d, float e, float f, boolean inlineImage) throws DocumentException {
	 try {
		 if (image.getLayer() != null) beginLayer(image.getLayer());
		 if (image.isImgTemplate()) {
			 writer.addDirectImageSimple(image);
			 PdfTemplate template = image.getTemplateData();
			 float w = template.getWidth();
			 float h = template.getHeight();
			 addTemplate(template, a / w, b / w, c / h, d / h, e, f);
		 }
		 else {
			 content.append(""q "");
			 content.append(a).append(' ');
			 content.append(b).append(' ');
			 content.append(c).append(' ');
			 content.append(d).append(' ');
			 content.append(e).append(' ');
			 content.append(f).append("" cm"");
			 if (inlineImage) {
				 content.append(""\nBI\n"");
				 PdfImage pimage = new PdfImage(image, """", null);
				 if (image instanceof ImgJBIG2) {
					 byte[] globals = ((ImgJBIG2)image).getGlobalBytes();
					 if (globals != null) {
						 PdfDictionary decodeparms = new PdfDictionary();
						 decodeparms.put(PdfName.JBIG2GLOBALS, writer.getReferenceJBIG2Globals(globals));
						 pimage.put(PdfName.DECODEPARMS, decodeparms);
					 }
				 }
				 for (Object element : pimage.getKeys()) {
					 PdfName key = (PdfName)element;
					 PdfObject value = pimage.get(key);
					 String s = abrev.get(key);
					 if (s == null) continue;
					 content.append(s);
					 boolean check = true;
					 if (key.equals(PdfName.COLORSPACE) && value.isArray()) {
						 PdfArray ar = (PdfArray)value;
						 if (ar.size() == 4 && PdfName.INDEXED.equals(ar.getAsName(0)) && ar.getPdfObject(1).isName() && ar.getPdfObject(2).isNumber() && ar.getPdfObject(3).isString() ) {
							 check = false;
						 }
					 }
					 if (check && key.equals(PdfName.COLORSPACE) && !value.isName()) {
						 PdfName cs = writer.getColorspaceName();
						 PageResources prs = getPageResources();
						 prs.addColor(cs, writer.addToBody(value).getIndirectReference());
						 value = cs;
					 }
					 value.toPdf(null, content);
					 content.append('\n');
				 }
				 content.append(""ID\n"");
				 pimage.writeContent(content);
				 content.append(""\nEI\nQ"").append_i(separator);
			 }
			 else {
				 PdfName name;
				 PageResources prs = getPageResources();
				 Image maskImage = image.getImageMask();
				 if (maskImage != null) {
					 name = writer.addDirectImageSimple(maskImage);
					 prs.addXObject(name, writer.getImageReference(name));
				 }
				 name = writer.addDirectImageSimple(image);
				 name = prs.addXObject(name, writer.getImageReference(name));
				 content.append(' ').append(name.getBytes()).append("" Do Q"").append_i(separator);
			 }
		 }
		 if (image.hasBorders()) {
			 saveState();
			 float w = image.getWidth();
			 float h = image.getHeight();
			 concatCTM(a / w, b / w, c / h, d / h, e, f);
			 rectangle(image);
			 restoreState();
		 }
		 if (image.getLayer() != null) endLayer();
		 Annotation annot = image.getAnnotation();
		 if (annot == null) return;
		 float[] r = new float[unitRect.length];
		 for (int k = 0;
		 k < unitRect.length;
		 k += 2) {
			 r[k] = a * unitRect[k] + c * unitRect[k + 1] + e;
			 r[k + 1] = b * unitRect[k] + d * unitRect[k + 1] + f;
		 }
		 float llx = r[0];
		 float lly = r[1];
		 float urx = llx;
		 float ury = lly;
		 for (int k = 2;
		 k < r.length;
		 k += 2) {
			 llx = Math.min(llx, r[k]);
			 lly = Math.min(lly, r[k + 1]);
			 urx = Math.max(urx, r[k]);
			 ury = Math.max(ury, r[k + 1]);
		 }
		 annot = new Annotation(annot);
		 annot.setDimensions(llx, lly, urx, ury);
		 PdfAnnotation an = PdfAnnotationsImp.convertAnnotation(writer, annot, new Rectangle(llx, lly, urx, ury));
		 if (an == null) return;
		 addAnnotation(an);
	 }
	 catch (Exception ee) {
		 throw new DocumentException(ee);
	 }
 }",0,0,1,0
"private static class ProxiedNiFiClient implements NiFiClient {
	 private final String proxiedEntity;
	 private final NiFiClient wrappedClient;
	 public ProxiedNiFiClient(final NiFiClient wrappedClient, final String proxiedEntity) {
		 this.proxiedEntity = proxiedEntity;
		 this.wrappedClient = wrappedClient;
	 }
	 public ControllerClient getControllerClient() {
		 return wrappedClient.getControllerClientForProxiedEntities(proxiedEntity);
	 }
	 public ControllerClient getControllerClientForProxiedEntities(String... proxiedEntity) {
		 return wrappedClient.getControllerClientForProxiedEntities(proxiedEntity);
	 }
	 public ControllerClient getControllerClientForToken(String token) {
		 return wrappedClient.getControllerClientForToken(token);
	 }
	 public FlowClient getFlowClient() {
		 return wrappedClient.getFlowClientForProxiedEntities(proxiedEntity);
	 }
	 public FlowClient getFlowClientForProxiedEntities(String... proxiedEntity) {
		 return wrappedClient.getFlowClientForProxiedEntities(proxiedEntity);
	 }
	 public FlowClient getFlowClientForToken(String token) {
		 return wrappedClient.getFlowClientForToken(token);
	 }
	 public ProcessGroupClient getProcessGroupClient() {
		 return wrappedClient.getProcessGroupClientForProxiedEntities(proxiedEntity);
	 }
	 public ProcessGroupClient getProcessGroupClientForProxiedEntities(String... proxiedEntity) {
		 return wrappedClient.getProcessGroupClientForProxiedEntities(proxiedEntity);
	 }
	 public ProcessGroupClient getProcessGroupClientForToken(String token) {
		 return wrappedClient.getProcessGroupClientForToken(token);
	 }
	 public VersionsClient getVersionsClient() {
		 return wrappedClient.getVersionsClientForProxiedEntities(proxiedEntity);
	 }
	 public VersionsClient getVersionsClientForProxiedEntities(String... proxiedEntity) {
		 return wrappedClient.getVersionsClientForProxiedEntities(proxiedEntity);
	 }
	 public VersionsClient getVersionsClientForToken(String token) {
		 return wrappedClient.getVersionsClientForToken(token);
	 }
	 public void close() throws IOException {
		 wrappedClient.close();
	 }
 }",1,1,0,0
"public class DeleteUserCommandHandler implements NewCommandSourceHandler {
	 private final AppUserWritePlatformService writePlatformService;
	 public DeleteUserCommandHandler(final AppUserWritePlatformService writePlatformService) {
		 this.writePlatformService = writePlatformService;
	 }
	 public CommandProcessingResult processCommand(final JsonCommand command) {
		 return this.writePlatformService.deleteUser(command.entityId());
	 }
}",0,0,0,0
"public class RoutesHealthCheckRepository implements CamelContextAware, HealthCheckRepository {
	 private final ConcurrentMap<Route, HealthCheck> checks;
	 private Set<String> blacklist;
	 private List<PerformanceCounterEvaluator<ManagedRouteMBean>> evaluators;
	 private ConcurrentMap<String, Collection<PerformanceCounterEvaluator<ManagedRouteMBean>>> evaluatorMap;
	 private volatile CamelContext context;
	 public RoutesHealthCheckRepository() {
		 this.checks = new ConcurrentHashMap<>();
	 }
	 public void setCamelContext(CamelContext camelContext) {
		 this.context = camelContext;
	 }
	 public CamelContext getCamelContext() {
		 return context;
	 }
	 public void setBlacklistedRoutes(Collection<String> blacklistedRoutes) {
		 blacklistedRoutes.forEach(this::addBlacklistedRoute);
	 }
	 public void addBlacklistedRoute(String routeId) {
		 if (this.blacklist == null) {
			 this.blacklist = new HashSet<>();
		 }
		 this.blacklist.add(routeId);
	 }
	 public void setEvaluators(Collection<PerformanceCounterEvaluator<ManagedRouteMBean>> evaluators) {
		 evaluators.forEach(this::addEvaluator);
	 }
	 public void addEvaluator(PerformanceCounterEvaluator<ManagedRouteMBean> evaluator) {
		 if (this.evaluators == null) {
			 this.evaluators = new CopyOnWriteArrayList<>();
		 }
		 this.evaluators.add(evaluator);
	 }
	 public void setRoutesEvaluators(Map<String, Collection<PerformanceCounterEvaluator<ManagedRouteMBean>>> evaluators) {
		 evaluators.forEach(this::setRouteEvaluators);
	 }
	 public void setRouteEvaluators(String routeId, Collection<PerformanceCounterEvaluator<ManagedRouteMBean>> evaluators) {
		 evaluators.forEach(evaluator -> addRouteEvaluator(routeId, evaluator));
	 }
	 public void addRouteEvaluator(String routeId, PerformanceCounterEvaluator<ManagedRouteMBean> evaluator) {
		 if (this.evaluatorMap == null) {
			 this.evaluatorMap = new ConcurrentHashMap<>();
		 }
		 this.evaluatorMap.computeIfAbsent(routeId, id -> new CopyOnWriteArrayList<>()).add(evaluator);
	 }
	 public Stream<PerformanceCounterEvaluator<ManagedRouteMBean>> evaluators() {
		 return this.evaluators != null ? this.evaluators.stream() : Stream.empty();
	 }
	 public Stream<PerformanceCounterEvaluator<ManagedRouteMBean>> evaluators(String routeId) {
		 return this.evaluatorMap != null ? evaluatorMap.getOrDefault(routeId, Collections.emptyList()).stream() : Stream.empty();
	 }
	 public Stream<HealthCheck> stream() {
		 return this.context != null ? this.context.getRoutes() .stream() .filter(route -> route.getId() != null) .filter(route -> isNotBlacklisted(route)) .map(this::toRouteHealthCheck) : Stream.empty();
	 }
	 private boolean isNotBlacklisted(Route route) {
		 return this.blacklist != null ? !this.blacklist.contains(route.getId()) : true;
	 }
	 private HealthCheck toRouteHealthCheck(Route route) {
		 return checks.computeIfAbsent( route, r -> {
			 HealthCheck check = new RouteHealthCheck( route, evaluatorMap != null ? evaluatorMap.getOrDefault(r.getId(), evaluators) : evaluators );
			 check.getConfiguration().setEnabled(true);
			 return check;
		 }
		 );
	 }
}",1,1,0,0
"public final void compilationUnit() throws RecognitionException, TokenStreamException {
	returnAST = null;
	ASTPair currentAST = new ASTPair();
	JavaAST compilationUnit_AST = null;
	JavaAST im_AST = null;
	JavaAST typ_AST = null;
	ArrayList imports = new ArrayList();
	ArrayList types = new ArrayList();
	try {
		 if ( inputState.guessing==0 ) {
			FileAST.currFile = new FileAST(file);
		}
		{
			switch ( LA(1)) {
				case LITERAL_package:{
					packageDefinition();
					astFactory.addASTChild(currentAST, returnAST);
					break;
				}
				case EOF:case SEMI:case LITERAL_import:case LITERAL_public:case LITERAL_private:case LITERAL_protected:case LITERAL_static:case LITERAL_final:case LITERAL_synchronized:case LITERAL_volatile:case LITERAL_transient:case LITERAL_native:case LITERAL_abstract:case LITERAL_strictfp:case LITERAL_class:case LITERAL_interface:{
					break;
				}
				default:{
					throw new NoViableAltException(LT(1), getFilename());
				}
			}
		}
		{
			_loop4:do {
				if ((LA(1)==LITERAL_import)) {
					importDefinition();
					im_AST = (JavaAST)returnAST;
					astFactory.addASTChild(currentAST, returnAST);
					if ( inputState.guessing==0 ) {
						imports.add(((IdentifierAST)im_AST.getFirstChild()).getName());
					}
				}
				else {
					break _loop4;
				}
			}
			 while (true);
		}
		if ( inputState.guessing==0 ) {
			FileAST.currFile.imports = new String[imports.size()];
			imports.toArray(FileAST.currFile.imports);
			imports = null;
		 }
		{
			_loop6:do {
				if ((_tokenSet_0.member(LA(1)))) {
					typeDefinition();
					typ_AST = (JavaAST)returnAST;
					astFactory.addASTChild(currentAST, returnAST);
					if ( inputState.guessing==0 ) {
						if (typ_AST.getType() != SEMI) types.add(typ_AST);
					}
				}
				else {
					break _loop6;
				}
			}
			 while (true);
		}
		if ( inputState.guessing==0 ) {
			FileAST.currFile.types = new jparse.TypeAST[types.size()];
			types.toArray(FileAST.currFile.types);
			types = null;
		 }
		match(Token.EOF_TYPE);
		if ( inputState.guessing==0 ) {
			compilationUnit_AST = (JavaAST)currentAST.root;
			compilationUnit_AST = (JavaAST)astFactory.make( (new ASTArray(2)).add(FileAST.currFile).add(compilationUnit_AST));
			currentAST.root = compilationUnit_AST;
			currentAST.child = compilationUnit_AST!=null &&compilationUnit_AST.getFirstChild()!=null ?compilationUnit_AST.getFirstChild() : compilationUnit_AST;
			currentAST.advanceChildToEnd();
		}
		compilationUnit_AST = (JavaAST)currentAST.root;
	}
	catch (RecognitionException ex) {
		if (inputState.guessing==0) {
			reportError(ex);
			consume();
			consumeUntil(_tokenSet_1);
		}
		 else {
			 throw ex;
		}
	}
	returnAST = compilationUnit_AST;
}",0,0,1,0
"private static List<Row> fetchRows(List<ReadCommand> commands, ConsistencyLevel consistency_level) throws IOException, UnavailableException, TimeoutException {
	 List<ReadCallback<Row>> readCallbacks = new ArrayList<ReadCallback<Row>>();
	 List<Row> rows = new ArrayList<Row>();
	 for (ReadCommand command: commands) {
		 assert !command.isDigestQuery();
		 logger.debug(""Command/ConsistencyLevel is {
		}
		/{
		}
		"", command, consistency_level);
		 List<InetAddress> endpoints = StorageService.instance.getLiveNaturalEndpoints(command.table, command.key);
		 DatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getLocalAddress(), endpoints);
		 RowDigestResolver resolver = new RowDigestResolver(command.table, command.key);
		 ReadCallback<Row> handler = getReadCallback(resolver, command, consistency_level, endpoints);
		 handler.assureSufficientLiveNodes();
		 assert !handler.endpoints.isEmpty();
		 ReadCommand digestCommand = null;
		 if (handler.endpoints.size() > 1) {
			 digestCommand = command.copy();
			 digestCommand.setDigestQuery(true);
		 }
		 InetAddress dataPoint = handler.endpoints.get(0);
		 if (dataPoint.equals(FBUtilities.getLocalAddress())) {
			 if (logger.isDebugEnabled()) logger.debug(""reading data locally"");
			 StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(command, handler));
		 }
		 else {
			 if (logger.isDebugEnabled()) logger.debug(""reading data from "" + dataPoint);
			 MessagingService.instance().sendRR(command, dataPoint, handler);
		 }
		 MessageProducer producer = new CachingMessageProducer(digestCommand);
		 for (InetAddress digestPoint : handler.endpoints.subList(1, handler.endpoints.size())) {
			 if (digestPoint.equals(FBUtilities.getLocalAddress())) {
				 if (logger.isDebugEnabled()) logger.debug(""reading digest locally"");
				 StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(digestCommand, handler));
			 }
			 else {
				 if (logger.isDebugEnabled()) logger.debug(""reading digest for from "" + digestPoint);
				 MessagingService.instance().sendRR(producer, digestPoint, handler);
			 }
		 }
		 readCallbacks.add(handler);
	 }
	 List<RepairCallback<Row>> repairResponseHandlers = null;
	 for (int i = 0;
	 i < commands.size();
	 i++) {
		 ReadCallback<Row> handler = readCallbacks.get(i);
		 Row row;
		 ReadCommand command = commands.get(i);
		 try {
			 long startTime2 = System.currentTimeMillis();
			 row = handler.get();
			 if (row != null) rows.add(row);
			 if (logger.isDebugEnabled()) logger.debug(""Read: "" + (System.currentTimeMillis() - startTime2) + "" ms."");
		 }
		 catch (TimeoutException ex) {
			 if (logger.isDebugEnabled()) logger.debug(""Read timeout: {
			}
			"", ex.toString());
			 throw ex;
		 }
		 catch (DigestMismatchException ex) {
			 if (logger.isDebugEnabled()) logger.debug(""Digest mismatch: {
			}
			"", ex.toString());
			 RowRepairResolver resolver = new RowRepairResolver(command.table, command.key);
			 RepairCallback<Row> repairHandler = new RepairCallback<Row>(resolver, handler.endpoints);
			 for (InetAddress endpoint : handler.endpoints) MessagingService.instance().sendRR(command, endpoint, repairHandler);
			 if (repairResponseHandlers == null) repairResponseHandlers = new ArrayList<RepairCallback<Row>>();
			 repairResponseHandlers.add(repairHandler);
		 }
	 }
	 if (repairResponseHandlers != null) {
		 for (RepairCallback<Row> handler : repairResponseHandlers) {
			 try {
				 Row row = handler.get();
				 if (row != null) rows.add(row);
			 }
			 catch (DigestMismatchException e) {
				 throw new AssertionError(e);
			 }
		 }
	 }
	 return rows;
 }",0,0,1,0
"public abstract class BinaryExpression implements Expression {
	 protected Expression left;
	 protected Expression right;
	 public BinaryExpression(Expression left, Expression right) {
		 this.left = left;
		 this.right = right;
	 }
	 public Expression getLeft() {
		 return left;
	 }
	 public Expression getRight() {
		 return right;
	 }
	 public String toString() {
		 return ""("" + left.toString() + "" "" + getExpressionSymbol() + "" "" + right.toString() + "")"";
	 }
	 public int hashCode() {
		 return toString().hashCode();
	 }
	 public boolean equals(Object o) {
		 if (o == null || !this.getClass().equals(o.getClass())) {
			 return false;
		 }
		 return toString().equals(o.toString());
	 }
	 public abstract String getExpressionSymbol();
	 public void setRight(Expression expression) {
		 right = expression;
	 }
	 public void setLeft(Expression expression) {
		 left = expression;
	 }
}",0,1,0,0
"protected void drawTopPen(Graphics2D grx, JRPen topPen, JRPen leftPen, JRPen rightPen, JRPrintElement element, int offsetX, int offsetY);",0,0,0,1
"public class Kit{
	 private static Method Throwable_initCause = null;
	 static {
		 try {
			 Class ThrowableClass = Kit.classOrNull(""java.lang.Throwable"");
			 Class[] signature = {
			 ThrowableClass }
			;
			 Throwable_initCause = ThrowableClass.getMethod(""initCause"", signature);
		 }
		 catch (Exception ex) {
		 }
	 }
	 public static Class classOrNull(String className) {
		 try {
			 return Class.forName(className);
		 }
		 catch (ClassNotFoundException ex) {
		 }
		 catch (SecurityException ex) {
		 }
		 catch (LinkageError ex) {
		 }
		 catch (IllegalArgumentException e) {
		 }
		 return null;
	 }
	 public static Class classOrNull(ClassLoader loader, String className) {
		 try {
			 return loader.loadClass(className);
		 }
		 catch (ClassNotFoundException ex) {
		 }
		 catch (SecurityException ex) {
		 }
		 catch (LinkageError ex) {
		 }
		 catch (IllegalArgumentException e) {
		 }
		 return null;
	 }
	 static Object newInstanceOrNull(Class cl) {
		 try {
			 return cl.newInstance();
		 }
		 catch (SecurityException x) {
		 }
		 catch (LinkageError ex) {
		 }
		 catch (InstantiationException x) {
		 }
		 catch (IllegalAccessException x) {
		 }
		 return null;
	 }
	 public static RuntimeException initCause(RuntimeException ex, Throwable cause) {
		 if (Throwable_initCause != null) {
			 Object[] args = {
			 cause }
			;
			 try {
				 Throwable_initCause.invoke(ex, args);
			 }
			 catch (Exception e) {
			 }
		 }
		 return ex;
	 }
	 public static String[] semicolonSplit(String s) {
		 int count = 0;
		 for (int cursor = 0;
		 ;
		) {
			 int next = s.indexOf(';
			', cursor) + 1;
			 if (next <= 0) {
				 if (cursor + 1 < s.length()) throw new IllegalArgumentException();
				 break;
			 }
			 ++count;
			 cursor = next + 1;
		 }
		 String[] array = new String[count];
		 count = 0;
		 for (int cursor = 0;
		 ;
		) {
			 int next = s.indexOf(';
			', cursor);
			 if (next < 0) {
				 break;
			 }
			 array[count] = s.substring(cursor, next);
			 ++count;
			 cursor = next + 1;
		 }
		 return array;
	 }
	 public static int xDigitToInt(int c, int accumulator) {
		 check: {
			 if (c <= '9') {
				 c -= '0';
				 if (0 <= c) {
					 break check;
				 }
			 }
			 else if (c <= 'F') {
				 if ('A' <= c) {
					 c -= ('A' - 10);
					 break check;
				 }
			 }
			 else if (c <= 'f') {
				 if ('a' <= c) {
					 c -= ('a' - 10);
					 break check;
				 }
			 }
			 return -1;
		 }
		 return (accumulator << 4) | c;
	 }
	 public static Object addListener(Object bag, Object listener) {
		 if (listener == null) throw new IllegalArgumentException();
		 if (listener instanceof Object[]) throw new IllegalArgumentException();
		 if (bag == null) {
			 bag = listener;
		 }
		 else if (!(bag instanceof Object[])) {
			 bag = new Object[] {
			 bag, listener }
			;
		 }
		 else {
			 Object[] array = (Object[])bag;
			 int L = array.length;
			 if (L < 2) throw new IllegalArgumentException();
			 Object[] tmp = new Object[L + 1];
			 System.arraycopy(array, 0, tmp, 0, L);
			 tmp[L] = listener;
			 bag = tmp;
		 }
		 return bag;
	 }
	 public static Object removeListener(Object bag, Object listener) {
		 if (listener == null) throw new IllegalArgumentException();
		 if (listener instanceof Object[]) throw new IllegalArgumentException();
		 if (bag == listener) {
			 bag = null;
		 }
		 else if (bag instanceof Object[]) {
			 Object[] array = (Object[])bag;
			 int L = array.length;
			 if (L < 2) throw new IllegalArgumentException();
			 if (L == 2) {
				 if (array[1] == listener) {
					 bag = array[0];
				 }
				 else if (array[0] == listener) {
					 bag = array[1];
				 }
			 }
			 else {
				 int i = L;
				 do {
					 --i;
					 if (array[i] == listener) {
						 Object[] tmp = new Object[L - 1];
						 System.arraycopy(array, 0, tmp, 0, i);
						 System.arraycopy(array, i + 1, tmp, i, L - (i + 1));
						 bag = tmp;
						 break;
					 }
				 }
				 while (i != 0);
			 }
		 }
		 return bag;
	 }
	 public static Object getListener(Object bag, int index) {
		 if (index == 0) {
			 if (bag == null) return null;
			 if (!(bag instanceof Object[])) return bag;
			 Object[] array = (Object[])bag;
			 if (array.length < 2) throw new IllegalArgumentException();
			 return array[0];
		 }
		 else if (index == 1) {
			 if (!(bag instanceof Object[])) {
				 if (bag == null) throw new IllegalArgumentException();
				 return null;
			 }
			 Object[] array = (Object[])bag;
			 return array[1];
		 }
		 else {
			 Object[] array = (Object[])bag;
			 int L = array.length;
			 if (L < 2) throw new IllegalArgumentException();
			 if (index == L) return null;
			 return array[index];
		 }
	 }
	 static Object initHash(Hashtable h, Object key, Object initialValue) {
		 synchronized (h) {
			 Object current = h.get(key);
			 if (current == null) {
				 h.put(key, initialValue);
			 }
			 else {
				 initialValue = current;
			 }
		 }
		 return initialValue;
	 }
	 private final static class ComplexKey {
		 private Object key1;
		 private Object key2;
		 private int hash;
		 ComplexKey(Object key1, Object key2) {
			 this.key1 = key1;
			 this.key2 = key2;
		 }
		 public boolean equals(Object anotherObj) {
			 if (!(anotherObj instanceof ComplexKey)) return false;
			 ComplexKey another = (ComplexKey)anotherObj;
			 return key1.equals(another.key1) && key2.equals(another.key2);
		 }
		 public int hashCode() {
			 if (hash == 0) {
				 hash = key1.hashCode() ^ key2.hashCode();
			 }
			 return hash;
		 }
	 }
	 public static Object makeHashKeyFromPair(Object key1, Object key2) {
		 if (key1 == null) throw new IllegalArgumentException();
		 if (key2 == null) throw new IllegalArgumentException();
		 return new ComplexKey(key1, key2);
	 }
	 public static String readReader(Reader r) throws IOException {
		 char[] buffer = new char[512];
		 int cursor = 0;
		 for (;
		;
		) {
			 int n = r.read(buffer, cursor, buffer.length - cursor);
			 if (n < 0) {
				 break;
			 }
			 cursor += n;
			 if (cursor == buffer.length) {
				 char[] tmp = new char[buffer.length * 2];
				 System.arraycopy(buffer, 0, tmp, 0, cursor);
				 buffer = tmp;
			 }
		 }
		 return new String(buffer, 0, cursor);
	 }
	 public static RuntimeException codeBug() throws RuntimeException {
		 RuntimeException ex = new IllegalStateException(""FAILED ASSERTION"");
		 ex.printStackTrace(System.err);
		 throw ex;
	 }
}",0,0,0,0
"public class VizObjectTester {
	public void checkProperties() {
		int id = 20110901;
		String name = ""September 1st 2011"";
		String description = ""The 1st day of the ninth month in the year of ""+ ""our Lord 2011"";
		VizObject testNC = new VizObject();
		testNC.setId(id);
		testNC.setName(name);
		testNC.setDescription(description);
		assertEquals(testNC.getId(), id);
		assertEquals(testNC.getName(), name);
		assertEquals(testNC.getDescription(), description);
	}
	public void checkCopying() {
		int id = 20110901;
		String name = ""September 1st 2011"";
		String description = ""The 1st day of the ninth month in the year of ""+ ""our Lord 2011"";
		VizObject testNC = new VizObject();
		testNC.setId(id);
		testNC.setName(name);
		testNC.setDescription(description);
		VizObject cloneNC = (VizObject) testNC.clone();
		assertEquals(testNC.getId(), cloneNC.getId());
		assertEquals(testNC.getName(), cloneNC.getName());
		assertEquals(testNC.getDescription(), cloneNC.getDescription());
		id = 20110901;
		name = ""September 1st 2011"";
		description = ""The 1st day of the ninth month in the year of ""+ ""our Lord 2011"";
		testNC = new VizObject();
		testNC.setId(id);
		testNC.setName(name);
		testNC.setDescription(description);
		VizObject testNC2 = new VizObject();
		testNC2.copy(testNC);
		assertEquals(testNC.getId(), testNC2.getId());
		assertEquals(testNC.getName(), testNC2.getName());
		assertEquals(testNC.getDescription(), testNC2.getDescription());
		id = 20110901;
		name = ""September 1st 2011"";
		description = ""The 1st day of the ninth month in the year of ""+ ""our Lord 2011"";
		testNC = new VizObject();
		testNC.setId(id);
		testNC.setName(name);
		testNC.setDescription(description);
		testNC.copy(null);
		assertEquals(testNC.getId(), id);
		assertEquals(testNC.getName(), name);
		assertEquals(testNC.getDescription(), description);
	}
	public void checkXMLPersistence()throws NullPointerException, JAXBException, IOException {
		VizObject testNC = null, testNC2 = null;
		int id = 20110901;
		String name = ""September 1st 2011"";
		String description = ""The 1st day of the ninth month in the year of ""+ ""our Lord 2011"";
		VizJAXBHandler xmlHandler = new VizJAXBHandler();
		ArrayList<Class> classList = new ArrayList<Class>();
		classList.add(VizObject.class);
		testNC = new VizObject();
		testNC.setId(id);
		testNC.setName(name);
		testNC.setDescription(description);
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		xmlHandler.write(testNC, classList, outputStream);
		ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
		testNC2 = (VizObject) xmlHandler.read(classList, inputStream);
		assertTrue(testNC.equals(testNC2));
	}
	public void checkEquality() {
		VizObject testVizObject = new VizObject();
		testVizObject.setId(12);
		testVizObject.setName(""ICE VizObject"");
		testVizObject.setDescription(""This is an VizObject that will ""+ ""be used for testing equality with other VizObjects."");
		VizObject equalObject = new VizObject();
		equalObject.setId(12);
		equalObject.setName(""ICE VizObject"");
		equalObject.setDescription(""This is an VizObject that will ""+ ""be used for testing equality with other VizObjects."");
		VizObject unEqualObject = new VizObject();
		unEqualObject.setId(52);
		unEqualObject.setName(""Bill the VizObject"");
		unEqualObject.setDescription(""This is an VizObject to verify that ""+ ""VizObject.equals() returns false for an object that is not ""+ ""equivalent to testVizObject."");
		VizObject transitiveObject = new VizObject();
		transitiveObject.setId(12);
		transitiveObject.setName(""ICE VizObject"");
		transitiveObject.setDescription(""This is an VizObject that will ""+ ""be used for testing equality with other VizObjects."");
		assertTrue(testVizObject.equals(equalObject));
		assertFalse(testVizObject.equals(unEqualObject));
		assertTrue(testVizObject.equals(testVizObject));
		assertTrue(testVizObject.equals(equalObject)&& equalObject.equals(testVizObject));
		if (testVizObject.equals(equalObject)&& equalObject.equals(transitiveObject)) {
			assertTrue(testVizObject.equals(transitiveObject));
		}
		 else {
			fail();
		}
		assertTrue(testVizObject.equals(equalObject)&& testVizObject.equals(equalObject)&& testVizObject.equals(equalObject));
		assertTrue(!testVizObject.equals(unEqualObject)&& !testVizObject.equals(unEqualObject)&& !testVizObject.equals(unEqualObject));
		assertFalse(testVizObject == null);
		assertTrue(testVizObject.equals(equalObject)&& testVizObject.hashCode() == equalObject.hashCode());
		assertTrue(testVizObject.hashCode() == testVizObject.hashCode());
		assertFalse(testVizObject.hashCode() == unEqualObject.hashCode());
	}
	public void checkNotifications() {
		TestVizComponentListener firstListener = new TestVizComponentListener();
		TestVizComponentListener secondListener = new TestVizComponentListener();
		VizObject iceObject = new VizObject();
		iceObject.register(firstListener);
		iceObject.register(secondListener);
		iceObject.setName(""Warren Buffett"");
		assertTrue(firstListener.wasNotified());
		assertTrue(secondListener.wasNotified());
		firstListener.reset();
		secondListener.reset();
		iceObject.unregister(secondListener);
		iceObject.setId(899);
		assertTrue(firstListener.wasNotified());
		assertFalse(secondListener.wasNotified());
		firstListener.reset();
		iceObject.setDescription(""New description"");
		assertTrue(firstListener.wasNotified());
		return;
	}
}",1,1,0,0
"public class PoolElement {
	 public static final short INVALID = -1;
	 public static final short IDLE = 0;
	 public static final short ACTIVE = 1;
	 volatile private PreparedStatement select = null, update = null, updateLastlogin = null, insert = null;
	 volatile private String selStrg = null, insStrg = null, updStrg = null, updLastloginStrg = null;
	 private DbProperties dbp;
	 private volatile boolean isValid=true;
	 ConnectionPool pool;
	 Connection con = null;
	 int id;
	 volatile int sCnt=0;
	 long validUntil;
	 volatile boolean isActive = false, hasBeenUsed=false, cleanedUp=false;
	 ResultSet rs;
	 PoolElement (ConnectionPool pool, Connection con, DbProperties dbp, int id) throws Exception {
		 if (con == null) throw new Exception (""no connection supplied"");
		 this.pool = pool;
		 this.dbp=dbp;
		 this.id = id;
		 this.con = con;
		 con.setAutoCommit (false);
		 validUntil = System.currentTimeMillis() + dbp.conTTL;
		 Server.log (""SqlAuthenticator"", ""Created new Connetion "" + this.toString(), Server.MSG_AUTH, Server.LVL_MAJOR);
		 if (Server.TRACE_CREATE_AND_FINALIZE) Server.log (this, ""++++++++++++++++++++++++++++++++++++++++CREATE"", Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
	 }
	private boolean isValid() {
		 if (!isValid) return false;
		 if (con == null || cleanedUp) return false;
		 if (!hasBeenUsed) return true;
		 if (sCnt > dbp.maxStmtPerCon) {
			 Server.log(this, ""invalid because max-statements/connection has been reached "" + dbp.maxStmtPerCon, Server.MSG_AUTH, Server.LVL_VERBOSE);
			 isValid=false;
			 return false;
		 }
		 if (validUntil <= System.currentTimeMillis()) {
			 Server.log(this, ""invalid because connection ttl has been reached "" + dbp.conTTL, Server.MSG_AUTH, Server.LVL_VERBOSE);
			 isValid=false;
			 return false;
		 }
		 return true;
	 }
	 public synchronized void cleanup () {
		 if (cleanedUp) return;
		 try {
			 if (select != null) {
				 select.close();
				 select = null;
			 }
		 }
		 catch (SQLException se) {
			 Server.debug(this, ""cleanup: select.close()"", se, Server.MSG_ERROR, Server.LVL_MAJOR);
		 }
		 try {
			 if (insert != null) {
				 insert.close();
				 insert = null;
			 }
		 }
		 catch (SQLException se) {
			 Server.debug(this, ""cleanup: insert.close()"", se, Server.MSG_ERROR, Server.LVL_MAJOR);
		 }
		 try {
			 if (update != null) {
				 update.close();
				 update = null;
			 }
		 }
		 catch (SQLException se) {
			 Server.debug(this, ""cleanup: update.close()"", se, Server.MSG_ERROR, Server.LVL_MAJOR);
		 }
		 try {
			 if (con!=null) {
				 con.close();
				 con = null;
			 }
		 }
		 catch (SQLException se) {
			 Server.debug(this, ""cleanup: connection.close()"", se, Server.MSG_ERROR, Server.LVL_MAJOR);
		 }
		 this.pool = null;
		 this.isActive = false;
		 this.cleanedUp = true;
		 Server.log (""SqlAuthenticator"", ""Closed Connetion "" + this.toString(), Server.MSG_AUTH, Server.LVL_MAJOR);
	 }
	public void checkWarnings(Statement s, String prefix) {
		 try {
			 SQLWarning sqlW = s.getWarnings();
			 while (sqlW != null) {
				 StringBuffer sb = new StringBuffer(this.toString());
				 sb.append ("" getResultSet: Encountered SQLWarning: "");
				 sb.append (prefix);
				 sb.append ("": "");
				 sb.append (sqlW.getErrorCode());
				 sb.append ("": "");
				 sb.append (sqlW.getCause());
				 Server.log (Thread.currentThread(), sb.toString (), Server.MSG_ERROR, Server.LVL_MAJOR);
				 sqlW = sqlW.getNextWarning();
			 }
		 }
		 catch (SQLException se) {
			 this.isValid=false;
			 Server.debug(this, ""checkWarnings caused exception"", se, Server.MSG_ERROR, Server.LVL_MAJOR);
		 }
	}
	 public String toString() {
		 StringBuffer sb = new StringBuffer(""[PoolElement: "");
		 sb.append (id);
		 sb.append (""/"");
		 sb.append (sCnt);
		 sb.append (""/"");
		 sb.append (dbp.url).append (""("").append (dbp.table).append("")"");
		 sb.append (""]"");
		 return sb.toString();
	 }
	 public synchronized short grab() {
		 if (this.isActive) return ACTIVE;
		 if (!isValid()) return INVALID;
		 this.isActive=true;
		 this.hasBeenUsed=true;
		 return IDLE;
	 }
	 public void release() {
		 try {
			 if (select!=null) {
				 select.clearParameters();
				 select.clearWarnings();
			 }
			 if (update!=null) {
				 update.clearParameters();
				 update.clearWarnings();
			 }
			 if (insert!=null) {
				 insert.clearParameters();
				 insert.clearWarnings();
			 }
		 }
		 catch (Exception se) {
			 Server.debug (this, ""catched exception while releasing PoolElement"", se, Server.MSG_AUTH, Server.LVL_MAJOR);
		 }
		 this.isActive=false;
	 }
	 private PreparedStatement getSelect() throws Exception {
		 try {
			 if (select!=null) return select;
			 if (con==null) throw new Exception (""No connection to retrieve a PreparedStatement from"");
			 StringBuffer sb = new StringBuffer (""SELECT "");
			 sb.append (dbp.columns[0]);
			 for (int i = 1;
			 i<dbp.columns.length;
			 i++) {
				 sb.append ("", "");
				 sb.append (dbp.columns[i]);
			 }
			 sb.append ("", "");
			 sb.append (dbp.fc_password);
			 sb.append ("" FROM "");
			 sb.append (dbp.table);
			 sb.append ("" WHERE "");
			 sb.append (dbp.fc_username);
			 sb.append ("" = ?"");
			 selStrg = sb.toString();
			 select = con.prepareStatement(selStrg, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
			 if (!dbp.RS_TYPE_SCROLL_SENSITIV){
				 select = con.prepareStatement(selStrg, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
			 }
			 else select = con.prepareStatement(selStrg, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
			 if (dbp.queryTimeout > 0) select.setQueryTimeout(dbp.queryTimeout);
			 return select;
		 }
		 catch (Exception e) {
			 isValid=false;
			 release();
			 throw e;
		 }
	 }
	 private PreparedStatement getUpdate() throws Exception {
		 try {
			 if (update != null) return update;
			 if (con==null) throw new Exception (""No connection to retrieve a PreparedStatement from"");
			 StringBuffer sb = new StringBuffer(""UPDATE "");
			 sb.append (dbp.table);
			 sb.append ("" SET "");
			 sb.append (dbp.updCols[0]);
			 sb.append ("" = ?"");
			 for (int i = 1;
			 i<dbp.updCols.length;
			 i++) {
				 sb.append ("", "");
				 sb.append (dbp.updCols[i]);
				 sb.append ("" = ?"");
			 }
			 sb.append ("" WHERE "");
			 if (dbp.idField != null) {
				 sb.append (dbp.idField);
				 sb.append ("" = ?"");
			 }
			 else {
				 sb.append (dbp.fc_username);
				 sb.append ("" = ?"");
			 }
			 updStrg = sb.toString();
			 update = con.prepareStatement(updStrg);
			 if (dbp.queryTimeout > 0) update.setQueryTimeout(dbp.queryTimeout);
			 return update;
		 }
		 catch (Exception e) {
			 isValid=false;
			 release();
			 throw e;
		 }
	 }
	 public User loginUser (String username, String password, String cookie) throws Exception {
		 try {
			 checkThread();
			 PreparedStatement ps = getSelect();
			 ps.setString(1, username.toLowerCase().trim());
			 ResultSet rs = ps.executeQuery();
			 sCnt++;
			 Server.log(Thread.currentThread(), this.toString() + ""LOGIN user uname="" + username.toLowerCase() + ""/pwd="" + password + ""/cookie="" + cookie + ""\r\n"" + selStrg, Server.MSG_AUTH, Server.LVL_VERY_VERBOSE);
			 dbp.cacheMetaData(rs);
			 if (!rs.next()) {
				 Server.log(Thread.currentThread(), this.toString()+ ""LOGIN no user mathing username and password "" + username + ""/"" + password, Server.MSG_AUTH, Server.LVL_MINOR);
				 rs.close();
				 return new User(username, cookie);
			 }
			 else if (!rs.isLast()) {
				 Server.log(Thread.currentThread(), this.toString() + ""LOGIN multible records returned for user "" + username, Server.MSG_AUTH, Server.LVL_MAJOR);
				 rs.close();
				 return null;
			 }
			 checkThread();
			 String dbpwd = rs.getString(dbp.columns.length+1);
			 if (dbpwd==null || !dbpwd.equals(password)) return null;
			 User u = new User (username, cookie);
			 u.isUnregistered = false;
			 readColumns(u, rs);
			 checkWarnings(ps, ""loginUser (getData)"");
			 checkThread();
			 if (!dbp.readOnly) {
				 doLoginUpdates(u, rs);
			 }
			 checkWarnings(ps, ""loginUser (update Data)"");
			 rs.close();
			 Server.log (Thread.currentThread(), this.toString() + ""LOGIN returning "" + u, Server.MSG_AUTH, Server.LVL_MAJOR);
			 u.isUnregistered = false;
			 return u;
		 }
		 catch (Exception e) {
			 Server.debug (this, selStrg, e, Server.MSG_AUTH, Server.LVL_MAJOR);
			 isValid=false;
			 release();
			 throw e;
		 }
	 }
	 public User loginUser (User u, String password) throws Exception {
		 try {
			 checkThread();
			 PreparedStatement ps = getSelect();
			 ps.setString(1, u.getName().toLowerCase().trim());
			 Server.log(Thread.currentThread(), this.toString() + ""LOGIN user uname="" + u.getName().toLowerCase() + ""\r\n"" + selStrg, Server.MSG_AUTH, Server.LVL_VERY_VERBOSE);
			 ResultSet rs = ps.executeQuery();
			 sCnt++;
			 dbp.cacheMetaData(rs);
			 if (!rs.next()) {
				 Server.log(Thread.currentThread(), this.toString()+ ""LOGIN no user mathing username "" + u.getName(), Server.MSG_AUTH, Server.LVL_MINOR);
				 rs.close();
				 return u;
			 }
			 else if (!rs.isLast()) {
				 Server.log(Thread.currentThread(), this.toString() + ""LOGIN multible records returned for user "" + u.getName(), Server.MSG_AUTH, Server.LVL_MAJOR);
				 rs.close();
				 return u;
			 }
			 if (u.isUnregistered == true) {
				 String dbpwd = rs.getString(dbp.columns.length+1);
				 if (dbpwd==null || !dbpwd.equals(password)) {
					 return null;
				 }
				 u.isUnregistered = false;
			 }
			 checkThread();
			 readColumns(u, rs);
			 checkWarnings(ps, ""loginUser (getData)"");
			 checkThread();
			 if (!dbp.readOnly) {
				 doLoginUpdates(u, rs);
			 }
			 checkWarnings(ps, ""loginUser (update Data)"");
			 rs.close();
			 Server.log (Thread.currentThread(), this.toString() + ""LOGIN returning "" + u, Server.MSG_AUTH, Server.LVL_MAJOR);
			 return u;
		 }
		 catch (Exception e) {
			 Server.log(this, selStrg, Server.MSG_AUTH, Server.LVL_MAJOR);
			 isValid=false;
			 release();
			 throw e;
		 }
	 }
	 private void readColumns(User u, ResultSet rs) throws SQLException {
		 for (int i = 0;
		 i<dbp.columns.length;
		 i++) {
			 String cname = dbp.names[i];
			 int idx = i+1;
			 if (""userright"".equals(cname)) {
				 String val = rs.getString(idx);
				 if (val == null || val.length()==0 || ""null"".equalsIgnoreCase(val)) {
					 u.setPermission(IUserStates.ROLE_USER);
				 }
				 else if (""true"".equalsIgnoreCase (val) || ""yes"".equalsIgnoreCase(val) || ""vip"".equalsIgnoreCase(val)) {
					 u.setPermission(IUserStates.ROLE_VIP);
				 }
				 else if (""admin"".equalsIgnoreCase(val)) {
					 u.setPermission(IUserStates.ROLE_GOD);
				 }
				 else if (""moderator"".equalsIgnoreCase(val)) {
					 u.setPermission(IUserStates.ROLE_VIP | IUserStates.IS_MODERATOR);
				 }
				 else if (""guest"".equalsIgnoreCase(val)) {
					 u.setPermission(IUserStates.IS_GUEST);
				 }
				 else if (""asshole"".equalsIgnoreCase(val)) {
					 u.setPermission(IUserStates.ROLE_ASSHOLE);
				 }
				 else {
					 try {
						 u.setPermission(Integer.parseInt(val));
					 }
					 catch (NumberFormatException nfe) {
						 Server.log(Thread.currentThread(), this.toString() + ""LOGIN userrights-column contains unknown value, corrected to ROLE_USER\r\n(must be null/true,yes,vip or VIP/admin/moderator/guest/user/assohle) "", Server.MSG_AUTH, Server.LVL_MAJOR);
						 u.setPermission(IUserStates.ROLE_USER);
					 }
				 }
			 }
			 else if (""id"".equals(cname)) {
				 u.setID(rs.getString(idx));
			 }
			 else if (""color"".equals(cname)) {
				 u.setColCode(rs.getString(idx));
			 }
			 else if (""fadecolor"".equals(cname)) {
				 Server.srv.USE_FADECOLOR =true;
				 if (rs.getString(idx)!= null ){
					 u.setFadeColCode(rs.getString(idx));
				 }
			 }
			 else if (""bgcolor"".equals(cname)) {
				 Server.srv.USE_BGCOLOR =true;
				 if (rs.getString(idx)!= null ){
					 u.setBgColCode(rs.getString(idx));
				 }
			 }
			 else if (""chattime"".equals(cname)) {
				 u.setProperty(""chattime"", new Long(rs.getLong(idx)));
			 }
			 else if (""lastlogin"".equals(cname)) {
				 switch (dbp.types[i]) {
					 case Types.BIGINT: case Types.INTEGER: case Types.NUMERIC: case Types.SMALLINT: u.setProperty(""lastlogin"", new Timestamp (rs.getLong(idx)));
					 break;
					 case Types.DATE: case Types.TIMESTAMP: Timestamp ts = rs.getTimestamp(idx);
					 u.setProperty(""lastlogin"", ts);
					 break;
					 default: String s = rs.getString(idx);
					 if (rs.wasNull()) {
						 u.setProperty(""lastlogin"", new Timestamp (System.currentTimeMillis()));
						 break;
					 }
					 try {
						 long l = Long.parseLong (s);
						 u.setProperty(""lastlogin"", new Timestamp(l));
					 }
					 catch (NumberFormatException nfe) {
						 try {
							 u.setProperty(""lastlogin"", Timestamp.valueOf(s));
						 }
						 catch (IllegalArgumentException iae) {
							 Server.log (this, ""LOGIN Unable to retrieve lastlogin-value! "" + s, Server.MSG_AUTH, Server.LVL_MAJOR);
						 }
					 }
				 }
			 }
			 else if (""friends"".equals(cname)) {
				 List<?> users = pool.authenticator.parseUserList(rs.getString(idx));
				 for (Iterator<?> it = users.iterator();
				 it.hasNext();
				 ) {
					 u.addFriend((String) it.next());
				 }
			 }
			 else if (""ignorelist"".equals(cname)) {
				 List<?> ignores = pool.authenticator.parseUserList(rs.getString(idx));
				 for (Iterator<?> it = ignores.iterator();
				 it.hasNext();
				 ) {
					 u.ignoreUser((String) it.next());
				 }
			 }
			 else if (""notifyfriends"".equals(cname)) {
				 switch (dbp.types[i]) {
					 case Types.BIGINT: case Types.INTEGER: case Types.NUMERIC: case Types.SMALLINT: u.setFriendsNotification(rs.getShort(idx));
					 break;
					 default: u.setFriendsNotification(pool.authenticator.parseBoolean(rs.getString(idx)) ? Server.srv.FN_DEFAULT_MODE_TRUE : Server.srv.FN_DEFAULT_MODE_FALSE);
				 }
			 }
			 else if (""customtitle"".equals(cname)) {
				 u.setCustomTitle(rs.getString(idx));
			 }
			 else if (""blocked"".equals(cname)) {
				 u.blocked = pool.authenticator.parseBoolean(rs.getString(idx));
			 }
			 else if (""activated"".equals(cname)) {
				 u.activated = pool.authenticator.parseBoolean(rs.getString(idx));
			 }
			 else {
				 String strg = getEncodedString (rs, idx);
				 u.setProperty(cname, strg);
			 }
		 }
	 }
	 private void doLoginUpdates(User nu, ResultSet rs) throws Exception {
		 boolean updated = false, error = false;
		 long ts = System.currentTimeMillis();
		 int idx = dbp.nameV.indexOf(""lastlogin"");
		 if (idx > -1) {
			 try {
				 switch (dbp.types[idx]) {
					 case Types.INTEGER: case Types.SMALLINT: rs.updateInt(idx+1, (int) (ts/1000));
					 break;
					 case Types.BIGINT: case Types.NUMERIC: case Types.DECIMAL: rs.updateLong(idx+1, ts/1000);
					 break;
					 case Types.DATE: case Types.TIMESTAMP: rs.updateTimestamp(idx+1, new Timestamp(ts));
					 break;
					 default: rs.updateString(idx+1, String.valueOf(ts/1000));
				 }
				 updated=true;
			 }
			 catch (SQLException se) {
				 Server.debug (Thread.currentThread(), this.toString() + ""LOGIN unable to update lastlogin"", se, Server.MSG_AUTH, Server.LVL_MAJOR);
				 error=true;
			 }
		 }
		 idx = dbp.nameV.indexOf(""cookie"");
		 if (idx > -1) try {
			 rs.updateString(idx+1, HashUtils.encodeMD5(nu.getCookie()));
		 }
		 catch (SQLException se) {
			 Server.debug (Thread.currentThread(), this.toString() + ""LOGIN unable to update cookie"", se, Server.MSG_AUTH, Server.LVL_MAJOR);
		 }
		 try {
			 if (updated) {
				 rs.updateRow();
				 con.commit();
			 }
			 else if (error) {
				 rs.cancelRowUpdates();
			 }
		 }
		 catch (SQLException se) {
			 Server.debug (Thread.currentThread(), this.toString() + ""LOGIN exception during updateRow/cancelRowUpdates"", se, Server.MSG_AUTH, Server.LVL_MAJOR);
		 }
	 }
	 public void logoutUser (User u) throws Exception {
		 try {
			 if (dbp.readOnly || dbp.updCols == null || dbp.updCols.length < 1) return;
			 PreparedStatement ps = getUpdate();
			 for (int i = 0;
			 i < dbp.updCols.length;
			 i++) {
				 String cname = dbp.updNames[i];
				 if (""chattime"".equalsIgnoreCase(cname)) {
					 ps.setLong(i+1, u.getChattime());
				 }
				 else if (""userrights"".equalsIgnoreCase(cname)) {
					 ps.setInt(i+1, u.getPermissionMap());
				 }
				 else if (""fadecolor"".equalsIgnoreCase(cname)) {
					 ps.setString(i+1, u.getFadeColCode());
				 }
				 else if (""bgcolor"".equalsIgnoreCase(cname)) {
					 ps.setString(i+1, u.getBgColCode());
				 }
				 else if (""color"".equalsIgnoreCase(cname)) {
					 ps.setString(i+1, u.getColCode());
				 }
				 else if (""friends"".equalsIgnoreCase(cname)) {
					 StringBuffer sb = new StringBuffer();
					 for (Enumeration<?> e = u.friends();
					 e.hasMoreElements();
					 ) {
						 String s = (String) e.nextElement();
						 sb.append (s);
						 if (e.hasMoreElements()) sb.append ("", "");
					 }
					 ps.setString(i+1, sb.toString());
				 }
				 else if (""ignorelist"".equalsIgnoreCase(cname)) {
					 StringBuffer sb = new StringBuffer();
					 for (Enumeration<String> e = u.ignoreList();
					 e.hasMoreElements();
					 ) {
						 String s = (String) e.nextElement();
						 sb.append (s);
						 if (e.hasMoreElements()) sb.append ("", "");
					 }
					 ps.setString(i+1, sb.toString());
				 }
				 else if (""notifyfriends"".equalsIgnoreCase(cname)) {
					 int idx = dbp.nameV.indexOf(""notifyfriends"");
					 switch (dbp.types[idx]) {
						 case Types.BIGINT: case Types.BIT: case Types.DECIMAL: case Types.INTEGER: case Types.SMALLINT: ps.setInt(i+1, u.notifyFriends());
						 break;
						 case Types.BOOLEAN: ps.setBoolean(i+1, u.notifyFriends()==User.FN_ALL ? true : false);
						 break;
						 default: ps.setString(i+1, u.notifyFriends()==User.FN_ALL ? ""true"" : ""false"");
					 }
				 }
				 else if (""extratitle"".equalsIgnoreCase(cname)) {
					 ps.setString(i+1, u.getCustomTitle());
				 }
				 else if (""cookie"".equalsIgnoreCase(cname)) {
					 ps.setString(i+1, ""not_logged_in"");
				 }
				 else if (""blocked"".equalsIgnoreCase(cname)) {
					 int idx = dbp.nameV.indexOf(""blocked"");
					 switch (dbp.types[idx]) {
						 case Types.BIGINT: case Types.BIT: case Types.DECIMAL: case Types.INTEGER: case Types.SMALLINT: ps.setInt(i+1, u.blocked ? 1 : 0);
						 break;
						 case Types.BOOLEAN: ps.setBoolean(i+1, u.blocked);
						 break;
						 default: ps.setString(i+1, u.blocked ? ""1"" : ""0"");
					 }
				 }
				 else if (""activated"".equalsIgnoreCase(cname)) {
					 int idx = dbp.nameV.indexOf(""activated"");
					 switch (dbp.types[idx]) {
						 case Types.BIGINT: case Types.BIT: case Types.DECIMAL: case Types.INTEGER: case Types.SMALLINT: ps.setInt(i+1, u.activated ? 1 : 0);
						 break;
						 case Types.BOOLEAN: ps.setBoolean(i+1, u.activated);
						 break;
						 default: ps.setString(i+1, u.activated ? ""1"" : ""0"");
					 }
				 }
				 else {
					 Server.log(this, ""save custom Property ""+cname, Server.MSG_AUTH, Server.LVL_VERBOSE);
					 int idx = dbp.nameV.indexOf(cname);
					 switch (dbp.types[idx]) {
						 case Types.BIGINT: case Types.BIT: case Types.DECIMAL: case Types.INTEGER: case Types.SMALLINT: case Types.BOOLEAN: default: ps.setObject(i+1,u.getProperty(cname));
					 }
				 }
			 }
			 if (dbp.idField != null) {
				 if (u.getID()==null) {
					 Server.log(u, ""Unable to store logout-data for "" + u.getName() + "" because of missing id-value"", Server.MSG_AUTH, Server.LVL_MAJOR);
					 return;
				 }
				 ps.setString(dbp.updCols.length+1, u.getID());
			 }
			 else {
				 ps.setString(dbp.updCols.length+1, u.getName().toLowerCase());
			 }
			 int rows = ps.executeUpdate();
			 sCnt++;
			 if (rows==1) {
				 con.commit();
			 }
			 else if (rows < 1) {
				 Server.log(Thread.currentThread(), this.toString() + ""LOGOUT unable to update userdata! No record for: "" + dbp.idField != null ? dbp.idField + "" = "" + u.getID() : ""username = "" + u.getName().toLowerCase(), Server.MSG_AUTH, Server.LVL_MAJOR);
				 return;
			 }
			 else if (rows > 1) {
				 Server.log(Thread.currentThread(), this.toString() + ""LOGOUT unable to update userdata! More than one value would be updated: ("" + dbp.idField != null ? dbp.idField + "" = "" + u.getID() : ""username = "" + u.getName().toLowerCase() + "")"", Server.MSG_AUTH, Server.LVL_MAJOR);
				 try {
					 con.rollback();
					 Server.log (Thread.currentThread(), this.toString() + ""LOGOUT rollback successfully"", Server.MSG_AUTH, Server.LVL_VERBOSE);
				 }
				 catch (SQLException se) {
					 Server.log (Thread.currentThread(), this.toString() + ""LOGOUT rollback failed!!!"", Server.MSG_AUTH, Server.LVL_MAJOR);
				 }
			 }
			 checkWarnings(ps, ""logoutUser"");
		 }
		 catch (Exception e) {
			 isValid=false;
			 release();
			 throw e;
		 }
	 }
	 private static String getEncodedString (ResultSet rs, int idx) {
		 if (rs == null) return null;
		 try {
			 String result = rs.getString (idx);
			 if (result==null) return null;
			 result = result.replaceAll (""[<]"", ""&lt;
			"");
			 result = result.replaceAll (""[>]"", ""&gt;
			"");
			 result = EntityDecoder.convertFormattingCharacters(result);
			 return result;
		 }
		 catch (Exception e) {
			 Server.debug (""static PoolElement"", ""getEncodedString: error geting encoded string"", e, Server.MSG_ERROR, Server.LVL_MAJOR);
		 }
		 return null;
	 }
	 private void checkThread() throws CanceledRequestException {
		 if (Thread.currentThread().isInterrupted()) throw new CanceledRequestException (""ConnectionBuffer has been invalidated"");
	 }
	 public void finalize() {
		 if (Server.TRACE_CREATE_AND_FINALIZE) Server.log(this, ""----------------------------------------FINALIZED"", Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
	 }
}",1,0,0,0
"public GSSCredentialSpi getCredentialElement(GSSNameSpi name, int initLifetime, int acceptLifetime, int usage) throws GSSException {
	 if (name != null && !(name instanceof GssNameElement)) {
		 name = GssNameElement.getInstance(name.toString(), name.getStringNameType());
	 }
	 GssCredElement credElement;
	 if (usage == GSSCredential.INITIATE_ONLY) {
		 credElement = GssInitCred.getInstance(caller, (GssNameElement) name, initLifetime);
	 }
	 else if (usage == GSSCredential.ACCEPT_ONLY) {
		 credElement = GssAcceptCred.getInstance(caller, (GssNameElement) name, acceptLifetime);
	 }
	 else if (usage == GSSCredential.INITIATE_AND_ACCEPT) {
		 throw new GSSException(GSSException.FAILURE, -1, ""Unsupported usage mode: INITIATE_AND_ACCEPT"");
	 }
	 else {
		 throw new GSSException(GSSException.FAILURE, -1, ""Unknown usage mode: "" + usage);
	 }
	 return credElement;
 }",0,0,1,0
"protected int compareEntries(Entry e1, Entry e2);",0,0,0,0
"public void deleteFolder(String folderPath) throws IOException {
	 FolderId folderId = getFolderIdIfExists(folderPath);
	 if (folderId != null) {
		 DeleteFolderMethod deleteFolderMethod = new DeleteFolderMethod(folderId);
		 executeMethod(deleteFolderMethod);
	 }
	 else {
		 LOGGER.debug(""Folder "" + folderPath + "" not found"");
	 }
 }",0,0,0,0
"public final class Properties{
	public static final Properties EMPTY_PROPERTIES = new Properties(""NULL"", ValueMap.EMPTY_MAP);
	private final String key;
	private final ValueMap strings;
	public Properties(final String key, final ValueMap strings){
		this.key = key;
		this.strings = strings;
	}
	public final ValueMap getAll(){
		return strings;
	}
	public final String getString(final String key){
		return strings.getString(key);
	}
	public final String toString(){
		return key;
	}
}",0,0,0,0
"public class HTMLDocumentImpl extends DocumentImpl implements HTMLDocument{
	 private static final long serialVersionUID = 4285791750126227180L;
	 private HTMLCollectionImpl _anchors;
	 private HTMLCollectionImpl _forms;
	 private HTMLCollectionImpl _images;
	 private HTMLCollectionImpl _links;
	 private HTMLCollectionImpl _applets;
	 private StringWriter _writer;
	 private static Hashtable _elementTypesHTML;
	 private static final Class[] _elemClassSigHTML = new Class[] {
	 HTMLDocumentImpl.class, String.class }
	;
	 public HTMLDocumentImpl() {
		 super();
		 populateElementTypes();
	 }
	 public synchronized Element getDocumentElement() {
		 Node html;
		 Node child;
		 Node next;
		 html = getFirstChild();
		 while ( html != null ) {
			 if ( html instanceof HTMLHtmlElement ) {
				 return (HTMLElement) html;
			 }
			 html = html.getNextSibling();
		 }
		 html = new HTMLHtmlElementImpl( this, ""HTML"" );
		 child = getFirstChild();
		 while ( child != null ) {
			 next = child.getNextSibling();
			 html.appendChild( child );
			 child = next;
		 }
		 appendChild( html );
		 return (HTMLElement) html;
	 }
	 public synchronized HTMLElement getHead() {
		 Node head;
		 Node html;
		 Node child;
		 Node next;
		 html = getDocumentElement();
		 synchronized ( html ) {
			 head = html.getFirstChild();
			 while ( head != null && ! ( head instanceof HTMLHeadElement ) ) head = head.getNextSibling();
			 if ( head != null ) {
				 synchronized ( head ) {
					 child = html.getFirstChild();
					 while ( child != null && child != head ) {
						 next = child.getNextSibling();
						 head.insertBefore( child, head.getFirstChild() );
						 child = next;
					 }
				 }
				 return (HTMLElement) head;
			 }
			 head = new HTMLHeadElementImpl( this, ""HEAD"" );
			 html.insertBefore( head, html.getFirstChild() );
		 }
		 return (HTMLElement) head;
	 }
	 public synchronized String getTitle() {
		 HTMLElement head;
		 NodeList list;
		 Node title;
		 head = getHead();
		 list = head.getElementsByTagName( ""TITLE"" );
		 if ( list.getLength() > 0 ) {
			 title = list.item( 0 );
			 return ( (HTMLTitleElement) title ).getText();
		 }
		 return """";
	 }
	 public synchronized void setTitle( String newTitle ) {
		 HTMLElement head;
		 NodeList list;
		 Node title;
		 head = getHead();
		 list = head.getElementsByTagName( ""TITLE"" );
		 if ( list.getLength() > 0 ) {
			 title = list.item( 0 );
			 if ( title.getParentNode() != head ) head.appendChild( title );
			 ( (HTMLTitleElement) title ).setText( newTitle );
		 }
		 else {
			 title = new HTMLTitleElementImpl( this, ""TITLE"" );
			 ( (HTMLTitleElement) title ).setText( newTitle );
			 head.appendChild( title );
		 }
	 }
	 public synchronized HTMLElement getBody() {
		 Node html;
		 Node head;
		 Node body;
		 Node child;
		 Node next;
		 html = getDocumentElement();
		 head = getHead();
		 synchronized ( html ) {
			 body = head.getNextSibling();
			 while ( body != null && ! ( body instanceof HTMLBodyElement ) && ! ( body instanceof HTMLFrameSetElement ) ) body = body.getNextSibling();
			 if ( body != null ) {
				 synchronized ( body ) {
					 child = head.getNextSibling();
					 while ( child != null && child != body ) {
						 next = child.getNextSibling();
						 body.insertBefore( child, body.getFirstChild() );
						 child = next;
					 }
				 }
				 return (HTMLElement) body;
			 }
			 body = new HTMLBodyElementImpl( this, ""BODY"" );
			 html.appendChild( body );
		 }
		 return (HTMLElement) body;
	 }
	 public synchronized void setBody( HTMLElement newBody ) {
		 Node html;
		 Node body;
		 Node head;
		 Node child;
		 NodeList list;
		 synchronized ( newBody ) {
			 html = getDocumentElement();
			 head = getHead();
			 synchronized ( html ) {
				 list = this.getElementsByTagName( ""BODY"" );
				 if ( list.getLength() > 0 ) {
					 body = list.item( 0 );
					 synchronized ( body ) {
						 child = head;
						 while ( child != null ) {
							 if ( child instanceof Element ) {
								 if ( child != body ) html.insertBefore( newBody, child );
								 else html.replaceChild( newBody, body );
								 return;
							 }
							 child = child.getNextSibling();
						 }
						 html.appendChild( newBody );
					 }
					 return;
				 }
				 html.appendChild( newBody );
			 }
		 }
	 }
	 public synchronized Element getElementById( String elementId ) {
		 Element idElement = super.getElementById(elementId);
		 if (idElement != null) {
			 return idElement;
		 }
		 return getElementById( elementId, this );
	 }
	 public NodeList getElementsByName( String elementName ) {
		 return new NameNodeListImpl( this, elementName );
	 }
	 public final NodeList getElementsByTagName( String tagName ) {
		 return super.getElementsByTagName( tagName.toUpperCase(Locale.ENGLISH) );
	 }
	 public final NodeList getElementsByTagNameNS( String namespaceURI, String localName ) {
		 if ( namespaceURI != null && namespaceURI.length() > 0 ) {
			 return super.getElementsByTagNameNS( namespaceURI, localName.toUpperCase(Locale.ENGLISH) );
		 }
		 return super.getElementsByTagName( localName.toUpperCase(Locale.ENGLISH) );
	 }
	 public Element createElementNS(String namespaceURI, String qualifiedName, String localpart) throws DOMException {
		 return createElementNS(namespaceURI, qualifiedName);
	 }
	 public Element createElementNS( String namespaceURI, String qualifiedName ) {
		 if ( namespaceURI == null || namespaceURI.length() == 0 ) {
			 return createElement( qualifiedName );
		 }
		 return super.createElementNS( namespaceURI, qualifiedName );
	 }
	 public Element createElement( String tagName ) throws DOMException {
		 Class elemClass;
		 Constructor cnst;
		 tagName = tagName.toUpperCase(Locale.ENGLISH);
		 elemClass = (Class) _elementTypesHTML.get( tagName );
		 if ( elemClass != null ) {
			 try {
				 cnst = elemClass.getConstructor( _elemClassSigHTML );
				 return (Element) cnst.newInstance( new Object[] {
				 this, tagName }
				 );
			 }
			 catch ( Exception except ) {
				 throw new IllegalStateException( ""HTM15 Tag '"" + tagName + ""' associated with an Element class that failed to construct.\n"" + tagName);
			 }
		 }
		 return new HTMLElementImpl( this, tagName );
	 }
	 public Attr createAttribute( String name ) throws DOMException {
		 return super.createAttribute( name.toLowerCase(Locale.ENGLISH) );
	 }
	 public String getReferrer() {
		 return null;
	 }
	 public String getDomain() {
		 return null;
	 }
	 public String getURL() {
		 return null;
	 }
	 public String getCookie() {
		 return null;
	 }
	 public void setCookie( String cookie ) {
	 }
	 public HTMLCollection getImages() {
		 if ( _images == null ) _images = new HTMLCollectionImpl( getBody(), HTMLCollectionImpl.IMAGE );
		 return _images;
	 }
	 public HTMLCollection getApplets() {
		 if ( _applets == null ) _applets = new HTMLCollectionImpl( getBody(), HTMLCollectionImpl.APPLET );
		 return _applets;
	 }
	 public HTMLCollection getLinks() {
		 if ( _links == null ) _links = new HTMLCollectionImpl( getBody(), HTMLCollectionImpl.LINK );
		 return _links;
	 }
	 public HTMLCollection getForms() {
		 if ( _forms == null ) _forms = new HTMLCollectionImpl( getBody(), HTMLCollectionImpl.FORM );
		 return _forms;
	 }
	 public HTMLCollection getAnchors() {
		 if ( _anchors == null ) _anchors = new HTMLCollectionImpl( getBody(), HTMLCollectionImpl.ANCHOR );
		 return _anchors;
	 }
	 public void open() {
		 if ( _writer == null ) _writer = new StringWriter();
	 }
	 public void close() {
		 if ( _writer != null ) {
			 _writer = null;
		 }
	 }
	 public void write( String text ) {
		 if ( _writer != null ) _writer.write( text );
	 }
	 public void writeln( String text ) {
		 if ( _writer != null ) _writer.write( text + ""\n"" );
	 }
	 public Node cloneNode( boolean deep ) {
		 HTMLDocumentImpl newdoc = new HTMLDocumentImpl();
		 callUserDataHandlers(this, newdoc, UserDataHandler.NODE_CLONED);
		 cloneNode(newdoc, deep);
		 return newdoc;
	 }
	 protected boolean canRenameElements(String newNamespaceURI, String newNodeName, ElementImpl el) {
		 if (el.getNamespaceURI() != null) {
			 return newNamespaceURI != null;
		 }
		 Class newClass = (Class) _elementTypesHTML.get(newNodeName.toUpperCase(Locale.ENGLISH));
		 Class oldClass = (Class) _elementTypesHTML.get(el.getTagName());
		 return newClass == oldClass;
	 }
	 private Element getElementById( String elementId, Node node ) {
		 Node child;
		 Element result;
		 child = node.getFirstChild();
		 while ( child != null ) {
			 if ( child instanceof Element ) {
				 if ( elementId.equals( ( (Element) child ).getAttribute( ""id"" ) ) ) return (Element) child;
				 result = getElementById( elementId, child );
				 if ( result != null ) return result;
			 }
			 child = child.getNextSibling();
		 }
		 return null;
	 }
	 private synchronized static void populateElementTypes() {
		 if ( _elementTypesHTML != null ) return;
		 _elementTypesHTML = new Hashtable( 63 );
		 populateElementType( ""A"", ""HTMLAnchorElementImpl"" );
		 populateElementType( ""APPLET"", ""HTMLAppletElementImpl"" );
		 populateElementType( ""AREA"", ""HTMLAreaElementImpl"" );
		 populateElementType( ""BASE"", ""HTMLBaseElementImpl"" );
		 populateElementType( ""BASEFONT"", ""HTMLBaseFontElementImpl"" );
		 populateElementType( ""BLOCKQUOTE"", ""HTMLQuoteElementImpl"" );
		 populateElementType( ""BODY"", ""HTMLBodyElementImpl"" );
		 populateElementType( ""BR"", ""HTMLBRElementImpl"" );
		 populateElementType( ""BUTTON"", ""HTMLButtonElementImpl"" );
		 populateElementType( ""DEL"", ""HTMLModElementImpl"" );
		 populateElementType( ""DIR"", ""HTMLDirectoryElementImpl"" );
		 populateElementType( ""DIV"", ""HTMLDivElementImpl"" );
		 populateElementType( ""DL"", ""HTMLDListElementImpl"" );
		 populateElementType( ""FIELDSET"", ""HTMLFieldSetElementImpl"" );
		 populateElementType( ""FONT"", ""HTMLFontElementImpl"" );
		 populateElementType( ""FORM"", ""HTMLFormElementImpl"" );
		 populateElementType( ""FRAME"",""HTMLFrameElementImpl"" );
		 populateElementType( ""FRAMESET"", ""HTMLFrameSetElementImpl"" );
		 populateElementType( ""HEAD"", ""HTMLHeadElementImpl"" );
		 populateElementType( ""H1"", ""HTMLHeadingElementImpl"" );
		 populateElementType( ""H2"", ""HTMLHeadingElementImpl"" );
		 populateElementType( ""H3"", ""HTMLHeadingElementImpl"" );
		 populateElementType( ""H4"", ""HTMLHeadingElementImpl"" );
		 populateElementType( ""H5"", ""HTMLHeadingElementImpl"" );
		 populateElementType( ""H6"", ""HTMLHeadingElementImpl"" );
		 populateElementType( ""HR"", ""HTMLHRElementImpl"" );
		 populateElementType( ""HTML"", ""HTMLHtmlElementImpl"" );
		 populateElementType( ""IFRAME"", ""HTMLIFrameElementImpl"" );
		 populateElementType( ""IMG"", ""HTMLImageElementImpl"" );
		 populateElementType( ""INPUT"", ""HTMLInputElementImpl"" );
		 populateElementType( ""INS"", ""HTMLModElementImpl"" );
		 populateElementType( ""ISINDEX"", ""HTMLIsIndexElementImpl"" );
		 populateElementType( ""LABEL"", ""HTMLLabelElementImpl"" );
		 populateElementType( ""LEGEND"", ""HTMLLegendElementImpl"" );
		 populateElementType( ""LI"", ""HTMLLIElementImpl"" );
		 populateElementType( ""LINK"", ""HTMLLinkElementImpl"" );
		 populateElementType( ""MAP"", ""HTMLMapElementImpl"" );
		 populateElementType( ""MENU"", ""HTMLMenuElementImpl"" );
		 populateElementType( ""META"", ""HTMLMetaElementImpl"" );
		 populateElementType( ""OBJECT"", ""HTMLObjectElementImpl"" );
		 populateElementType( ""OL"", ""HTMLOListElementImpl"" );
		 populateElementType( ""OPTGROUP"", ""HTMLOptGroupElementImpl"" );
		 populateElementType( ""OPTION"", ""HTMLOptionElementImpl"" );
		 populateElementType( ""P"", ""HTMLParagraphElementImpl"" );
		 populateElementType( ""PARAM"", ""HTMLParamElementImpl"" );
		 populateElementType( ""PRE"", ""HTMLPreElementImpl"" );
		 populateElementType( ""Q"", ""HTMLQuoteElementImpl"" );
		 populateElementType( ""SCRIPT"", ""HTMLScriptElementImpl"" );
		 populateElementType( ""SELECT"", ""HTMLSelectElementImpl"" );
		 populateElementType( ""STYLE"", ""HTMLStyleElementImpl"" );
		 populateElementType( ""TABLE"", ""HTMLTableElementImpl"" );
		 populateElementType( ""CAPTION"", ""HTMLTableCaptionElementImpl"" );
		 populateElementType( ""TD"", ""HTMLTableCellElementImpl"" );
		 populateElementType( ""TH"", ""HTMLTableCellElementImpl"" );
		 populateElementType( ""COL"", ""HTMLTableColElementImpl"" );
		 populateElementType( ""COLGROUP"", ""HTMLTableColElementImpl"" );
		 populateElementType( ""TR"", ""HTMLTableRowElementImpl"" );
		 populateElementType( ""TBODY"", ""HTMLTableSectionElementImpl"" );
		 populateElementType( ""THEAD"", ""HTMLTableSectionElementImpl"" );
		 populateElementType( ""TFOOT"", ""HTMLTableSectionElementImpl"" );
		 populateElementType( ""TEXTAREA"", ""HTMLTextAreaElementImpl"" );
		 populateElementType( ""TITLE"", ""HTMLTitleElementImpl"" );
		 populateElementType( ""UL"", ""HTMLUListElementImpl"" );
	 }
	 private static void populateElementType( String tagName, String className ) {
		 try {
			 _elementTypesHTML.put( tagName, ObjectFactory.findProviderClass(""org.apache.html.dom."" + className, HTMLDocumentImpl.class.getClassLoader(), true) );
		 }
		 catch ( Exception except ) {
			 throw new RuntimeException( ""HTM019 OpenXML Error: Could not find or execute class "" + className + "" implementing HTML element "" + tagName + ""\n"" + className + ""\t"" + tagName);
		 }
	 }
}",1,0,0,0
"public class RepositoryServiceImpl implements RepositoryService, DavConstants {
	 private static Logger log = LoggerFactory.getLogger(RepositoryServiceImpl.class);
	 private static final SubscriptionInfo S_INFO = new SubscriptionInfo(DefaultEventType.create(EventUtil.EVENT_ALL, ItemResourceConstants.NAMESPACE), true, INFINITE_TIMEOUT);
	 private static final String CLIENT_KEY = ""repoCreation"";
	 public static final int MAX_CONNECTIONS_DEFAULT = 20;
	 private final IdFactory idFactory;
	 private final NameFactory nameFactory;
	 private final PathFactory pathFactory;
	 private final QValueFactory qValueFactory;
	 private final ValueFactory valueFactory;
	 private final int itemInfoCacheSize;
	 private final NamespaceCache nsCache;
	 private final URIResolverImpl uriResolver;
	 private final HttpHost httpHost;
	 private final ConcurrentMap<Object, HttpClient> clients;
	 private final HttpClientBuilder httpClientBuilder;
	 private final Map<AuthScope, org.apache.http.auth.Credentials> commonCredentials;
	 private final Map<Name, QNodeTypeDefinition> nodeTypeDefinitions = new HashMap<Name, QNodeTypeDefinition>();
	 private final Map<String, QValue[]> descriptors = new HashMap<String, QValue[]>();
	 private boolean remoteServerProvidesNodeTypes = false;
	 private boolean remoteServerProvidesNoLocalFlag = false;
	 private Set<String> remoteDavComplianceClasses = null;
	 public RepositoryServiceImpl(String uri, IdFactory idFactory, NameFactory nameFactory, PathFactory pathFactory, QValueFactory qValueFactory) throws RepositoryException {
		 this(uri, idFactory, nameFactory, pathFactory, qValueFactory, ItemInfoCacheImpl.DEFAULT_CACHE_SIZE);
	 }
	 public RepositoryServiceImpl(String uri, IdFactory idFactory, NameFactory nameFactory, PathFactory pathFactory, QValueFactory qValueFactory, int itemInfoCacheSize) throws RepositoryException {
		 this(uri, idFactory, nameFactory, pathFactory, qValueFactory, itemInfoCacheSize, ConnectionOptions.DEFAULT);
	 }
	 public RepositoryServiceImpl(String uri, IdFactory idFactory, NameFactory nameFactory, PathFactory pathFactory, QValueFactory qValueFactory, int itemInfoCacheSize, ConnectionOptions connectionOptions) throws RepositoryException {
		 if (uri == null || """".equals(uri)) {
			 throw new RepositoryException(""Invalid repository uri '"" + uri + ""'."");
		 }
		 if (idFactory == null || qValueFactory == null) {
			 throw new RepositoryException(""IdFactory and QValueFactory may not be null."");
		 }
		 this.idFactory = idFactory;
		 this.nameFactory = nameFactory;
		 this.pathFactory = pathFactory;
		 this.qValueFactory = qValueFactory;
		 this.itemInfoCacheSize = itemInfoCacheSize;
		 this.commonCredentials = new HashMap<>();
		 try {
			 URI repositoryUri = computeRepositoryUri(uri);
			 httpHost = new HttpHost(repositoryUri.getHost(), repositoryUri.getPort(), repositoryUri.getScheme());
			 nsCache = new NamespaceCache();
			 uriResolver = new URIResolverImpl(repositoryUri, this, DomUtil.createDocument());
			 NamePathResolver resolver = new NamePathResolverImpl(nsCache);
			 valueFactory = new ValueFactoryQImpl(qValueFactory, resolver);
		 }
		 catch (URISyntaxException e) {
			 throw new RepositoryException(e);
		 }
		 catch (ParserConfigurationException e) {
			 throw new RepositoryException(e);
		 }
		 HttpClientBuilder hcb = HttpClients.custom();
		 final SSLConnectionSocketFactory sslSocketFactory;
		 RequestConfig requestConfig = RequestConfig.custom(). setConnectTimeout(connectionOptions.getConnectionTimeoutMs()). setConnectionRequestTimeout(connectionOptions.getRequestTimeoutMs()). setSocketTimeout(connectionOptions.getSocketTimeoutMs()).build();
		 hcb.setDefaultRequestConfig(requestConfig);
		 if (Boolean.getBoolean(""jackrabbit.client.useSystemProperties"") || connectionOptions.isUseSystemPropertes()) {
			 log.debug(""Using system properties for establishing connection!"");
			 if (connectionOptions.isAllowSelfSignedCertificates()) {
				 throw new RepositoryException(ConnectionOptions.PARAM_ALLOW_SELF_SIGNED_CERTIFICATES + "" is not allowed when system properties (jackrabbit.client.useSystemProperties) have been specified."");
			 }
			 if (connectionOptions.isDisableHostnameVerification()) {
				 throw new RepositoryException(ConnectionOptions.PARAM_DISABLE_HOSTNAME_VERIFICATION + "" is not allowed when system properties (jackrabbit.client.useSystemProperties) have been specified."");
			 }
			 hcb.useSystemProperties();
			 sslSocketFactory = SSLConnectionSocketFactory.getSystemSocketFactory();
		 }
		 else {
			 final SSLContext sslContext;
			 try {
				 if (connectionOptions.isAllowSelfSignedCertificates()) {
					 log.warn(""Nonsecure TLS setting: Accepting self-signed certificates!"");
					 sslContext = SSLContextBuilder.create().loadTrustMaterial(new TrustSelfSignedStrategy()).build();
					 hcb.setSSLContext(sslContext);
				 }
				 else {
					 sslContext = SSLContextBuilder.create().build();
				 }
			 }
			 catch (KeyManagementException | NoSuchAlgorithmException | KeyStoreException e) {
				 throw new RepositoryException(e);
			 }
			 if (connectionOptions.isDisableHostnameVerification()) {
				 log.warn(""Nonsecure TLS setting: Host name verification of TLS certificates disabled!"");
				 sslSocketFactory = new SSLConnectionSocketFactory(sslContext, NoopHostnameVerifier.INSTANCE);
			 }
			 else {
				 sslSocketFactory = new SSLConnectionSocketFactory(sslContext);
			 }
		 }
		 Registry<ConnectionSocketFactory> socketFactoryRegistry = RegistryBuilder.<ConnectionSocketFactory>create() .register(""http"", PlainConnectionSocketFactory.getSocketFactory()) .register(""https"", sslSocketFactory) .build();
		 PoolingHttpClientConnectionManager cmgr = new PoolingHttpClientConnectionManager(socketFactoryRegistry);
		 int maxConnections = connectionOptions.getMaxConnections();
		 if (maxConnections > 0) {
			 cmgr.setDefaultMaxPerRoute(connectionOptions.getMaxConnections());
			 cmgr.setMaxTotal(connectionOptions.getMaxConnections());
		 }
		 else {
			 maxConnections = ConnectionOptions.MAX_CONNECTIONS_DEFAULT;
		 }
		 hcb.setConnectionManager(cmgr);
		 if (connectionOptions.getProxyHost() != null) {
			 HttpHost proxy = new HttpHost(connectionOptions.getProxyHost(), connectionOptions.getProxyPort(), connectionOptions.getProxyProtocol());
			 DefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);
			 hcb.setRoutePlanner(routePlanner);
			 log.debug(""Connection via proxy {
			}
			"", proxy);
			 if (connectionOptions.getProxyUsername() != null) {
				 log.debug(""Proxy connection with credentials {
				}
				"", proxy);
				 commonCredentials.put( new AuthScope(proxy), new UsernamePasswordCredentials(connectionOptions.getProxyUsername(), connectionOptions.getProxyPassword()));
				 hcb.setProxyAuthenticationStrategy(new ProxyAuthenticationStrategy());
			 }
		 }
		 httpClientBuilder = hcb;
		 clients = new ConcurrentHashMap<Object, HttpClient>(maxConnections, .75f, maxConnections);
	 }
	 private static void checkSessionInfo(SessionInfo sessionInfo) throws RepositoryException {
		 if (!(sessionInfo instanceof SessionInfoImpl)) {
			 throw new RepositoryException(""Unknown SessionInfo implementation."");
		 }
	 }
	 private static String resolve(String baseUri, String relUri) throws RepositoryException {
		 try {
			 java.net.URI base = new java.net.URI(baseUri);
			 java.net.URI rel = new java.net.URI(relUri);
			 return base.resolve(rel).toString();
		 }
		 catch (URISyntaxException ex) {
			 throw new RepositoryException(ex);
		 }
	 }
	 private static void checkSubscription(Subscription subscription) throws RepositoryException {
		 if (!(subscription instanceof EventSubscriptionImpl)) {
			 throw new RepositoryException(""Unknown Subscription implementation."");
		 }
	 }
	 private static boolean isUnLockMethod(HttpUriRequest request) {
		 int code = DavMethods.getMethodCode(request.getMethod());
		 return DavMethods.DAV_UNLOCK == code;
	 }
	 protected static void initMethod(HttpUriRequest request, SessionInfo sessionInfo, boolean addIfHeader) throws RepositoryException {
		 if (addIfHeader) {
			 checkSessionInfo(sessionInfo);
			 Set<String> allLockTokens = ((SessionInfoImpl) sessionInfo).getAllLockTokens();
			 if (!allLockTokens.isEmpty()) {
				 String[] locktokens = allLockTokens.toArray(new String[allLockTokens.size()]);
				 IfHeader ifH = new IfHeader(locktokens);
				 request.setHeader(ifH.getHeaderName(), ifH.getHeaderValue());
			 }
		 }
		 initMethod(request, sessionInfo);
	 }
	 private static final Set<String> readMethods;
	 static {
		 Set<String> tmp = new HashSet<String>();
		 tmp.add(""GET"");
		 tmp.add(""HEAD"");
		 tmp.add(""PROPFIND"");
		 tmp.add(""POLL"");
		 tmp.add(""REPORT"");
		 tmp.add(""SEARCH"");
		 readMethods = Collections.unmodifiableSet(tmp);
	 }
	 protected static void initMethod(HttpUriRequest request, SessionInfo sessionInfo) throws RepositoryException {
		 boolean isReadAccess = readMethods.contains(request.getMethod());
		 boolean needsSessionId = !isReadAccess || ""POLL"".equals(request.getMethod());
		 if (sessionInfo instanceof SessionInfoImpl && needsSessionId) {
			 request.addHeader(""Link"", generateLinkHeaderFieldValue(sessionInfo, isReadAccess));
		 }
	 }
	 private static String generateLinkHeaderFieldValue(SessionInfo sessionInfo, boolean isReadAccess) {
		 StringBuilder linkHeaderField = new StringBuilder();
		 String sessionIdentifier = ((SessionInfoImpl) sessionInfo).getSessionIdentifier();
		 linkHeaderField.append(""<"").append(sessionIdentifier).append("">;
		 rel=\"""") .append(JcrRemotingConstants.RELATION_REMOTE_SESSION_ID).append(""\"""");
		 String userdata = ((SessionInfoImpl) sessionInfo).getUserData();
		 if (userdata != null && !isReadAccess) {
			 String escaped = Text.escape(userdata);
			 linkHeaderField.append("", <data:,"").append(escaped).append("">;
			 rel=\"""").append(JcrRemotingConstants.RELATION_USER_DATA) .append(""\"""");
		 }
		 return linkHeaderField.toString();
	 }
	 private static void initMethod(HttpUriRequest request, BatchImpl batchImpl, boolean addIfHeader) throws RepositoryException {
		 initMethod(request, batchImpl.sessionInfo, addIfHeader);
		 CodedUrlHeader ch = new CodedUrlHeader(TransactionConstants.HEADER_TRANSACTIONID, batchImpl.batchId);
		 request.setHeader(ch.getHeaderName(), ch.getHeaderValue());
	 }
	 private static boolean isSameResource(String requestURI, MultiStatusResponse response) {
		 try {
			 String href = resolve(requestURI, response.getHref());
			 if (href.endsWith(""/"") && !requestURI.endsWith(""/"")) {
				 href = href.substring(0, href.length() - 1);
			 }
			 return requestURI.equals(href);
		 }
		 catch (RepositoryException e) {
			 return false;
		 }
	 }
	 private String saveGetIdString(ItemId id, SessionInfo sessionInfo) {
		 NamePathResolver resolver = null;
		 try {
			 resolver = getNamePathResolver(sessionInfo);
		 }
		 catch (RepositoryException e) {
		 }
		 return saveGetIdString(id, resolver);
	 }
	 private String saveGetIdString(ItemId id, NamePathResolver resolver) {
		 StringBuffer bf = new StringBuffer();
		 String uid = id.getUniqueID();
		 if (uid != null) {
			 bf.append(uid);
		 }
		 Path p = id.getPath();
		 if (p != null) {
			 if (resolver == null) {
				 bf.append(p.toString());
			 }
			 else {
				 try {
					 bf.append(resolver.getJCRPath(p));
				 }
				 catch (NamespaceException e) {
					 bf.append(p.toString());
				 }
			 }
		 }
		 return bf.toString();
	 }
	 protected NamePathResolver getNamePathResolver(SessionInfo sessionInfo) throws RepositoryException {
		 checkSessionInfo(sessionInfo);
		 return getNamePathResolver(((SessionInfoImpl) sessionInfo));
	 }
	 private NamePathResolver getNamePathResolver(SessionInfoImpl sessionInfo) {
		 NamePathResolver resolver = sessionInfo.getNamePathResolver();
		 if (resolver == null) {
			 resolver = new NamePathResolverImpl(sessionInfo);
			 sessionInfo.setNamePathResolver(resolver);
		 }
		 return resolver;
	 }
	 private static Object getClientKey(SessionInfo sessionInfo) {
		 return (sessionInfo == null) ? CLIENT_KEY : sessionInfo;
	 }
	 protected HttpClient getClient(SessionInfo sessionInfo) throws RepositoryException {
		 Object clientKey = getClientKey(sessionInfo);
		 HttpClient client = clients.get(clientKey);
		 if (client == null) {
			 client = httpClientBuilder.build();
			 if (sessionInfo != null) {
				 checkSessionInfo(sessionInfo);
				 clients.put(clientKey, client);
				 log.debug(""Created Client "" + client + "" for SessionInfo "" + sessionInfo);
			 }
		 }
		 return client;
	 }
	 protected HttpContext getContext(SessionInfo sessionInfo) throws RepositoryException {
		 HttpClientContext result = HttpClientContext.create();
		 CredentialsProvider credsProvider = new BasicCredentialsProvider();
		 result.setCredentialsProvider(credsProvider);
		 for (Map.Entry<AuthScope, org.apache.http.auth.Credentials> entry : commonCredentials.entrySet()) {
			 credsProvider.setCredentials(entry.getKey(), entry.getValue());
		 }
		 if (sessionInfo != null) {
			 checkSessionInfo(sessionInfo);
			 org.apache.http.auth.Credentials creds = ((SessionInfoImpl) sessionInfo).getCredentials().getHttpCredentials();
			 if (creds != null) {
				 credsProvider.setCredentials(new org.apache.http.auth.AuthScope(httpHost.getHostName(), httpHost.getPort()), creds);
				 BasicScheme basicAuth = new BasicScheme();
				 AuthCache authCache = new BasicAuthCache();
				 authCache.put(httpHost, basicAuth);
				 result.setAuthCache(authCache);
			 }
		 }
		 return result;
	 }
	 private void removeClient(SessionInfo sessionInfo) {
		 HttpClient cl = clients.remove(getClientKey(sessionInfo));
		 log.debug(""Removed Client "" + cl + "" for SessionInfo "" + sessionInfo);
	 }
	 protected String getItemUri(ItemId itemId, SessionInfo sessionInfo) throws RepositoryException {
		 return getItemUri(itemId, sessionInfo, sessionInfo.getWorkspaceName());
	 }
	 protected String getItemUri(ItemId itemId, SessionInfo sessionInfo, String workspaceName) throws RepositoryException {
		 return uriResolver.getItemUri(itemId, workspaceName, sessionInfo);
	 }
	 protected void clearItemUriCache(SessionInfo sessionInfo) {
		 uriResolver.clearCacheEntries(sessionInfo);
	 }
	 private String getItemUri(NodeId parentId, Name childName, SessionInfo sessionInfo) throws RepositoryException {
		 String parentUri = uriResolver.getItemUri(parentId, sessionInfo.getWorkspaceName(), sessionInfo);
		 NamePathResolver resolver = getNamePathResolver(sessionInfo);
		 if (!parentUri.endsWith(""/"")) {
			 parentUri += ""/"";
		 }
		 return parentUri + Text.escape(resolver.getJCRName(childName));
	 }
	 private NodeId getParentId(String baseUri, DavPropertySet propSet, SessionInfo sessionInfo) throws RepositoryException {
		 NodeId parentId = null;
		 DavProperty<?> p = propSet.get(JcrRemotingConstants.JCR_PARENT_LN, ItemResourceConstants.NAMESPACE);
		 if (p != null) {
			 HrefProperty parentProp = new HrefProperty(p);
			 String parentHref = parentProp.getHrefs().get(0);
			 if (parentHref != null && parentHref.length() > 0) {
				 parentId = uriResolver.getNodeId(resolve(baseUri, parentHref), sessionInfo);
			 }
		 }
		 return parentId;
	 }
	 String getUniqueID(DavPropertySet propSet) {
		 DavProperty<?> prop = propSet.get(JcrRemotingConstants.JCR_UUID_LN, ItemResourceConstants.NAMESPACE);
		 if (prop != null) {
			 return prop.getValue().toString();
		 }
		 else {
			 return null;
		 }
	 }
	 Name getQName(DavPropertySet propSet, NamePathResolver resolver) throws RepositoryException {
		 DavProperty<?> nameProp = propSet.get(JcrRemotingConstants.JCR_NAME_LN, ItemResourceConstants.NAMESPACE);
		 if (nameProp != null && nameProp.getValue() != null) {
			 String jcrName = nameProp.getValue().toString();
			 try {
				 return resolver.getQName(jcrName);
			 }
			 catch (NameException e) {
				 throw new RepositoryException(e);
			 }
		 }
		 else {
			 return NameConstants.ROOT;
		 }
	 }
	 int getIndex(DavPropertySet propSet) {
		 int index = Path.INDEX_UNDEFINED;
		 DavProperty<?> indexProp = propSet.get(JcrRemotingConstants.JCR_INDEX_LN, ItemResourceConstants.NAMESPACE);
		 if (indexProp != null && indexProp.getValue() != null) {
			 index = Integer.parseInt(indexProp.getValue().toString());
		 }
		 return index;
	 }
	 private HttpResponse execute(BaseDavRequest request, SessionInfo sessionInfo) throws RepositoryException {
		 try {
			 initMethod(request, sessionInfo, !isUnLockMethod(request));
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 return response;
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e, request);
		 }
	 }
	 public IdFactory getIdFactory() {
		 return idFactory;
	 }
	 public NameFactory getNameFactory() {
		 return nameFactory;
	 }
	 public PathFactory getPathFactory() {
		 return pathFactory;
	 }
	 public QValueFactory getQValueFactory() {
		 return qValueFactory;
	 }
	 public ItemInfoCache getItemInfoCache(SessionInfo sessionInfo) throws RepositoryException {
		 return new ItemInfoCacheImpl(itemInfoCacheSize);
	 }
	 public Map<String, QValue[]> getRepositoryDescriptors() throws RepositoryException {
		 if (descriptors.isEmpty()) {
			 ReportInfo info = new ReportInfo(JcrRemotingConstants.REPORT_REPOSITORY_DESCRIPTORS, ItemResourceConstants.NAMESPACE);
			 HttpReport request = null;
			 try {
				 request = new HttpReport(uriResolver.getRepositoryUri(), info);
				 HttpResponse response = executeRequest(null, request);
				 int sc = response.getStatusLine().getStatusCode();
				 if (sc == HttpStatus.SC_UNAUTHORIZED || sc == HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED) {
					 log.warn(""Authentication required to access repository descriptors"");
					 return descriptors;
				 }
				 request.checkSuccess(response);
				 Document doc = request.getResponseBodyAsDocument(response.getEntity());
				 if (doc != null) {
					 Element rootElement = doc.getDocumentElement();
					 ElementIterator nsElems = DomUtil.getChildren(rootElement, JcrRemotingConstants.XML_DESCRIPTOR, ItemResourceConstants.NAMESPACE);
					 while (nsElems.hasNext()) {
						 Element elem = nsElems.nextElement();
						 String key = DomUtil.getChildText(elem, JcrRemotingConstants.XML_DESCRIPTORKEY, ItemResourceConstants.NAMESPACE);
						 ElementIterator it = DomUtil.getChildren(elem, JcrRemotingConstants.XML_DESCRIPTORVALUE, ItemResourceConstants.NAMESPACE);
						 List<QValue> vs = new ArrayList<QValue>();
						 while (it.hasNext()) {
							 Element dv = it.nextElement();
							 String descriptor = DomUtil.getText(dv);
							 if (key != null && descriptor != null) {
								 String typeStr = (DomUtil.getAttribute(dv, JcrRemotingConstants.ATTR_VALUE_TYPE, null));
								 int type = (typeStr == null) ? PropertyType.STRING : PropertyType.valueFromName(typeStr);
								 vs.add(getQValueFactory().create(descriptor, type));
							 }
							 else {
								 log.error(""Invalid descriptor key / value pair: "" + key + "" -> "" + descriptor);
							 }
						 }
						 descriptors.put(key, vs.toArray(new QValue[vs.size()]));
					 }
				 }
			 }
			 catch (IOException e) {
				 throw new RepositoryException(e);
			 }
			 catch (DavException e) {
				 throw ExceptionConverter.generate(e);
			 }
			 finally {
				 if (request != null) {
					 request.releaseConnection();
				 }
			 }
		 }
		 return descriptors;
	 }
	 public SessionInfo obtain(Credentials credentials, String workspaceName) throws RepositoryException {
		 CredentialsWrapper dc = new CredentialsWrapper(credentials);
		 return obtain(dc, workspaceName);
	 }
	 public SessionInfo obtain(SessionInfo sessionInfo, String workspaceName) throws RepositoryException {
		 checkSessionInfo(sessionInfo);
		 return obtain(((SessionInfoImpl) sessionInfo).getCredentials(), workspaceName);
	 }
	 public SessionInfo impersonate(SessionInfo sessionInfo, Credentials credentials) throws RepositoryException {
		 throw new UnsupportedOperationException(""Not implemented yet."");
	 }
	 private SessionInfo obtain(CredentialsWrapper credentials, String workspaceName) throws RepositoryException {
		 HttpPropfind request = null;
		 SessionInfoImpl sessionInfo = new SessionInfoImpl(credentials, workspaceName);
		 try {
			 DavPropertyNameSet nameSet = new DavPropertyNameSet();
			 nameSet.add(DeltaVConstants.WORKSPACE);
			 nameSet.add(JcrRemotingConstants.JCR_WORKSPACE_NAME_LN, ItemResourceConstants.NAMESPACE);
			 request = new HttpPropfind(uriResolver.getWorkspaceUri(workspaceName), nameSet, DEPTH_0);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 MultiStatusResponse[] responses = request.getResponseBodyAsMultiStatus(response).getResponses();
			 if (responses.length != 1) {
				 throw new LoginException(""Login failed: Unknown workspace '"" + workspaceName + ""'."");
			 }
			 DavPropertySet props = responses[0].getProperties(DavServletResponse.SC_OK);
			 DavProperty<?> prop = props.get(JcrRemotingConstants.JCR_WORKSPACE_NAME_LN, ItemResourceConstants.NAMESPACE);
			 if (prop != null) {
				 String wspName = prop.getValue().toString();
				 if (workspaceName == null) {
					 sessionInfo = new SessionInfoImpl(credentials, wspName);
				 }
				 else if (!wspName.equals(workspaceName)) {
					 throw new LoginException(""Login failed: Invalid workspace name '"" + workspaceName + ""'."");
				 }
			 }
			 else if (props.contains(DeltaVConstants.WORKSPACE)) {
				 String wspHref = new HrefProperty(props.get(DeltaVConstants.WORKSPACE)).getHrefs().get(0);
				 String wspName = Text.unescape(Text.getName(wspHref, true));
				 if (!wspName.equals(workspaceName)) {
					 throw new LoginException(""Login failed: Invalid workspace name "" + workspaceName);
				 }
			 }
			 else {
				 throw new LoginException(""Login failed: Unknown workspace '"" + workspaceName + ""'."");
			 }
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e.getMessage(), e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
		 if (nsCache.prefixToURI.isEmpty()) {
			 try {
				 getRegisteredNamespaces(sessionInfo);
			 }
			 catch (RepositoryException e) {
			 }
		 }
		 return sessionInfo;
	 }
	 public void dispose(SessionInfo sessionInfo) throws RepositoryException {
		 checkSessionInfo(sessionInfo);
		 removeClient(sessionInfo);
	 }
	 public String[] getWorkspaceNames(SessionInfo sessionInfo) throws RepositoryException {
		 DavPropertyNameSet nameSet = new DavPropertyNameSet();
		 nameSet.add(DeltaVConstants.WORKSPACE);
		 HttpPropfind request = null;
		 try {
			 request = new HttpPropfind(uriResolver.getRepositoryUri(), nameSet, DEPTH_1);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 MultiStatusResponse[] mresponses = request.getResponseBodyAsMultiStatus(response).getResponses();
			 Set<String> wspNames = new HashSet<String>();
			 for (MultiStatusResponse mresponse : mresponses) {
				 DavPropertySet props = mresponse.getProperties(DavServletResponse.SC_OK);
				 if (props.contains(DeltaVConstants.WORKSPACE)) {
					 HrefProperty hp = new HrefProperty(props.get(DeltaVConstants.WORKSPACE));
					 String wspHref = hp.getHrefs().get(0);
					 String name = Text.unescape(Text.getName(wspHref, true));
					 wspNames.add(name);
				 }
			 }
			 return wspNames.toArray(new String[wspNames.size()]);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public boolean isGranted(SessionInfo sessionInfo, ItemId itemId, String[] actions) throws RepositoryException {
		 HttpReport request = null;
		 try {
			 String uri = obtainAbsolutePathFromUri(getItemUri(itemId, sessionInfo));
			 ReportInfo reportInfo = new ReportInfo(JcrRemotingConstants.REPORT_PRIVILEGES, ItemResourceConstants.NAMESPACE);
			 reportInfo.setContentElement(DomUtil.hrefToXml(uri, DomUtil.createDocument()));
			 request = new HttpReport(uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName()), reportInfo);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 MultiStatusResponse[] responses = request.getResponseBodyAsMultiStatus(response).getResponses();
			 if (responses.length < 1) {
				 throw new ItemNotFoundException(""Unable to retrieve permissions for item "" + saveGetIdString(itemId, sessionInfo));
			 }
			 DavProperty<?> p = responses[0].getProperties(DavServletResponse.SC_OK).get(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
			 if (p == null) {
				 return false;
			 }
			 Set<Privilege> requiredPrivileges = new HashSet<Privilege>();
			 for (String action : actions) {
				 requiredPrivileges.add(Privilege.getPrivilege(action, ItemResourceConstants.NAMESPACE));
			 }
			 CurrentUserPrivilegeSetProperty privSet = new CurrentUserPrivilegeSetProperty(p);
			 Collection<Privilege> privileges = privSet.getValue();
			 return privileges.containsAll(requiredPrivileges);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (ParserConfigurationException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public PrivilegeDefinition[] getPrivilegeDefinitions(SessionInfo sessionInfo) throws RepositoryException {
		 return internalGetPrivilegeDefinitions(sessionInfo, uriResolver.getRepositoryUri());
	 }
	 public PrivilegeDefinition[] getSupportedPrivileges(SessionInfo sessionInfo, NodeId nodeId) throws RepositoryException {
		 String uri = (nodeId == null) ? uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName()) : getItemUri(nodeId, sessionInfo);
		 return internalGetPrivilegeDefinitions(sessionInfo, uri);
	 }
	 public Name[] getPrivilegeNames(SessionInfo sessionInfo, NodeId nodeId) throws RepositoryException {
		 String uri = (nodeId == null) ? uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName()) : getItemUri(nodeId, sessionInfo);
		 DavPropertyNameSet nameSet = new DavPropertyNameSet();
		 nameSet.add(SecurityConstants.CURRENT_USER_PRIVILEGE_SET);
		 HttpPropfind propfindRequest = null;
		 try {
			 propfindRequest = new HttpPropfind(uri, nameSet, DEPTH_0);
			 HttpResponse response = execute(propfindRequest, sessionInfo);
			 propfindRequest.checkSuccess(response);
			 MultiStatusResponse[] mresponses = propfindRequest.getResponseBodyAsMultiStatus(response).getResponses();
			 if (mresponses.length < 1) {
				 throw new PathNotFoundException(""Unable to retrieve privileges definitions."");
			 }
			 DavPropertyName displayName = SecurityConstants.CURRENT_USER_PRIVILEGE_SET;
			 DavProperty<?> p = mresponses[0].getProperties(DavServletResponse.SC_OK).get(displayName);
			 if (p == null) {
				 return new Name[0];
			 }
			 else {
				 Collection<Privilege> privs = new CurrentUserPrivilegeSetProperty(p).getValue();
				 Set<Name> privNames = new HashSet<Name>(privs.size());
				 for (Privilege priv : privs) {
					 privNames.add(nameFactory.create(priv.getNamespace().getURI(), priv.getName()));
				 }
				 return privNames.toArray(new Name[privNames.size()]);
			 }
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (propfindRequest != null) {
				 propfindRequest.releaseConnection();
			 }
		 }
	 }
	 private PrivilegeDefinition[] internalGetPrivilegeDefinitions(SessionInfo sessionInfo, String uri) throws RepositoryException {
		 DavPropertyNameSet nameSet = new DavPropertyNameSet();
		 nameSet.add(SecurityConstants.SUPPORTED_PRIVILEGE_SET);
		 HttpPropfind request = null;
		 try {
			 request = new HttpPropfind(uri, nameSet, DEPTH_0);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 MultiStatusResponse[] mresponses = request.getResponseBodyAsMultiStatus(response).getResponses();
			 if (mresponses.length < 1) {
				 throw new PathNotFoundException(""Unable to retrieve privileges definitions."");
			 }
			 DavPropertyName displayName = SecurityConstants.SUPPORTED_PRIVILEGE_SET;
			 DavProperty<?> p = mresponses[0].getProperties(DavServletResponse.SC_OK).get(displayName);
			 if (p == null) {
				 return new PrivilegeDefinition[0];
			 }
			 else {
				 Map<Name, SupportedPrivilege> spMap = new HashMap<Name, SupportedPrivilege>();
				 fillSupportedPrivilegeMap(new SupportedPrivilegeSetProperty(p).getValue(), spMap, getNameFactory());
				 List<PrivilegeDefinition> pDefs = new ArrayList<PrivilegeDefinition>();
				 for (Name privilegeName : spMap.keySet()) {
					 SupportedPrivilege sp = spMap.get(privilegeName);
					 Set<Name> aggrnames = null;
					 SupportedPrivilege[] aggregates = sp.getSupportedPrivileges();
					 if (aggregates != null && aggregates.length > 0) {
						 aggrnames = new HashSet<Name>();
						 for (SupportedPrivilege aggregate : aggregates) {
							 Name aggregateName = nameFactory.create(aggregate.getPrivilege().getNamespace().getURI(), aggregate.getPrivilege().getName());
							 aggrnames.add(aggregateName);
						 }
					 }
					 PrivilegeDefinition def = new PrivilegeDefinitionImpl(privilegeName, sp.isAbstract(), aggrnames);
					 pDefs.add(def);
				 }
				 return pDefs.toArray(new PrivilegeDefinition[pDefs.size()]);
			 }
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 private static void fillSupportedPrivilegeMap(List<SupportedPrivilege> sps, Map<Name, SupportedPrivilege> spMap, NameFactory nameFactory) throws NamespaceException, IllegalNameException {
		 for (SupportedPrivilege sp : sps) {
			 Privilege p = sp.getPrivilege();
			 Name privName = nameFactory.create(p.getNamespace().getURI(), p.getName());
			 spMap.put(privName, sp);
			 List<SupportedPrivilege> agg = Arrays.asList(sp.getSupportedPrivileges());
			 if (!agg.isEmpty()) {
				 fillSupportedPrivilegeMap(agg, spMap, nameFactory);
			 }
		 }
	 }
	 public QNodeDefinition getNodeDefinition(SessionInfo sessionInfo, NodeId nodeId) throws RepositoryException {
		 return (QNodeDefinition) getItemDefinition(sessionInfo, nodeId);
	 }
	 public QPropertyDefinition getPropertyDefinition(SessionInfo sessionInfo, PropertyId propertyId) throws RepositoryException {
		 return (QPropertyDefinition) getItemDefinition(sessionInfo, propertyId);
	 }
	 private QItemDefinition getItemDefinition(SessionInfo sessionInfo, ItemId itemId) throws RepositoryException {
		 DavPropertyNameSet nameSet = new DavPropertyNameSet();
		 nameSet.add(JcrRemotingConstants.JCR_DEFINITION_LN, ItemResourceConstants.NAMESPACE);
		 nameSet.add(DavPropertyName.RESOURCETYPE);
		 HttpPropfind request = null;
		 try {
			 String uri = getItemUri(itemId, sessionInfo);
			 request = new HttpPropfind(uri, nameSet, DEPTH_0);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 MultiStatusResponse[] mresponses = request.getResponseBodyAsMultiStatus(response).getResponses();
			 if (mresponses.length < 1) {
				 throw new ItemNotFoundException( ""Unable to retrieve the item definition for "" + saveGetIdString(itemId, sessionInfo));
			 }
			 if (mresponses.length > 1) {
				 throw new RepositoryException( ""Internal error: ambigous item definition found '"" + saveGetIdString(itemId, sessionInfo) + ""'."");
			 }
			 DavPropertySet propertySet = mresponses[0].getProperties(DavServletResponse.SC_OK);
			 DavProperty<?> rType = propertySet.get(DavPropertyName.RESOURCETYPE);
			 if (rType.getValue() == null && itemId.denotesNode()) {
				 throw new RepositoryException(""Internal error: requested node definition and got property definition."");
			 }
			 NamePathResolver resolver = getNamePathResolver(sessionInfo);
			 QItemDefinition definition = null;
			 DavProperty<?> prop = propertySet.get(JcrRemotingConstants.JCR_DEFINITION_LN, ItemResourceConstants.NAMESPACE);
			 if (prop != null) {
				 Object value = prop.getValue();
				 if (value != null && value instanceof Element) {
					 Element idfElem = (Element) value;
					 if (itemId.denotesNode()) {
						 definition = DefinitionUtil.createQNodeDefinition(null, idfElem, resolver);
					 }
					 else {
						 definition = DefinitionUtil.createQPropertyDefinition(null, idfElem, resolver, getQValueFactory());
					 }
				 }
			 }
			 if (definition == null) {
				 throw new RepositoryException(""Unable to retrieve definition for item with id '"" + saveGetIdString(itemId, resolver) + ""'."");
			 }
			 return definition;
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public NodeInfo getNodeInfo(SessionInfo sessionInfo, NodeId nodeId) throws RepositoryException {
		 DavPropertyNameSet nameSet = new DavPropertyNameSet();
		 nameSet.add(JcrRemotingConstants.JCR_INDEX_LN, ItemResourceConstants.NAMESPACE);
		 nameSet.add(JcrRemotingConstants.JCR_PARENT_LN, ItemResourceConstants.NAMESPACE);
		 nameSet.add(JcrRemotingConstants.JCR_NAME_LN, ItemResourceConstants.NAMESPACE);
		 nameSet.add(JcrRemotingConstants.JCR_PRIMARYNODETYPE_LN, ItemResourceConstants.NAMESPACE);
		 nameSet.add(JcrRemotingConstants.JCR_MIXINNODETYPES_LN, ItemResourceConstants.NAMESPACE);
		 nameSet.add(JcrRemotingConstants.JCR_REFERENCES_LN, ItemResourceConstants.NAMESPACE);
		 nameSet.add(JcrRemotingConstants.JCR_UUID_LN, ItemResourceConstants.NAMESPACE);
		 nameSet.add(JcrRemotingConstants.JCR_PATH_LN, ItemResourceConstants.NAMESPACE);
		 nameSet.add(DavPropertyName.RESOURCETYPE);
		 HttpPropfind request = null;
		 try {
			 String uri = getItemUri(nodeId, sessionInfo);
			 request = new HttpPropfind(uri, nameSet, DEPTH_1);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 MultiStatusResponse[] mresponses = request.getResponseBodyAsMultiStatus(response).getResponses();
			 if (mresponses.length < 1) {
				 throw new ItemNotFoundException(""Unable to retrieve the node with id "" + saveGetIdString(nodeId, sessionInfo));
			 }
			 MultiStatusResponse nodeResponse = null;
			 List<MultiStatusResponse> childResponses = new ArrayList<MultiStatusResponse>();
			 for (MultiStatusResponse mresponse : mresponses) {
				 if (isSameResource(uri, mresponse)) {
					 nodeResponse = mresponse;
				 }
				 else {
					 childResponses.add(mresponse);
				 }
			 }
			 if (nodeResponse == null) {
				 throw new ItemNotFoundException(""Unable to retrieve the node "" + saveGetIdString(nodeId, sessionInfo));
			 }
			 DavPropertySet propSet = nodeResponse.getProperties(DavServletResponse.SC_OK);
			 Object type = propSet.get(DavPropertyName.RESOURCETYPE).getValue();
			 if (type == null) {
				 throw new ItemNotFoundException(""No node for id "" + saveGetIdString(nodeId, sessionInfo));
			 }
			 NamePathResolver resolver = getNamePathResolver(sessionInfo);
			 NodeId parentId = getParentId(uri, propSet, sessionInfo);
			 NodeInfoImpl nInfo = buildNodeInfo(uri, nodeResponse, parentId, propSet, sessionInfo, resolver);
			 for (MultiStatusResponse resp : childResponses) {
				 DavPropertySet childProps = resp.getProperties(DavServletResponse.SC_OK);
				 if (childProps.contains(DavPropertyName.RESOURCETYPE) && childProps.get(DavPropertyName.RESOURCETYPE).getValue() != null) {
					 nInfo.addChildInfo(buildChildInfo(childProps, sessionInfo));
				 }
				 else {
					 PropertyId childId = uriResolver.buildPropertyId(nInfo.getId(), resp, sessionInfo.getWorkspaceName(), getNamePathResolver(sessionInfo));
					 nInfo.addPropertyId(childId);
				 }
			 }
			 return nInfo;
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 catch (NameException e) {
			 throw new RepositoryException(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public Iterator<? extends ItemInfo> getItemInfos(SessionInfo sessionInfo, ItemId itemId) throws RepositoryException {
		 if (itemId.denotesNode()) {
			 List<ItemInfo> l = new ArrayList<ItemInfo>();
			 NodeInfo nInfo = getNodeInfo(sessionInfo, (NodeId) itemId);
			 l.add(nInfo);
			 l.addAll(buildPropertyInfos(nInfo));
			 return l.iterator();
		 }
		 else {
			 PropertyInfo pInfo = getPropertyInfo(sessionInfo, (PropertyId) itemId);
			 return Iterators.singleton(pInfo);
		 }
	 }
	 private NodeInfoImpl buildNodeInfo(String baseUri, MultiStatusResponse nodeResponse, NodeId parentId, DavPropertySet propSet, SessionInfo sessionInfo, NamePathResolver resolver) throws RepositoryException {
		 NodeId id = uriResolver.buildNodeId(parentId, baseUri, nodeResponse, sessionInfo.getWorkspaceName(), getNamePathResolver(sessionInfo));
		 NodeInfoImpl nInfo = new NodeInfoImpl(id, propSet, resolver);
		 DavProperty p = propSet.get(JcrRemotingConstants.JCR_REFERENCES_LN, ItemResourceConstants.NAMESPACE);
		 if (p != null) {
			 HrefProperty refProp = new HrefProperty(p);
			 for (String propertyHref : refProp.getHrefs()) {
				 PropertyId propertyId = uriResolver.getPropertyId(propertyHref, sessionInfo);
				 nInfo.addReference(propertyId);
			 }
		 }
		 return nInfo;
	 }
	 private List<PropertyInfo> buildPropertyInfos(NodeInfo nInfo) throws RepositoryException {
		 List<PropertyInfo> l = new ArrayList<PropertyInfo>(3);
		 NodeId nid = nInfo.getId();
		 Path nPath = nInfo.getPath();
		 if (nid.getPath() == null) {
			 PropertyId id = getIdFactory().createPropertyId(nid, NameConstants.JCR_UUID);
			 QValue[] vs = new QValue[] {
			 getQValueFactory().create(nid.getUniqueID(), PropertyType.STRING) }
			;
			 Path p = getPathFactory().create(nPath, NameConstants.JCR_UUID, true);
			 PropertyInfo pi = new PropertyInfoImpl(id, p, PropertyType.STRING, false, vs);
			 l.add(pi);
		 }
		 Name pName = NameConstants.JCR_PRIMARYTYPE;
		 QValue[] vs = new QValue[] {
		 getQValueFactory().create(nInfo.getNodetype()) }
		;
		 PropertyInfo pi = new PropertyInfoImpl(getIdFactory().createPropertyId(nid, pName), getPathFactory().create(nPath, pName, true), PropertyType.NAME, false, vs);
		 l.add(pi);
		 Name[] mixins = nInfo.getMixins();
		 if (mixins.length > 0) {
			 pName = NameConstants.JCR_MIXINTYPES;
			 vs = new QValue[mixins.length];
			 for (int i = 0;
			 i < mixins.length;
			 i++) {
				 vs[i] = getQValueFactory().create(mixins[i]);
			 }
			 pi = new PropertyInfoImpl(getIdFactory().createPropertyId(nid, pName), getPathFactory().create(nPath, pName, true), PropertyType.NAME, true, vs);
			 l.add(pi);
		 }
		 return l;
	 }
	 public Iterator<ChildInfo> getChildInfos(SessionInfo sessionInfo, NodeId parentId) throws RepositoryException {
		 DavPropertyNameSet nameSet = new DavPropertyNameSet();
		 nameSet.add(JcrRemotingConstants.JCR_NAME_LN, ItemResourceConstants.NAMESPACE);
		 nameSet.add(JcrRemotingConstants.JCR_INDEX_LN, ItemResourceConstants.NAMESPACE);
		 nameSet.add(JcrRemotingConstants.JCR_PARENT_LN, ItemResourceConstants.NAMESPACE);
		 nameSet.add(JcrRemotingConstants.JCR_UUID_LN, ItemResourceConstants.NAMESPACE);
		 nameSet.add(DavPropertyName.RESOURCETYPE);
		 HttpPropfind request = null;
		 try {
			 String uri = getItemUri(parentId, sessionInfo);
			 request = new HttpPropfind(uri, nameSet, DEPTH_1);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 List<ChildInfo> childEntries;
			 MultiStatusResponse[] mresponses = request.getResponseBodyAsMultiStatus(response).getResponses();
			 if (mresponses.length < 1) {
				 throw new ItemNotFoundException(""Unable to retrieve the node with id "" + saveGetIdString(parentId, sessionInfo));
			 }
			 else if (mresponses.length == 1) {
				 childEntries = Collections.emptyList();
				 return childEntries.iterator();
			 }
			 childEntries = new ArrayList<ChildInfo>();
			 for (MultiStatusResponse mresponse : mresponses) {
				 if (!isSameResource(uri, mresponse)) {
					 DavPropertySet childProps = mresponse.getProperties(DavServletResponse.SC_OK);
					 if (childProps.contains(DavPropertyName.RESOURCETYPE) && childProps.get(DavPropertyName.RESOURCETYPE).getValue() != null) {
						 childEntries.add(buildChildInfo(childProps, sessionInfo));
					 }
				 }
			 }
			 return childEntries.iterator();
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 private ChildInfo buildChildInfo(DavPropertySet properties, SessionInfo sessionInfo) throws RepositoryException {
		 Name qName = getQName(properties, getNamePathResolver(sessionInfo));
		 int index = getIndex(properties);
		 String uuid = getUniqueID(properties);
		 return new ChildInfoImpl(qName, uuid, index);
	 }
	 public Iterator<PropertyId> getReferences(SessionInfo sessionInfo, NodeId nodeId, Name propertyName, boolean weakReferences) throws RepositoryException {
		 DavPropertyNameSet nameSet = new DavPropertyNameSet();
		 String refType = weakReferences ? JcrRemotingConstants.JCR_WEAK_REFERENCES_LN : JcrRemotingConstants.JCR_REFERENCES_LN;
		 nameSet.add(refType, ItemResourceConstants.NAMESPACE);
		 HttpPropfind request = null;
		 try {
			 String uri = getItemUri(nodeId, sessionInfo);
			 request = new HttpPropfind(uri, nameSet, DEPTH_0);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 MultiStatusResponse[] mresponses = request.getResponseBodyAsMultiStatus(response).getResponses();
			 if (mresponses.length < 1) {
				 throw new ItemNotFoundException(""Unable to retrieve the node with id "" + saveGetIdString(nodeId, sessionInfo));
			 }
			 List<PropertyId> refIds = Collections.emptyList();
			 for (MultiStatusResponse mresponse : mresponses) {
				 if (isSameResource(uri, mresponse)) {
					 DavPropertySet props = mresponse.getProperties(DavServletResponse.SC_OK);
					 DavProperty<?> p = props.get(refType, ItemResourceConstants.NAMESPACE);
					 if (p != null) {
						 refIds = new ArrayList<PropertyId>();
						 HrefProperty hp = new HrefProperty(p);
						 for (String propHref : hp.getHrefs()) {
							 PropertyId propId = uriResolver.getPropertyId(resolve(uri, propHref), sessionInfo);
							 if (propertyName == null || propertyName.equals(propId.getName())) {
								 refIds.add(propId);
							 }
						 }
					 }
				 }
			 }
			 return refIds.iterator();
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public PropertyInfo getPropertyInfo(SessionInfo sessionInfo, PropertyId propertyId) throws RepositoryException {
		 HttpGet request = null;
		 try {
			 String uri = getItemUri(propertyId, sessionInfo);
			 request = new HttpGet(uri);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 int status = response.getStatusLine().getStatusCode();
			 if (status != DavServletResponse.SC_OK) {
				 throw ExceptionConverter.generate(new DavException(status, response.getStatusLine().getReasonPhrase()));
			 }
			 Path path = uriResolver.getQPath(uri, sessionInfo);
			 HttpEntity entity = response.getEntity();
			 ContentType ct = ContentType.get(entity);
			 boolean isMultiValued;
			 QValue[] values;
			 int type;
			 NamePathResolver resolver = getNamePathResolver(sessionInfo);
			 if (ct != null && ct.getMimeType().startsWith(""jcr-value"")) {
				 type = JcrValueType.typeFromContentType(ct.getMimeType());
				 QValue v;
				 if (type == PropertyType.BINARY) {
					 v = getQValueFactory().create(entity.getContent());
				 }
				 else {
					 Reader reader = new InputStreamReader(entity.getContent(), ct.getCharset());
					 StringBuffer sb = new StringBuffer();
					 int c;
					 while ((c = reader.read()) > -1) {
						 sb.append((char) c);
					 }
					 Value jcrValue = valueFactory.createValue(sb.toString(), type);
					 if (jcrValue instanceof QValueValue) {
						 v = ((QValueValue) jcrValue).getQValue();
					 }
					 else {
						 v = ValueFormat.getQValue(jcrValue, resolver, getQValueFactory());
					 }
				 }
				 values = new QValue[] {
				 v }
				;
				 isMultiValued = false;
			 }
			 else if (ct != null && ct.getMimeType().equals(""text/xml"")) {
				 values = getValues(entity.getContent(), resolver, propertyId);
				 type = (values.length > 0) ? values[0].getType() : loadType(uri, getClient(sessionInfo), propertyId, sessionInfo, resolver);
				 isMultiValued = true;
			 }
			 else {
				 throw new ItemNotFoundException(""Unable to retrieve the property with id "" + saveGetIdString(propertyId, resolver));
			 }
			 return new PropertyInfoImpl(propertyId, path, type, isMultiValued, values);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 catch (NameException e) {
			 throw new RepositoryException(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 private QValue[] getValues(InputStream response, NamePathResolver resolver, ItemId id) throws RepositoryException {
		 try {
			 Document doc = DomUtil.parseDocument(response);
			 Element prop = DomUtil.getChildElement(doc, JcrRemotingConstants.JCR_VALUES_LN, ItemResourceConstants.NAMESPACE);
			 if (prop == null) {
				 throw new ItemNotFoundException(""No property found at "" + saveGetIdString(id, resolver));
			 }
			 else {
				 DavProperty<?> p = DefaultDavProperty.createFromXml(prop);
				 Value[] jcrVs = ValueUtil.valuesFromXml(p.getValue(), PropertyType.STRING, valueFactory);
				 QValue[] qvs = new QValue[jcrVs.length];
				 int type = (jcrVs.length > 0) ? jcrVs[0].getType() : PropertyType.STRING;
				 for (int i = 0;
				 i < jcrVs.length;
				 i++) {
					 if (jcrVs[i] instanceof QValueValue) {
						 qvs[i] = ((QValueValue) jcrVs[i]).getQValue();
					 }
					 else if (type == PropertyType.BINARY) {
						 qvs[i] = qValueFactory.create(jcrVs[i].getStream());
					 }
					 else {
						 qvs[i] = ValueFormat.getQValue(jcrVs[i], resolver, qValueFactory);
					 }
				 }
				 return qvs;
			 }
		 }
		 catch (SAXException e) {
			 log.warn(""Internal error: {
			}
			"", e.getMessage());
			 throw new RepositoryException(e);
		 }
		 catch (IOException e) {
			 log.warn(""Internal error: {
			}
			"", e.getMessage());
			 throw new RepositoryException(e);
		 }
		 catch (ParserConfigurationException e) {
			 log.warn(""Internal error: {
			}
			"", e.getMessage());
			 throw new RepositoryException(e);
		 }
	 }
	 private int loadType(String propertyURI, HttpClient client, PropertyId propertyId, SessionInfo sessionInfo, NamePathResolver resolver) throws IOException, DavException, RepositoryException {
		 DavPropertyNameSet nameSet = new DavPropertyNameSet();
		 nameSet.add(JcrRemotingConstants.JCR_TYPE_LN, ItemResourceConstants.NAMESPACE);
		 HttpPropfind request = null;
		 try {
			 request = new HttpPropfind(propertyURI, nameSet, DEPTH_0);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 MultiStatusResponse[] mresponses = request.getResponseBodyAsMultiStatus(response).getResponses();
			 if (mresponses.length == 1) {
				 DavPropertySet props = mresponses[0].getProperties(DavServletResponse.SC_OK);
				 DavProperty<?> type = props.get(JcrRemotingConstants.JCR_TYPE_LN, ItemResourceConstants.NAMESPACE);
				 if (type != null) {
					 return PropertyType.valueFromName(type.getValue().toString());
				 }
				 else {
					 throw new RepositoryException(""Internal error. Cannot retrieve property type at "" + saveGetIdString(propertyId, resolver));
				 }
			 }
			 else {
				 throw new ItemNotFoundException(""Internal error. Cannot retrieve property type at "" + saveGetIdString(propertyId, resolver));
			 }
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public Batch createBatch(SessionInfo sessionInfo, ItemId itemId) throws RepositoryException {
		 checkSessionInfo(sessionInfo);
		 return new BatchImpl(itemId, sessionInfo);
	 }
	 public void submit(Batch batch) throws RepositoryException {
		 if (!(batch instanceof BatchImpl)) {
			 throw new RepositoryException(""Unknown Batch implementation."");
		 }
		 BatchImpl batchImpl = (BatchImpl) batch;
		 if (batchImpl.isEmpty()) {
			 batchImpl.dispose();
			 return;
		 }
		 HttpRequestBase request = null;
		 try {
			 HttpClient client = batchImpl.start();
			 boolean success = false;
			 try {
				 Iterator<HttpRequestBase> it = batchImpl.requests();
				 while (it.hasNext()) {
					 request = it.next();
					 initMethod(request, batchImpl, true);
					 HttpResponse response = client.execute(request);
					 if (request instanceof BaseDavRequest) {
						 ((BaseDavRequest) request).checkSuccess(response);
					 }
					 else {
						 int statusCode = response.getStatusLine().getStatusCode();
						 if (statusCode < 200 || statusCode >= 300) {
							 throw new DavException(statusCode, ""Unexpected status code "" + statusCode + "" in response to "" + request.getMethod() + "" request."");
						 }
					 }
					 request.releaseConnection();
				 }
				 success = true;
			 }
			 finally {
				 batchImpl.end(client, success);
			 }
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e, request);
		 }
		 finally {
			 batchImpl.dispose();
		 }
	 }
	 public Tree createTree(SessionInfo sessionInfo, Batch batch, Name nodeName, Name primaryTypeName, String uniqueId) throws RepositoryException {
		 return new DocumentTree(nodeName, primaryTypeName, uniqueId, getNamePathResolver(sessionInfo));
	 }
	 public void importXml(SessionInfo sessionInfo, NodeId parentId, InputStream xmlStream, int uuidBehaviour) throws RepositoryException {
		 Name nodeName = getNameFactory().create(Name.NS_DEFAULT_URI, UUID.randomUUID().toString());
		 String uri = getItemUri(parentId, nodeName, sessionInfo);
		 HttpMkcol mkcolRequest = new HttpMkcol(uri);
		 mkcolRequest.addHeader(JcrRemotingConstants.IMPORT_UUID_BEHAVIOR, Integer.toString(uuidBehaviour));
		 mkcolRequest.setEntity(new InputStreamEntity(xmlStream, ContentType.create(""text/xml"")));
		 execute(mkcolRequest, sessionInfo);
	 }
	 public void move(SessionInfo sessionInfo, NodeId srcNodeId, NodeId destParentNodeId, Name destName) throws RepositoryException {
		 String uri = getItemUri(srcNodeId, sessionInfo);
		 String destUri = getItemUri(destParentNodeId, destName, sessionInfo);
		 if (isDavClass3(sessionInfo)) {
			 destUri = obtainAbsolutePathFromUri(destUri);
		 }
		 HttpMove request = new HttpMove(uri, destUri, false);
		 try {
			 initMethod(request, sessionInfo);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 clearItemUriCache(sessionInfo);
		 }
		 catch (IOException ex) {
			 throw new RepositoryException(ex);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e, request);
		 }
		 finally {
			 request.releaseConnection();
		 }
	 }
	 public void copy(SessionInfo sessionInfo, String srcWorkspaceName, NodeId srcNodeId, NodeId destParentNodeId, Name destName) throws RepositoryException {
		 String uri = uriResolver.getItemUri(srcNodeId, srcWorkspaceName, sessionInfo);
		 String destUri = getItemUri(destParentNodeId, destName, sessionInfo);
		 if (isDavClass3(sessionInfo)) {
			 destUri = obtainAbsolutePathFromUri(destUri);
		 }
		 HttpCopy request = new HttpCopy(uri, destUri, false, false);
		 try {
			 initMethod(request, sessionInfo);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
		 }
		 catch (IOException ex) {
			 throw new RepositoryException(ex);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e, request);
		 }
		 finally {
			 request.releaseConnection();
		 }
	 }
	 public void update(SessionInfo sessionInfo, NodeId nodeId, String srcWorkspaceName) throws RepositoryException {
		 String uri = getItemUri(nodeId, sessionInfo);
		 String workspUri = uriResolver.getWorkspaceUri(srcWorkspaceName);
		 update(uri, null, new String[] {
		 workspUri }
		, UpdateInfo.UPDATE_BY_WORKSPACE, false, sessionInfo);
	 }
	 public void clone(SessionInfo sessionInfo, String srcWorkspaceName, NodeId srcNodeId, NodeId destParentNodeId, Name destName, boolean removeExisting) throws RepositoryException {
		 throw new UnsupportedOperationException(""Missing implementation"");
	 }
	 public LockInfo getLockInfo(SessionInfo sessionInfo, NodeId nodeId) throws RepositoryException {
		 DavPropertyNameSet nameSet = new DavPropertyNameSet();
		 nameSet.add(DavPropertyName.LOCKDISCOVERY);
		 nameSet.add(JcrRemotingConstants.JCR_PARENT_LN, ItemResourceConstants.NAMESPACE);
		 HttpPropfind request = null;
		 try {
			 String uri = getItemUri(nodeId, sessionInfo);
			 request = new HttpPropfind(uri, nameSet, DEPTH_0);
			 initMethod(request, sessionInfo, false);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 MultiStatusResponse[] mresponses = request.getResponseBodyAsMultiStatus(response).getResponses();
			 if (mresponses.length != 1) {
				 throw new ItemNotFoundException( ""Unable to retrieve the LockInfo. No such node "" + saveGetIdString(nodeId, sessionInfo));
			 }
			 DavPropertySet ps = mresponses[0].getProperties(DavServletResponse.SC_OK);
			 if (ps.contains(DavPropertyName.LOCKDISCOVERY)) {
				 DavProperty<?> p = ps.get(DavPropertyName.LOCKDISCOVERY);
				 LockDiscovery ld = LockDiscovery.createFromXml(p.toXml(DomUtil.createDocument()));
				 NodeId parentId = getParentId(uri, ps, sessionInfo);
				 return retrieveLockInfo(ld, sessionInfo, nodeId, parentId);
			 }
			 else {
				 log.debug(""No Lock present on node with id "" + saveGetIdString(nodeId, sessionInfo));
				 return null;
			 }
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (ParserConfigurationException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public LockInfo lock(SessionInfo sessionInfo, NodeId nodeId, boolean deep, boolean sessionScoped) throws RepositoryException {
		 return lock(sessionInfo, nodeId, deep, sessionScoped, Long.MAX_VALUE, null);
	 }
	 public LockInfo lock(SessionInfo sessionInfo, NodeId nodeId, boolean deep, boolean sessionScoped, long timeoutHint, String ownerHint) throws RepositoryException {
		 HttpLock request = null;
		 try {
			 checkSessionInfo(sessionInfo);
			 long davTimeout = (timeoutHint == Long.MAX_VALUE) ? INFINITE_TIMEOUT : timeoutHint * 1000;
			 String ownerInfo = (ownerHint == null) ? sessionInfo.getUserID() : ownerHint;
			 String uri = getItemUri(nodeId, sessionInfo);
			 Scope scope = (sessionScoped) ? ItemResourceConstants.EXCLUSIVE_SESSION : Scope.EXCLUSIVE;
			 request = new HttpLock(uri, new org.apache.jackrabbit.webdav.lock.LockInfo(scope, Type.WRITE, ownerInfo, davTimeout, deep));
			 HttpResponse response = execute(request, sessionInfo);
			 String lockToken = request.getLockToken(response);
			 ((SessionInfoImpl) sessionInfo).addLockToken(lockToken, sessionScoped);
			 LockDiscovery disc = request.getResponseBodyAsLockDiscovery(response);
			 return retrieveLockInfo(disc, sessionInfo, nodeId, null);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public void refreshLock(SessionInfo sessionInfo, NodeId nodeId) throws RepositoryException {
		 checkSessionInfo(sessionInfo);
		 String uri = getItemUri(nodeId, sessionInfo);
		 Set<String> allLockTokens = ((SessionInfoImpl) sessionInfo).getAllLockTokens();
		 String[] locktokens = allLockTokens.toArray(new String[allLockTokens.size()]);
		 HttpLock httpLock = null;
		 try {
			 httpLock = new HttpLock(uri, INFINITE_TIMEOUT, locktokens);
			 execute(httpLock, sessionInfo);
		 }
		 finally {
			 if (httpLock != null) {
				 httpLock.releaseConnection();
			 }
		 }
	 }
	 public void unlock(SessionInfo sessionInfo, NodeId nodeId) throws RepositoryException {
		 checkSessionInfo(sessionInfo);
		 String uri = getItemUri(nodeId, sessionInfo);
		 LockInfoImpl lInfo = (LockInfoImpl) getLockInfo(sessionInfo, nodeId);
		 if (lInfo == null) {
			 throw new LockException(""No Lock present on Node with id "" + saveGetIdString(nodeId, sessionInfo));
		 }
		 String lockToken = lInfo.getActiveLock().getToken();
		 boolean isSessionScoped = lInfo.isSessionScoped();
		 if (!((SessionInfoImpl) sessionInfo).getAllLockTokens().contains(lockToken)) {
			 throw new LockException(""Lock "" + lockToken + "" not owned by this session"");
		 }
		 HttpUnlock unlockRequest = new HttpUnlock(uri, lockToken);
		 try {
			 execute(unlockRequest, sessionInfo);
			 ((SessionInfoImpl) sessionInfo).removeLockToken(lockToken, isSessionScoped);
		 }
		 finally {
			 unlockRequest.releaseConnection();
		 }
	 }
	 private LockInfo retrieveLockInfo(LockDiscovery lockDiscovery, SessionInfo sessionInfo, NodeId nodeId, NodeId parentId) throws RepositoryException {
		 checkSessionInfo(sessionInfo);
		 List<ActiveLock> activeLocks = lockDiscovery.getValue();
		 ActiveLock activeLock = null;
		 for (ActiveLock l : activeLocks) {
			 Scope sc = l.getScope();
			 if (l.getType() == Type.WRITE && (Scope.EXCLUSIVE.equals(sc) || sc == ItemResourceConstants.EXCLUSIVE_SESSION)) {
				 if (activeLock != null) {
					 throw new RepositoryException(""Node "" + saveGetIdString(nodeId, sessionInfo) + "" contains multiple exclusive write locks."");
				 }
				 else {
					 activeLock = l;
				 }
			 }
		 }
		 if (activeLock == null) {
			 log.debug(""No lock present on node "" + saveGetIdString(nodeId, sessionInfo));
			 return null;
		 }
		 NodeId holder = null;
		 String lockroot = activeLock.getLockroot();
		 if (activeLock.getLockroot() != null) {
			 holder = uriResolver.getNodeId(lockroot, sessionInfo);
		 }
		 if (activeLock.isDeep() && holder == null && parentId != null) {
			 LockInfo pLockInfo = getLockInfo(sessionInfo, parentId);
			 if (pLockInfo != null) {
				 return pLockInfo;
			 }
		 }
		 return new LockInfoImpl(activeLock, holder == null ? nodeId : holder, ((SessionInfoImpl) sessionInfo).getAllLockTokens());
	 }
	 public NodeId checkin(SessionInfo sessionInfo, NodeId nodeId) throws RepositoryException {
		 String uri = getItemUri(nodeId, sessionInfo);
		 HttpCheckin request = new HttpCheckin(uri);
		 try {
			 initMethod(request, sessionInfo, !isUnLockMethod(request));
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 org.apache.http.Header rh = response.getFirstHeader(DeltaVConstants.HEADER_LOCATION);
			 return uriResolver.getNodeId(resolve(uri, rh.getValue()), sessionInfo);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException ex) {
			 throw ExceptionConverter.generate(ex);
		 }
		 finally {
			 request.releaseConnection();
		 }
	 }
	 public void checkout(SessionInfo sessionInfo, NodeId nodeId) throws RepositoryException {
		 String uri = getItemUri(nodeId, sessionInfo);
		 HttpCheckout request = new HttpCheckout(uri);
		 try {
			 initMethod(request, sessionInfo, !isUnLockMethod(request));
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException ex) {
			 throw ExceptionConverter.generate(ex);
		 }
		 finally {
			 request.releaseConnection();
		 }
	 }
	 public void checkout(SessionInfo sessionInfo, NodeId nodeId, NodeId activityId) throws RepositoryException {
		 if (activityId == null) {
			 checkout(sessionInfo, nodeId);
		 }
		 else {
			 throw new UnsupportedOperationException(""JCR-2104: JSR 283 Versioning. Implementation missing"");
		 }
	 }
	 public NodeId checkpoint(SessionInfo sessionInfo, NodeId nodeId) throws RepositoryException {
		 NodeId vID = checkin(sessionInfo, nodeId);
		 checkout(sessionInfo, nodeId);
		 return vID;
	 }
	 public NodeId checkpoint(SessionInfo sessionInfo, NodeId nodeId, NodeId activityId) throws RepositoryException {
		 if (activityId == null) {
			 return checkpoint(sessionInfo, nodeId);
		 }
		 else {
			 throw new UnsupportedOperationException(""JCR-2104: JSR 283 Versioning. Implementation missing"");
		 }
	 }
	 public void removeVersion(SessionInfo sessionInfo, NodeId versionHistoryId, NodeId versionId) throws RepositoryException {
		 String uri = getItemUri(versionId, sessionInfo);
		 HttpDelete request = new HttpDelete(uri);
		 try {
			 initMethod(request, sessionInfo, !isUnLockMethod(request));
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
		 }
		 catch (IOException ex) {
			 throw new RepositoryException(ex);
		 }
		 catch (DavException ex) {
			 throw ExceptionConverter.generate(ex);
		 }
		 finally {
			 request.releaseConnection();
		 }
	 }
	 public void restore(SessionInfo sessionInfo, NodeId nodeId, NodeId versionId, boolean removeExisting) throws RepositoryException {
		 String uri = getItemUri(nodeId, sessionInfo);
		 String vUri = getItemUri(versionId, sessionInfo);
		 Path relPath = null;
		 if (!exists(sessionInfo, uri)) {
			 Path path = nodeId.getPath();
			 if (nodeId.getUniqueID() != null) {
				 uri = getItemUri(idFactory.createNodeId(nodeId.getUniqueID(), null), sessionInfo);
				 relPath = (path.isAbsolute()) ? getPathFactory().getRootPath().computeRelativePath(path) : path;
			 }
			 else {
				 int degree = 0;
				 while (degree < path.getLength()) {
					 Path ancestorPath = path.getAncestor(degree);
					 NodeId parentId = idFactory.createNodeId(nodeId.getUniqueID(), ancestorPath);
					 if (exists(sessionInfo, getItemUri(parentId, sessionInfo))) {
						 uri = getItemUri(parentId, sessionInfo);
						 relPath = ancestorPath.computeRelativePath(path);
						 break;
					 }
					 degree++;
				 }
			 }
		 }
		 update(uri, relPath, new String[] {
		 vUri }
		, UpdateInfo.UPDATE_BY_VERSION, removeExisting, sessionInfo);
	 }
	 private boolean exists(SessionInfo sInfo, String uri) {
		 HttpHead request = new HttpHead(uri);
		 try {
			 int statusCode = executeRequest(sInfo, request).getStatusLine().getStatusCode();
			 return (statusCode == DavServletResponse.SC_OK);
		 }
		 catch (IOException e) {
			 log.error(""Unexpected error while testing existence of item."", e);
			 return false;
		 }
		 catch (RepositoryException e) {
			 log.error(e.getMessage());
			 return false;
		 }
		 finally {
			 request.releaseConnection();
		 }
	 }
	 public void restore(SessionInfo sessionInfo, NodeId[] versionIds, boolean removeExisting) throws RepositoryException {
		 String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
		 String[] vUris = new String[versionIds.length];
		 for (int i = 0;
		 i < versionIds.length;
		 i++) {
			 vUris[i] = getItemUri(versionIds[i], sessionInfo);
		 }
		 update(uri, null, vUris, UpdateInfo.UPDATE_BY_VERSION, removeExisting, sessionInfo);
	 }
	 private void update(String uri, Path relPath, String[] updateSource, int updateType, boolean removeExisting, SessionInfo sessionInfo) throws RepositoryException {
		 HttpUpdate request = null;
		 try {
			 UpdateInfo uInfo;
			 String tmpUpdateSource[] = obtainAbsolutePathsFromUris(updateSource);
			 if (removeExisting || relPath != null) {
				 Element uElem = UpdateInfo.createUpdateElement(tmpUpdateSource, updateType, DomUtil.createDocument());
				 if (removeExisting) {
					 DomUtil.addChildElement(uElem, JcrRemotingConstants.XML_REMOVEEXISTING, ItemResourceConstants.NAMESPACE);
				 }
				 if (relPath != null) {
					 DomUtil.addChildElement(uElem, JcrRemotingConstants.XML_RELPATH, ItemResourceConstants.NAMESPACE, getNamePathResolver(sessionInfo).getJCRPath(relPath));
				 }
				 uInfo = new UpdateInfo(uElem);
			 }
			 else {
				 uInfo = new UpdateInfo(tmpUpdateSource, updateType, new DavPropertyNameSet());
			 }
			 request = new HttpUpdate(uri, uInfo);
			 initMethod(request, sessionInfo, !isUnLockMethod(request));
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (ParserConfigurationException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public Iterator<NodeId> merge(SessionInfo sessionInfo, NodeId nodeId, String srcWorkspaceName, boolean bestEffort) throws RepositoryException {
		 return merge(sessionInfo, nodeId, srcWorkspaceName, bestEffort, false);
	 }
	 public Iterator<NodeId> merge(SessionInfo sessionInfo, NodeId nodeId, String srcWorkspaceName, boolean bestEffort, boolean isShallow) throws RepositoryException {
		 HttpMerge request = null;
		 try {
			 Document doc = DomUtil.createDocument();
			 String wspHref = obtainAbsolutePathFromUri(uriResolver.getWorkspaceUri(srcWorkspaceName));
			 Element mElem = MergeInfo.createMergeElement(new String[] {
			 wspHref }
			, !bestEffort, false, doc);
			 if (isShallow) {
				 mElem.appendChild(DomUtil.depthToXml(false, doc));
			 }
			 MergeInfo mInfo = new MergeInfo(mElem);
			 String uri = getItemUri(nodeId, sessionInfo);
			 request = new HttpMerge(uri, mInfo);
			 initMethod(request, sessionInfo, !isUnLockMethod(request));
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 MultiStatusResponse[] resps = request.getResponseBodyAsMultiStatus(response).getResponses();
			 List<NodeId> failedIds = new ArrayList<NodeId>(resps.length);
			 for (MultiStatusResponse resp : resps) {
				 String href = resolve(uri, resp.getHref());
				 failedIds.add(uriResolver.getNodeId(href, sessionInfo));
			 }
			 return failedIds.iterator();
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (ParserConfigurationException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public void resolveMergeConflict(SessionInfo sessionInfo, NodeId nodeId, NodeId[] mergeFailedIds, NodeId[] predecessorIds) throws RepositoryException {
		 HttpProppatch request = null;
		 try {
			 List<HrefProperty> changeList = new ArrayList<HrefProperty>();
			 String[] mergeFailedHref = new String[mergeFailedIds.length];
			 for (int i = 0;
			 i < mergeFailedIds.length;
			 i++) {
				 mergeFailedHref[i] = getItemUri(mergeFailedIds[i], sessionInfo);
			 }
			 changeList.add(new HrefProperty(VersionControlledResource.AUTO_MERGE_SET, mergeFailedHref, false));
			 if (predecessorIds != null && predecessorIds.length > 0) {
				 String[] pdcHrefs = new String[predecessorIds.length];
				 for (int i = 0;
				 i < predecessorIds.length;
				 i++) {
					 pdcHrefs[i] = getItemUri(predecessorIds[i], sessionInfo);
				 }
				 changeList.add(new HrefProperty(VersionControlledResource.PREDECESSOR_SET, pdcHrefs, false));
			 }
			 request = new HttpProppatch(getItemUri(nodeId, sessionInfo), changeList);
			 initMethod(request, sessionInfo, !isUnLockMethod(request));
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public void addVersionLabel(SessionInfo sessionInfo, NodeId versionHistoryId, NodeId versionId, Name label, boolean moveLabel) throws RepositoryException {
		 HttpLabel request = null;
		 try {
			 String uri = getItemUri(versionId, sessionInfo);
			 String strLabel = getNamePathResolver(sessionInfo).getJCRName(label);
			 request = new HttpLabel(uri, new LabelInfo(strLabel, moveLabel ? LabelInfo.TYPE_SET : LabelInfo.TYPE_ADD));
			 initMethod(request, sessionInfo, !isUnLockMethod(request));
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException ex) {
			 throw ExceptionConverter.generate(ex);
		 }
		 finally {
			 request.releaseConnection();
		 }
	 }
	 public void removeVersionLabel(SessionInfo sessionInfo, NodeId versionHistoryId, NodeId versionId, Name label) throws RepositoryException {
		 HttpLabel request = null;
		 try {
			 String uri = getItemUri(versionId, sessionInfo);
			 String strLabel = getNamePathResolver(sessionInfo).getJCRName(label);
			 request = new HttpLabel(uri, new LabelInfo(strLabel, LabelInfo.TYPE_REMOVE));
			 initMethod(request, sessionInfo, !isUnLockMethod(request));
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException ex) {
			 throw ExceptionConverter.generate(ex);
		 }
		 finally {
			 request.releaseConnection();
		 }
	 }
	 public NodeId createActivity(SessionInfo sessionInfo, String title) throws RepositoryException {
		 throw new UnsupportedOperationException(""JCR-2104: JSR 283 Versioning. Implementation missing"");
	 }
	 public void removeActivity(SessionInfo sessionInfo, NodeId activityId) throws RepositoryException {
		 throw new UnsupportedOperationException(""JCR-2104: JSR 283 Versioning. Implementation missing"");
	 }
	 public Iterator<NodeId> mergeActivity(SessionInfo sessionInfo, NodeId activityId) throws RepositoryException {
		 throw new UnsupportedOperationException(""JCR-2104: JSR 283 Versioning. Implementation missing"");
	 }
	 public NodeId createConfiguration(SessionInfo sessionInfo, NodeId nodeId) throws RepositoryException {
		 throw new UnsupportedOperationException(""JCR-2104: JSR 283 Versioning. Implementation missing"");
	 }
	 public String[] getSupportedQueryLanguages(SessionInfo sessionInfo) throws RepositoryException {
		 HttpOptions request = new HttpOptions(uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName()));
		 try {
			 HttpResponse response = executeRequest(sessionInfo, request);
			 int status = response.getStatusLine().getStatusCode();
			 if (status != DavServletResponse.SC_OK) {
				 throw new DavException(status);
			 }
			 return request.getSearchGrammars(response).toArray(new String[0]);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 request.releaseConnection();
		 }
	 }
	 public String[] checkQueryStatement(SessionInfo sessionInfo, String statement, String language, Map<String, String> namespaces) throws RepositoryException {
		 return new String[0];
	 }
	 public QueryInfo executeQuery(SessionInfo sessionInfo, String statement, String language, Map<String, String> namespaces, long limit, long offset, Map<String, QValue> values) throws RepositoryException {
		 HttpSearch request = null;
		 try {
			 String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
			 SearchInfo sInfo = new SearchInfo( language, ItemResourceConstants.NAMESPACE, statement, namespaces);
			 if (limit != -1) {
				 sInfo.setNumberResults(limit);
			 }
			 if (offset != -1) {
				 sInfo.setOffset(offset);
			 }
			 if (!(values == null || values.isEmpty())) {
				 throw new UnsupportedOperationException(""Implementation missing: JCR-2107"");
			 }
			 request = new HttpSearch(uri, sInfo);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 MultiStatus ms = request.getResponseBodyAsMultiStatus(response);
			 NamePathResolver resolver = getNamePathResolver(sessionInfo);
			 return new QueryInfoImpl(ms, idFactory, resolver, valueFactory, getQValueFactory());
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public EventFilter createEventFilter(SessionInfo sessionInfo, int eventTypes, Path absPath, boolean isDeep, String[] uuids, Name[] nodeTypeNames, boolean noLocal) throws RepositoryException {
		 Set<Name> resolvedTypeNames = null;
		 if (nodeTypeNames != null) {
			 resolvedTypeNames = new HashSet<Name>();
			 if (nodeTypeDefinitions.size() == 0) {
				 getQNodeTypeDefinitions(sessionInfo);
			 }
			 synchronized (nodeTypeDefinitions) {
				 for (Name nodeTypeName : nodeTypeNames) {
					 resolveNodeType(resolvedTypeNames, nodeTypeName);
				 }
			 }
		 }
		 return new EventFilterImpl(eventTypes, absPath, isDeep, uuids, resolvedTypeNames, noLocal);
	 }
	 public EventBundle[] getEvents(Subscription subscription, long timeout) throws RepositoryException {
		 checkSubscription(subscription);
		 EventSubscriptionImpl subscr = (EventSubscriptionImpl) subscription;
		 String rootUri = uriResolver.getRootItemUri(subscr.getSessionInfo().getWorkspaceName());
		 return poll(rootUri, subscr.getId(), timeout, subscr.getSessionInfo());
	 }
	 public EventBundle getEvents(SessionInfo sessionInfo, EventFilter filter, long after) throws RepositoryException {
		 HttpGet request = null;
		 String rootUri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
		 rootUri += ""?type=journal"";
		 try {
			 request = new HttpGet(rootUri);
			 request.addHeader(""If-None-Match"", ""\"""" + Long.toHexString(after) + ""\"""");
			 initMethod(request, sessionInfo);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 int status = response.getStatusLine().getStatusCode();
			 if (status != 200) {
				 throw new RepositoryException(""getEvents to "" + rootUri + "" failed with "" + response.getStatusLine());
			 }
			 HttpEntity entity = response.getEntity();
			 InputStream in = entity.getContent();
			 Document doc = null;
			 if (in != null) {
				 try {
					 doc = DomUtil.parseDocument(in);
				 }
				 catch (ParserConfigurationException e) {
					 throw new IOException(""XML parser configuration error"", e);
				 }
				 catch (SAXException e) {
					 throw new IOException(""XML parsing error"", e);
				 }
				 finally {
					 in.close();
				 }
			 }
			 List<Event> events = new ArrayList<Event>();
			 ElementIterator entries = DomUtil.getChildren(doc.getDocumentElement(), AtomFeedConstants.N_ENTRY);
			 while (entries.hasNext()) {
				 Element entryElem = entries.next();
				 Element contentElem = DomUtil.getChildElement(entryElem, AtomFeedConstants.N_CONTENT);
				 if (contentElem != null && ""application/vnd.apache.jackrabbit.event+xml"".equals(contentElem.getAttribute(""type""))) {
					 List<Event> el = buildEventList(contentElem, (SessionInfoImpl) sessionInfo, rootUri);
					 for (Event e : el) {
						 if (e.getDate() > after && (filter == null || filter.accept(e, false))) {
							 events.add(e);
						 }
					 }
				 }
			 }
			 return new EventBundleImpl(events, false);
		 }
		 catch (Exception ex) {
			 log.error(""extracting events from journal feed"", ex);
			 throw new RepositoryException(""extracting events from journal feed: "" + ex.getMessage(), ex);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public Subscription createSubscription(SessionInfo sessionInfo, EventFilter[] filters) throws RepositoryException {
		 checkSessionInfo(sessionInfo);
		 String rootUri = uriResolver.getRootItemUri(sessionInfo.getWorkspaceName());
		 String subscriptionId = subscribe(rootUri, S_INFO, null, sessionInfo, null);
		 log.debug(""Subscribed on server for session info "" + sessionInfo);
		 try {
			 checkEventFilterSupport(filters);
		 }
		 catch (UnsupportedRepositoryOperationException ex) {
			 unsubscribe(rootUri, subscriptionId, sessionInfo);
			 throw (ex);
		 }
		 return new EventSubscriptionImpl(subscriptionId, (SessionInfoImpl) sessionInfo);
	 }
	 public void updateEventFilters(Subscription subscription, EventFilter[] filters) throws RepositoryException {
		 checkEventFilterSupport(filters);
	 }
	 private void checkEventFilterSupport(EventFilter[] filters) throws UnsupportedRepositoryOperationException {
		 for (EventFilter ef : filters) {
			 if (ef instanceof EventFilterImpl) {
				 EventFilterImpl efi = (EventFilterImpl) ef;
				 if (efi.getNodeTypeNames() != null && !remoteServerProvidesNodeTypes) {
					 throw new UnsupportedRepositoryOperationException( ""Remote server does not provide node type information in events"");
				 }
				 if (efi.getNoLocal() && !remoteServerProvidesNoLocalFlag) {
					 throw new UnsupportedRepositoryOperationException( ""Remote server does not provide local flag in events"");
				 }
			 }
		 }
	 }
	 public void dispose(Subscription subscription) throws RepositoryException {
		 checkSubscription(subscription);
		 EventSubscriptionImpl subscr = (EventSubscriptionImpl) subscription;
		 String rootUri = uriResolver.getRootItemUri( subscr.getSessionInfo().getWorkspaceName());
		 unsubscribe(rootUri, subscr.getId(), subscr.getSessionInfo());
	 }
	 private String subscribe(String uri, SubscriptionInfo subscriptionInfo, String subscriptionId, SessionInfo sessionInfo, String batchId) throws RepositoryException {
		 HttpSubscribe request = null;
		 try {
			 request = new HttpSubscribe(uri, subscriptionInfo, subscriptionId);
			 initMethod(request, sessionInfo);
			 if (batchId != null) {
				 CodedUrlHeader ch = new CodedUrlHeader(TransactionConstants.HEADER_TRANSACTIONID, batchId);
				 request.setHeader(ch.getHeaderName(), ch.getHeaderValue());
			 }
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 org.apache.jackrabbit.webdav.observation.Subscription[] subs = request.getResponseBodyAsSubscriptionDiscovery(response) .getValue();
			 if (subs.length == 1) {
				 this.remoteServerProvidesNodeTypes = subs[0].eventsProvideNodeTypeInformation();
				 this.remoteServerProvidesNoLocalFlag = subs[0].eventsProvideNoLocalFlag();
			 }
			 return request.getSubscriptionId(response);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 private void unsubscribe(String uri, String subscriptionId, SessionInfo sessionInfo) throws RepositoryException {
		 HttpUnsubscribe request = null;
		 try {
			 request = new HttpUnsubscribe(uri, subscriptionId);
			 initMethod(request, sessionInfo);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 private void resolveNodeType(Set<Name> resolved, Name ntName) {
		 if (!resolved.add(ntName)) {
			 return;
		 }
		 QNodeTypeDefinition def = nodeTypeDefinitions.get(ntName);
		 if (def != null) {
			 for (Name supertype : def.getSupertypes()) {
				 resolveNodeType(resolved, supertype);
			 }
		 }
	 }
	 private EventBundle[] poll(String uri, String subscriptionId, long timeout, SessionInfoImpl sessionInfo) throws RepositoryException {
		 HttpPoll request = null;
		 try {
			 request = new HttpPoll(uri, subscriptionId, timeout);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 EventDiscovery disc = request.getResponseBodyAsEventDiscovery(response);
			 EventBundle[] events;
			 if (disc.isEmpty()) {
				 events = new EventBundle[0];
			 }
			 else {
				 Element discEl = disc.toXml(DomUtil.createDocument());
				 ElementIterator it = DomUtil.getChildren(discEl, ObservationConstants.N_EVENTBUNDLE);
				 List<EventBundle> bundles = new ArrayList<EventBundle>();
				 while (it.hasNext()) {
					 Element bundleElement = it.nextElement();
					 String value = DomUtil.getAttribute(bundleElement, ObservationConstants.XML_EVENT_LOCAL, null);
					 boolean isLocal = false;
					 if (value != null) {
						 isLocal = Boolean.parseBoolean(value);
					 }
					 bundles.add(new EventBundleImpl( buildEventList(bundleElement, sessionInfo, uri), isLocal));
				 }
				 events = bundles.toArray(new EventBundle[bundles.size()]);
			 }
			 return events;
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (ParserConfigurationException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 private List<Event> buildEventList(Element bundleElement, SessionInfoImpl sessionInfo, String baseUri) throws RepositoryException {
		 List<Event> events = new ArrayList<Event>();
		 ElementIterator eventElementIterator = DomUtil.getChildren(bundleElement, ObservationConstants.N_EVENT);
		 String userId = null;
		 if (DomUtil.matches(bundleElement, AtomFeedConstants.N_ENTRY)) {
			 Element authorEl = DomUtil.getChildElement(bundleElement, AtomFeedConstants.N_AUTHOR);
			 Element nameEl = authorEl != null ? DomUtil.getChildElement(authorEl, AtomFeedConstants.N_NAME) : null;
			 if (nameEl != null) {
				 userId = DomUtil.getTextTrim(nameEl);
			 }
		 }
		 while (eventElementIterator.hasNext()) {
			 Element evElem = eventElementIterator.nextElement();
			 Element typeEl = DomUtil.getChildElement(evElem, ObservationConstants.N_EVENTTYPE);
			 EventType[] et = DefaultEventType.createFromXml(typeEl);
			 if (et.length == 0 || et.length > 1) {
				 log.error(""Ambiguous event type definition: expected one single event type."");
				 continue;
			 }
			 String href = DomUtil.getChildTextTrim(evElem, XML_HREF, NAMESPACE);
			 int type = EventUtil.getJcrEventType(et[0].getName());
			 Path eventPath = null;
			 ItemId eventId = null;
			 NodeId parentId = null;
			 if (href != null) {
				 href = resolve(baseUri, href);
				 try {
					 eventPath = uriResolver.getQPath(href, sessionInfo);
				 }
				 catch (RepositoryException e) {
					 log.error(""Internal error while building Event: ()"", e.getMessage());
					 continue;
				 }
				 boolean isForNode = (type == Event.NODE_ADDED || type == Event.NODE_REMOVED || type == Event.NODE_MOVED);
				 try {
					 if (isForNode) {
						 eventId = uriResolver.getNodeIdAfterEvent(href, sessionInfo, type == Event.NODE_REMOVED);
					 }
					 else {
						 eventId = uriResolver.getPropertyId(href, sessionInfo);
					 }
				 }
				 catch (RepositoryException e) {
					 if (isForNode) {
						 eventId = idFactory.createNodeId((String) null, eventPath);
					 }
					 else {
						 try {
							 eventId = idFactory.createPropertyId( idFactory.createNodeId((String) null, eventPath.getAncestor(1)), eventPath.getName());
						 }
						 catch (RepositoryException e1) {
							 log.warn(""Unable to build event itemId: {
							}
							"", e.getMessage());
						 }
					 }
				 }
				 String parentHref = Text.getRelativeParent(href, 1, true);
				 try {
					 parentId = uriResolver.getNodeId(parentHref, sessionInfo);
				 }
				 catch (RepositoryException e) {
					 log.warn(""Unable to build event parentId: {
					}
					"", e.getMessage());
				 }
			 }
			 if (userId == null) {
				 userId = DomUtil.getChildTextTrim(evElem, ObservationConstants.N_EVENTUSERID);
			 }
			 events.add(new EventImpl(eventId, eventPath, parentId, type, userId, evElem, getNamePathResolver(sessionInfo), getQValueFactory()));
		 }
		 return events;
	 }
	 public Map<String, String> getRegisteredNamespaces(SessionInfo sessionInfo) throws RepositoryException {
		 ReportInfo info = new ReportInfo(JcrRemotingConstants.REPORT_REGISTERED_NAMESPACES, ItemResourceConstants.NAMESPACE);
		 HttpReport request = null;
		 try {
			 request = new HttpReport(uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName()), info);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 Document doc = request.getResponseBodyAsDocument(response.getEntity());
			 Map<String, String> namespaces = new HashMap<String, String>();
			 if (doc != null) {
				 Element rootElement = doc.getDocumentElement();
				 ElementIterator nsElems = DomUtil.getChildren(rootElement, JcrRemotingConstants.XML_NAMESPACE, ItemResourceConstants.NAMESPACE);
				 while (nsElems.hasNext()) {
					 Element elem = nsElems.nextElement();
					 String prefix = DomUtil.getChildText(elem, JcrRemotingConstants.XML_PREFIX, ItemResourceConstants.NAMESPACE);
					 String uri = DomUtil.getChildText(elem, JcrRemotingConstants.XML_URI, ItemResourceConstants.NAMESPACE);
					 if (prefix == null && uri == null) {
						 prefix = uri = """";
					 }
					 if (uri != null) {
						 namespaces.put(prefix, uri);
						 nsCache.add(prefix, uri);
					 }
					 else {
						 log.error(""Invalid prefix / uri pair: "" + prefix + "" -> "" + uri);
					 }
				 }
			 }
			 return namespaces;
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public String getNamespaceURI(SessionInfo sessionInfo, String prefix) throws RepositoryException {
		 try {
			 return nsCache.getURI(prefix);
		 }
		 catch (NamespaceException e) {
			 getRegisteredNamespaces(sessionInfo);
			 return nsCache.getURI(prefix);
		 }
	 }
	 public String getNamespacePrefix(SessionInfo sessionInfo, String uri) throws RepositoryException {
		 try {
			 return nsCache.getPrefix(uri);
		 }
		 catch (NamespaceException e) {
			 getRegisteredNamespaces(sessionInfo);
			 return nsCache.getPrefix(uri);
		 }
	 }
	 public void registerNamespace(SessionInfo sessionInfo, String prefix, String uri) throws RepositoryException {
		 getRegisteredNamespaces(sessionInfo);
		 Map<String, String> namespaces = new HashMap<String, String>(nsCache.getNamespaces());
		 namespaces.put(prefix, uri);
		 internalSetNamespaces(sessionInfo, namespaces);
		 nsCache.add(prefix, uri);
	 }
	 public void unregisterNamespace(SessionInfo sessionInfo, String uri) throws RepositoryException {
		 getRegisteredNamespaces(sessionInfo);
		 String prefix = nsCache.getPrefix(uri);
		 Map<String, String> namespaces = new HashMap<String, String>(nsCache.getNamespaces());
		 namespaces.remove(prefix);
		 internalSetNamespaces(sessionInfo, namespaces);
		 nsCache.remove(prefix, uri);
	 }
	 private void internalSetNamespaces(SessionInfo sessionInfo, Map<String, String> namespaces) throws RepositoryException {
		 DavPropertySet setProperties = new DavPropertySet();
		 setProperties.add(createNamespaceProperty(namespaces));
		 HttpProppatch request = null;
		 try {
			 String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
			 request = new HttpProppatch(uri, setProperties, new DavPropertyNameSet());
			 initMethod(request, sessionInfo, true);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public Iterator<QNodeTypeDefinition> getQNodeTypeDefinitions(SessionInfo sessionInfo) throws RepositoryException {
		 HttpReport request = null;
		 try {
			 ReportInfo info = new ReportInfo(JcrRemotingConstants.REPORT_NODETYPES, ItemResourceConstants.NAMESPACE);
			 info.setContentElement(DomUtil.createElement(DomUtil.createDocument(), NodeTypeConstants.XML_REPORT_ALLNODETYPES, ItemResourceConstants.NAMESPACE));
			 String workspaceUri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
			 request = new HttpReport(workspaceUri, info);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
			 Document reportDoc = request.getResponseBodyAsDocument(response.getEntity());
			 return retrieveQNodeTypeDefinitions(sessionInfo, reportDoc);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (ParserConfigurationException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public Iterator<QNodeTypeDefinition> getQNodeTypeDefinitions(SessionInfo sessionInfo, Name[] nodetypeNames) throws RepositoryException {
		 return getQNodeTypeDefinitions(sessionInfo);
	 }
	 public void registerNodeTypes(SessionInfo sessionInfo, QNodeTypeDefinition[] nodeTypeDefinitions, boolean allowUpdate) throws RepositoryException {
		 HttpProppatch request = null;
		 try {
			 DavPropertySet setProperties = new DavPropertySet();
			 setProperties.add(createRegisterNodeTypesProperty(sessionInfo, nodeTypeDefinitions, allowUpdate));
			 String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
			 request = new HttpProppatch(uri, setProperties, new DavPropertyNameSet());
			 initMethod(request, sessionInfo, true);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public void unregisterNodeTypes(SessionInfo sessionInfo, Name[] nodeTypeNames) throws RepositoryException {
		 HttpProppatch request = null;
		 try {
			 DavPropertySet setProperties = new DavPropertySet();
			 setProperties.add(createUnRegisterNodeTypesProperty(sessionInfo, nodeTypeNames));
			 String uri = uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName());
			 request = new HttpProppatch(uri, setProperties, new DavPropertyNameSet());
			 initMethod(request, sessionInfo, true);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public void createWorkspace(SessionInfo sessionInfo, String name, String srcWorkspaceName) throws RepositoryException {
		 if (srcWorkspaceName != null) {
			 throw new UnsupportedOperationException(""JCR-2003. Implementation missing"");
		 }
		 HttpMkworkspace request = null;
		 try {
			 request = new HttpMkworkspace(uriResolver.getWorkspaceUri(name));
			 initMethod(request, sessionInfo, true);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public void deleteWorkspace(SessionInfo sessionInfo, String name) throws RepositoryException {
		 HttpDelete request = null;
		 try {
			 request = new HttpDelete(uriResolver.getWorkspaceUri(name));
			 initMethod(request, sessionInfo, true);
			 HttpResponse response = executeRequest(sessionInfo, request);
			 request.checkSuccess(response);
		 }
		 catch (IOException e) {
			 throw new RepositoryException(e);
		 }
		 catch (DavException e) {
			 throw ExceptionConverter.generate(e);
		 }
		 finally {
			 if (request != null) {
				 request.releaseConnection();
			 }
		 }
	 }
	 public static URI computeRepositoryUri(String uri) throws URISyntaxException {
		 URI repositoryUri = URI.create((uri.endsWith(""/"")) ? uri : uri + ""/"");
		 boolean useDefaultPort = (""http"".equalsIgnoreCase(repositoryUri.getScheme()) && repositoryUri.getPort() == 80) || ((""https"".equalsIgnoreCase(repositoryUri.getScheme()) && repositoryUri.getPort() == 443));
		 if (useDefaultPort) {
			 repositoryUri = new URI(repositoryUri.getScheme(), repositoryUri.getUserInfo(), repositoryUri.getHost(), -1, repositoryUri.getPath(), repositoryUri.getQuery(), repositoryUri.getFragment());
		 }
		 return repositoryUri;
	 }
	 public HttpResponse executeRequest(SessionInfo sessionInfo, HttpUriRequest request) throws IOException, RepositoryException {
		 return getClient(sessionInfo).execute(request, getContext(sessionInfo));
	 }
	 private Iterator<QNodeTypeDefinition> retrieveQNodeTypeDefinitions(SessionInfo sessionInfo, Document reportDoc) throws RepositoryException {
		 ElementIterator it = DomUtil.getChildren(reportDoc.getDocumentElement(), NodeTypeConstants.NODETYPE_ELEMENT, null);
		 List<QNodeTypeDefinition> ntDefs = new ArrayList<QNodeTypeDefinition>();
		 NamePathResolver resolver = getNamePathResolver(sessionInfo);
		 while (it.hasNext()) {
			 ntDefs.add(DefinitionUtil.createQNodeTypeDefinition(it.nextElement(), resolver, getQValueFactory()));
		 }
		 synchronized (nodeTypeDefinitions) {
			 nodeTypeDefinitions.clear();
			 for (Object ntDef : ntDefs) {
				 QNodeTypeDefinition def = (QNodeTypeDefinition) ntDef;
				 nodeTypeDefinitions.put(def.getName(), def);
			 }
		 }
		 return ntDefs.iterator();
	 }
	 private DavProperty<List<XmlSerializable>> createRegisterNodeTypesProperty(SessionInfo sessionInfo, QNodeTypeDefinition[] nodeTypeDefinitions, final boolean allowUpdate) throws IOException {
		 List<XmlSerializable> val = new ArrayList<XmlSerializable>();
		 StringWriter sw = new StringWriter();
		 CompactNodeTypeDefWriter writer = new CompactNodeTypeDefWriter(sw, new NamespaceResolverImpl(sessionInfo), true);
		 writer.write(Arrays.asList(nodeTypeDefinitions));
		 writer.close();
		 final String cnd = sw.toString();
		 val.add(new XmlSerializable() {
			 public Element toXml(Document document) {
				 Element cndElem = document.createElementNS(JcrRemotingConstants.NS_URI, JcrRemotingConstants.NS_PREFIX + "":"" + JcrRemotingConstants.XML_CND);
				 DomUtil.setText(cndElem, cnd);
				 return cndElem;
			 }
		 }
		);
		 val.add(new XmlSerializable() {
			 public Element toXml(Document document) {
				 Element allowElem = document.createElementNS(JcrRemotingConstants.NS_URI, JcrRemotingConstants.NS_PREFIX + "":"" + JcrRemotingConstants.XML_ALLOWUPDATE);
				 DomUtil.setText(allowElem, Boolean.toString(allowUpdate));
				 return allowElem;
			 }
		 }
		);
		 return new DefaultDavProperty<List<XmlSerializable>>(JcrRemotingConstants.JCR_NODETYPES_CND_LN, val, ItemResourceConstants.NAMESPACE, false);
	 }
	 private DavProperty<List<XmlSerializable>> createUnRegisterNodeTypesProperty(SessionInfo sessionInfo, Name[] nodeTypeNames) throws IOException, RepositoryException {
		 NamePathResolver resolver = getNamePathResolver(sessionInfo);
		 List<XmlSerializable> val = new ArrayList<XmlSerializable>();
		 for (Name ntName : nodeTypeNames) {
			 final String jcrName = resolver.getJCRName(ntName);
			 val.add(new XmlSerializable() {
				 public Element toXml(Document document) {
					 Element ntNameElem = document.createElementNS(JcrRemotingConstants.NS_URI, JcrRemotingConstants.NS_PREFIX + "":"" + JcrRemotingConstants.XML_NODETYPENAME);
					 org.w3c.dom.Text txt = document.createTextNode(jcrName);
					 ntNameElem.appendChild(txt);
					 return ntNameElem;
				 }
			 }
			);
		 }
		 return new DefaultDavProperty<List<XmlSerializable>>(JcrRemotingConstants.JCR_NODETYPES_CND_LN, val, ItemResourceConstants.NAMESPACE, false);
	 }
	 private static DavProperty<List<XmlSerializable>> createValuesProperty(Value[] jcrValues) {
		 List<XmlSerializable> val = new ArrayList<XmlSerializable>();
		 for (final Value jcrValue : jcrValues) {
			 val.add(new XmlSerializable() {
				 public Element toXml(Document document) {
					 try {
						 return ValueUtil.valueToXml(jcrValue, document);
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
			);
		 }
		 return new DefaultDavProperty<List<XmlSerializable>>(JcrRemotingConstants.JCR_VALUES_LN, val, ItemResourceConstants.NAMESPACE, false);
	 }
	 private static DavProperty<List<XmlSerializable>> createNamespaceProperty(final Map<String, String> namespaces) {
		 List<XmlSerializable> val = new ArrayList<XmlSerializable>();
		 for (final String prefix : namespaces.keySet()) {
			 val.add(new XmlSerializable() {
				 public Element toXml(Document document) {
					 Element nsElem = document.createElementNS(JcrRemotingConstants.NS_URI, JcrRemotingConstants.NS_PREFIX + "":"" + JcrRemotingConstants.XML_NAMESPACE);
					 Element prefixElem = document.createElementNS(JcrRemotingConstants.NS_URI, JcrRemotingConstants.NS_PREFIX + "":"" + JcrRemotingConstants.XML_PREFIX);
					 org.w3c.dom.Text txt = document.createTextNode(prefix);
					 prefixElem.appendChild(txt);
					 final String uri = namespaces.get(prefix);
					 Element uriElem = document.createElementNS(JcrRemotingConstants.NS_URI, JcrRemotingConstants.NS_PREFIX + "":"" + JcrRemotingConstants.XML_URI);
					 org.w3c.dom.Text txt2 = document.createTextNode(uri);
					 uriElem.appendChild(txt2);
					 nsElem.appendChild(prefixElem);
					 nsElem.appendChild(uriElem);
					 return nsElem;
				 }
			 }
			);
		 }
		 return new DefaultDavProperty<List<XmlSerializable>>(JcrRemotingConstants.JCR_NAMESPACES_LN, val, ItemResourceConstants.NAMESPACE, false);
	 }
	 private static DavProperty<List<XmlSerializable>> createNodeTypeProperty(String localName, String[] ntNames) {
		 List<XmlSerializable> val = new ArrayList<XmlSerializable>();
		 for (final String ntName : ntNames) {
			 val.add(new XmlSerializable() {
				 public Element toXml(Document document) {
					 return NodeTypeUtil.ntNameToXml(ntName, document);
				 }
			 }
			);
		 }
		 return new DefaultDavProperty<List<XmlSerializable>>(localName, val, ItemResourceConstants.NAMESPACE, false);
	 }
	 private Set<String> getDavComplianceClasses(SessionInfo sessionInfo) throws RepositoryException {
		 if (this.remoteDavComplianceClasses == null) {
			 HttpOptions request = new HttpOptions(uriResolver.getWorkspaceUri(sessionInfo.getWorkspaceName()));
			 try {
				 HttpResponse response = executeRequest(sessionInfo, request);
				 int status = response.getStatusLine().getStatusCode();
				 if (status != DavServletResponse.SC_OK) {
					 throw new DavException(status);
				 }
				 this.remoteDavComplianceClasses = request.getDavComplianceClasses(response);
			 }
			 catch (IOException e) {
				 throw new RepositoryException(e);
			 }
			 catch (DavException e) {
				 throw ExceptionConverter.generate(e);
			 }
			 finally {
				 request.releaseConnection();
			 }
		 }
		 return this.remoteDavComplianceClasses;
	 }
	 private boolean isDavClass3(SessionInfo sessionInfo) {
		 try {
			 return getDavComplianceClasses(sessionInfo).contains(""3"");
		 }
		 catch (RepositoryException ex) {
			 log.warn(""failure to obtain OPTIONS response"", ex);
			 return false;
		 }
	 }
	 private static String obtainAbsolutePathFromUri(String uri) {
		 try {
			 java.net.URI u = new java.net.URI(uri);
			 StringBuilder sb = new StringBuilder();
			 sb.append(u.getRawPath());
			 if (u.getRawQuery() != null) {
				 sb.append(""?"").append(u.getRawQuery());
			 }
			 return sb.toString();
		 }
		 catch (java.net.URISyntaxException ex) {
			 log.warn(""parsing "" + uri, ex);
			 return uri;
		 }
	 }
	 private static String[] obtainAbsolutePathsFromUris(String[] uris) {
		 if (uris == null) {
			 return null;
		 }
		 else {
			 String result[] = new String[uris.length];
			 for (int i = 0;
			 i < result.length;
			 i++) {
				 result[i] = obtainAbsolutePathFromUri(uris[i]);
			 }
			 return result;
		 }
	 }
	 private class BatchImpl implements Batch {
		 private final SessionInfo sessionInfo;
		 private final ItemId targetId;
		 private final List<HttpRequestBase> requests = new ArrayList<HttpRequestBase>();
		 private final NamePathResolver resolver;
		 private String batchId;
		 private boolean isConsumed = false;
		 private boolean clear = false;
		 private BatchImpl(ItemId targetId, SessionInfo sessionInfo) throws RepositoryException {
			 this.targetId = targetId;
			 this.sessionInfo = sessionInfo;
			 this.resolver = getNamePathResolver(sessionInfo);
		 }
		 private HttpClient start() throws RepositoryException {
			 checkConsumed();
			 String uri = getItemUri(targetId, sessionInfo);
			 HttpLock request = null;
			 try {
				 request = new HttpLock(uri, new org.apache.jackrabbit.webdav.lock.LockInfo(TransactionConstants.LOCAL, TransactionConstants.TRANSACTION, null, INFINITE_TIMEOUT, true));
				 initMethod(request, sessionInfo, true);
				 HttpClient client = getClient(sessionInfo);
				 HttpResponse response = client.execute(request,getContext(sessionInfo));
				 if (response.getStatusLine().getStatusCode() == DavServletResponse.SC_PRECONDITION_FAILED) {
					 throw new InvalidItemStateException(""Unable to persist transient changes."");
				 }
				 request.checkSuccess(response);
				 batchId = request.getLockToken(response);
				 return client;
			 }
			 catch (IOException e) {
				 throw new RepositoryException(e);
			 }
			 catch (DavException e) {
				 throw ExceptionConverter.generate(e);
			 }
			 finally {
				 if (request != null) {
					 request.releaseConnection();
				 }
			 }
		 }
		 private void end(HttpClient client, boolean commit) throws RepositoryException {
			 checkConsumed();
			 String uri = getItemUri(targetId, sessionInfo);
			 HttpUnlock request = null;
			 try {
				 request = new HttpUnlock(uri, batchId);
				 initMethod(request, sessionInfo, true);
				 request.setEntity(XmlEntity.create(new TransactionInfo(commit)));
				 HttpResponse response = client.execute(request, getContext(sessionInfo));
				 request.checkSuccess(response);
				 if (sessionInfo instanceof SessionInfoImpl) {
					 ((SessionInfoImpl) sessionInfo).setLastBatchId(batchId);
				 }
				 if (clear) {
					 clearItemUriCache(sessionInfo);
				 }
			 }
			 catch (IOException e) {
				 throw new RepositoryException(e);
			 }
			 catch (DavException e) {
				 throw ExceptionConverter.generate(e);
			 }
			 finally {
				 if (request != null) {
					 request.releaseConnection();
				 }
			 }
		 }
		 private void dispose() {
			 requests.clear();
			 isConsumed = true;
		 }
		 private void checkConsumed() {
			 if (isConsumed) {
				 throw new IllegalStateException(""Batch has already been consumed."");
			 }
		 }
		 private boolean isEmpty() {
			 return requests.isEmpty();
		 }
		 private Iterator<HttpRequestBase> requests() {
			 return requests.iterator();
		 }
		 public void addNode(NodeId parentId, Name nodeName, Name nodetypeName, String uuid) throws RepositoryException {
			 checkConsumed();
			 try {
				 Name fakeName = getNameFactory().create(Name.NS_DEFAULT_URI, UUID.randomUUID().toString());
				 String uri = getItemUri(parentId, fakeName, sessionInfo);
				 HttpMkcol request = new HttpMkcol(uri);
				 Document body = DomUtil.createDocument();
				 BatchUtils.createNodeElement(body, nodeName, nodetypeName, uuid, resolver);
				 request.setEntity(XmlEntity.create(body));
				 requests.add(request);
			 }
			 catch (IOException e) {
				 throw new RepositoryException(e);
			 }
			 catch (ParserConfigurationException e) {
				 throw new RepositoryException(e);
			 }
		 }
		 public void addProperty(NodeId parentId, Name propertyName, QValue value) throws RepositoryException {
			 checkConsumed();
			 String uri = getItemUri(parentId, propertyName, sessionInfo);
			 HttpPut request = new HttpPut(uri);
			 request.setHeader(HEADER_CONTENT_TYPE, JcrValueType.contentTypeFromType(value.getType()));
			 request.setEntity(getEntity(value));
			 requests.add(request);
		 }
		 public void addProperty(NodeId parentId, Name propertyName, QValue[] values) throws RepositoryException {
			 checkConsumed();
			 try {
				 String uri = getItemUri(parentId, propertyName, sessionInfo);
				 Value[] jcrValues = new Value[values.length];
				 for (int i = 0;
				 i < values.length;
				 i++) {
					 jcrValues[i] = ValueFormat.getJCRValue(values[i], resolver, valueFactory);
				 }
				 DavProperty<List<XmlSerializable>> vp = createValuesProperty(jcrValues);
				 HttpPut request = new HttpPut(uri);
				 request.setEntity(XmlEntity.create(vp));
				 requests.add(request);
			 }
			 catch (IOException e) {
				 throw new RepositoryException(e);
			 }
		 }
		 public void setValue(PropertyId propertyId, QValue value) throws RepositoryException {
			 checkConsumed();
			 if (value == null) {
				 remove(propertyId);
			 }
			 else {
				 HttpEntity ent = getEntity(value);
				 String uri = getItemUri(propertyId, sessionInfo);
				 HttpPut request = new HttpPut(uri);
				 request.setHeader(HEADER_CONTENT_TYPE, JcrValueType.contentTypeFromType(value.getType()));
				 request.setEntity(ent);
				 requests.add(request);
			 }
		 }
		 public void setValue(PropertyId propertyId, QValue[] values) throws RepositoryException {
			 checkConsumed();
			 if (values == null) {
				 remove(propertyId);
			 }
			 else {
				 DavPropertySet setProperties = new DavPropertySet();
				 Value[] jcrValues = new Value[values.length];
				 for (int i = 0;
				 i < values.length;
				 i++) {
					 jcrValues[i] = ValueFormat.getJCRValue(values[i], resolver, valueFactory);
				 }
				 setProperties.add(createValuesProperty(jcrValues));
				 try {
					 String uri = getItemUri(propertyId, sessionInfo);
					 HttpProppatch request = new HttpProppatch(uri, setProperties, new DavPropertyNameSet());
					 requests.add(request);
				 }
				 catch (IOException e) {
					 throw new RepositoryException(e);
				 }
			 }
		 }
		 private HttpEntity getEntity(QValue value) throws RepositoryException {
			 int type = value.getType();
			 String contentType = JcrValueType.contentTypeFromType(type);
			 HttpEntity ent;
			 switch (type) {
				 case PropertyType.NAME: case PropertyType.PATH: String str = ValueFormat.getJCRString(value, resolver);
				 ent = new StringEntity(str, ContentType.create(contentType, ""UTF-8""));
				 break;
				 case PropertyType.BINARY: InputStream in = value.getStream();
				 ent = new InputStreamEntity(in, ContentType.create(contentType));
				 break;
				 default: str = value.getString();
				 ent = new StringEntity(str, ContentType.create(contentType, ""UTF-8""));
				 break;
			 }
			 return ent;
		 }
		 public void remove(ItemId itemId) throws RepositoryException {
			 checkConsumed();
			 String uri = getItemUri(itemId, sessionInfo);
			 HttpDelete request = new HttpDelete(uri);
			 requests.add(request);
			 if (itemId.getPath() == null) {
				 clear = true;
			 }
		 }
		 public void reorderNodes(NodeId parentId, NodeId srcNodeId, NodeId beforeNodeId) throws RepositoryException {
			 checkConsumed();
			 try {
				 String uri = getItemUri(parentId, sessionInfo);
				 String srcUri = getItemUri(srcNodeId, sessionInfo);
				 String srcSegment = Text.getName(srcUri, true);
				 Position p;
				 if (beforeNodeId == null) {
					 p = new Position(OrderingConstants.XML_LAST);
				 }
				 else {
					 String beforeUri = getItemUri(beforeNodeId, sessionInfo);
					 String targetSegment = Text.getName(beforeUri, true);
					 p = new Position(OrderingConstants.XML_BEFORE, targetSegment);
				 }
				 OrderPatch op = new OrderPatch(OrderingConstants.ORDERING_TYPE_CUSTOM, new OrderPatch.Member(srcSegment, p));
				 HttpOrderpatch request = new HttpOrderpatch(uri, op);
				 requests.add(request);
			 }
			 catch (IOException e) {
				 throw new RepositoryException(e);
			 }
		 }
		 public void setMixins(NodeId nodeId, Name[] mixinNodeTypeIds) throws RepositoryException {
			 checkConsumed();
			 try {
				 DavPropertySet setProperties;
				 DavPropertyNameSet removeProperties;
				 if (mixinNodeTypeIds == null || mixinNodeTypeIds.length == 0) {
					 setProperties = new DavPropertySet();
					 removeProperties = new DavPropertyNameSet();
					 removeProperties.add(JcrRemotingConstants.JCR_MIXINNODETYPES_LN, ItemResourceConstants.NAMESPACE);
				 }
				 else {
					 String[] ntNames = new String[mixinNodeTypeIds.length];
					 for (int i = 0;
					 i < mixinNodeTypeIds.length;
					 i++) {
						 ntNames[i] = resolver.getJCRName(mixinNodeTypeIds[i]);
					 }
					 setProperties = new DavPropertySet();
					 setProperties.add(createNodeTypeProperty(JcrRemotingConstants.JCR_MIXINNODETYPES_LN, ntNames));
					 removeProperties = new DavPropertyNameSet();
				 }
				 String uri = getItemUri(nodeId, sessionInfo);
				 HttpProppatch request = new HttpProppatch(uri, setProperties, removeProperties);
				 requests.add(request);
			 }
			 catch (IOException e) {
				 throw new RepositoryException(e);
			 }
		 }
		 public void setPrimaryType(NodeId nodeId, Name primaryNodeTypeName) throws RepositoryException {
			 checkConsumed();
			 try {
				 DavPropertySet setProperties = new DavPropertySet();
				 setProperties.add(createNodeTypeProperty(JcrRemotingConstants.JCR_PRIMARYNODETYPE_LN, new String[] {
				resolver.getJCRName(primaryNodeTypeName)}
				));
				 String uri = getItemUri(nodeId, sessionInfo);
				 HttpProppatch request = new HttpProppatch(uri, setProperties, new DavPropertyNameSet());
				 requests.add(request);
			 }
			 catch (IOException e) {
				 throw new RepositoryException(e);
			 }
		 }
		 public void move(NodeId srcNodeId, NodeId destParentNodeId, Name destName) throws RepositoryException {
			 checkConsumed();
			 String uri = getItemUri(srcNodeId, sessionInfo);
			 String destUri = getItemUri(destParentNodeId, destName, sessionInfo);
			 if (isDavClass3(sessionInfo)) {
				 destUri = obtainAbsolutePathFromUri(destUri);
			 }
			 HttpMove request = new HttpMove(uri, destUri, false);
			 requests.add(request);
			 clear = true;
		 }
		 public void setTree(NodeId parentId, Tree tree) throws RepositoryException {
			 checkConsumed();
			 if (!(tree instanceof DocumentTree)) {
				 throw new RepositoryException(""Invalid tree implementation "" + tree.getClass().getName());
			 }
			 try {
				 Name fakeName = getNameFactory().create(Name.NS_DEFAULT_URI, UUID.randomUUID().toString());
				 String uri = getItemUri(parentId, fakeName, sessionInfo);
				 HttpMkcol request = new HttpMkcol(uri);
				 request.setEntity(XmlEntity.create(((DocumentTree) tree).toDocument()));
				 requests.add(request);
			 }
			 catch (IOException e) {
				 throw new RepositoryException(e);
			 }
		 }
	 }
	 private class NamespaceResolverImpl implements NamespaceResolver {
		 private final SessionInfo sessionInfo;
		 private NamespaceResolverImpl(SessionInfo sessionInfo) {
			 this.sessionInfo = sessionInfo;
		 }
		 public String getURI(String prefix) throws NamespaceException {
			 try {
				 return getNamespaceURI(sessionInfo, prefix);
			 }
			 catch (RepositoryException e) {
				 String msg = ""Error retrieving namespace uri"";
				 throw new NamespaceException(msg, e);
			 }
		 }
		 public String getPrefix(String uri) throws NamespaceException {
			 try {
				 return getNamespacePrefix(sessionInfo, uri);
			 }
			 catch (RepositoryException e) {
				 String msg = ""Error retrieving namespace prefix"";
				 throw new NamespaceException(msg, e);
			 }
		 }
	 }
	 private class IdentifierResolverImpl implements IdentifierResolver {
		 private final SessionInfo sessionInfo;
		 private IdentifierResolverImpl(SessionInfo sessionInfo) {
			 this.sessionInfo = sessionInfo;
		 }
		 private Path buildPath(String uniqueID) throws RepositoryException {
			 String uri = uriResolver.getItemUri(getIdFactory().createNodeId(uniqueID), sessionInfo.getWorkspaceName(), sessionInfo);
			 return uriResolver.getQPath(uri, sessionInfo);
		 }
		 private Path resolvePath(String jcrPath) throws RepositoryException {
			 return ((SessionInfoImpl) sessionInfo).getNamePathResolver().getQPath(jcrPath);
		 }
		 public Path getPath(String identifier) throws MalformedPathException {
			 try {
				 int pos = identifier.indexOf('/');
				 if (pos == -1) {
					 return buildPath(identifier);
				 }
				 else if (pos == 0) {
					 return resolvePath(identifier);
				 }
				 else {
					 Path p1 = buildPath(identifier.substring(0, pos));
					 Path p2 = resolvePath(identifier.substring(pos));
					 return getPathFactory().create(p1, p2, true);
				 }
			 }
			 catch (RepositoryException e) {
				 throw new MalformedPathException(identifier);
			 }
		 }
		 public void checkFormat(String identifier) throws MalformedPathException {
		 }
	 }
	 private class NamePathResolverImpl implements NamePathResolver {
		 private final NameResolver nResolver;
		 private final PathResolver pResolver;
		 private NamePathResolverImpl(SessionInfo sessionInfo) {
			 NamespaceResolver nsResolver = new NamespaceResolverImpl(sessionInfo);
			 nResolver = new ParsingNameResolver(getNameFactory(), nsResolver);
			 IdentifierResolver idResolver = new IdentifierResolverImpl(sessionInfo);
			 pResolver = new ParsingPathResolver(getPathFactory(), nResolver, idResolver);
		 }
		 private NamePathResolverImpl(NamespaceResolver nsResolver) {
			 nResolver = new ParsingNameResolver(getNameFactory(), nsResolver);
			 pResolver = new ParsingPathResolver(getPathFactory(), nResolver);
		 }
		 public Name getQName(String jcrName) throws IllegalNameException, NamespaceException {
			 return nResolver.getQName(jcrName);
		 }
		 public String getJCRName(Name qName) throws NamespaceException {
			 return nResolver.getJCRName(qName);
		 }
		 public Path getQPath(String path) throws MalformedPathException, IllegalNameException, NamespaceException {
			 return pResolver.getQPath(path);
		 }
		 public Path getQPath(String path, boolean normalizeIdentifier) throws MalformedPathException, IllegalNameException, NamespaceException {
			 return pResolver.getQPath(path, normalizeIdentifier);
		 }
		 public String getJCRPath(Path path) throws NamespaceException {
			 return pResolver.getJCRPath(path);
		 }
	 }
	 private static class NamespaceCache extends AbstractNamespaceResolver {
		 private final HashMap<String, String> prefixToURI = new HashMap<String, String>();
		 private final HashMap<String, String> uriToPrefix = new HashMap<String, String>();
		 public Map<String, String> getNamespaces() {
			 return new HashMap<String, String>(prefixToURI);
		 }
		 public void add(String prefix, String uri) {
			 prefixToURI.put(prefix, uri);
			 uriToPrefix.put(uri, prefix);
		 }
		 public void remove(String prefix, String uri) {
			 prefixToURI.remove(prefix);
			 uriToPrefix.remove(uri);
		 }
		 public String getURI(String prefix) throws NamespaceException {
			 String uri = prefixToURI.get(prefix);
			 if (uri != null) {
				 return uri;
			 }
			 else {
				 throw new NamespaceException(prefix + "": is not a registered namespace prefix."");
			 }
		 }
		 public String getPrefix(String uri) throws NamespaceException {
			 String prefix = uriToPrefix.get(uri);
			 if (prefix != null) {
				 return prefix;
			 }
			 else {
				 throw new NamespaceException(uri + "": is not a registered namespace uri."");
			 }
		 }
	 }
}",1,0,0,0
"public void setOptions(String options) {
	 cmdOptions = options;
 }",0,0,0,0
"public class User {
	 private String name = ""nameA"";
	 private int age = 100;
	 private int index;
	 private String[] names;
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public String[] getNames() {
		 return names;
	 }
	 public void setNames(String[] names) {
		 this.names = names;
	 }
	 public int getAge() {
		 return age;
	 }
	 public void setAge(int age) {
		 this.age = age;
	 }
	 public int getIndex() {
		 return index;
	 }
	 public void setIndex(int index) {
		 this.index = index;
	 }
	 public String toString() {
		 return ""User [name="" + name + "", age="" + age + "", index="" + index + ""]"";
	 }
	 public String jsonString() {
		 try {
			 return JsonUtils.writeValueAsString(this);
		 }
		 catch (JsonProcessingException e) {
			 throw new IllegalStateException(e);
		 }
	 }
}",0,1,0,0
"public Integer apply(Writable from) {
	 if (!(from instanceof HBaseRPC.Invocation)) return NORMAL_QOS;
	 HBaseRPC.Invocation inv = (HBaseRPC.Invocation) from;
	 String methodName = inv.getMethodName();
	 Integer priorityByAnnotation = annotatedQos.get(methodName);
	 if (priorityByAnnotation != null) {
		 return priorityByAnnotation;
	 }
	 if (methodName.equals(""next"") || methodName.equals(""close"")) {
		 Long scannerId;
		 try {
			 scannerId = (Long) inv.getParameters()[0];
		 }
		 catch (ClassCastException ignored) {
			 return NORMAL_QOS;
		 }
		 String scannerIdString = Long.toString(scannerId);
		 InternalScanner scanner = scanners.get(scannerIdString);
		 if (scanner instanceof HRegion.RegionScanner) {
			 HRegion.RegionScanner rs = (HRegion.RegionScanner) scanner;
			 HRegionInfo regionName = rs.getRegionName();
			 if (regionName.isMetaRegion()) {
				 return HIGH_QOS;
			 }
		 }
	 }
	 else if (inv.getParameterClasses().length == 0) {
	 }
	 else if (inv.getParameterClasses()[0] == byte[].class) {
		 if (isMetaRegion((byte[]) inv.getParameters()[0])) {
			 return HIGH_QOS;
		 }
	 }
	 else if (inv.getParameterClasses()[0] == MultiAction.class) {
		 MultiAction ma = (MultiAction) inv.getParameters()[0];
		 Set<byte[]> regions = ma.getRegions();
		 for (byte[] region : regions) {
			 if (isMetaRegion(region)) {
				 return HIGH_QOS;
			 }
		 }
	 }
	 return NORMAL_QOS;
 }",0,0,1,0
"public abstract class HCatEventMessage {
	 public static enum EventType {
		 CREATE_DATABASE(HCatConstants.HCAT_CREATE_DATABASE_EVENT), DROP_DATABASE(HCatConstants.HCAT_DROP_DATABASE_EVENT), CREATE_TABLE(HCatConstants.HCAT_CREATE_TABLE_EVENT), DROP_TABLE(HCatConstants.HCAT_DROP_TABLE_EVENT), ADD_PARTITION(HCatConstants.HCAT_ADD_PARTITION_EVENT), DROP_PARTITION(HCatConstants.HCAT_DROP_PARTITION_EVENT), ALTER_TABLE(HCatConstants.HCAT_ALTER_TABLE_EVENT), ALTER_PARTITION(HCatConstants.HCAT_ALTER_PARTITION_EVENT), INSERT(HCatConstants.HCAT_INSERT_EVENT), CREATE_FUNCTION(HCatConstants.HCAT_CREATE_FUNCTION_EVENT), DROP_FUNCTION(HCatConstants.HCAT_DROP_FUNCTION_EVENT);
		 private String typeString;
		 EventType(String typeString) {
			 this.typeString = typeString;
		 }
		 public String toString() {
			 return typeString;
		 }
	 }
	 protected EventType eventType;
	 protected HCatEventMessage(EventType eventType) {
		 this.eventType = eventType;
	 }
	 public EventType getEventType() {
		 return eventType;
	 }
	 public abstract String getServer();
	 public abstract String getServicePrincipal();
	 public abstract String getDB();
	 public abstract Long getTimestamp();
	 public HCatEventMessage checkValid() {
		 if (getServer() == null || getServicePrincipal() == null) {
			 throw new IllegalStateException(""Server-URL/Service-Principal shouldn't be null."");
		 }
		 if (getEventType() == null) {
			 throw new IllegalStateException(""Event-type unset."");
		 }
		 if (getDB() == null) {
			 throw new IllegalArgumentException(""DB-name unset."");
		 }
		 return this;
	 }
}",0,0,0,0
"private final int jjStartNfa_0(int pos, long active0){
	 return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
}",0,0,0,0
"public class RowIteratorFactory{
	 private static final Comparator<IColumnIterator> COMPARE_BY_KEY = new Comparator<IColumnIterator>() {
		 public int compare(IColumnIterator o1, IColumnIterator o2) {
			 return DecoratedKey.comparator.compare(o1.getKey(), o2.getKey());
		 }
	 }
	;
	 public static CloseableIterator<Row> getIterator(final Iterable<Memtable> memtables, final Collection<SSTableReader> sstables, final RowPosition startWith, final RowPosition stopAt, final QueryFilter filter, final ColumnFamilyStore cfs) {
		 final List<CloseableIterator<IColumnIterator>> iterators = new ArrayList<CloseableIterator<IColumnIterator>>();
		 for (Memtable memtable : memtables) {
			 iterators.add(new ConvertToColumnIterator(filter, memtable.getEntryIterator(startWith, stopAt)));
		 }
		 for (SSTableReader sstable : sstables) {
			 final SSTableScanner scanner = sstable.getScanner(filter);
			 scanner.seekTo(startWith);
			 assert scanner instanceof Closeable;
			 iterators.add(scanner);
		 }
		 return MergeIterator.get(iterators, COMPARE_BY_KEY, new MergeIterator.Reducer<IColumnIterator, Row>() {
			 private final int gcBefore = (int) (System.currentTimeMillis() / 1000) - cfs.metadata.getGcGraceSeconds();
			 private final List<IColumnIterator> colIters = new ArrayList<IColumnIterator>();
			 private DecoratedKey key;
			 private ColumnFamily returnCF;
			 protected void onKeyChange() {
				 this.returnCF = ColumnFamily.create(cfs.metadata);
			 }
			 public void reduce(IColumnIterator current) {
				 this.colIters.add(current);
				 this.key = current.getKey();
				 this.returnCF.delete(current.getColumnFamily());
			 }
			 protected Row getReduced() {
				 ColumnFamily cached = cfs.getRawCachedRow(key);
				 if (cached == null) {
					 filter.collateColumns(returnCF, colIters, gcBefore);
				 }
				 else {
					 QueryFilter keyFilter = new QueryFilter(key, filter.path, filter.filter);
					 returnCF = cfs.filterColumnFamily(cached, keyFilter, gcBefore);
				 }
				 Row rv = new Row(key, returnCF);
				 colIters.clear();
				 key = null;
				 return rv;
			 }
		 }
		);
	 }
	 private static class ConvertToColumnIterator extends AbstractIterator<IColumnIterator> implements CloseableIterator<IColumnIterator> {
		 private final QueryFilter filter;
		 private final Iterator<Map.Entry<DecoratedKey, ColumnFamily>> iter;
		 public ConvertToColumnIterator(QueryFilter filter, Iterator<Map.Entry<DecoratedKey, ColumnFamily>> iter) {
			 this.filter = filter;
			 this.iter = iter;
		 }
		 public IColumnIterator computeNext() {
			 if (iter.hasNext()) {
				 Map.Entry<DecoratedKey, ColumnFamily> entry = iter.next();
				 return filter.getMemtableColumnIterator(entry.getValue(), entry.getKey());
			 }
			 return endOfData();
		 }
		 public void close() {
		 }
	 }
}",0,0,0,0
"public class ReloadingWicketFilter extends WicketFilter{
	private ReloadingClassLoader reloadingClassLoader;
	public ReloadingWicketFilter(){
		reloadingClassLoader = new ReloadingClassLoader(getClass().getClassLoader());
	}
	protected ClassLoader getClassLoader(){
		return reloadingClassLoader;
	}
	public void init(final FilterConfig filterConfig) throws ServletException{
		reloadingClassLoader.setListener(new IChangeListener(){
			public void onChange(){
				reloadingClassLoader.destroy();
				reloadingClassLoader = new ReloadingClassLoader(getClass().getClassLoader());
				try{
					init(filterConfig);
				}
				catch (ServletException e){
					throw new RuntimeException(e);
				}
			}
		}
		);
		super.init(filterConfig);
	}
}",0,0,0,0
"public class ScriptRuntime {
	 protected ScriptRuntime() {
	 }
	 public final static Class BooleanClass = Kit.classOrNull(""java.lang.Boolean""), ByteClass = Kit.classOrNull(""java.lang.Byte""), CharacterClass = Kit.classOrNull(""java.lang.Character""), ClassClass = Kit.classOrNull(""java.lang.Class""), DoubleClass = Kit.classOrNull(""java.lang.Double""), FloatClass = Kit.classOrNull(""java.lang.Float""), IntegerClass = Kit.classOrNull(""java.lang.Integer""), LongClass = Kit.classOrNull(""java.lang.Long""), NumberClass = Kit.classOrNull(""java.lang.Number""), ObjectClass = Kit.classOrNull(""java.lang.Object""), ShortClass = Kit.classOrNull(""java.lang.Short""), StringClass = Kit.classOrNull(""java.lang.String""), DateClass = Kit.classOrNull(""java.util.Date"");
	 public final static Class ContextClass = Kit.classOrNull(""org.mozilla.javascript.Context""), ContextFactoryClass = Kit.classOrNull(""org.mozilla.javascript.ContextFactory""), FunctionClass = Kit.classOrNull(""org.mozilla.javascript.Function""), ScriptableClass = Kit.classOrNull(""org.mozilla.javascript.Scriptable""), ScriptableObjectClass = Kit.classOrNull(""org.mozilla.javascript.ScriptableObject"");
	 private static final String XML_INIT_CLASS = ""org.mozilla.javascript.xmlimpl.XMLLibImpl"";
	 private static final String[] lazilyNames = {
	 ""RegExp"", ""org.mozilla.javascript.regexp.NativeRegExp"", ""Packages"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""java"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""getClass"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""JavaAdapter"", ""org.mozilla.javascript.JavaAdapter"", ""JavaImporter"", ""org.mozilla.javascript.ImporterTopLevel"", ""XML"", XML_INIT_CLASS, ""XMLList"", XML_INIT_CLASS, ""Namespace"", XML_INIT_CLASS, ""QName"", XML_INIT_CLASS, }
	;
	 private static final Object LIBRARY_SCOPE_KEY = new Object();
	 public static boolean isRhinoRuntimeType(Class cl) {
		 if (cl.isPrimitive()) {
			 return (cl != Character.TYPE);
		 }
		 else {
			 return (cl == StringClass || cl == BooleanClass || NumberClass.isAssignableFrom(cl) || ScriptableClass.isAssignableFrom(cl));
		 }
	 }
	 public static ScriptableObject initStandardObjects(Context cx, ScriptableObject scope, boolean sealed) {
		 if (scope == null) {
			 scope = new NativeObject();
		 }
		 scope.associateValue(LIBRARY_SCOPE_KEY, scope);
		 (new ClassCache()).associate(scope);
		 BaseFunction.init(scope, sealed);
		 NativeObject.init(scope, sealed);
		 Scriptable objectProto = ScriptableObject.getObjectPrototype(scope);
		 Scriptable functionProto = ScriptableObject.getFunctionPrototype(scope);
		 functionProto.setPrototype(objectProto);
		 if (scope.getPrototype() == null) scope.setPrototype(objectProto);
		 NativeError.init(scope, sealed);
		 NativeGlobal.init(cx, scope, sealed);
		 NativeArray.init(scope, sealed);
		 NativeString.init(scope, sealed);
		 NativeBoolean.init(scope, sealed);
		 NativeNumber.init(scope, sealed);
		 NativeDate.init(scope, sealed);
		 NativeMath.init(scope, sealed);
		 NativeWith.init(scope, sealed);
		 NativeCall.init(scope, sealed);
		 NativeScript.init(scope, sealed);
		 boolean withXml = cx.hasFeature(Context.FEATURE_E4X);
		 for (int i = 0;
		 i != lazilyNames.length;
		 i += 2) {
			 String topProperty = lazilyNames[i];
			 String className = lazilyNames[i + 1];
			 if (!withXml && className == XML_INIT_CLASS) {
				 continue;
			 }
			 new LazilyLoadedCtor(scope, topProperty, className, sealed);
		 }
		 Continuation.init(scope, sealed);
		 return scope;
	 }
	 public static ScriptableObject getLibraryScopeOrNull(Scriptable scope) {
		 ScriptableObject libScope;
		 libScope = (ScriptableObject)ScriptableObject. getTopScopeValue(scope, LIBRARY_SCOPE_KEY);
		 return libScope;
	 }
	 public static boolean isJSLineTerminator(int c) {
		 if ((c & 0xDFD0) != 0) {
			 return false;
		 }
		 return c == '\n' || c == '\r' || c == 0x2028 || c == 0x2029;
	 }
	 public static Boolean wrapBoolean(boolean b) {
		 return b ? Boolean.TRUE : Boolean.FALSE;
	 }
	 public static Integer wrapInt(int i) {
		 return new Integer(i);
	 }
	 public static Number wrapNumber(double x) {
		 if (x != x) {
			 return ScriptRuntime.NaNobj;
		 }
		 return new Double(x);
	 }
	 public static boolean toBoolean(Object val) {
		 for (;
		;
		) {
			 if (val instanceof Boolean) return ((Boolean) val).booleanValue();
			 if (val == null || val == Undefined.instance) return false;
			 if (val instanceof String) return ((String) val).length() != 0;
			 if (val instanceof Number) {
				 double d = ((Number) val).doubleValue();
				 return (d == d && d != 0.0);
			 }
			 if (val instanceof Scriptable) {
				 if (Context.getContext().isVersionECMA1()) {
					 return true;
				 }
				 val = ((Scriptable) val).getDefaultValue(BooleanClass);
				 if (val instanceof Scriptable) throw errorWithClassName(""msg.primitive.expected"", val);
				 continue;
			 }
			 warnAboutNonJSObject(val);
			 return true;
		 }
	 }
	 public static boolean toBoolean(Object[] args, int index) {
		 return (index < args.length) ? toBoolean(args[index]) : false;
	 }
	 public static double toNumber(Object val) {
		 for (;
		;
		) {
			 if (val instanceof Number) return ((Number) val).doubleValue();
			 if (val == null) return +0.0;
			 if (val == Undefined.instance) return NaN;
			 if (val instanceof String) return toNumber((String) val);
			 if (val instanceof Boolean) return ((Boolean) val).booleanValue() ? 1 : +0.0;
			 if (val instanceof Scriptable) {
				 val = ((Scriptable) val).getDefaultValue(NumberClass);
				 if (val instanceof Scriptable) throw errorWithClassName(""msg.primitive.expected"", val);
				 continue;
			 }
			 warnAboutNonJSObject(val);
			 return NaN;
		 }
	 }
	 public static double toNumber(Object[] args, int index) {
		 return (index < args.length) ? toNumber(args[index]) : NaN;
	 }
	 public static final double NaN = Double.longBitsToDouble(0x7ff8000000000000L);
	 public static final double negativeZero = Double.longBitsToDouble(0x8000000000000000L);
	 public static final Double NaNobj = new Double(NaN);
	 static double stringToNumber(String s, int start, int radix) {
		 char digitMax = '9';
		 char lowerCaseBound = 'a';
		 char upperCaseBound = 'A';
		 int len = s.length();
		 if (radix < 10) {
			 digitMax = (char) ('0' + radix - 1);
		 }
		 if (radix > 10) {
			 lowerCaseBound = (char) ('a' + radix - 10);
			 upperCaseBound = (char) ('A' + radix - 10);
		 }
		 int end;
		 double sum = 0.0;
		 for (end=start;
		 end < len;
		 end++) {
			 char c = s.charAt(end);
			 int newDigit;
			 if ('0' <= c && c <= digitMax) newDigit = c - '0';
			 else if ('a' <= c && c < lowerCaseBound) newDigit = c - 'a' + 10;
			 else if ('A' <= c && c < upperCaseBound) newDigit = c - 'A' + 10;
			 else break;
			 sum = sum*radix + newDigit;
		 }
		 if (start == end) {
			 return NaN;
		 }
		 if (sum >= 9007199254740992.0) {
			 if (radix == 10) {
				 try {
					 return Double.valueOf(s.substring(start, end)).doubleValue();
				 }
				 catch (NumberFormatException nfe) {
					 return NaN;
				 }
			 }
			 else if (radix == 2 || radix == 4 || radix == 8 || radix == 16 || radix == 32) {
				 int bitShiftInChar = 1;
				 int digit = 0;
				 final int SKIP_LEADING_ZEROS = 0;
				 final int FIRST_EXACT_53_BITS = 1;
				 final int AFTER_BIT_53 = 2;
				 final int ZEROS_AFTER_54 = 3;
				 final int MIXED_AFTER_54 = 4;
				 int state = SKIP_LEADING_ZEROS;
				 int exactBitsLimit = 53;
				 double factor = 0.0;
				 boolean bit53 = false;
				 boolean bit54 = false;
				 for (;
				;
				) {
					 if (bitShiftInChar == 1) {
						 if (start == end) break;
						 digit = s.charAt(start++);
						 if ('0' <= digit && digit <= '9') digit -= '0';
						 else if ('a' <= digit && digit <= 'z') digit -= 'a' - 10;
						 else digit -= 'A' - 10;
						 bitShiftInChar = radix;
					 }
					 bitShiftInChar >>= 1;
					 boolean bit = (digit & bitShiftInChar) != 0;
					 switch (state) {
						 case SKIP_LEADING_ZEROS: if (bit) {
							 --exactBitsLimit;
							 sum = 1.0;
							 state = FIRST_EXACT_53_BITS;
						 }
						 break;
						 case FIRST_EXACT_53_BITS: sum *= 2.0;
						 if (bit) sum += 1.0;
						 --exactBitsLimit;
						 if (exactBitsLimit == 0) {
							 bit53 = bit;
							 state = AFTER_BIT_53;
						 }
						 break;
						 case AFTER_BIT_53: bit54 = bit;
						 factor = 2.0;
						 state = ZEROS_AFTER_54;
						 break;
						 case ZEROS_AFTER_54: if (bit) {
							 state = MIXED_AFTER_54;
						 }
						 case MIXED_AFTER_54: factor *= 2;
						 break;
					 }
				 }
				 switch (state) {
					 case SKIP_LEADING_ZEROS: sum = 0.0;
					 break;
					 case FIRST_EXACT_53_BITS: case AFTER_BIT_53: break;
					 case ZEROS_AFTER_54: if (bit54 & bit53) sum += 1.0;
					 sum *= factor;
					 break;
					 case MIXED_AFTER_54: if (bit54) sum += 1.0;
					 sum *= factor;
					 break;
				 }
			 }
		 }
		 return sum;
	 }
	 public static double toNumber(String s) {
		 int len = s.length();
		 int start = 0;
		 char startChar;
		 for (;
		;
		) {
			 if (start == len) {
				 return +0.0;
			 }
			 startChar = s.charAt(start);
			 if (!Character.isWhitespace(startChar)) break;
			 start++;
		 }
		 if (startChar == '0') {
			 if (start + 2 < len) {
				 int c1 = s.charAt(start + 1);
				 if (c1 == 'x' || c1 == 'X') {
					 return stringToNumber(s, start + 2, 16);
				 }
			 }
		 }
		 else if (startChar == '+' || startChar == '-') {
			 if (start + 3 < len && s.charAt(start + 1) == '0') {
				 int c2 = s.charAt(start + 2);
				 if (c2 == 'x' || c2 == 'X') {
					 double val = stringToNumber(s, start + 3, 16);
					 return startChar == '-' ? -val : val;
				 }
			 }
		 }
		 int end = len - 1;
		 char endChar;
		 while (Character.isWhitespace(endChar = s.charAt(end))) end--;
		 if (endChar == 'y') {
			 if (startChar == '+' || startChar == '-') start++;
			 if (start + 7 == end && s.regionMatches(start, ""Infinity"", 0, 8)) return startChar == '-' ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
			 return NaN;
		 }
		 String sub = s.substring(start, end+1);
		 if (MSJVM_BUG_WORKAROUNDS) {
			 for (int i=sub.length()-1;
			 i >= 0;
			 i--) {
				 char c = sub.charAt(i);
				 if (('0' <= c && c <= '9') || c == '.' || c == 'e' || c == 'E' || c == '+' || c == '-') continue;
				 return NaN;
			 }
		 }
		 try {
			 return Double.valueOf(sub).doubleValue();
		 }
		 catch (NumberFormatException ex) {
			 return NaN;
		 }
	 }
	 public static Object[] padArguments(Object[] args, int count) {
		 if (count < args.length) return args;
		 int i;
		 Object[] result = new Object[count];
		 for (i = 0;
		 i < args.length;
		 i++) {
			 result[i] = args[i];
		 }
		 for (;
		 i < count;
		 i++) {
			 result[i] = Undefined.instance;
		 }
		 return result;
	 }
	 private final static boolean MSJVM_BUG_WORKAROUNDS = true;
	 public static String escapeString(String s) {
		 return escapeString(s, '""');
	 }
	 public static String escapeString(String s, char escapeQuote) {
		 if (!(escapeQuote == '""' || escapeQuote == '\'')) Kit.codeBug();
		 StringBuffer sb = null;
		 for(int i = 0, L = s.length();
		 i != L;
		 ++i) {
			 int c = s.charAt(i);
			 if (' ' <= c && c <= '~' && c != escapeQuote && c != '\\') {
				 if (sb != null) {
					 sb.append((char)c);
				 }
				 continue;
			 }
			 if (sb == null) {
				 sb = new StringBuffer(L + 3);
				 sb.append(s);
				 sb.setLength(i);
			 }
			 int escape = -1;
			 switch (c) {
				 case '\b': escape = 'b';
				 break;
				 case '\f': escape = 'f';
				 break;
				 case '\n': escape = 'n';
				 break;
				 case '\r': escape = 'r';
				 break;
				 case '\t': escape = 't';
				 break;
				 case 0xb: escape = 'v';
				 break;
				 case ' ': escape = ' ';
				 break;
				 case '\\': escape = '\\';
				 break;
			 }
			 if (escape >= 0) {
				 sb.append('\\');
				 sb.append((char)escape);
			 }
			 else if (c == escapeQuote) {
				 sb.append('\\');
				 sb.append(escapeQuote);
			 }
			 else {
				 int hexSize;
				 if (c < 256) {
					 sb.append(""\\x"");
					 hexSize = 2;
				 }
				 else {
					 sb.append(""\\u"");
					 hexSize = 4;
				 }
				 for (int shift = (hexSize - 1) * 4;
				 shift >= 0;
				 shift -= 4) {
					 int digit = 0xf & (c >> shift);
					 int hc = (digit < 10) ? '0' + digit : 'a' - 10 + digit;
					 sb.append((char)hc);
				 }
			 }
		 }
		 return (sb == null) ? s : sb.toString();
	 }
	 static boolean isValidIdentifierName(String s) {
		 int L = s.length();
		 if (L == 0) return false;
		 if (!Character.isJavaIdentifierStart(s.charAt(0))) return false;
		 for (int i = 1;
		 i != L;
		 ++i) {
			 if (!Character.isJavaIdentifierPart(s.charAt(i))) return false;
		 }
		 return !TokenStream.isKeyword(s);
	 }
	 public static String toString(Object val) {
		 for (;
		;
		) {
			 if (val == null) {
				 return ""null"";
			 }
			 if (val == Undefined.instance) {
				 return ""undefined"";
			 }
			 if (val instanceof String) {
				 return (String)val;
			 }
			 if (val instanceof Number) {
				 return numberToString(((Number)val).doubleValue(), 10);
			 }
			 if (val instanceof Scriptable) {
				 val = ((Scriptable) val).getDefaultValue(StringClass);
				 if (val instanceof Scriptable) {
					 throw errorWithClassName(""msg.primitive.expected"", val);
				 }
				 continue;
			 }
			 return val.toString();
		 }
	 }
	 static String defaultObjectToString(Scriptable obj) {
		 return ""[object "" + obj.getClassName() + ']';
	 }
	 public static String toString(Object[] args, int index) {
		 return (index < args.length) ? toString(args[index]) : ""undefined"";
	 }
	 public static String toString(double val) {
		 return numberToString(val, 10);
	 }
	 public static String numberToString(double d, int base) {
		 if (d != d) return ""NaN"";
		 if (d == Double.POSITIVE_INFINITY) return ""Infinity"";
		 if (d == Double.NEGATIVE_INFINITY) return ""-Infinity"";
		 if (d == 0.0) return ""0"";
		 if ((base < 2) || (base > 36)) {
			 throw Context.reportRuntimeError1( ""msg.bad.radix"", Integer.toString(base));
		 }
		 if (base != 10) {
			 return DToA.JS_dtobasestr(base, d);
		 }
		 else {
			 StringBuffer result = new StringBuffer();
			 DToA.JS_dtostr(result, DToA.DTOSTR_STANDARD, 0, d);
			 return result.toString();
		 }
	 }
	 static String uneval(Context cx, Scriptable scope, Object value) {
		 if (value == null) {
			 return ""null"";
		 }
		 if (value == Undefined.instance) {
			 return ""undefined"";
		 }
		 if (value instanceof String) {
			 String escaped = escapeString((String)value);
			 StringBuffer sb = new StringBuffer(escaped.length() + 2);
			 sb.append('\""');
			 sb.append(escaped);
			 sb.append('\""');
			 return sb.toString();
		 }
		 if (value instanceof Number) {
			 double d = ((Number)value).doubleValue();
			 if (d == 0 && 1 / d < 0) {
				 return ""-0"";
			 }
			 return toString(d);
		 }
		 if (value instanceof Boolean) {
			 return toString(value);
		 }
		 if (value instanceof Scriptable) {
			 Scriptable obj = (Scriptable)value;
			 Object v = ScriptableObject.getProperty(obj, ""toSource"");
			 if (v instanceof Function) {
				 Function f = (Function)v;
				 return toString(f.call(cx, scope, obj, emptyArgs));
			 }
			 return toString(value);
		 }
		 warnAboutNonJSObject(value);
		 return value.toString();
	 }
	 static String defaultObjectToSource(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 boolean toplevel, iterating;
		 if (cx.iterating == null) {
			 toplevel = true;
			 iterating = false;
			 cx.iterating = new ObjToIntMap(31);
		 }
		 else {
			 toplevel = false;
			 iterating = cx.iterating.has(thisObj);
		 }
		 StringBuffer result = new StringBuffer(128);
		 if (toplevel) {
			 result.append(""("");
		 }
		 result.append('{
			');
			 try {
				 if (!iterating) {
					 cx.iterating.intern(thisObj);
					 Object[] ids = thisObj.getIds();
					 for(int i=0;
					 i < ids.length;
					 i++) {
						 if (i > 0) result.append("", "");
						 Object id = ids[i];
						 Object value;
						 if (id instanceof Integer) {
							 int intId = ((Integer)id).intValue();
							 value = thisObj.get(intId, thisObj);
							 result.append(intId);
						 }
						 else {
							 String strId = (String)id;
							 value = thisObj.get(strId, thisObj);
							 if (ScriptRuntime.isValidIdentifierName(strId)) {
								 result.append(strId);
							 }
							 else {
								 result.append('\'');
								 result.append( ScriptRuntime.escapeString(strId, '\''));
								 result.append('\'');
							 }
						 }
						 result.append(':');
						 result.append(ScriptRuntime.uneval(cx, scope, value));
					 }
				 }
			 }
			 finally {
				 if (toplevel) {
					 cx.iterating = null;
				 }
			 }
		 result.append('}
		');
		 if (toplevel) {
			 result.append(')');
		 }
		 return result.toString();
	 }
	 public static Scriptable toObject(Scriptable scope, Object val) {
		 if (val instanceof Scriptable) {
			 return (Scriptable)val;
		 }
		 return toObject(Context.getContext(), scope, val);
	 }
	 public static Scriptable toObjectOrNull(Context cx, Object obj) {
		 if (obj instanceof Scriptable) {
			 return (Scriptable)obj;
		 }
		 else if (obj != null && obj != Undefined.instance) {
			 return toObject(cx, getTopCallScope(cx), obj);
		 }
		 return null;
	 }
	 public static Scriptable toObject(Scriptable scope, Object val, Class staticClass) {
		 if (val instanceof Scriptable) {
			 return (Scriptable)val;
		 }
		 return toObject(Context.getContext(), scope, val);
	 }
	 public static Scriptable toObject(Context cx, Scriptable scope, Object val) {
		 if (val instanceof Scriptable) {
			 return (Scriptable) val;
		 }
		 if (val == null) {
			 throw typeError0(""msg.null.to.object"");
		 }
		 if (val == Undefined.instance) {
			 throw typeError0(""msg.undef.to.object"");
		 }
		 String className = val instanceof String ? ""String"" : val instanceof Number ? ""Number"" : val instanceof Boolean ? ""Boolean"" : null;
		 if (className != null) {
			 Object[] args = {
			 val }
			;
			 scope = ScriptableObject.getTopLevelScope(scope);
			 return newObject(cx, scope, className, args);
		 }
		 Object wrapped = cx.getWrapFactory().wrap(cx, scope, val, null);
		 if (wrapped instanceof Scriptable) return (Scriptable) wrapped;
		 throw errorWithClassName(""msg.invalid.type"", val);
	 }
	 public static Scriptable toObject(Context cx, Scriptable scope, Object val, Class staticClass) {
		 return toObject(cx, scope, val);
	 }
	 public static Object call(Context cx, Object fun, Object thisArg, Object[] args, Scriptable scope) {
		 if (!(fun instanceof Function)) {
			 throw notFunctionError(toString(fun));
		 }
		 Function function = (Function)fun;
		 Scriptable thisObj = toObjectOrNull(cx, thisArg);
		 if (thisObj == null) {
			 throw undefCallError(thisObj, ""function"");
		 }
		 return function.call(cx, scope, thisObj, args);
	 }
	 public static Scriptable newObject(Context cx, Scriptable scope, String constructorName, Object[] args) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 Function ctor = getExistingCtor(cx, scope, constructorName);
		 if (args == null) {
			 args = ScriptRuntime.emptyArgs;
		 }
		 return ctor.construct(cx, scope, args);
	 }
	 public static double toInteger(Object val) {
		 return toInteger(toNumber(val));
	 }
	 public static double toInteger(double d) {
		 if (d != d) return +0.0;
		 if (d == 0.0 || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) return d;
		 if (d > 0.0) return Math.floor(d);
		 else return Math.ceil(d);
	 }
	 public static double toInteger(Object[] args, int index) {
		 return (index < args.length) ? toInteger(args[index]) : +0.0;
	 }
	 public static int toInt32(Object val) {
		 if (val instanceof Integer) return ((Integer)val).intValue();
		 return toInt32(toNumber(val));
	 }
	 public static int toInt32(Object[] args, int index) {
		 return (index < args.length) ? toInt32(args[index]) : 0;
	 }
	 public static int toInt32(double d) {
		 int id = (int)d;
		 if (id == d) {
			 return id;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 double two32 = 4294967296.0;
		 d = Math.IEEEremainder(d, two32);
		 long l = (long)d;
		 return (int)l;
	 }
	 public static long toUint32(double d) {
		 long l = (long)d;
		 if (l == d) {
			 return l & 0xffffffffL;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 double two32 = 4294967296.0;
		 l = (long)Math.IEEEremainder(d, two32);
		 return l & 0xffffffffL;
	 }
	 public static long toUint32(Object val) {
		 return toUint32(toNumber(val));
	 }
	 public static char toUint16(Object val) {
		 double d = toNumber(val);
		 int i = (int)d;
		 if (i == d) {
			 return (char)i;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 int int16 = 0x10000;
		 i = (int)Math.IEEEremainder(d, int16);
		 return (char)i;
	 }
	 private static final String DEFAULT_NS_TAG = ""__default_namespace__"";
	 public static Object setDefaultNamespace(Object namespace, Context cx) {
		 Scriptable scope = cx.currentActivationCall;
		 if (scope == null) {
			 scope = getTopCallScope(cx);
		 }
		 XMLLib xmlLib = currentXMLLib(cx);
		 Object ns = xmlLib.toDefaultXmlNamespace(cx, namespace);
		 if (!scope.has(DEFAULT_NS_TAG, scope)) {
			 ScriptableObject.defineProperty(scope, DEFAULT_NS_TAG, ns, ScriptableObject.PERMANENT | ScriptableObject.DONTENUM);
		 }
		 else {
			 scope.put(DEFAULT_NS_TAG, scope, ns);
		 }
		 return Undefined.instance;
	 }
	 public static Object searchDefaultNamespace(Context cx) {
		 Scriptable scope = cx.currentActivationCall;
		 if (scope == null) {
			 scope = getTopCallScope(cx);
		 }
		 Object nsObject;
		 for (;
		;
		) {
			 Scriptable parent = scope.getParentScope();
			 if (parent == null) {
				 nsObject = ScriptableObject.getProperty(scope, DEFAULT_NS_TAG);
				 if (nsObject == Scriptable.NOT_FOUND) {
					 return null;
				 }
				 break;
			 }
			 nsObject = scope.get(DEFAULT_NS_TAG, scope);
			 if (nsObject != Scriptable.NOT_FOUND) {
				 break;
			 }
			 scope = parent;
		 }
		 return nsObject;
	 }
	 public static Object getTopLevelProp(Scriptable scope, String id) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 return ScriptableObject.getProperty(scope, id);
	 }
	 static Function getExistingCtor(Context cx, Scriptable scope, String constructorName) {
		 Object ctorVal = ScriptableObject.getProperty(scope, constructorName);
		 if (ctorVal instanceof Function) {
			 return (Function)ctorVal;
		 }
		 if (ctorVal == Scriptable.NOT_FOUND) {
			 throw Context.reportRuntimeError1( ""msg.ctor.not.found"", constructorName);
		 }
		 else {
			 throw Context.reportRuntimeError1( ""msg.not.ctor"", constructorName);
		 }
	 }
	 private static long indexFromString(String str) {
		 final int MAX_VALUE_LENGTH = 10;
		 int len = str.length();
		 if (len > 0) {
			 int i = 0;
			 boolean negate = false;
			 int c = str.charAt(0);
			 if (c == '-') {
				 if (len > 1) {
					 c = str.charAt(1);
					 i = 1;
					 negate = true;
				 }
			 }
			 c -= '0';
			 if (0 <= c && c <= 9 && len <= (negate ? MAX_VALUE_LENGTH + 1 : MAX_VALUE_LENGTH)) {
				 int index = -c;
				 int oldIndex = 0;
				 i++;
				 if (index != 0) {
					 while (i != len && 0 <= (c = str.charAt(i) - '0') && c <= 9) {
						 oldIndex = index;
						 index = 10 * index - c;
						 i++;
					 }
				 }
				 if (i == len && (oldIndex > (Integer.MIN_VALUE / 10) || (oldIndex == (Integer.MIN_VALUE / 10) && c <= (negate ? -(Integer.MIN_VALUE % 10) : (Integer.MAX_VALUE % 10))))) {
					 return 0xFFFFFFFFL & (negate ? index : -index);
				 }
			 }
		 }
		 return -1L;
	 }
	 public static long testUint32String(String str) {
		 final int MAX_VALUE_LENGTH = 10;
		 int len = str.length();
		 if (1 <= len && len <= MAX_VALUE_LENGTH) {
			 int c = str.charAt(0);
			 c -= '0';
			 if (c == 0) {
				 return (len == 1) ? 0L : -1L;
			 }
			 if (1 <= c && c <= 9) {
				 long v = c;
				 for (int i = 1;
				 i != len;
				 ++i) {
					 c = str.charAt(i) - '0';
					 if (!(0 <= c && c <= 9)) {
						 return -1;
					 }
					 v = 10 * v + c;
				 }
				 if ((v >>> 32) == 0) {
					 return v;
				 }
			 }
		 }
		 return -1;
	 }
	 static Object getIndexObject(String s) {
		 long indexTest = indexFromString(s);
		 if (indexTest >= 0) {
			 return new Integer((int)indexTest);
		 }
		 return s;
	 }
	 static Object getIndexObject(double d) {
		 int i = (int)d;
		 if (i == d) {
			 return new Integer(i);
		 }
		 return toString(d);
	 }
	 static String toStringIdOrIndex(Context cx, Object id) {
		 if (id instanceof Number) {
			 double d = ((Number)id).doubleValue();
			 int index = (int)d;
			 if (index == d) {
				 storeIndexResult(cx, index);
				 return null;
			 }
			 return toString(id);
		 }
		 else {
			 String s;
			 if (id instanceof String) {
				 s = (String)id;
			 }
			 else {
				 s = toString(id);
			 }
			 long indexTest = indexFromString(s);
			 if (indexTest >= 0) {
				 storeIndexResult(cx, (int)indexTest);
				 return null;
			 }
			 return s;
		 }
	 }
	 public static Object getObjectElem(Object obj, Object elem, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, elem);
		 }
		 return getObjectElem(sobj, elem, cx);
	 }
	 public static Object getObjectElem(Scriptable obj, Object elem, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, elem);
		 }
		 Object result;
		 String s = toStringIdOrIndex(cx, elem);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 result = ScriptableObject.getProperty(obj, index);
		 }
		 else {
			 result = ScriptableObject.getProperty(obj, s);
		 }
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object getObjectProp(Object obj, String property, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, property);
		 }
		 return getObjectProp(sobj, property, cx);
	 }
	 public static Object getObjectProp(Scriptable obj, String property, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, property);
		 }
		 Object result = ScriptableObject.getProperty(obj, property);
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object getObjectIndex(Object obj, double dblIndex, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, toString(dblIndex));
		 }
		 int index = (int)dblIndex;
		 if (index == dblIndex) {
			 return getObjectIndex(sobj, index, cx);
		 }
		 else {
			 String s = toString(dblIndex);
			 return getObjectProp(sobj, s, cx);
		 }
	 }
	 public static Object getObjectIndex(Scriptable obj, int index, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, new Integer(index));
		 }
		 Object result = ScriptableObject.getProperty(obj, index);
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object setObjectElem(Object obj, Object elem, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, elem, value);
		 }
		 return setObjectElem(sobj, elem, value, cx);
	 }
	 public static Object setObjectElem(Scriptable obj, Object elem, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, elem, value);
			 return value;
		 }
		 String s = toStringIdOrIndex(cx, elem);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 ScriptableObject.putProperty(obj, index, value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, s, value);
		 }
		 return value;
	 }
	 public static Object setObjectProp(Object obj, String property, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, property, value);
		 }
		 return setObjectProp(sobj, property, value, cx);
	 }
	 public static Object setObjectProp(Scriptable obj, String property, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, property, value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, property, value);
		 }
		 return value;
	 }
	 public static Object setObjectIndex(Object obj, double dblIndex, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, String.valueOf(dblIndex), value);
		 }
		 int index = (int)dblIndex;
		 if (index == dblIndex) {
			 return setObjectIndex(sobj, index, value, cx);
		 }
		 else {
			 String s = toString(dblIndex);
			 return setObjectProp(sobj, s, value, cx);
		 }
	 }
	 public static Object setObjectIndex(Scriptable obj, int index, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, new Integer(index), value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, index, value);
		 }
		 return value;
	 }
	 public static boolean deleteObjectElem(Scriptable target, Object elem, Context cx) {
		 boolean result;
		 if (target instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)target;
			 result = xmlObject.ecmaDelete(cx, elem);
		 }
		 else {
			 String s = toStringIdOrIndex(cx, elem);
			 if (s == null) {
				 int index = lastIndexResult(cx);
				 result = ScriptableObject.deleteProperty(target, index);
			 }
			 else {
				 result = ScriptableObject.deleteProperty(target, s);
			 }
		 }
		 return result;
	 }
	 public static boolean hasObjectElem(Scriptable target, Object elem, Context cx) {
		 boolean result;
		 if (target instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)target;
			 result = xmlObject.ecmaHas(cx, elem);
		 }
		 else {
			 String s = toStringIdOrIndex(cx, elem);
			 if (s == null) {
				 int index = lastIndexResult(cx);
				 result = ScriptableObject.hasProperty(target, index);
			 }
			 else {
				 result = ScriptableObject.hasProperty(target, s);
			 }
		 }
		 return result;
	 }
	 public static Object refGet(Ref ref, Context cx) {
		 return ref.get(cx);
	 }
	 public static Object refSet(Ref ref, Object value, Context cx) {
		 return ref.set(cx, value);
	 }
	 public static Object refDel(Ref ref, Context cx) {
		 return wrapBoolean(ref.delete(cx));
	 }
	 static boolean isSpecialProperty(String s) {
		 return s.equals(""__proto__"") || s.equals(""__parent__"");
	 }
	 public static Ref specialRef(Object obj, String specialProperty, Context cx) {
		 return SpecialRef.createSpecial(cx, obj, specialProperty);
	 }
	 public static Object delete(Object obj, Object id, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 String idStr = (id == null) ? ""null"" : id.toString();
			 throw typeError2(""msg.undef.prop.delete"", toString(obj), idStr);
		 }
		 boolean result = deleteObjectElem(sobj, id, cx);
		 return wrapBoolean(result);
	 }
	 public static Object name(Context cx, Scriptable scope, String name) {
		 Scriptable parent = scope.getParentScope();
		 if (parent == null) {
			 Object result = topScopeName(cx, scope, name);
			 if (result == Scriptable.NOT_FOUND) {
				 throw notFoundError(scope, name);
			 }
			 return result;
		 }
		 return nameOrFunction(cx, scope, parent, name, false);
	 }
	 private static Object nameOrFunction(Context cx, Scriptable scope, Scriptable parentScope, String name, boolean asFunctionCall) {
		 Object result;
		 Scriptable thisObj = scope;
		 XMLObject firstXMLObject = null;
		 for (;
		;
		) {
			 if (scope instanceof NativeWith) {
				 Scriptable withObj = scope.getPrototype();
				 if (withObj instanceof XMLObject) {
					 XMLObject xmlObj = (XMLObject)withObj;
					 if (xmlObj.ecmaHas(cx, name)) {
						 thisObj = xmlObj;
						 result = xmlObj.ecmaGet(cx, name);
						 break;
					 }
					 if (firstXMLObject == null) {
						 firstXMLObject = xmlObj;
					 }
				 }
				 else {
					 result = ScriptableObject.getProperty(withObj, name);
					 if (result != Scriptable.NOT_FOUND) {
						 thisObj = withObj;
						 break;
					 }
				 }
			 }
			 else if (scope instanceof NativeCall) {
				 result = scope.get(name, scope);
				 if (result != Scriptable.NOT_FOUND) {
					 if (asFunctionCall) {
						 thisObj = ScriptableObject. getTopLevelScope(parentScope);
					 }
					 break;
				 }
			 }
			 else {
				 result = ScriptableObject.getProperty(scope, name);
				 if (result != Scriptable.NOT_FOUND) {
					 thisObj = scope;
					 break;
				 }
			 }
			 scope = parentScope;
			 parentScope = parentScope.getParentScope();
			 if (parentScope == null) {
				 result = topScopeName(cx, scope, name);
				 if (result == Scriptable.NOT_FOUND) {
					 if (firstXMLObject == null || asFunctionCall) {
						 throw notFoundError(scope, name);
					 }
					 result = firstXMLObject.ecmaGet(cx, name);
				 }
				 thisObj = scope;
				 break;
			 }
		 }
		 if (asFunctionCall) {
			 if (!(result instanceof Callable)) {
				 throw notFunctionError(result, name);
			 }
			 storeScriptable(cx, thisObj);
		 }
		 return result;
	 }
	 private static Object topScopeName(Context cx, Scriptable scope, String name) {
		 if (cx.useDynamicScope) {
			 scope = checkDynamicScope(cx.topCallScope, scope);
		 }
		 return ScriptableObject.getProperty(scope, name);
	 }
	 public static Scriptable bind(Context cx, Scriptable scope, String id) {
		 Scriptable firstXMLObject = null;
		 Scriptable parent = scope.getParentScope();
		 childScopesChecks: if (parent != null) {
			 while (scope instanceof NativeWith) {
				 Scriptable withObj = scope.getPrototype();
				 if (withObj instanceof XMLObject) {
					 XMLObject xmlObject = (XMLObject)withObj;
					 if (xmlObject.ecmaHas(cx, id)) {
						 return xmlObject;
					 }
					 if (firstXMLObject == null) {
						 firstXMLObject = xmlObject;
					 }
				 }
				 else {
					 if (ScriptableObject.hasProperty(withObj, id)) {
						 return withObj;
					 }
				 }
				 scope = parent;
				 parent = parent.getParentScope();
				 if (parent == null) {
					 break childScopesChecks;
				 }
			 }
			 for (;
			;
			) {
				 if (ScriptableObject.hasProperty(scope, id)) {
					 return scope;
				 }
				 scope = parent;
				 parent = parent.getParentScope();
				 if (parent == null) {
					 break childScopesChecks;
				 }
			 }
		 }
		 if (cx.useDynamicScope) {
			 scope = checkDynamicScope(cx.topCallScope, scope);
		 }
		 if (ScriptableObject.hasProperty(scope, id)) {
			 return scope;
		 }
		 return firstXMLObject;
	 }
	 public static Object setName(Scriptable bound, Object value, Context cx, Scriptable scope, String id) {
		 if (bound != null) {
			 if (bound instanceof XMLObject) {
				 XMLObject xmlObject = (XMLObject)bound;
				 xmlObject.ecmaPut(cx, id, value);
			 }
			 else {
				 ScriptableObject.putProperty(bound, id, value);
			 }
		 }
		 else {
			 if (cx.hasFeature(Context.FEATURE_STRICT_VARS)) {
				 throw Context.reportRuntimeError1(""msg.assn.create.strict"", id);
			 }
			 bound = ScriptableObject.getTopLevelScope(scope);
			 if (cx.useDynamicScope) {
				 bound = checkDynamicScope(cx.topCallScope, bound);
			 }
			 bound.put(id, bound, value);
		 }
		 return value;
	 }
	 private static class IdEnumeration {
		 Scriptable obj;
		 Object[] ids;
		 int index;
		 ObjToIntMap used;
		 String currentId;
		 boolean enumValues;
	 }
	 public static Object enumInit(Object value, Context cx, boolean enumValues) {
		 IdEnumeration x = new IdEnumeration();
		 x.obj = toObjectOrNull(cx, value);
		 if (x.obj != null) {
			 x.enumValues = enumValues;
			 enumChangeObject(x);
		 }
		 return x;
	 }
	 public static Boolean enumNext(Object enumObj) {
		 boolean result;
		 IdEnumeration x = (IdEnumeration)enumObj;
		 for (;
		;
		) {
			 if (x.obj == null) {
				 result = false;
				 break;
			 }
			 if (x.index == x.ids.length) {
				 x.obj = x.obj.getPrototype();
				 enumChangeObject(x);
				 continue;
			 }
			 Object id = x.ids[x.index++];
			 if (x.used != null && x.used.has(id)) {
				 continue;
			 }
			 if (id instanceof String) {
				 String strId = (String)id;
				 if (!x.obj.has(strId, x.obj)) continue;
				 x.currentId = strId;
			 }
			 else {
				 int intId = ((Number)id).intValue();
				 if (!x.obj.has(intId, x.obj)) continue;
				 x.currentId = String.valueOf(intId);
			 }
			 result = true;
			 break;
		 }
		 return wrapBoolean(result);
	 }
	 public static Object enumId(Object enumObj, Context cx) {
		 IdEnumeration x = (IdEnumeration)enumObj;
		 if (!x.enumValues) return x.currentId;
		 Object result;
		 String s = toStringIdOrIndex(cx, x.currentId);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 result = x.obj.get(index, x.obj);
		 }
		 else {
			 result = x.obj.get(s, x.obj);
		 }
		 return result;
	 }
	 private static void enumChangeObject(IdEnumeration x) {
		 Object[] ids = null;
		 while (x.obj != null) {
			 ids = x.obj.getIds();
			 if (ids.length != 0) {
				 break;
			 }
			 x.obj = x.obj.getPrototype();
		 }
		 if (x.obj != null && x.ids != null) {
			 Object[] previous = x.ids;
			 int L = previous.length;
			 if (x.used == null) {
				 x.used = new ObjToIntMap(L);
			 }
			 for (int i = 0;
			 i != L;
			 ++i) {
				 x.used.intern(previous[i]);
			 }
		 }
		 x.ids = ids;
		 x.index = 0;
	 }
	 public static Callable getNameFunctionAndThis(String name, Context cx, Scriptable scope) {
		 Scriptable parent = scope.getParentScope();
		 if (parent == null) {
			 Object result = topScopeName(cx, scope, name);
			 if (!(result instanceof Callable)) {
				 if (result == Scriptable.NOT_FOUND) {
					 throw notFoundError(scope, name);
				 }
				 else {
					 throw notFunctionError(result, name);
				 }
			 }
			 Scriptable thisObj = scope;
			 storeScriptable(cx, thisObj);
			 return (Callable)result;
		 }
		 return (Callable)nameOrFunction(cx, scope, parent, name, true);
	 }
	 public static Callable getElemFunctionAndThis(Object obj, Object elem, Context cx) {
		 String s = toStringIdOrIndex(cx, elem);
		 if (s != null) {
			 return getPropFunctionAndThis(obj, s, cx);
		 }
		 int index = lastIndexResult(cx);
		 Scriptable thisObj = toObjectOrNull(cx, obj);
		 if (thisObj == null) {
			 throw undefCallError(obj, String.valueOf(index));
		 }
		 Object value;
		 for (;
		;
		) {
			 value = ScriptableObject.getProperty(thisObj, index);
			 if (value != Scriptable.NOT_FOUND) {
				 break;
			 }
			 if (!(thisObj instanceof XMLObject)) {
				 break;
			 }
			 XMLObject xmlObject = (XMLObject)thisObj;
			 Scriptable extra = xmlObject.getExtraMethodSource(cx);
			 if (extra == null) {
				 break;
			 }
			 thisObj = extra;
		 }
		 if (!(value instanceof Callable)) {
			 throw notFunctionError(value, elem);
		 }
		 storeScriptable(cx, thisObj);
		 return (Callable)value;
	 }
	 public static Callable getPropFunctionAndThis(Object obj, String property, Context cx) {
		 Scriptable thisObj = toObjectOrNull(cx, obj);
		 if (thisObj == null) {
			 throw undefCallError(obj, property);
		 }
		 Object value;
		 for (;
		;
		) {
			 value = ScriptableObject.getProperty(thisObj, property);
			 if (value != Scriptable.NOT_FOUND) {
				 break;
			 }
			 if (!(thisObj instanceof XMLObject)) {
				 break;
			 }
			 XMLObject xmlObject = (XMLObject)thisObj;
			 Scriptable extra = xmlObject.getExtraMethodSource(cx);
			 if (extra == null) {
				 break;
			 }
			 thisObj = extra;
		 }
		 if (!(value instanceof Callable)) {
			 throw notFunctionError(value, property);
		 }
		 storeScriptable(cx, thisObj);
		 return (Callable)value;
	 }
	 public static Callable getValueFunctionAndThis(Object value, Context cx) {
		 if (!(value instanceof Callable)) {
			 throw notFunctionError(value);
		 }
		 Callable f = (Callable)value;
		 Scriptable thisObj;
		 if (f instanceof Scriptable) {
			 thisObj = ((Scriptable)f).getParentScope();
		 }
		 else {
			 if (cx.topCallScope == null) throw new IllegalStateException();
			 thisObj = cx.topCallScope;
		 }
		 if (thisObj.getParentScope() != null) {
			 if (thisObj instanceof NativeWith) {
			 }
			 else if (thisObj instanceof NativeCall) {
				 thisObj = ScriptableObject.getTopLevelScope(thisObj);
			 }
		 }
		 storeScriptable(cx, thisObj);
		 return f;
	 }
	 public static Ref callRef(Callable function, Scriptable thisObj, Object[] args, Context cx) {
		 if (function instanceof RefCallable) {
			 RefCallable rfunction = (RefCallable)function;
			 Ref ref = rfunction.refCall(cx, thisObj, args);
			 if (ref == null) {
				 throw new IllegalStateException(rfunction.getClass().getName()+"".refCall() returned null"");
			 }
			 return ref;
		 }
		 String msg = getMessage1(""msg.no.ref.from.function"", toString(function));
		 throw constructError(""ReferenceError"", msg);
	 }
	 public static Scriptable newObject(Object fun, Context cx, Scriptable scope, Object[] args) {
		 if (!(fun instanceof Function)) {
			 throw notFunctionError(fun);
		 }
		 Function function = (Function)fun;
		 return function.construct(cx, scope, args);
	 }
	 public static Object callSpecial(Context cx, Callable fun, Scriptable thisObj, Object[] args, Scriptable scope, Scriptable callerThis, int callType, String filename, int lineNumber) {
		 if (callType == Node.SPECIALCALL_EVAL) {
			 if (NativeGlobal.isEvalFunction(fun)) {
				 return evalSpecial(cx, scope, callerThis, args, filename, lineNumber);
			 }
		 }
		 else if (callType == Node.SPECIALCALL_WITH) {
			 if (NativeWith.isWithFunction(fun)) {
				 throw Context.reportRuntimeError1(""msg.only.from.new"", ""With"");
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
		 return fun.call(cx, scope, thisObj, args);
	 }
	 public static Object newSpecial(Context cx, Object fun, Object[] args, Scriptable scope, int callType) {
		 if (callType == Node.SPECIALCALL_EVAL) {
			 if (NativeGlobal.isEvalFunction(fun)) {
				 throw typeError1(""msg.not.ctor"", ""eval"");
			 }
		 }
		 else if (callType == Node.SPECIALCALL_WITH) {
			 if (NativeWith.isWithFunction(fun)) {
				 return NativeWith.newWithSpecial(cx, scope, args);
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
		 return newObject(fun, cx, scope, args);
	 }
	 public static Object applyOrCall(boolean isApply, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 int L = args.length;
		 Callable function;
		 if (thisObj instanceof Callable) {
			 function = (Callable)thisObj;
		 }
		 else {
			 Object value = thisObj.getDefaultValue(ScriptRuntime.FunctionClass);
			 if (!(value instanceof Callable)) {
				 throw ScriptRuntime.notFunctionError(value, thisObj);
			 }
			 function = (Callable)value;
		 }
		 Scriptable callThis = null;
		 if (L != 0) {
			 callThis = toObjectOrNull(cx, args[0]);
		 }
		 if (callThis == null) {
			 callThis = getTopCallScope(cx);
		 }
		 Object[] callArgs;
		 if (isApply) {
			 if (L <= 1) {
				 callArgs = ScriptRuntime.emptyArgs;
			 }
			 else {
				 Object arg1 = args[1];
				 if (arg1 == null || arg1 == Undefined.instance) {
					 callArgs = ScriptRuntime.emptyArgs;
				 }
				 else if (arg1 instanceof NativeArray || arg1 instanceof Arguments) {
					 callArgs = cx.getElements((Scriptable) arg1);
				 }
				 else {
					 throw ScriptRuntime.typeError0(""msg.arg.isnt.array"");
				 }
			 }
		 }
		 else {
			 if (L <= 1) {
				 callArgs = ScriptRuntime.emptyArgs;
			 }
			 else {
				 callArgs = new Object[L - 1];
				 System.arraycopy(args, 1, callArgs, 0, L - 1);
			 }
		 }
		 return function.call(cx, scope, callThis, callArgs);
	 }
	 public static Object evalSpecial(Context cx, Scriptable scope, Object thisArg, Object[] args, String filename, int lineNumber) {
		 if (args.length < 1) return Undefined.instance;
		 Object x = args[0];
		 if (!(x instanceof String)) {
			 if (cx.hasFeature(Context.FEATURE_STRICT_EVAL)) {
				 throw Context.reportRuntimeError0(""msg.eval.nonstring.strict"");
			 }
			 String message = ScriptRuntime.getMessage0(""msg.eval.nonstring"");
			 Context.reportWarning(message);
			 return x;
		 }
		 if (filename == null) {
			 int[] linep = new int[1];
			 filename = Context.getSourcePositionFromStack(linep);
			 if (filename != null) {
				 lineNumber = linep[0];
			 }
			 else {
				 filename = """";
			 }
		 }
		 String sourceName = ScriptRuntime. makeUrlForGeneratedScript(true, filename, lineNumber);
		 ErrorReporter reporter;
		 reporter = DefaultErrorReporter.forEval(cx.getErrorReporter());
		 Script script = cx.compileString((String)x, new Interpreter(), reporter, sourceName, 1, null);
		 ((InterpretedFunction)script).idata.evalScriptFlag = true;
		 Callable c = (Callable)script;
		 return c.call(cx, scope, (Scriptable)thisArg, ScriptRuntime.emptyArgs);
	 }
	 public static String typeof(Object value) {
		 if (value == null) return ""object"";
		 if (value == Undefined.instance) return ""undefined"";
		 if (value instanceof Scriptable) {
			 if (value instanceof XMLObject) return ""xml"";
			 return (value instanceof Callable) ? ""function"" : ""object"";
		 }
		 if (value instanceof String) return ""string"";
		 if (value instanceof Number) return ""number"";
		 if (value instanceof Boolean) return ""boolean"";
		 throw errorWithClassName(""msg.invalid.type"", value);
	 }
	 public static String typeofName(Scriptable scope, String id) {
		 Context cx = Context.getContext();
		 Scriptable val = bind(cx, scope, id);
		 if (val == null) return ""undefined"";
		 return typeof(getObjectProp(val, id, cx));
	 }
	 public static Object add(Object val1, Object val2, Context cx) {
		 if(val1 instanceof Number && val2 instanceof Number) {
			 return wrapNumber(((Number)val1).doubleValue() + ((Number)val2).doubleValue());
		 }
		 if (val1 instanceof XMLObject) {
			 Object test = ((XMLObject)val1).addValues(cx, true, val2);
			 if (test != Scriptable.NOT_FOUND) {
				 return test;
			 }
		 }
		 if (val2 instanceof XMLObject) {
			 Object test = ((XMLObject)val2).addValues(cx, false, val1);
			 if (test != Scriptable.NOT_FOUND) {
				 return test;
			 }
		 }
		 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(null);
		 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(null);
		 if (!(val1 instanceof String) && !(val2 instanceof String)) if ((val1 instanceof Number) && (val2 instanceof Number)) return wrapNumber(((Number)val1).doubleValue() + ((Number)val2).doubleValue());
		 else return wrapNumber(toNumber(val1) + toNumber(val2));
		 return toString(val1).concat(toString(val2));
	 }
	 public static Object nameIncrDecr(Scriptable scopeChain, String id, int incrDecrMask) {
		 Scriptable target;
		 Object value;
		 search: {
			 do {
				 target = scopeChain;
				 do {
					 value = target.get(id, scopeChain);
					 if (value != Scriptable.NOT_FOUND) {
						 break search;
					 }
					 target = target.getPrototype();
				 }
				 while (target != null);
				 scopeChain = scopeChain.getParentScope();
			 }
			 while (scopeChain != null);
			 throw notFoundError(scopeChain, id);
		 }
		 return doScriptableIncrDecr(target, id, scopeChain, value, incrDecrMask);
	 }
	 public static Object propIncrDecr(Object obj, String id, Context cx, int incrDecrMask) {
		 Scriptable start = toObjectOrNull(cx, obj);
		 if (start == null) {
			 throw undefReadError(obj, id);
		 }
		 Scriptable target = start;
		 Object value;
		 search: {
			 do {
				 value = target.get(id, start);
				 if (value != Scriptable.NOT_FOUND) {
					 break search;
				 }
				 target = target.getPrototype();
			 }
			 while (target != null);
			 start.put(id, start, NaNobj);
			 return NaNobj;
		 }
		 return doScriptableIncrDecr(target, id, start, value, incrDecrMask);
	 }
	 private static Object doScriptableIncrDecr(Scriptable target, String id, Scriptable protoChainStart, Object value, int incrDecrMask) {
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 target.put(id, protoChainStart, result);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 public static Object elemIncrDecr(Object obj, Object index, Context cx, int incrDecrMask) {
		 Object value = getObjectElem(obj, index, cx);
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 setObjectElem(obj, index, result, cx);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 public static Object refIncrDecr(Ref ref, Context cx, int incrDecrMask) {
		 Object value = ref.get(cx);
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 ref.set(cx, result);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 private static Object toPrimitive(Object val) {
		 if (!(val instanceof Scriptable)) {
			 return val;
		 }
		 Scriptable s = (Scriptable)val;
		 Object result = s.getDefaultValue(null);
		 if (result instanceof Scriptable) throw typeError0(""msg.bad.default.value"");
		 return result;
	 }
	 public static boolean eq(Object x, Object y) {
		 if (x == null || x == Undefined.instance) {
			 if (y == null || y == Undefined.instance) {
				 return true;
			 }
			 if (y instanceof ScriptableObject) {
				 Object test = ((ScriptableObject)y).equivalentValues(x);
				 if (test != Scriptable.NOT_FOUND) {
					 return ((Boolean)test).booleanValue();
				 }
			 }
			 return false;
		 }
		 else if (x instanceof Number) {
			 return eqNumber(((Number)x).doubleValue(), y);
		 }
		 else if (x instanceof String) {
			 return eqString((String)x, y);
		 }
		 else if (x instanceof Boolean) {
			 boolean b = ((Boolean)x).booleanValue();
			 if (y instanceof Boolean) {
				 return b == ((Boolean)y).booleanValue();
			 }
			 if (y instanceof ScriptableObject) {
				 Object test = ((ScriptableObject)y).equivalentValues(x);
				 if (test != Scriptable.NOT_FOUND) {
					 return ((Boolean)test).booleanValue();
				 }
			 }
			 return eqNumber(b ? 1.0 : 0.0, y);
		 }
		 else if (x instanceof Scriptable) {
			 if (y instanceof Scriptable) {
				 if (x == y) {
					 return true;
				 }
				 if (x instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)x).equivalentValues(y);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 if (y instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)y).equivalentValues(x);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 if (x instanceof Wrapper && y instanceof Wrapper) {
					 return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();
				 }
				 return false;
			 }
			 else if (y instanceof Boolean) {
				 if (x instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)x).equivalentValues(y);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 double d = ((Boolean)y).booleanValue() ? 1.0 : 0.0;
				 return eqNumber(d, x);
			 }
			 else if (y instanceof Number) {
				 return eqNumber(((Number)y).doubleValue(), x);
			 }
			 else if (y instanceof String) {
				 return eqString((String)y, x);
			 }
			 return false;
		 }
		 else {
			 warnAboutNonJSObject(x);
			 return x == y;
		 }
	 }
	 static boolean eqNumber(double x, Object y) {
		 for (;
		;
		) {
			 if (y == null || y == Undefined.instance) {
				 return false;
			 }
			 else if (y instanceof Number) {
				 return x == ((Number)y).doubleValue();
			 }
			 else if (y instanceof String) {
				 return x == toNumber(y);
			 }
			 else if (y instanceof Boolean) {
				 return x == (((Boolean)y).booleanValue() ? 1.0 : +0.0);
			 }
			 else if (y instanceof Scriptable) {
				 if (y instanceof ScriptableObject) {
					 Object xval = wrapNumber(x);
					 Object test = ((ScriptableObject)y).equivalentValues(xval);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 y = toPrimitive(y);
			 }
			 else {
				 warnAboutNonJSObject(y);
				 return false;
			 }
		 }
	 }
	 private static boolean eqString(String x, Object y) {
		 for (;
		;
		) {
			 if (y == null || y == Undefined.instance) {
				 return false;
			 }
			 else if (y instanceof String) {
				 return x.equals(y);
			 }
			 else if (y instanceof Number) {
				 return toNumber(x) == ((Number)y).doubleValue();
			 }
			 else if (y instanceof Boolean) {
				 return toNumber(x) == (((Boolean)y).booleanValue() ? 1.0 : 0.0);
			 }
			 else if (y instanceof Scriptable) {
				 if (y instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)y).equivalentValues(x);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 y = toPrimitive(y);
				 continue;
			 }
			 else {
				 warnAboutNonJSObject(y);
				 return false;
			 }
		 }
	 }
	 public static boolean shallowEq(Object x, Object y) {
		 if (x == y) {
			 if (!(x instanceof Number)) {
				 return true;
			 }
			 double d = ((Number)x).doubleValue();
			 return d == d;
		 }
		 if (x == null || x == Undefined.instance) {
			 return false;
		 }
		 else if (x instanceof Number) {
			 if (y instanceof Number) {
				 return ((Number)x).doubleValue() == ((Number)y).doubleValue();
			 }
		 }
		 else if (x instanceof String) {
			 if (y instanceof String) {
				 return x.equals(y);
			 }
		 }
		 else if (x instanceof Boolean) {
			 if (y instanceof Boolean) {
				 return x.equals(y);
			 }
		 }
		 else if (x instanceof Scriptable) {
			 if (x instanceof Wrapper && y instanceof Wrapper) {
				 return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();
			 }
		 }
		 else {
			 warnAboutNonJSObject(x);
			 return x == y;
		 }
		 return false;
	 }
	 public static boolean instanceOf(Object a, Object b, Context cx) {
		 if (! (b instanceof Scriptable)) {
			 throw typeError0(""msg.instanceof.not.object"");
		 }
		 if (! (a instanceof Scriptable)) return false;
		 return ((Scriptable)b).hasInstance((Scriptable)a);
	 }
	 protected static boolean jsDelegatesTo(Scriptable lhs, Scriptable rhs) {
		 Scriptable proto = lhs.getPrototype();
		 while (proto != null) {
			 if (proto.equals(rhs)) return true;
			 proto = proto.getPrototype();
		 }
		 return false;
	 }
	 public static boolean in(Object a, Object b, Context cx) {
		 if (!(b instanceof Scriptable)) {
			 throw typeError0(""msg.instanceof.not.object"");
		 }
		 return hasObjectElem((Scriptable)b, a, cx);
	 }
	 public static boolean cmp_LT(Object val1, Object val2) {
		 double d1, d2;
		 if (val1 instanceof Number && val2 instanceof Number) {
			 d1 = ((Number)val1).doubleValue();
			 d2 = ((Number)val2).doubleValue();
		 }
		 else {
			 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
			 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
			 if (val1 instanceof String && val2 instanceof String) {
				 return ((String)val1).compareTo((String)val2) < 0;
			 }
			 d1 = toNumber(val1);
			 d2 = toNumber(val2);
		 }
		 return d1 < d2;
	 }
	 public static boolean cmp_LE(Object val1, Object val2) {
		 double d1, d2;
		 if (val1 instanceof Number && val2 instanceof Number) {
			 d1 = ((Number)val1).doubleValue();
			 d2 = ((Number)val2).doubleValue();
		 }
		 else {
			 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
			 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
			 if (val1 instanceof String && val2 instanceof String) {
				 return ((String)val1).compareTo((String)val2) <= 0;
			 }
			 d1 = toNumber(val1);
			 d2 = toNumber(val2);
		 }
		 return d1 <= d2;
	 }
	 public static ScriptableObject getGlobal(Context cx) {
		 final String GLOBAL_CLASS = ""org.mozilla.javascript.tools.shell.Global"";
		 Class globalClass = Kit.classOrNull(GLOBAL_CLASS);
		 if (globalClass != null) {
			 try {
				 Class[] parm = {
				 ScriptRuntime.ContextClass }
				;
				 Constructor globalClassCtor = globalClass.getConstructor(parm);
				 Object[] arg = {
				 cx }
				;
				 return (ScriptableObject) globalClassCtor.newInstance(arg);
			 }
			 catch (Exception e) {
			 }
		 }
		 return new ImporterTopLevel(cx);
	 }
	 public static boolean hasTopCall(Context cx) {
		 return (cx.topCallScope != null);
	 }
	 public static Scriptable getTopCallScope(Context cx) {
		 Scriptable scope = cx.topCallScope;
		 if (scope == null) {
			 throw new IllegalStateException();
		 }
		 return scope;
	 }
	 public static Object doTopCall(Callable callable, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (scope == null) throw new IllegalArgumentException();
		 if (cx.topCallScope != null) throw new IllegalStateException();
		 Object result;
		 cx.topCallScope = ScriptableObject.getTopLevelScope(scope);
		 cx.useDynamicScope = cx.hasFeature(Context.FEATURE_DYNAMIC_SCOPE);
		 ContextFactory f = cx.getFactory();
		 try {
			 result = f.doTopCall(callable, cx, scope, thisObj, args);
		 }
		 finally {
			 cx.topCallScope = null;
			 cx.cachedXMLLib = null;
			 if (cx.currentActivationCall != null) {
				 throw new IllegalStateException();
			 }
		 }
		 return result;
	 }
	 static Scriptable checkDynamicScope(Scriptable possibleDynamicScope, Scriptable staticTopScope) {
		 if (possibleDynamicScope == staticTopScope) {
			 return possibleDynamicScope;
		 }
		 Scriptable proto = possibleDynamicScope;
		 for (;
		;
		) {
			 proto = proto.getPrototype();
			 if (proto == staticTopScope) {
				 return possibleDynamicScope;
			 }
			 if (proto == null) {
				 return staticTopScope;
			 }
		 }
	 }
	 public static void initScript(NativeFunction funObj, Scriptable thisObj, Context cx, Scriptable scope, boolean evalScript) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 int varCount = funObj.getParamAndVarCount();
		 if (varCount != 0) {
			 Scriptable varScope = scope;
			 while (varScope instanceof NativeWith) {
				 varScope = varScope.getParentScope();
			 }
			 for (int i = varCount;
			 i-- != 0;
			) {
				 String name = funObj.getParamOrVarName(i);
				 if (!ScriptableObject.hasProperty(scope, name)) {
					 if (!evalScript) {
						 ScriptableObject.defineProperty( varScope, name, Undefined.instance, ScriptableObject.PERMANENT);
					 }
					 else {
						 varScope.put(name, varScope, Undefined.instance);
					 }
				 }
			 }
		 }
	 }
	 public static Scriptable createFunctionActivation(NativeFunction funObj, Scriptable scope, Object[] args) {
		 return new NativeCall(funObj, scope, args);
	 }
	 public static void enterActivationFunction(Context cx, Scriptable activation) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 NativeCall call = (NativeCall)activation;
		 call.parentActivationCall = cx.currentActivationCall;
		 cx.currentActivationCall = call;
	 }
	 public static void exitActivationFunction(Context cx) {
		 NativeCall call = cx.currentActivationCall;
		 cx.currentActivationCall = call.parentActivationCall;
		 call.parentActivationCall = null;
	 }
	 static NativeCall findFunctionActivation(Context cx, Function f) {
		 NativeCall call = cx.currentActivationCall;
		 while (call != null) {
			 if (call.function == f) return call;
			 call = call.parentActivationCall;
		 }
		 return null;
	 }
	 public static Scriptable newCatchScope(Throwable t, Scriptable lastCatchScope, String exceptionName, Context cx, Scriptable scope) {
		 Object obj;
		 boolean cacheObj;
		 getObj: if (t instanceof JavaScriptException) {
			 cacheObj = false;
			 obj = ((JavaScriptException)t).getValue();
		 }
		 else {
			 cacheObj = true;
			 if (lastCatchScope != null) {
				 NativeObject last = (NativeObject)lastCatchScope;
				 obj = last.getAssociatedValue(t);
				 if (obj == null) Kit.codeBug();
				 break getObj;
			 }
			 RhinoException re;
			 String errorName;
			 String errorMsg;
			 Throwable javaException = null;
			 if (t instanceof EcmaError) {
				 EcmaError ee = (EcmaError)t;
				 re = ee;
				 errorName = ee.getName();
				 errorMsg = ee.getErrorMessage();
			 }
			 else if (t instanceof WrappedException) {
				 WrappedException we = (WrappedException)t;
				 re = we;
				 javaException = we.getWrappedException();
				 errorName = ""JavaException"";
				 errorMsg = javaException.getClass().getName() +"": ""+javaException.getMessage();
			 }
			 else if (t instanceof EvaluatorException) {
				 EvaluatorException ee = (EvaluatorException)t;
				 re = ee;
				 errorName = ""InternalError"";
				 errorMsg = ee.getMessage();
			 }
			 else {
				 throw Kit.codeBug();
			 }
			 String sourceUri = re.sourceName();
			 if (sourceUri == null) {
				 sourceUri = """";
			 }
			 int line = re.lineNumber();
			 Object args[];
			 if (line > 0) {
				 args = new Object[] {
				 errorMsg, sourceUri, new Integer(line) }
				;
			 }
			 else {
				 args = new Object[] {
				 errorMsg, sourceUri }
				;
			 }
			 Scriptable errorObject = cx.newObject(scope, errorName, args);
			 ScriptableObject.putProperty(errorObject, ""name"", errorName);
			 if (javaException != null) {
				 Object wrap = cx.getWrapFactory().wrap(cx, scope, javaException, null);
				 ScriptableObject.defineProperty( errorObject, ""javaException"", wrap, ScriptableObject.PERMANENT | ScriptableObject.READONLY);
			 }
			 Object wrap = cx.getWrapFactory().wrap(cx, scope, re, null);
			 ScriptableObject.defineProperty( errorObject, ""rhinoException"", wrap, ScriptableObject.PERMANENT | ScriptableObject.READONLY);
			 obj = errorObject;
		 }
		 NativeObject catchScopeObject = new NativeObject();
		 catchScopeObject.defineProperty( exceptionName, obj, ScriptableObject.PERMANENT);
		 if (cacheObj) {
			 catchScopeObject.associateValue(t, obj);
		 }
		 return catchScopeObject;
	 }
	 public static Scriptable enterWith(Object obj, Context cx, Scriptable scope) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw typeError1(""msg.undef.with"", toString(obj));
		 }
		 if (sobj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)sobj;
			 return xmlObject.enterWith(scope);
		 }
		 return new NativeWith(scope, sobj);
	 }
	 public static Scriptable leaveWith(Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.getParentScope();
	 }
	 public static Scriptable enterDotQuery(Object value, Scriptable scope) {
		 if (!(value instanceof XMLObject)) {
			 throw notXmlError(value);
		 }
		 XMLObject object = (XMLObject)value;
		 return object.enterDotQuery(scope);
	 }
	 public static Object updateDotQuery(boolean value, Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.updateDotQuery(value);
	 }
	 public static Scriptable leaveDotQuery(Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.getParentScope();
	 }
	 public static void setFunctionProtoAndParent(BaseFunction fn, Scriptable scope) {
		 fn.setParentScope(scope);
		 fn.setPrototype(ScriptableObject.getFunctionPrototype(scope));
	 }
	 public static void setObjectProtoAndParent(ScriptableObject object, Scriptable scope) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 object.setParentScope(scope);
		 Scriptable proto = ScriptableObject.getClassPrototype(scope, object.getClassName());
		 object.setPrototype(proto);
	 }
	 public static void initFunction(Context cx, Scriptable scope, NativeFunction function, int type, boolean fromEvalCode) {
		 if (type == FunctionNode.FUNCTION_STATEMENT) {
			 String name = function.getFunctionName();
			 if (name != null && name.length() != 0) {
				 if (!fromEvalCode) {
					 ScriptableObject.defineProperty (scope, name, function, ScriptableObject.PERMANENT);
				 }
				 else {
					 scope.put(name, scope, function);
				 }
			 }
		 }
		 else if (type == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
			 String name = function.getFunctionName();
			 if (name != null && name.length() != 0) {
				 while (scope instanceof NativeWith) {
					 scope = scope.getParentScope();
				 }
				 scope.put(name, scope, function);
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
	 }
	 public static Scriptable newArrayLiteral(Object[] objects, int[] skipIndexces, Context cx, Scriptable scope) {
		 int count = objects.length;
		 int skipCount = 0;
		 if (skipIndexces != null) {
			 skipCount = skipIndexces.length;
		 }
		 int length = count + skipCount;
		 Integer lengthObj = new Integer(length);
		 Scriptable arrayObj;
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) {
			 arrayObj = cx.newObject(scope, ""Array"", ScriptRuntime.emptyArgs);
			 ScriptableObject.putProperty(arrayObj, ""length"", lengthObj);
		 }
		 else {
			 arrayObj = cx.newObject(scope, ""Array"", new Object[] {
			 lengthObj }
			);
		 }
		 int skip = 0;
		 for (int i = 0, j = 0;
		 i != length;
		 ++i) {
			 if (skip != skipCount && skipIndexces[skip] == i) {
				 ++skip;
				 continue;
			 }
			 ScriptableObject.putProperty(arrayObj, i, objects[j]);
			 ++j;
		 }
		 return arrayObj;
	 }
	 public static Scriptable newObjectLiteral(Object[] propertyIds, Object[] propertyValues, Context cx, Scriptable scope) {
		 Scriptable object = cx.newObject(scope);
		 for (int i = 0, end = propertyIds.length;
		 i != end;
		 ++i) {
			 Object id = propertyIds[i];
			 Object value = propertyValues[i];
			 if (id instanceof String) {
				 ScriptableObject.putProperty(object, (String)id, value);
			 }
			 else {
				 int index = ((Integer)id).intValue();
				 ScriptableObject.putProperty(object, index, value);
			 }
		 }
		 return object;
	 }
	 public static boolean isArrayObject(Object obj) {
		 return obj instanceof NativeArray || obj instanceof Arguments;
	 }
	 public static Object[] getArrayElements(Scriptable object) {
		 Context cx = Context.getContext();
		 long longLen = NativeArray.getLengthProperty(cx, object);
		 if (longLen > Integer.MAX_VALUE) {
			 throw new IllegalArgumentException();
		 }
		 int len = (int) longLen;
		 if (len == 0) {
			 return ScriptRuntime.emptyArgs;
		 }
		 else {
			 Object[] result = new Object[len];
			 for (int i=0;
			 i < len;
			 i++) {
				 Object elem = ScriptableObject.getProperty(object, i);
				 result[i] = (elem == Scriptable.NOT_FOUND) ? Undefined.instance : elem;
			 }
			 return result;
		 }
	 }
	 static void checkDeprecated(Context cx, String name) {
		 int version = cx.getLanguageVersion();
		 if (version >= Context.VERSION_1_4 || version == Context.VERSION_DEFAULT) {
			 String msg = getMessage1(""msg.deprec.ctor"", name);
			 if (version == Context.VERSION_DEFAULT) Context.reportWarning(msg);
			 else throw Context.reportRuntimeError(msg);
		 }
	 }
	 public static String getMessage0(String messageId) {
		 return getMessage(messageId, null);
	 }
	 public static String getMessage1(String messageId, Object arg1) {
		 Object[] arguments = {
		arg1}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage2( String messageId, Object arg1, Object arg2) {
		 Object[] arguments = {
		arg1, arg2}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage3( String messageId, Object arg1, Object arg2, Object arg3) {
		 Object[] arguments = {
		arg1, arg2, arg3}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage4( String messageId, Object arg1, Object arg2, Object arg3, Object arg4) {
		 Object[] arguments = {
		arg1, arg2, arg3, arg4}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage(String messageId, Object[] arguments) {
		 final String defaultResource = ""org.mozilla.javascript.resources.Messages"";
		 Context cx = Context.getCurrentContext();
		 Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();
		 ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);
		 String formatString;
		 try {
			 formatString = rb.getString(messageId);
		 }
		 catch (java.util.MissingResourceException mre) {
			 throw new RuntimeException (""no message resource found for message property ""+ messageId);
		 }
		 MessageFormat formatter = new MessageFormat(formatString);
		 return formatter.format(arguments);
	 }
	 public static EcmaError constructError(String error, String message) {
		 int[] linep = new int[1];
		 String filename = Context.getSourcePositionFromStack(linep);
		 return constructError(error, message, filename, linep[0], null, 0);
	 }
	 public static EcmaError constructError(String error, String message, String sourceName, int lineNumber, String lineSource, int columnNumber) {
		 return new EcmaError(error, message, sourceName, lineNumber, lineSource, columnNumber);
	 }
	 public static EcmaError typeError(String message) {
		 return constructError(""TypeError"", message);
	 }
	 public static EcmaError typeError0(String messageId) {
		 String msg = getMessage0(messageId);
		 return typeError(msg);
	 }
	 public static EcmaError typeError1(String messageId, String arg1) {
		 String msg = getMessage1(messageId, arg1);
		 return typeError(msg);
	 }
	 public static EcmaError typeError2(String messageId, String arg1, String arg2) {
		 String msg = getMessage2(messageId, arg1, arg2);
		 return typeError(msg);
	 }
	 public static EcmaError typeError3(String messageId, String arg1, String arg2, String arg3) {
		 String msg = getMessage3(messageId, arg1, arg2, arg3);
		 return typeError(msg);
	 }
	 public static RuntimeException undefReadError(Object object, Object id) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 return typeError2(""msg.undef.prop.read"", toString(object), idStr);
	 }
	 public static RuntimeException undefCallError(Object object, Object id) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 return typeError2(""msg.undef.method.call"", toString(object), idStr);
	 }
	 public static RuntimeException undefWriteError(Object object, Object id, Object value) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 String valueStr = (value instanceof Scriptable) ? value.toString() : toString(value);
		 return typeError3(""msg.undef.prop.write"", toString(object), idStr, valueStr);
	 }
	 public static RuntimeException notFoundError(Scriptable object, String property) {
		 String msg = getMessage1(""msg.is.not.defined"", property);
		 throw constructError(""ReferenceError"", msg);
	 }
	 public static RuntimeException notFunctionError(Object value) {
		 return notFunctionError(value, value);
	 }
	 public static RuntimeException notFunctionError(Object value, Object messageHelper) {
		 String msg = (messageHelper == null) ? ""null"" : messageHelper.toString();
		 if (value == Scriptable.NOT_FOUND) {
			 return typeError1(""msg.function.not.found"", msg);
		 }
		 return typeError2(""msg.isnt.function"", msg, value == null ? ""null"" : value.getClass().getName());
	 }
	 private static RuntimeException notXmlError(Object value) {
		 throw typeError1(""msg.isnt.xml.object"", ScriptRuntime.toString(value));
	 }
	 private static void warnAboutNonJSObject(Object nonJSObject) {
		 String message =""RHINO USAGE WARNING: Missed Context.javaToJS() conversion:\n""+""Rhino runtime detected object ""+nonJSObject+"" of class ""+nonJSObject.getClass().getName()+"" where it expected String, Number, Boolean or Scriptable instance. Please check your code for missing Context.javaToJS() call."";
		 Context.reportWarning(message);
		 System.err.println(message);
	 }
	 public static RegExpProxy getRegExpProxy(Context cx) {
		 return cx.getRegExpProxy();
	 }
	 public static void setRegExpProxy(Context cx, RegExpProxy proxy) {
		 if (proxy == null) throw new IllegalArgumentException();
		 cx.regExpProxy = proxy;
	 }
	 public static RegExpProxy checkRegExpProxy(Context cx) {
		 RegExpProxy result = getRegExpProxy(cx);
		 if (result == null) {
			 throw Context.reportRuntimeError0(""msg.no.regexp"");
		 }
		 return result;
	 }
	 private static XMLLib currentXMLLib(Context cx) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 XMLLib xmlLib = cx.cachedXMLLib;
		 if (xmlLib == null) {
			 xmlLib = XMLLib.extractFromScope(cx.topCallScope);
			 if (xmlLib == null) throw new IllegalStateException();
			 cx.cachedXMLLib = xmlLib;
		 }
		 return xmlLib;
	 }
	 public static String escapeAttributeValue(Object value, Context cx) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.escapeAttributeValue(value);
	 }
	 public static String escapeTextValue(Object value, Context cx) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.escapeTextValue(value);
	 }
	 public static Ref memberRef(Object obj, Object elem, Context cx, int memberTypeFlags) {
		 if (!(obj instanceof XMLObject)) {
			 throw notXmlError(obj);
		 }
		 XMLObject xmlObject = (XMLObject)obj;
		 return xmlObject.memberRef(cx, elem, memberTypeFlags);
	 }
	 public static Ref memberRef(Object obj, Object namespace, Object elem, Context cx, int memberTypeFlags) {
		 if (!(obj instanceof XMLObject)) {
			 throw notXmlError(obj);
		 }
		 XMLObject xmlObject = (XMLObject)obj;
		 return xmlObject.memberRef(cx, namespace, elem, memberTypeFlags);
	 }
	 public static Ref nameRef(Object name, Context cx, Scriptable scope, int memberTypeFlags) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.nameRef(cx, name, scope, memberTypeFlags);
	 }
	 public static Ref nameRef(Object namespace, Object name, Context cx, Scriptable scope, int memberTypeFlags) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.nameRef(cx, namespace, name, scope, memberTypeFlags);
	 }
	 private static void storeIndexResult(Context cx, int index) {
		 cx.scratchIndex = index;
	 }
	 static int lastIndexResult(Context cx) {
		 return cx.scratchIndex;
	 }
	 public static void storeUint32Result(Context cx, long value) {
		 if ((value >>> 32) != 0) throw new IllegalArgumentException();
		 cx.scratchUint32 = value;
	 }
	 public static long lastUint32Result(Context cx) {
		 long value = cx.scratchUint32;
		 if ((value >>> 32) != 0) throw new IllegalStateException();
		 return value;
	 }
	 private static void storeScriptable(Context cx, Scriptable value) {
		 if (cx.scratchScriptable != null) throw new IllegalStateException();
		 cx.scratchScriptable = value;
	 }
	 public static Scriptable lastStoredScriptable(Context cx) {
		 Scriptable result = cx.scratchScriptable;
		 cx.scratchScriptable = null;
		 return result;
	 }
	 static String makeUrlForGeneratedScript (boolean isEval, String masterScriptUrl, int masterScriptLine) {
		 if (isEval) {
			 return masterScriptUrl+'#'+masterScriptLine+""(eval)"";
		 }
		 else {
			 return masterScriptUrl+'#'+masterScriptLine+""(Function)"";
		 }
	 }
	 static boolean isGeneratedScript(String sourceUrl) {
		 return sourceUrl.indexOf(""(eval)"") >= 0 || sourceUrl.indexOf(""(Function)"") >= 0;
	 }
	 private static RuntimeException errorWithClassName(String msg, Object val) {
		 return Context.reportRuntimeError1(msg, val.getClass().getName());
	 }
	 public static final Object[] emptyArgs = new Object[0];
	 public static final String[] emptyStrings = new String[0];
}",1,0,0,0
"public List<String> describe_splits(String cfName, String start_token, String end_token, int keys_per_split) throws TException, InvalidRequestException {
	 Token.TokenFactory tf = StorageService.getPartitioner().getTokenFactory();
	 List<Token> tokens = StorageService.instance.getSplits(state().getKeyspace(), cfName, new Range<Token>(tf.fromString(start_token), tf.fromString(end_token)), keys_per_split);
	 List<String> splits = new ArrayList<String>(tokens.size());
	 for (Token token : tokens) {
		 splits.add(tf.toString(token));
	 }
	 return splits;
 }",0,0,0,0
"protected String formatTest(Test test) {
	 if (test == null) {
		 return ""Null Test: "";
	 }
	 else {
		 return ""Testcase: "" + test.toString() + "":"";
	 }
 }",0,0,0,0
"public class Ant extends Task {
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private File dir = null;
	 private String antFile = null;
	 private String output = null;
	 private boolean inheritAll = true;
	 private boolean inheritRefs = false;
	 private Vector properties = new Vector();
	 private Vector references = new Vector();
	 private Project newProject;
	 private PrintStream out = null;
	 private Vector propertySets = new Vector();
	 private Vector targets = new Vector();
	 private boolean targetAttributeSet = false;
	 private boolean useNativeBasedir = false;
	 public Ant() {
	 }
	 public Ant(Task owner) {
		 bindToOwner(owner);
	 }
	 public void setUseNativeBasedir(boolean b) {
		 useNativeBasedir = b;
	 }
	 public void setInheritAll(boolean value) {
		 inheritAll = value;
	 }
	 public void setInheritRefs(boolean value) {
		 inheritRefs = value;
	 }
	 public void init() {
		 newProject = getProject().createSubProject();
		 newProject.setJavaVersionProperty();
	 }
	 private void reinit() {
		 init();
	 }
	 private void initializeProject() {
		 newProject.setInputHandler(getProject().getInputHandler());
		 Iterator iter = getBuildListeners();
		 while (iter.hasNext()) {
			 newProject.addBuildListener((BuildListener) iter.next());
		 }
		 if (output != null) {
			 File outfile = null;
			 if (dir != null) {
				 outfile = FILE_UTILS.resolveFile(dir, output);
			 }
			 else {
				 outfile = getProject().resolveFile(output);
			 }
			 try {
				 out = new PrintStream(new FileOutputStream(outfile));
				 DefaultLogger logger = new DefaultLogger();
				 logger.setMessageOutputLevel(Project.MSG_INFO);
				 logger.setOutputPrintStream(out);
				 logger.setErrorPrintStream(out);
				 newProject.addBuildListener(logger);
			 }
			 catch (IOException ex) {
				 log(""Ant: Can't set output to "" + output);
			 }
		 }
		 if (useNativeBasedir) {
			 addAlmostAll(getProject().getUserProperties(), PropertyType.USER);
		 }
		 else {
			 getProject().copyUserProperties(newProject);
		 }
		 if (!inheritAll) {
			 newProject.initProperties();
		 }
		 else {
			 addAlmostAll(getProject().getProperties(), PropertyType.PLAIN);
		 }
		 Enumeration e = propertySets.elements();
		 while (e.hasMoreElements()) {
			 PropertySet ps = (PropertySet) e.nextElement();
			 addAlmostAll(ps.getProperties(), PropertyType.PLAIN);
		 }
	 }
	 public void handleOutput(String outputToHandle) {
		 if (newProject != null) {
			 newProject.demuxOutput(outputToHandle, false);
		 }
		 else {
			 super.handleOutput(outputToHandle);
		 }
	 }
	 public int handleInput(byte[] buffer, int offset, int length) throws IOException {
		 if (newProject != null) {
			 return newProject.demuxInput(buffer, offset, length);
		 }
		 return super.handleInput(buffer, offset, length);
	 }
	 public void handleFlush(String toFlush) {
		 if (newProject != null) {
			 newProject.demuxFlush(toFlush, false);
		 }
		 else {
			 super.handleFlush(toFlush);
		 }
	 }
	 public void handleErrorOutput(String errorOutputToHandle) {
		 if (newProject != null) {
			 newProject.demuxOutput(errorOutputToHandle, true);
		 }
		 else {
			 super.handleErrorOutput(errorOutputToHandle);
		 }
	 }
	 public void handleErrorFlush(String errorOutputToFlush) {
		 if (newProject != null) {
			 newProject.demuxFlush(errorOutputToFlush, true);
		 }
		 else {
			 super.handleErrorFlush(errorOutputToFlush);
		 }
	 }
	 public void execute() throws BuildException {
		 File savedDir = dir;
		 String savedAntFile = antFile;
		 Vector locals = new VectorSet(targets);
		 try {
			 getNewProject();
			 if (dir == null && inheritAll) {
				 dir = getProject().getBaseDir();
			 }
			 initializeProject();
			 if (dir != null) {
				 if (!useNativeBasedir) {
					 newProject.setBaseDir(dir);
					 if (savedDir != null) {
						 newProject.setInheritedProperty(MagicNames.PROJECT_BASEDIR, dir.getAbsolutePath());
					 }
				 }
			 }
			 else {
				 dir = getProject().getBaseDir();
			 }
			 overrideProperties();
			 if (antFile == null) {
				 antFile = getDefaultBuildFile();
			 }
			 File file = FILE_UTILS.resolveFile(dir, antFile);
			 antFile = file.getAbsolutePath();
			 log(""calling target(s) "" + ((locals.size() > 0) ? locals.toString() : ""[default]"") + "" in build file "" + antFile, Project.MSG_VERBOSE);
			 newProject.setUserProperty(MagicNames.ANT_FILE , antFile);
			 String thisAntFile = getProject().getProperty(MagicNames.ANT_FILE);
			 if (thisAntFile != null && file.equals(getProject().resolveFile(thisAntFile)) && getOwningTarget() != null) {
				 if (getOwningTarget().getName().equals("""")) {
					 if (getTaskName().equals(""antcall"")) {
						 throw new BuildException(""antcall must not be used at"" + "" the top level."");
					 }
					 throw new BuildException(getTaskName() + "" task at the"" + "" top level must not invoke"" + "" its own build file."");
				 }
			 }
			 try {
				 ProjectHelper.configureProject(newProject, file);
			 }
			 catch (BuildException ex) {
				 throw ProjectHelper.addLocationToBuildException( ex, getLocation());
			 }
			 if (locals.size() == 0) {
				 String defaultTarget = newProject.getDefaultTarget();
				 if (defaultTarget != null) {
					 locals.add(defaultTarget);
				 }
			 }
			 if (newProject.getProperty(MagicNames.ANT_FILE) .equals(getProject().getProperty(MagicNames.ANT_FILE)) && getOwningTarget() != null) {
				 String owningTargetName = getOwningTarget().getName();
				 if (locals.contains(owningTargetName)) {
					 throw new BuildException(getTaskName() + "" task calling "" + ""its own parent target."");
				 }
				 boolean circular = false;
				 for (Iterator it = locals.iterator();
				 !circular && it.hasNext();
				) {
					 Target other = (Target) (getProject().getTargets().get(it.next()));
					 circular |= (other != null && other.dependsOn(owningTargetName));
				 }
				 if (circular) {
					 throw new BuildException(getTaskName() + "" task calling a target"" + "" that depends on"" + "" its parent target \'"" + owningTargetName + ""\'."");
				 }
			 }
			 addReferences();
			 if (locals.size() > 0 && !(locals.size() == 1 && """".equals(locals.get(0)))) {
				 BuildException be = null;
				 try {
					 log(""Entering "" + antFile + ""..."", Project.MSG_VERBOSE);
					 newProject.fireSubBuildStarted();
					 newProject.executeTargets(locals);
				 }
				 catch (BuildException ex) {
					 be = ProjectHelper .addLocationToBuildException(ex, getLocation());
					 throw be;
				 }
				 finally {
					 log(""Exiting "" + antFile + ""."", Project.MSG_VERBOSE);
					 newProject.fireSubBuildFinished(be);
				 }
			 }
		 }
		 finally {
			 newProject = null;
			 Enumeration e = properties.elements();
			 while (e.hasMoreElements()) {
				 Property p = (Property) e.nextElement();
				 p.setProject(null);
			 }
			 if (output != null && out != null) {
				 try {
					 out.close();
				 }
				 catch (final Exception ex) {
				 }
			 }
			 dir = savedDir;
			 antFile = savedAntFile;
		 }
	 }
	 protected String getDefaultBuildFile() {
		 return Main.DEFAULT_BUILD_FILENAME;
	 }
	 private void overrideProperties() throws BuildException {
		 Set set = new HashSet();
		 for (int i = properties.size() - 1;
		 i >= 0;
		 --i) {
			 Property p = (Property) properties.get(i);
			 if (p.getName() != null && !p.getName().equals("""")) {
				 if (set.contains(p.getName())) {
					 properties.remove(i);
				 }
				 else {
					 set.add(p.getName());
				 }
			 }
		 }
		 Enumeration e = properties.elements();
		 while (e.hasMoreElements()) {
			 Property p = (Property) e.nextElement();
			 p.setProject(newProject);
			 p.execute();
		 }
		 if (useNativeBasedir) {
			 addAlmostAll(getProject().getInheritedProperties(), PropertyType.INHERITED);
		 }
		 else {
			 getProject().copyInheritedProperties(newProject);
		 }
	 }
	 private void addReferences() throws BuildException {
		 Hashtable thisReferences = (Hashtable) getProject().getReferences().clone();
		 Hashtable newReferences = newProject.getReferences();
		 Enumeration e;
		 if (references.size() > 0) {
			 for (e = references.elements();
			 e.hasMoreElements();
			) {
				 Reference ref = (Reference) e.nextElement();
				 String refid = ref.getRefId();
				 if (refid == null) {
					 throw new BuildException(""the refid attribute is required"" + "" for reference elements"");
				 }
				 if (!thisReferences.containsKey(refid)) {
					 log(""Parent project doesn't contain any reference '"" + refid + ""'"", Project.MSG_WARN);
					 continue;
				 }
				 thisReferences.remove(refid);
				 String toRefid = ref.getToRefid();
				 if (toRefid == null) {
					 toRefid = refid;
				 }
				 copyReference(refid, toRefid);
			 }
		 }
		 if (inheritRefs) {
			 for (e = thisReferences.keys();
			 e.hasMoreElements();
			) {
				 String key = (String) e.nextElement();
				 if (newReferences.containsKey(key)) {
					 continue;
				 }
				 copyReference(key, key);
				 newProject.inheritIDReferences(getProject());
			 }
		 }
	 }
	 private void copyReference(String oldKey, String newKey) {
		 Object orig = getProject().getReference(oldKey);
		 if (orig == null) {
			 log(""No object referenced by "" + oldKey + "". Can't copy to "" + newKey, Project.MSG_WARN);
			 return;
		 }
		 Class c = orig.getClass();
		 Object copy = orig;
		 try {
			 Method cloneM = c.getMethod(""clone"", new Class[0]);
			 if (cloneM != null) {
				 copy = cloneM.invoke(orig, new Object[0]);
				 log(""Adding clone of reference "" + oldKey, Project.MSG_DEBUG);
			 }
		 }
		 catch (Exception e) {
		 }
		 if (copy instanceof ProjectComponent) {
			 ((ProjectComponent) copy).setProject(newProject);
		 }
		 else {
			 try {
				 Method setProjectM = c.getMethod(""setProject"", new Class[] {
				Project.class}
				);
				 if (setProjectM != null) {
					 setProjectM.invoke(copy, new Object[] {
					newProject}
					);
				 }
			 }
			 catch (NoSuchMethodException e) {
			 }
			 catch (Exception e2) {
				 String msg = ""Error setting new project instance for "" + ""reference with id "" + oldKey;
				 throw new BuildException(msg, e2, getLocation());
			 }
		 }
		 newProject.addReference(newKey, copy);
	 }
	 private void addAlmostAll(Hashtable props, PropertyType type) {
		 Enumeration e = props.keys();
		 while (e.hasMoreElements()) {
			 String key = e.nextElement().toString();
			 if (MagicNames.PROJECT_BASEDIR.equals(key) || MagicNames.ANT_FILE.equals(key)) {
				 continue;
			 }
			 String value = props.get(key).toString();
			 if (type == PropertyType.PLAIN) {
				 if (newProject.getProperty(key) == null) {
					 newProject.setNewProperty(key, value);
				 }
			 }
			 else if (type == PropertyType.USER) {
				 newProject.setUserProperty(key, value);
			 }
			 else if (type == PropertyType.INHERITED) {
				 newProject.setInheritedProperty(key, value);
			 }
		 }
	 }
	 public void setDir(File dir) {
		 this.dir = dir;
	 }
	 public void setAntfile(String antFile) {
		 this.antFile = antFile;
	 }
	 public void setTarget(String targetToAdd) {
		 if (targetToAdd.equals("""")) {
			 throw new BuildException(""target attribute must not be empty"");
		 }
		 targets.add(targetToAdd);
		 targetAttributeSet = true;
	 }
	 public void setOutput(String outputFile) {
		 this.output = outputFile;
	 }
	 public Property createProperty() {
		 Property p = new Property(true, getProject());
		 p.setProject(getNewProject());
		 p.setTaskName(""property"");
		 properties.addElement(p);
		 return p;
	 }
	 public void addReference(Reference ref) {
		 references.addElement(ref);
	 }
	 public void addConfiguredTarget(TargetElement t) {
		 if (targetAttributeSet) {
			 throw new BuildException( ""nested target is incompatible with the target attribute"");
		 }
		 String name = t.getName();
		 if (name.equals("""")) {
			 throw new BuildException(""target name must not be empty"");
		 }
		 targets.add(name);
	 }
	 public void addPropertyset(PropertySet ps) {
		 propertySets.addElement(ps);
	 }
	 protected Project getNewProject() {
		 if (newProject == null) {
			 reinit();
		 }
		 return newProject;
	 }
	 private Iterator getBuildListeners() {
		 return getProject().getBuildListeners().iterator();
	 }
	 public static class Reference extends org.apache.tools.ant.types.Reference {
		 public Reference() {
			 super();
		 }
		 private String targetid = null;
		 public void setToRefid(String targetid) {
			 this.targetid = targetid;
		 }
		 public String getToRefid() {
			 return targetid;
		 }
	 }
	 public static class TargetElement {
		 private String name;
		 public TargetElement() {
		 }
		 public void setName(String name) {
			 this.name = name;
		 }
		 public String getName() {
			 return name;
		 }
	 }
	 private static final class PropertyType {
		 private PropertyType() {
		}
		 private static final PropertyType PLAIN = new PropertyType();
		 private static final PropertyType INHERITED = new PropertyType();
		 private static final PropertyType USER = new PropertyType();
	 }
}",0,0,0,0
"public class SwitchEmitter extends JSSubEmitter implements ISubEmitter<ISwitchNode>{
	 public SwitchEmitter(IJSEmitter emitter) {
		 super(emitter);
	 }
	 public void emit(ISwitchNode node) {
		 startMapping(node);
		 writeToken(ASEmitterTokens.SWITCH);
		 write(ASEmitterTokens.PAREN_OPEN);
		 endMapping(node);
		 IASNode expressionNode = node.getChild(0);
		 getWalker().walk(expressionNode);
		 startMapping(node, expressionNode);
		 writeToken(ASEmitterTokens.PAREN_CLOSE);
		 endMapping(node);
		 IASNode statementContentsNode = node.getStatementContentsNode();
		 startMapping(statementContentsNode);
		 write(ASEmitterTokens.BLOCK_OPEN);
		 endMapping(statementContentsNode);
		 indentPush();
		 writeNewline();
		 IConditionalNode[] cnodes = ASNodeUtils.getCaseNodes(node);
		 ITerminalNode dnode = ASNodeUtils.getDefaultNode(node);
		 for (int i = 0;
		 i < cnodes.length;
		 i++) {
			 IConditionalNode casen = cnodes[i];
			 IContainerNode cnode = (IContainerNode) casen.getChild(1);
			 startMapping(casen);
			 writeToken(ASEmitterTokens.CASE);
			 endMapping(casen);
			 IExpressionNode conditionalExpressionNode = casen.getConditionalExpressionNode();
			 getWalker().walk(conditionalExpressionNode);
			 startMapping(casen, conditionalExpressionNode);
			 write(ASEmitterTokens.COLON);
			 if (!EmitterUtils.isImplicit(cnode)) write(ASEmitterTokens.SPACE);
			 endMapping(casen);
			 getWalker().walk(casen.getStatementContentsNode());
			 if (i == cnodes.length - 1 && dnode == null) {
				 indentPop();
				 writeNewline();
			 }
			 else writeNewline();
		 }
		 if (dnode != null) {
			 IContainerNode cnode = (IContainerNode) dnode.getChild(0);
			 startMapping(dnode);
			 write(ASEmitterTokens.DEFAULT);
			 write(ASEmitterTokens.COLON);
			 if (!EmitterUtils.isImplicit(cnode)) write(ASEmitterTokens.SPACE);
			 endMapping(dnode);
			 getWalker().walk(dnode);
			 indentPop();
			 writeNewline();
		 }
		 startMapping(node, node.getEndLine(), node.getEndColumn() - 1);
		 write(ASEmitterTokens.BLOCK_CLOSE);
		 endMapping(node);
	 }
}",0,0,0,0
"public CODE<T> $class(String value) {
	 addAttr(""class"", value);
	 return this;
 }",0,0,0,0
"public void configure(JobConf job) {
	 retryMax = job.getInt(""db.fetch.retry.max"", 3);
	 scfilters = new ScoringFilters(job);
	 additionsAllowed = job.getBoolean(CrawlDb.CRAWLDB_ADDITIONS_ALLOWED, true);
	 int oldMaxInterval = job.getInt(""db.max.fetch.interval"", 0);
	 maxInterval = job.getInt(""db.fetch.interval.max"", 0 );
	 if (oldMaxInterval > 0 && maxInterval == 0) maxInterval = oldMaxInterval * FetchSchedule.SECONDS_PER_DAY;
	 schedule = FetchScheduleFactory.getFetchSchedule(job);
	 int maxLinks = job.getInt(""db.update.max.inlinks"", 10000);
	 linked = new InlinkPriorityQueue(maxLinks);
 }",0,0,0,0
"public class FilterParams {
	 private final Collection<TargetUpdateStatus> filterByStatus;
	 private final Boolean overdueState;
	 private final String filterBySearchText;
	 private final Boolean selectTargetWithNoTag;
	 private final String[] filterByTagNames;
	 private final Long filterByDistributionId;
	 public FilterParams(final Collection<TargetUpdateStatus> filterByStatus, final Boolean overdueState, final String filterBySearchText, final Long filterByInstalledOrAssignedDistributionSetId, final Boolean selectTargetWithNoTag, final String... filterByTagNames) {
		 this.filterByStatus = filterByStatus;
		 this.overdueState = overdueState;
		 this.filterBySearchText = filterBySearchText;
		 this.filterByDistributionId = filterByInstalledOrAssignedDistributionSetId;
		 this.selectTargetWithNoTag = selectTargetWithNoTag;
		 this.filterByTagNames = filterByTagNames;
	 }
	 public Long getFilterByDistributionId() {
		 return filterByDistributionId;
	 }
	 public Collection<TargetUpdateStatus> getFilterByStatus() {
		 return filterByStatus;
	 }
	 public Boolean getOverdueState() {
		 return overdueState;
	 }
	 public String getFilterBySearchText() {
		 return filterBySearchText;
	 }
	 public Boolean getSelectTargetWithNoTag() {
		 return selectTargetWithNoTag;
	 }
	 public String[] getFilterByTagNames() {
		 return filterByTagNames;
	 }
}",0,1,0,0
"public class RecoveryInProgressException extends IOException {
	 private static final long serialVersionUID = 1L;
	 public RecoveryInProgressException(String msg) {
		 super(msg);
	 }
}",0,0,0,0
"public abstract class Definer extends DefBase {
	 private static final String ANTLIB_XML = ""/antlib.xml"";
	 private static class ResourceStack extends ThreadLocal {
		 public Object initialValue() {
			 return new HashMap();
		 }
		 Map getStack() {
			 return (Map) get();
		 }
	 }
	 private static ResourceStack resourceStack = new ResourceStack();
	 private String name;
	 private String classname;
	 private File file;
	 private String resource;
	 private int format = Format.PROPERTIES;
	 private boolean definerSet = false;
	 private int onError = OnError.FAIL;
	 private String adapter;
	 private String adaptTo;
	 private Class adapterClass;
	 private Class adaptToClass;
	 public static class OnError extends EnumeratedAttribute {
		 public static final int FAIL = 0, REPORT = 1, IGNORE = 2, FAIL_ALL = 3;
		 public static final String POLICY_FAIL = ""fail"";
		 public static final String POLICY_REPORT = ""report"";
		 public static final String POLICY_IGNORE = ""ignore"";
		 public static final String POLICY_FAILALL = ""failall"";
		 public OnError() {
			 super();
		 }
		 public OnError(String value) {
			 setValue(value);
		 }
		 public String[] getValues() {
			 return new String[] {
			POLICY_FAIL, POLICY_REPORT, POLICY_IGNORE, POLICY_FAILALL}
			;
		 }
	 }
	 public static class Format extends EnumeratedAttribute {
		 public static final int PROPERTIES = 0, XML = 1;
		 public String[] getValues() {
			 return new String[] {
			""properties"", ""xml""}
			;
		 }
	 }
	 public void setOnError(OnError onError) {
		 this.onError = onError.getIndex();
	 }
	 public void setFormat(Format format) {
		 this.format = format.getIndex();
	 }
	 public String getName() {
		 return name;
	 }
	 public File getFile() {
		 return file;
	 }
	 public String getResource() {
		 return resource;
	 }
	 public void execute() throws BuildException {
		 ClassLoader al = createLoader();
		 if (!definerSet) {
			 if (getURI() == null) {
				 throw new BuildException( ""name, file or resource attribute of "" + getTaskName() + "" is undefined"", getLocation());
			 }
			 if (getURI().startsWith(MagicNames.ANTLIB_PREFIX)) {
				 String uri1 = getURI();
				 setResource(makeResourceFromURI(uri1));
			 }
			 else {
				 throw new BuildException( ""Only antlib URIs can be located from the URI alone,"" + ""not the URI "" + getURI());
			 }
		 }
		 if (name != null) {
			 if (classname == null) {
				 throw new BuildException( ""classname attribute of "" + getTaskName() + "" element "" + ""is undefined"", getLocation());
			 }
			 addDefinition(al, name, classname);
		 }
		 else {
			 if (classname != null) {
				 String msg = ""You must not specify classname "" + ""together with file or resource."";
				 throw new BuildException(msg, getLocation());
			 }
			 Enumeration urls = null;
			 if (file != null) {
				 final URL url = fileToURL();
				 if (url == null) {
					 return;
				 }
				 urls = new Enumeration() {
					 private boolean more = true;
					 public boolean hasMoreElements() {
						 return more;
					 }
					 public Object nextElement() throws NoSuchElementException {
						 if (more) {
							 more = false;
							 return url;
						 }
						 else {
							 throw new NoSuchElementException();
						 }
					 }
				 }
				;
			 }
			 else {
				 urls = resourceToURLs(al);
			 }
			 while (urls.hasMoreElements()) {
				 URL url = (URL) urls.nextElement();
				 int fmt = this.format;
				 if (url.toString().toLowerCase(Locale.US).endsWith("".xml"")) {
					 fmt = Format.XML;
				 }
				 if (fmt == Format.PROPERTIES) {
					 loadProperties(al, url);
					 break;
				 }
				 else {
					 if (resourceStack.getStack().get(url) != null) {
						 log(""Warning: Recursive loading of "" + url + "" ignored"" + "" at "" + getLocation() + "" originally loaded at "" + resourceStack.getStack().get(url), Project.MSG_WARN);
					 }
					 else {
						 try {
							 resourceStack.getStack().put(url, getLocation());
							 loadAntlib(al, url);
						 }
						 finally {
							 resourceStack.getStack().remove(url);
						 }
					 }
				 }
			 }
		 }
	 }
	 public static String makeResourceFromURI(String uri) {
		 String path = uri.substring(MagicNames.ANTLIB_PREFIX.length());
		 String resource;
		 if (path.startsWith("" resource = path.substring("" if (!resource.endsWith("".xml"")) {
			 resource = resource + ANTLIB_XML;
		 }
	 }
	 else {
		 resource = path.replace('.', '/') + ANTLIB_XML;
	 }
	 return resource;
 }
 private URL fileToURL() {
	 String message = null;
	 if (!(file.exists())) {
		 message = ""File "" + file + "" does not exist"";
	 }
	 if (message == null && !(file.isFile())) {
		 message = ""File "" + file + "" is not a file"";
	 }
	 try {
		 if (message == null) {
			 return file.toURL();
		 }
	 }
	 catch (Exception ex) {
		 message = ""File "" + file + "" cannot use as URL: "" + ex.toString();
	 }
	 switch (onError) {
		 case OnError.FAIL_ALL: throw new BuildException(message);
		 case OnError.FAIL: case OnError.REPORT: log(message, Project.MSG_WARN);
		 break;
		 case OnError.IGNORE: log(message, Project.MSG_VERBOSE);
		 break;
		 default: break;
	 }
	 return null;
 }
 private Enumeration resourceToURLs(ClassLoader classLoader) {
	 Enumeration ret;
	 try {
		 ret = classLoader.getResources(resource);
	 }
	 catch (IOException e) {
		 throw new BuildException( ""Could not fetch resources named "" + resource, e, getLocation());
	 }
	 if (!ret.hasMoreElements()) {
		 String message = ""Could not load definitions from resource "" + resource + "". It could not be found."";
		 switch (onError) {
			 case OnError.FAIL_ALL: throw new BuildException(message);
			 case OnError.FAIL: case OnError.REPORT: log(message, Project.MSG_WARN);
			 break;
			 case OnError.IGNORE: log(message, Project.MSG_VERBOSE);
			 break;
			 default: break;
		 }
	 }
	 return ret;
 }
 protected void loadProperties(ClassLoader al, URL url) {
	 InputStream is = null;
	 try {
		 is = url.openStream();
		 if (is == null) {
			 log(""Could not load definitions from "" + url, Project.MSG_WARN);
			 return;
		 }
		 Properties props = new Properties();
		 props.load(is);
		 Enumeration keys = props.keys();
		 while (keys.hasMoreElements()) {
			 name = ((String) keys.nextElement());
			 classname = props.getProperty(name);
			 addDefinition(al, name, classname);
		 }
	 }
	 catch (IOException ex) {
		 throw new BuildException(ex, getLocation());
	 }
	 finally {
		 FileUtils.close(is);
	 }
 }
 private void loadAntlib(ClassLoader classLoader, URL url) {
	 try {
		 Antlib antlib = Antlib.createAntlib(getProject(), url, getURI());
		 antlib.setClassLoader(classLoader);
		 antlib.setURI(getURI());
		 antlib.execute();
	 }
	 catch (BuildException ex) {
		 throw ProjectHelper.addLocationToBuildException( ex, getLocation());
	 }
 }
 public void setFile(File file) {
	 if (definerSet) {
		 tooManyDefinitions();
	 }
	 definerSet = true;
	 this.file = file;
 }
 public void setResource(String res) {
	 if (definerSet) {
		 tooManyDefinitions();
	 }
	 definerSet = true;
	 this.resource = res;
 }
 public void setAntlib(String antlib) {
	 if (definerSet) {
		 tooManyDefinitions();
	 }
	 if (!antlib.startsWith(""antlib:"")) {
		 throw new BuildException( ""Invalid antlib attribute - it must start with antlib:"");
	 }
	 setURI(antlib);
	 this.resource = antlib.substring(""antlib:"".length()).replace('.', '/') + ""/antlib.xml"";
	 definerSet = true;
 }
 public void setName(String name) {
	 if (definerSet) {
		 tooManyDefinitions();
	 }
	 definerSet = true;
	 this.name = name;
 }
 public String getClassname() {
	 return classname;
 }
 public void setClassname(String classname) {
	 this.classname = classname;
 }
 public void setAdapter(String adapter) {
	 this.adapter = adapter;
 }
 protected void setAdapterClass(Class adapterClass) {
	 this.adapterClass = adapterClass;
 }
 public void setAdaptTo(String adaptTo) {
	 this.adaptTo = adaptTo;
 }
 protected void setAdaptToClass(Class adaptToClass) {
	 this.adaptToClass = adaptToClass;
 }
 protected void addDefinition(ClassLoader al, String name, String classname) throws BuildException {
	 Class cl = null;
	 try {
		 try {
			 name = ProjectHelper.genComponentName(getURI(), name);
			 if (onError != OnError.IGNORE) {
				 cl = Class.forName(classname, true, al);
			 }
			 if (adapter != null) {
				 adapterClass = Class.forName(adapter, true, al);
			 }
			 if (adaptTo != null) {
				 adaptToClass = Class.forName(adaptTo, true, al);
			 }
			 AntTypeDefinition def = new AntTypeDefinition();
			 def.setName(name);
			 def.setClassName(classname);
			 def.setClass(cl);
			 def.setAdapterClass(adapterClass);
			 def.setAdaptToClass(adaptToClass);
			 def.setClassLoader(al);
			 if (cl != null) {
				 def.checkClass(getProject());
			 }
			 ComponentHelper.getComponentHelper(getProject()) .addDataTypeDefinition(def);
		 }
		 catch (ClassNotFoundException cnfe) {
			 String msg = getTaskName() + "" class "" + classname + "" cannot be found"";
			 throw new BuildException(msg, cnfe, getLocation());
		 }
		 catch (NoClassDefFoundError ncdfe) {
			 String msg = getTaskName() + "" A class needed by class "" + classname + "" cannot be found: "" + ncdfe.getMessage();
			 throw new BuildException(msg, ncdfe, getLocation());
		 }
	 }
	 catch (BuildException ex) {
		 switch (onError) {
			 case OnError.FAIL_ALL: case OnError.FAIL: throw ex;
			 case OnError.REPORT: log(ex.getLocation() + ""Warning: "" + ex.getMessage(), Project.MSG_WARN);
			 break;
			 default: log(ex.getLocation() + ex.getMessage(), Project.MSG_DEBUG);
		 }
	 }
 }
 private void tooManyDefinitions() {
	 throw new BuildException( ""Only one of the attributes name, file and resource"" + "" can be set"", getLocation());
 }
}",0,0,0,0
"public class OrderedJUnit4Runner extends BlockJUnit4ClassRunner {
	 public TestOrder {
		 String[] value();
	 }
	 private String testClassName;
	 private String[] orderedTestMethods;
	 private List<FrameworkMethod> methodsCustomOrder;
	 public OrderedJUnit4Runner(Class<?> klass) throws InitializationError {
		 super(klass);
		 TestOrder testOrder = klass.getAnnotation(TestOrder.class);
		 if (testOrder != null) {
			 orderedTestMethods = testOrder.value();
		 }
		 this.testClassName = klass.getName();
	 }
	 protected List<FrameworkMethod> computeTestMethods() {
		 List<FrameworkMethod> methodsReflectionOrder = super .computeTestMethods();
		 if (orderedTestMethods == null || orderedTestMethods.length == 0) {
			 return methodsReflectionOrder;
		 }
		 else {
			 if (methodsCustomOrder == null) {
				 Set<String> uniqueMethods = new HashSet<String>();
				 Collections.addAll(uniqueMethods, orderedTestMethods);
				 if (uniqueMethods.size() != orderedTestMethods.length) {
					 throw new IllegalArgumentException( ""The TestOrder annotation in "" + testClassName + "" has duplicate test method names"");
				 }
				 methodsCustomOrder = new ArrayList<FrameworkMethod>();
				 for (String method : orderedTestMethods) {
					 for (FrameworkMethod fMethod : methodsReflectionOrder) {
						 if (fMethod.getName().equals(method)) {
							 methodsCustomOrder.add(fMethod);
							 break;
						 }
					 }
				 }
				 methodsReflectionOrder.removeAll(methodsCustomOrder);
				 if (methodsReflectionOrder.size() > 0) {
					 String tests = """";
					 for (FrameworkMethod fMethod : methodsReflectionOrder) {
						 tests = tests + fMethod.getName();
					 }
					 throw new IllegalArgumentException( ""The TestOrder annotation in "" + testClassName + "" does not include the following tests which have : "" + tests);
				 }
			 }
			 return methodsCustomOrder;
		 }
	 }
}",1,0,0,0
"public void toSchema(RowMutation rm, String cfName, AbstractType<T> comparator, long timestamp) {
	 ColumnFamily cf = rm.addOrGet(SystemTable.SCHEMA_COLUMNS_CF);
	 int ldt = (int) (System.currentTimeMillis() / 1000);
	 cf.addColumn(Column.create(validator.toString(), timestamp, cfName, comparator.getString(name), ""validator""));
	 cf.addColumn(index_type == null ? DeletedColumn.create(ldt, timestamp, cfName, comparator.getString(name), ""index_type"") : Column.create(index_type.toString(), timestamp, cfName, comparator.getString(name), ""index_type""));
	 cf.addColumn(index_options == null ? DeletedColumn.create(ldt, timestamp, cfName, comparator.getString(name), ""index_options"") : Column.create(json(index_options), timestamp, cfName, comparator.getString(name), ""index_options""));
	 cf.addColumn(index_name == null ? DeletedColumn.create(ldt, timestamp, cfName, comparator.getString(name), ""index_name"") : Column.create(index_name, timestamp, cfName, comparator.getString(name), ""index_name""));
	 cf.addColumn(componentIndex == null ? DeletedColumn.create(ldt, timestamp, cfName, comparator.getString(name), ""component_index"") : Column.create(componentIndex, timestamp, cfName, comparator.getString(name), ""component_index""));
 }",0,0,0,0
"protected void setup() throws IOException {
	 logger.info(""JVM vendor/version: {
	}
	/{
	}
	"", System.getProperty(""java.vm.name""), System.getProperty(""java.version"") );
	 logger.info(""Heap size: {
	}
	/{
	}
	"", Runtime.getRuntime().totalMemory(), Runtime.getRuntime().maxMemory());
	 logger.info(""Classpath: {
	}
	"", System.getProperty(""java.class.path""));
	 CLibrary.tryMlockall();
	 listenPort = DatabaseDescriptor.getRpcPort();
	 listenAddr = DatabaseDescriptor.getRpcAddress();
	 Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
		 public void uncaughtException(Thread t, Throwable e) {
			 exceptions.incrementAndGet();
			 logger.error(""Exception in thread "" + t, e);
			 for (Throwable e2 = e;
			 e2 != null;
			 e2 = e2.getCause()) {
				 if (e2 instanceof OutOfMemoryError) System.exit(100);
			 }
		 }
	 }
	);
	 Iterable<String> dirs = Iterables.concat(Arrays.asList(DatabaseDescriptor.getAllDataFileLocations()), Arrays.asList(new String[] {
	DatabaseDescriptor.getCommitLogLocation(), DatabaseDescriptor.getSavedCachesLocation()}
	));
	 for (String dataDir : dirs) {
		 logger.debug(""Checking directory {
		}
		"", dataDir);
		 File dir = new File(dataDir);
		 if (dir.exists()) assert dir.isDirectory() && dir.canRead() && dir.canWrite() && dir.canExecute() : String.format(""Directory %s is not accessible."", dataDir);
	 }
	 if (Directories.sstablesNeedsMigration()) Directories.migrateSSTables();
	 if (CacheService.instance == null) throw new RuntimeException(""Failed to initialize Cache Service."");
	 for (CFMetaData cfm : Schema.instance.getTableMetaData(Table.SYSTEM_TABLE).values()) ColumnFamilyStore.scrubDataDirectories(Table.SYSTEM_TABLE, cfm.cfName);
	 try {
		 SystemTable.checkHealth();
	 }
	 catch (ConfigurationException e) {
		 logger.error(""Fatal exception during initialization"", e);
		 System.exit(100);
	 }
	 try {
		 DatabaseDescriptor.loadSchemas();
	 }
	 catch (IOException e) {
		 logger.error(""Fatal exception during initialization"", e);
		 System.exit(100);
	 }
	 for (String table : Schema.instance.getTables()) {
		 for (CFMetaData cfm : Schema.instance.getTableMetaData(table).values()) {
			 ColumnFamilyStore.scrubDataDirectories(table, cfm.cfName);
		 }
	 }
	 for (String table : Schema.instance.getTables()) {
		 if (logger.isDebugEnabled()) logger.debug(""opening keyspace "" + table);
		 Table.open(table);
	 }
	 if (CacheService.instance.keyCache.size() > 0) logger.info(""completed pre-loading ({
	}
	 keys) key cache."", CacheService.instance.keyCache.size());
	 if (CacheService.instance.rowCache.size() > 0) logger.info(""completed pre-loading ({
	}
	 keys) row cache."", CacheService.instance.rowCache.size());
	 try {
		 GCInspector.instance.start();
	 }
	 catch (Throwable t) {
		 logger.warn(""Unable to start GCInspector (currently only supported on the Sun JVM)"");
	 }
	 CommitLog.instance.recover();
	 SystemTable.finishStartup();
	 StorageService.instance.registerDaemon(this);
	 try {
		 StorageService.instance.initServer();
	 }
	 catch (ConfigurationException e) {
		 logger.error(""Fatal configuration error"", e);
		 System.err.println(e.getMessage() + ""\nFatal configuration error;
		 unable to start server. See log for stacktrace."");
		 System.exit(1);
	 }
	 Mx4jTool.maybeLoad();
 }",0,0,1,0
"protected static class MultiEnumeration<T> implements Enumeration<T> {
	 private final Enumeration<T>[] e;
	 public MultiEnumeration(Enumeration<T>[] lists) {
		 e = lists;
	 }
	 public boolean hasMoreElements() {
		 for ( int i=0;
		 i<e.length;
		 i++ ) {
			 if ( e[i].hasMoreElements() ) return true;
		 }
		 return false;
	 }
	 public T nextElement() {
		 for ( int i=0;
		 i<e.length;
		 i++ ) {
			 if ( e[i].hasMoreElements() ) return e[i].nextElement();
		 }
		 return null;
	 }
 }",0,0,0,0
"public class NamedField extends Field {
	 final MajorType keyType;
	 String fieldName;
	 public NamedField(RecordSchema parentSchema, String prefixFieldName, String fieldName, MajorType fieldType) {
		 this(parentSchema, prefixFieldName, fieldName, fieldType, JacksonHelper.STRING_TYPE);
	 }
	 public NamedField(RecordSchema parentSchema, String prefixFieldName, String fieldName, MajorType fieldType, MajorType keyType) {
		 super(parentSchema, fieldType, prefixFieldName);
		 this.fieldName = fieldName;
		 this.keyType = keyType;
	 }
	 public String getFieldName() {
		 return fieldName;
	 }
	 protected MoreObjects.ToStringHelper addAttributesToHelper(MoreObjects.ToStringHelper helper) {
		 return helper.add(""keyType"", keyType);
	 }
}",0,0,0,0
"public class AttList implements Attributes{
	 NamedNodeMap m_attrs;
	 int m_lastIndex;
	 DOMHelper m_dh;
	 public AttList(NamedNodeMap attrs, DOMHelper dh) {
		 m_attrs = attrs;
		 m_lastIndex = m_attrs.getLength() - 1;
		 m_dh = dh;
	 }
	 public int getLength() {
		 return m_attrs.getLength();
	 }
	 public String getURI(int index) {
		 String ns = m_dh.getNamespaceOfNode(((Attr) m_attrs.item(index)));
		 if(null == ns) ns = """";
		 return ns;
	 }
	 public String getLocalName(int index) {
		 return m_dh.getLocalNameOfNode(((Attr) m_attrs.item(index)));
	 }
	 public String getQName(int i) {
		 return ((Attr) m_attrs.item(i)).getName();
	 }
	 public String getType(int i) {
		 return ""CDATA"";
	 }
	 public String getValue(int i) {
		 return ((Attr) m_attrs.item(i)).getValue();
	 }
	 public String getType(String name) {
		 return ""CDATA"";
	 }
	 public String getType(String uri, String localName) {
		 return ""CDATA"";
	 }
	 public String getValue(String name) {
		 Attr attr = ((Attr) m_attrs.getNamedItem(name));
		 return (null != attr) ? attr.getValue() : null;
	 }
	 public String getValue(String uri, String localName) {
		Node a=m_attrs.getNamedItemNS(uri,localName);
		return (a==null) ? null : a.getNodeValue();
	 }
	 public int getIndex(String uri, String localPart) {
		 for(int i=m_attrs.getLength()-1;
		i>=0;
		--i) {
			 Node a=m_attrs.item(i);
			 String u=a.getNamespaceURI();
			 if( (u==null ? uri==null : u.equals(uri)) && a.getLocalName().equals(localPart) )return i;
		 }
		 return -1;
	 }
	 public int getIndex(String qName) {
		 for(int i=m_attrs.getLength()-1;
		i>=0;
		--i) {
			 Node a=m_attrs.item(i);
			 if(a.getNodeName().equals(qName) )return i;
		 }
		 return -1;
	 }
}",0,0,0,0
"public class Customer223 {
	 private long id;
	private String firstName;
	private String lastName;
	protected Customer223() {
	}
	public Customer223(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	public String toString() {
		return String.format(""Customer223[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}
}",0,1,0,0
"public static class MetaColumn implements Named {
	 public final String tableCat;
	 public final String tableSchem;
	 public final String tableName;
	 public final String columnName;
	 public final int dataType;
	 public final String typeName;
	 public final Integer columnSize;
	 public final Integer bufferLength = null;
	 public final Integer decimalDigits;
	 public final Integer numPrecRadix;
	 public final int nullable;
	 public final String remarks = null;
	 public final String columnDef = null;
	 public final Integer sqlDataType = null;
	 public final Integer sqlDatetimeSub = null;
	 public final Integer charOctetLength;
	 public final int ordinalPosition;
	 public final String isNullable;
	 public final String scopeCatalog = null;
	 public final String scopeSchema = null;
	 public final String scopeTable = null;
	 public final Short sourceDataType = null;
	 public final String isAutoincrement = """";
	 public final String isGeneratedcolumn = """";
	 public MetaColumn( String tableCat, String tableSchem, String tableName, String columnName, int dataType, String typeName, Integer columnSize, Integer decimalDigits, Integer numPrecRadix, int nullable, Integer charOctetLength, int ordinalPosition, String isNullable) {
		 this.tableCat = tableCat;
		 this.tableSchem = tableSchem;
		 this.tableName = tableName;
		 this.columnName = columnName;
		 this.dataType = dataType;
		 this.typeName = typeName;
		 this.columnSize = columnSize;
		 this.decimalDigits = decimalDigits;
		 this.numPrecRadix = numPrecRadix;
		 this.nullable = nullable;
		 this.charOctetLength = charOctetLength;
		 this.ordinalPosition = ordinalPosition;
		 this.isNullable = isNullable;
	 }
	 public String getName() {
		 return columnName;
	 }
 }",1,1,0,0
"public class FieldRefCPInfo extends ConstantPoolEntry {
	 private String fieldClassName;
	 private String fieldName;
	 private String fieldType;
	 private int classIndex;
	 private int nameAndTypeIndex;
	 public FieldRefCPInfo() {
		 super(CONSTANT_FIELDREF, 1);
	 }
	 public void read(DataInputStream cpStream) throws IOException {
		 classIndex = cpStream.readUnsignedShort();
		 nameAndTypeIndex = cpStream.readUnsignedShort();
	 }
	 public void resolve(ConstantPool constantPool) {
		 ClassCPInfo fieldClass = (ClassCPInfo) constantPool.getEntry(classIndex);
		 fieldClass.resolve(constantPool);
		 fieldClassName = fieldClass.getClassName();
		 NameAndTypeCPInfo nt = (NameAndTypeCPInfo) constantPool.getEntry(nameAndTypeIndex);
		 nt.resolve(constantPool);
		 fieldName = nt.getName();
		 fieldType = nt.getType();
		 super.resolve(constantPool);
	 }
	 public String toString() {
		 String value;
		 if (isResolved()) {
			 value = ""Field : Class = "" + fieldClassName + "", name = "" + fieldName + "", type = "" + fieldType;
		 }
		 else {
			 value = ""Field : Class index = "" + classIndex + "", name and type index = "" + nameAndTypeIndex;
		 }
		 return value;
	 }
	 public String getFieldClassName() {
		 return fieldClassName;
	 }
	 public String getFieldName() {
		 return fieldName;
	 }
	 public String getFieldType() {
		 return fieldType;
	 }
}",0,0,0,0
"public void onClick(){
}",0,0,0,0
"public class RowView implements Comparable<RowView> {
	 private final ThreadData data;
	 private int i = -1;
	 RowView(ThreadData data) {
		 this.data = data;
		 if (getMaxIndex() >= 0) i = findLastIndex();
	 }
	 public int getLastIndex() {
		 return i == Integer.MIN_VALUE || i == Integer.MAX_VALUE ? -1 : i;
	 }
	 public int getMaxIndex() {
		 return data.size() - 1;
	 }
	 public long getTime(int index) {
		 return data.getTimeStampAt(index);
	 }
	 public int getState(int index) {
		 return data.getStateAt(index);
	 }
	 public int getPosition(long time) {
		 return (int)((time - getFirstTime()) * zoom);
	 }
	 public int getMaxPosition() {
		 return getViewWidth();
	 }
	 private int findLastIndex() {
		 if (isTrackingEnd() || isFit()) return getMaxIndex();
		 i = Integer.MIN_VALUE;
		 return findLastIndexLeft();
	 }
	 private int findLastIndexLeft() {
		 if (i == Integer.MAX_VALUE) return i;
		 int maxIndex = getMaxIndex();
		 int newIndex = i == Integer.MIN_VALUE ? maxIndex : i;
		 Position position = getIndexPosition(newIndex);
		 while (newIndex > 0 && Position.RIGHT.equals(position)) position = getIndexPosition(--newIndex);
		 if (Position.RIGHT.equals(position)) return Integer.MAX_VALUE;
		 if (Position.LEFT.equals(position) && newIndex == maxIndex && getMaxPosition() - offset < 0) return Integer.MIN_VALUE;
		 return newIndex;
	 }
	 private int findLastIndexRight() {
		 if (i == Integer.MIN_VALUE) return i;
		 int maxIndex = getMaxIndex();
		 int newIndex = i == Integer.MAX_VALUE ? 0 : i;
		 Position position = getIndexPosition(newIndex);
		 while (newIndex < maxIndex && !Position.RIGHT.equals(position)) position = getIndexPosition(++newIndex);
		 if (Position.RIGHT.equals(position)) return newIndex == 0 ? Integer.MAX_VALUE : newIndex - 1;
		 if (Position.LEFT.equals(position) && newIndex == maxIndex && getMaxPosition() - offset < 0) return Integer.MIN_VALUE;
		 return newIndex;
	 }
	 private Position getIndexPosition(int index) {
		 int position = getPosition(getTime(index)) - offset;
		 if (position < 0) return Position.LEFT;
		 else if (position >= width) return Position.RIGHT;
		 else return Position.WITHIN;
	 }
	 private void offsetChanged(int oldOffset, int newOffset) {
		 int maxIndex = getMaxIndex();
		 if (maxIndex == -1) return;
		 if (isTrackingEnd()) {
			 i = maxIndex;
		 }
		 else {
			 if (newOffset > oldOffset) {
				 i = i == -1 ? findLastIndex() : findLastIndexRight();
			 }
			 else {
				 i = i == -1 ? findLastIndex() : findLastIndexLeft();
			 }
		 }
	 }
	 private void widthChanged(int oldWidth, int newWidth) {
		 int maxIndex = getMaxIndex();
		 if (maxIndex == -1) return;
		 if (isTrackingEnd() || isFit()) {
			 i = maxIndex;
		 }
		 else {
			 if (newWidth > oldWidth) {
				 i = i == -1 ? findLastIndex() : findLastIndexRight();
			 }
			 else {
				 i = i == -1 ? findLastIndex() : findLastIndexLeft();
			 }
		 }
	 }
	 private boolean lastMaxIn = true;
	 private void preferredWidthChanged(int oldWidth, int newWidth) {
		 int maxIndex = getMaxIndex();
		 if (maxIndex == -1) return;
		 int currPos = getMaxPosition() - offset;
		 if (currPos >= 0 && currPos < width) {
			 i = maxIndex;
			 lastMaxIn = true;
		 }
		 else {
			 if (lastMaxIn && currPos >= width) {
				 i = maxIndex;
				 findLastIndexLeft();
			 }
			 lastMaxIn = false;
		 }
	 }
	 private void zoomChanged(double oldZoom, double newZoom) {
		 int maxIndex = getMaxIndex();
		 if (maxIndex == -1) return;
		 if (isTrackingEnd() || isFit()) {
			 i = maxIndex;
		 }
		 else {
			 i = findLastIndex();
		 }
	 }
	 public int compareTo(RowView view) {
		 return Long.compare(data.getFirstTimeStamp(), view.data.getFirstTimeStamp());
	 }
	 public String toString() {
		 return BUNDLE().getString(""COL_Timeline"");
	 }
 }",0,0,0,0
"public class BufferedRandomAccessFile extends RandomAccessFile implements FileDataInput{
	 private static final long MAX_BYTES_IN_PAGE_CACHE = (long) Math.pow(2, 27);
	 private final String filePath;
	 public static final int DEFAULT_BUFFER_SIZE = 65535;
	 private boolean isDirty, syncNeeded;
	 private byte[] buffer;
	 private long bufferOffset, current = 0;
	 private int validBufferBytes = 0;
	 private final long fileLength;
	 private final FileChannel channel;
	 private long markedPointer;
	 private int fd;
	 private final boolean skipCache;
	 private long bytesSinceCacheFlush = 0;
	 private long minBufferOffset = Long.MAX_VALUE;
	 public BufferedRandomAccessFile(String name, String mode) throws IOException {
		 this(new File(name), mode, DEFAULT_BUFFER_SIZE);
	 }
	 public BufferedRandomAccessFile(String name, String mode, int bufferSize) throws IOException {
		 this(new File(name), mode, bufferSize);
	 }
	 public BufferedRandomAccessFile(File file, String mode) throws IOException {
		 this(file, mode, DEFAULT_BUFFER_SIZE);
	 }
	 public BufferedRandomAccessFile(File file, String mode, int bufferSize) throws IOException {
		 this(file, mode, bufferSize, false);
	 }
	 public BufferedRandomAccessFile(File file, String mode, int bufferSize, boolean skipCache) throws IOException {
		 super(file, mode);
		 this.skipCache = skipCache;
		 channel = super.getChannel();
		 filePath = file.getAbsolutePath();
		 if (bufferSize <= 0) throw new IllegalArgumentException(""bufferSize must be positive"");
		 buffer = new byte[bufferSize];
		 reBuffer();
		 fileLength = (mode.equals(""r"")) ? this.channel.size() : -1;
		 fd = CLibrary.getfd(this.getFD());
	 }
	 public void sync() throws IOException {
		 if (syncNeeded) {
			 flush();
			 channel.force(true);
			 if (skipCache) {
				 CLibrary.trySkipCache(this.fd, 0, 0);
				 minBufferOffset = Long.MAX_VALUE;
				 bytesSinceCacheFlush = 0;
			 }
			 syncNeeded = false;
		 }
	 }
	 public void flush() throws IOException {
		 if (isDirty) {
			 if (channel.position() != bufferOffset) channel.position(bufferOffset);
			 super.write(buffer, 0, validBufferBytes);
			 if (skipCache) {
				 bytesSinceCacheFlush += validBufferBytes;
				 if (bufferOffset < minBufferOffset) minBufferOffset = bufferOffset;
				 if (bytesSinceCacheFlush >= MAX_BYTES_IN_PAGE_CACHE) {
					 CLibrary.trySkipCache(this.fd, (int) minBufferOffset, 0);
					 minBufferOffset = bufferOffset;
					 bytesSinceCacheFlush = 0;
				 }
			 }
			 resetBuffer();
			 isDirty = false;
		 }
	 }
	 public void setLength(long newLength) throws IOException {
		 if (newLength < 0) throw new IllegalArgumentException();
		 if (isDirty) {
			 if (newLength < bufferOffset) {
				 validBufferBytes = 0;
			 }
			 else if (newLength > (bufferOffset + validBufferBytes)) {
				 flush();
			 }
			 else {
				 validBufferBytes = (int)(newLength - bufferOffset);
				 flush();
			 }
		 }
		 super.setLength(newLength);
		 validBufferBytes = 0;
		 current = newLength;
		 reBuffer();
	 }
	 private void resetBuffer() {
		 bufferOffset = current;
		 validBufferBytes = 0;
	 }
	 private void reBuffer() throws IOException {
		 flush();
		 resetBuffer();
		 if (bufferOffset >= channel.size()) return;
		 if (bufferOffset < minBufferOffset) minBufferOffset = bufferOffset;
		 channel.position(bufferOffset);
		 int read = 0;
		 while (read < buffer.length) {
			 int n = super.read(buffer, read, buffer.length - read);
			 if (n < 0) break;
			 read += n;
		 }
		 validBufferBytes = read;
		 bytesSinceCacheFlush += read;
		 if (skipCache && bytesSinceCacheFlush >= MAX_BYTES_IN_PAGE_CACHE) {
			 CLibrary.trySkipCache(this.fd, (int) minBufferOffset, 0);
			 bytesSinceCacheFlush = 0;
			 minBufferOffset = Long.MAX_VALUE;
		 }
	 }
	 public int read() throws IOException {
		 if (isEOF()) return -1;
		 if (current >= bufferOffset + buffer.length) reBuffer();
		 assert current >= bufferOffset && current < bufferOffset + validBufferBytes;
		 return ((int) buffer[(int) (current++ - bufferOffset)]) & 0xFF;
	 }
	 public int read(byte[] buffer) throws IOException {
		 return read(buffer, 0, buffer.length);
	 }
	 public int read(byte[] buff, int offset, int length) throws IOException {
		 if (length == 0) return 0;
		 if (isEOF()) return -1;
		 if (current >= bufferOffset + buffer.length) reBuffer();
		 assert current >= bufferOffset && current < bufferOffset + validBufferBytes;
		 int toCopy = Math.min(length, validBufferBytes - (int) (current - bufferOffset));
		 System.arraycopy(buffer, (int) (current - bufferOffset), buff, offset, toCopy);
		 current += toCopy;
		 return toCopy;
	 }
	 public ByteBuffer readBytes(int length) throws IOException {
		 assert length >= 0 : ""buffer length should not be negative: "" + length;
		 byte[] buff = new byte[length];
		 readFully(buff);
		 return ByteBuffer.wrap(buff);
	 }
	 private final byte[] singleByteBuffer = new byte[1];
	 public void write(int val) throws IOException {
		 singleByteBuffer[0] = (byte) val;
		 this.write(singleByteBuffer, 0, 1);
	 }
	 public void write(byte[] b) throws IOException {
		 write(b, 0, b.length);
	 }
	 public void write(byte[] buff, int offset, int length) throws IOException {
		 if (buffer == null) throw new ClosedChannelException();
		 if (isReadOnly()) throw new IOException(""Unable to write: file is in the read-only mode."");
		 while (length > 0) {
			 int n = writeAtMost(buff, offset, length);
			 offset += n;
			 length -= n;
			 isDirty = true;
			 syncNeeded = true;
		 }
	 }
	 private boolean isReadOnly() {
		 return fileLength != -1;
	 }
	 private int writeAtMost(byte[] buff, int offset, int length) throws IOException {
		 if (current >= bufferOffset + buffer.length) reBuffer();
		 assert current < bufferOffset + buffer.length;
		 int positionWithinBuffer = (int) (current - bufferOffset);
		 int toCopy = Math.min(length, buffer.length - positionWithinBuffer);
		 System.arraycopy(buff, offset, buffer, positionWithinBuffer, toCopy);
		 current += toCopy;
		 validBufferBytes = Math.max(validBufferBytes, positionWithinBuffer + toCopy);
		 assert current <= bufferOffset + buffer.length;
		 return toCopy;
	 }
	 public void seek(long newPosition) throws IOException {
		 if (newPosition < 0) throw new IllegalArgumentException(""new position should not be negative"");
		 if (isReadOnly() && newPosition > fileLength) throw new EOFException(String.format(""unable to seek to position %d in %s (%d bytes) in read-only mode"", newPosition, filePath, fileLength));
		 current = newPosition;
		 if (newPosition > (bufferOffset + validBufferBytes) || newPosition < bufferOffset) reBuffer();
	 }
	 public int skipBytes(int count) throws IOException {
		 if (count > 0) {
			 long currentPos = getFilePointer(), eof = length();
			 int newCount = (int) ((currentPos + count > eof) ? eof - currentPos : count);
			 seek(currentPos + newCount);
			 return newCount;
		 }
		 return 0;
	 }
	 public long length() throws IOException {
		 return (fileLength == -1) ? Math.max(Math.max(current, channel.size()), bufferOffset + validBufferBytes) : fileLength;
	 }
	 public long getFilePointer() {
		 return current;
	 }
	 public String getPath() {
		 return filePath;
	 }
	 public boolean isEOF() throws IOException {
		 return getFilePointer() == length();
	 }
	 public long bytesRemaining() throws IOException {
		 return length() - getFilePointer();
	 }
	 public void close() throws IOException {
		 sync();
		 buffer = null;
		 if (skipCache && bytesSinceCacheFlush > 0) {
			 CLibrary.trySkipCache(this.fd, 0, 0);
		 }
		 super.close();
	 }
	 public void reset() throws IOException {
		 seek(markedPointer);
	 }
	 public long bytesPastMark() {
		 long bytes = getFilePointer() - markedPointer;
		 assert bytes >= 0;
		 return bytes;
	 }
	 public FileMark mark() {
		 markedPointer = getFilePointer();
		 return new BufferedRandomAccessFileMark(markedPointer);
	 }
	 public void reset(FileMark mark) throws IOException {
		 assert mark instanceof BufferedRandomAccessFileMark;
		 seek(((BufferedRandomAccessFileMark) mark).pointer);
	 }
	 public long bytesPastMark(FileMark mark) {
		 assert mark instanceof BufferedRandomAccessFileMark;
		 long bytes = getFilePointer() - ((BufferedRandomAccessFileMark) mark).pointer;
		 assert bytes >= 0;
		 return bytes;
	 }
	 public static BufferedRandomAccessFile getUncachingReader(String filename) throws IOException {
		 return new BufferedRandomAccessFile(new File(filename), ""r"", 8 * 1024 * 1024, true);
	 }
	 protected static class BufferedRandomAccessFileMark implements FileMark {
		 long pointer;
		 public BufferedRandomAccessFileMark(long pointer) {
			 this.pointer = pointer;
		 }
	 }
	 public String toString() {
		 return getClass().getSimpleName() + ""("" + ""filePath='"" + filePath + ""'"" + "", length="" + fileLength + "", skipCache="" + skipCache + "")"";
	 }
}",0,0,0,0
"public void execute() throws IOException, JSchException {
	 if (directoryList != null) {
		 doMultipleTransfer();
	 }
	 if (localFile != null) {
		 doSingleTransfer();
	 }
	 log(""done.\n"");
 }",0,0,0,0
"public class AppService implements ApplicationService {
	 private static final Logger logger = LoggerFactory.getLogger(ApplicationService.class);
	 public static ApplicationService createAndRegister(TopologyProvider provider, DirectSubmitter<Topology, Job> submitter) {
		 AppService service = new AppService(provider, submitter, ALIAS);
		 submitter.getServices().addService(ApplicationService.class, service);
		 return service;
	 }
	 private final Map<String,BiConsumer<Topology, JsonObject>> applications = Collections.synchronizedMap(new HashMap<>());
	 private final TopologyProvider provider;
	 private final DirectSubmitter<Topology, Job> submitter;
	 public AppService(TopologyProvider provider, DirectSubmitter<Topology, Job> submitter, String alias) {
		 this.provider = provider;
		 this.submitter = submitter;
		 ControlService cs = submitter.getServices().getService(ControlService.class);
		 if (cs != null) cs.registerControl(ApplicationServiceMXBean.TYPE, ALIAS+System.currentTimeMillis(), alias, ApplicationServiceMXBean.class, new AppServiceControl(this));
	 }
	 public void registerTopology(String applicationName, BiConsumer<Topology, JsonObject> builder) {
		 if (applicationName == null || applicationName.isEmpty()) {
			 throw new IllegalArgumentException();
		 }
		 logger.trace(""Register application name: {
		}
		"", applicationName);
		 applications.put(applicationName, builder);
	 }
	 public void registerJar(String jarURL, String jsonConfig) throws Exception {
		 logger.trace(""Register jar: {
		}
		"", jarURL);
		 URL url = new URL(jarURL);
		 String protocol = url.getProtocol();
		 if (""http"".equals(protocol) || ""https"".equals(protocol)) {
			 url = downloadJar(url);
		 }
		 URLClassLoader loader = new URLClassLoader(new URL[] {
		url}
		);
		 for (TopologyBuilder topoBuilder : ServiceLoader.load(TopologyBuilder.class, loader)) {
			 registerTopology(topoBuilder.getName(), topoBuilder.getBuilder());
		 }
	 }
	 private URL downloadJar(URL url) throws Exception {
		 HttpURLConnection httpConn = (HttpURLConnection) url.openConnection();
		 int responseCode = httpConn.getResponseCode();
		 if (responseCode != HttpURLConnection.HTTP_OK) {
			 logger.error(""Error response code for URL: {
			}
			 : response code={
			}
			"", url.toExternalForm(), responseCode);
			 throw new IOException();
		 }
		 String fileName = """";
		 String disposition = httpConn.getHeaderField(""Content-Disposition"");
		 if (disposition != null) {
			 int index = disposition.indexOf(""filename="");
			 if (index > 0) {
				 fileName = disposition.substring(index + 10, disposition.length() - 1);
			 }
		 }
		 else {
			 String path = url.getPath();
			 if (!path.isEmpty()) {
				 int lastSlash = path.lastIndexOf(""/"");
				 if (lastSlash == -1) fileName = path;
				 else fileName = path.substring(lastSlash+1);
			 }
		 }
		 Path dir = Files.createTempDirectory(""edgentjars"");
		 File file;
		 if (fileName.isEmpty()) file = File.createTempFile(""edgent"", ""jar"", dir.toFile());
		 else file = new File(dir.toFile(), fileName);
		 InputStream inputStream = httpConn.getInputStream();
		 FileOutputStream outputStream = new FileOutputStream(file);
		 int bytesRead;
		 byte[] buffer = new byte[4096];
		 while ((bytesRead = inputStream.read(buffer)) != -1) {
			 outputStream.write(buffer, 0, bytesRead);
		 }
		 outputStream.flush();
		 outputStream.close();
		 inputStream.close();
		 logger.trace(""Register jar downloaded as: {
		}
		"", file);
		 return file.toURI().toURL();
	 }
	 public Set<String> getApplicationNames() {
		 synchronized (applications) {
			 return new HashSet<>(applications.keySet());
		 }
	 }
	 BiConsumer<Topology, JsonObject> getBuilder(String applicationName) {
		 return applications.get(applicationName);
	 }
	 TopologyProvider getProvider() {
		 return provider;
	 }
	 DirectSubmitter<Topology, Job> getSubmitter() {
		 return submitter;
	 }
}",1,0,0,0
"protected int resolveCharOnlyEntity(boolean checkStd) throws XMLStreamException {
	 int avail = mInputEnd - mInputPtr;
	 if (avail < 6) {
		 --mInputPtr;
		 if (!ensureInput(6)) {
			 avail = inputInBuffer();
			 if (avail < 3) {
				 throwUnexpectedEOF(SUFFIX_IN_ENTITY_REF);
			 }
		 }
		 else {
			 avail = 6;
		 }
		 ++mInputPtr;
	 }
	 char c = mInputBuffer[mInputPtr];
	 if (c == '#') {
		 ++mInputPtr;
		 return resolveCharEnt(null);
	 }
	 if (checkStd) {
		 if (c == 'a') {
			 char d = mInputBuffer[mInputPtr+1];
			 if (d == 'm') {
				 if (avail >= 4 && mInputBuffer[mInputPtr+2] == 'p' && mInputBuffer[mInputPtr+3] == ';
				') {
					 mInputPtr += 4;
					 return '&';
				 }
			 }
			 else if (d == 'p') {
				 if (avail >= 5 && mInputBuffer[mInputPtr+2] == 'o' && mInputBuffer[mInputPtr+3] == 's' && mInputBuffer[mInputPtr+4] == ';
				') {
					 mInputPtr += 5;
					 return '\'';
				 }
			 }
		 }
		 else if (c == 'l') {
			 if (avail >= 3 && mInputBuffer[mInputPtr+1] == 't' && mInputBuffer[mInputPtr+2] == ';
			') {
				 mInputPtr += 3;
				 return '<';
			 }
		 }
		 else if (c == 'g') {
			 if (avail >= 3 && mInputBuffer[mInputPtr+1] == 't' && mInputBuffer[mInputPtr+2] == ';
			') {
				 mInputPtr += 3;
				 return '>';
			 }
		 }
		 else if (c == 'q') {
			 if (avail >= 5 && mInputBuffer[mInputPtr+1] == 'u' && mInputBuffer[mInputPtr+2] == 'o' && mInputBuffer[mInputPtr+3] == 't' && mInputBuffer[mInputPtr+4] == ';
			') {
				 mInputPtr += 5;
				 return '""';
			 }
		 }
	 }
	 return 0;
 }",0,0,1,0
"private static class Map4<K, V> extends Map3<K, V> {
	 private static final long serialVersionUID = 0L;
	 protected K k4;
	 protected V v4;
	 Map4() {
	 }
	 Map4(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
		 super(k1, v1, k2, v2, k3, v3);
		 this.k4 = k4;
		 this.v4 = v4;
	 }
	 public boolean isFull() {
		 return size() == 4;
	 }
	 public V remove(Object key) {
		 if (F.eq(key, k4)) {
			 V res = v4;
			 v4 = null;
			 k4 = null;
			 return res;
		 }
		 return super.remove(key);
	 }
	 public int size() {
		 return super.size() + (k4 != null ? 1 : 0);
	 }
	 public boolean containsKey(Object k) {
		 return super.containsKey(k) || (k4 != null && F.eq(k, k4));
	 }
	 public boolean containsValue(Object v) {
		 return super.containsValue(v) || (k4 != null && F.eq(v, v4));
	 }
	 public V get(Object k) {
		 V v = super.get(k);
		 return v != null ? v : (k4 != null && F.eq(k, k4)) ? v4 : null;
	 }
	 public V put(K key, V val) throws NullPointerException {
		 V oldVal = get(key);
		 if (k1 == null || F.eq(k1, key)) {
			 k1 = key;
			 v1 = val;
		 }
		 else if (k2 == null || F.eq(k2, key)) {
			 k2 = key;
			 v2 = val;
		 }
		 else if (k3 == null || F.eq(k3, key)) {
			 k3 = key;
			 v3 = val;
		 }
		 else if (k4 == null || F.eq(k4, key)) {
			 k4 = key;
			 v4 = val;
		 }
		 return oldVal;
	 }
	 public Set<Entry<K, V>> entrySet() {
		 return new AbstractSet<Entry<K, V>>() {
			 public Iterator<Entry<K, V>> iterator() {
				 return new Iterator<Entry<K, V>>() {
					 private int idx;
					 private Entry<K, V> next;
					 {
						 if (k1 != null) {
							 idx = 1;
							 next = e(k1, v1);
						 }
						 else if (k2 != null) {
							 idx = 2;
							 next = e(k2, v2);
						 }
						 else if (k3 != null) {
							 idx = 3;
							 next = e(k3, v3);
						 }
						 else if (k4 != null) {
							 idx = 4;
							 next = e(k4, v4);
						 }
					 }
					 public boolean hasNext() {
						 return next != null;
					 }
					 public Entry<K, V> next() {
						 if (!hasNext()) throw new NoSuchElementException();
						 Entry<K, V> old = next;
						 next = null;
						 switch (idx) {
							 case 1: if (k2 != null) {
								 idx = 2;
								 next = e(k2, v2);
								 break;
							 }
							 case 2: if (k3 != null) {
								 idx = 3;
								 next = e(k3, v3);
								 break;
							 }
							 case 3: if (k4 != null) {
								 idx = 4;
								 next = e(k4, v4);
								 break;
							 }
						 }
						 return old;
					 }
					 public void remove() {
						 throw new UnsupportedOperationException();
					 }
				 }
				;
			 }
			 public int size() {
				 return Map4.this.size();
			 }
		 }
		;
	 }
 }",1,1,0,0
"public SAXImpl(XSLTCDTMManager mgr, Source source, int dtmIdentity, DTMWSFilter whiteSpaceFilter, XMLStringFactory xstringfactory, boolean doIndexing, boolean buildIdIndex);",0,0,0,1
"public synchronized void setFile(File file) {
	 add(new FileResource(file));
 }",0,0,0,0
"public class MajoritySelector extends BaseSelectorContainer {
	 private boolean allowtie = true;
	 public MajoritySelector() {
	 }
	 public String toString() {
		 StringBuffer buf = new StringBuffer();
		 if (hasSelectors()) {
			 buf.append(""{
				majorityselect: "");
				 buf.append(super.toString());
			 buf.append(""}
			"");
		 }
		 return buf.toString();
	 }
	 public void setAllowtie(boolean tiebreaker) {
		 allowtie = tiebreaker;
	 }
	 public boolean isSelected(File basedir, String filename, File file) {
		 validate();
		 int yesvotes = 0;
		 int novotes = 0;
		 Enumeration e = selectorElements();
		 boolean result;
		 while (e.hasMoreElements()) {
			 result = ((FileSelector) e.nextElement()).isSelected(basedir, filename, file);
			 if (result) {
				 yesvotes = yesvotes + 1;
			 }
			 else {
				 novotes = novotes + 1;
			 }
		 }
		 if (yesvotes > novotes) {
			 return true;
		 }
		 else if (novotes > yesvotes) {
			 return false;
		 }
		 return allowtie;
	 }
}",0,0,0,0
"public BufferedImage processImage(BufferedImage image) {
	 originalImage = image;
	 width = originalImage.getWidth();
	 height = originalImage.getHeight();
	 filteredImage = new BufferedImage(width, height, originalImage.getType());
	 imageM = new int[width][height];
	 for (int i = 0;
	 i < width;
	 i++) {
		 for (int j = 0;
		 j < height;
		 j++) {
			 int col = new Color(originalImage.getRGB(i, j)).getRed();
			 if (blackLetters) {
				 imageM[i][j] = 1 - (col / 255);
			 }
			 else {
				 imageM[i][j] = col / 255;
			 }
		 }
	 }
	 while (true) {
		 int[][] start = new int[width][height];
		 for (int i = 0;
		 i < width;
		 i++) {
			 for (int j = 0;
			 j < height;
			 j++) {
				 start[i][j] = imageM[i][j];
			 }
		 }
		 thiningIteration(0);
		 thiningIteration(1);
		 boolean same = true;
		 MainforLoop: for (int i = 0;
		 i < width;
		 i++) {
			 for (int j = 0;
			 j < height;
			 j++) {
				 if (start[i][j] != imageM[i][j]) {
					 same = false;
					 break MainforLoop;
				 }
			 }
		 }
		 if (same) {
			 break;
		 }
	 }
	 for (int i = 0;
	 i < width;
	 i++) {
		 for (int j = 0;
		 j < height;
		 j++) {
			 int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
			 int col;
			 if (blackLetters) {
				 col = 255 - imageM[i][j] * 255;
			 }
			 else {
				 col = imageM[i][j] * 255;
			 }
			 int rgb = ImageUtilities.colorToRGB(alpha, col, col, col);
			 filteredImage.setRGB(i, j, rgb);
		 }
	 }
	 return filteredImage;
 }",0,0,1,0
"public class MarkupParserFactory implements IMarkupParserFactory{
	public MarkupParserFactory(){
	}
	public MarkupParser newMarkupParser(final MarkupResourceStream resource){
		return new MarkupParser(new XmlPullParser(), resource);
	}
}",0,0,0,0
"private static class list_roles_argsTupleScheme extends TupleScheme<list_roles_args> {
	 public void write(org.apache.thrift.protocol.TProtocol prot, list_roles_args struct) throws org.apache.thrift.TException {
		 TTupleProtocol oprot = (TTupleProtocol) prot;
		 BitSet optionals = new BitSet();
		 if (struct.isSetPrincipal_name()) {
			 optionals.set(0);
		 }
		 if (struct.isSetPrincipal_type()) {
			 optionals.set(1);
		 }
		 oprot.writeBitSet(optionals, 2);
		 if (struct.isSetPrincipal_name()) {
			 oprot.writeString(struct.principal_name);
		 }
		 if (struct.isSetPrincipal_type()) {
			 oprot.writeI32(struct.principal_type.getValue());
		 }
	 }
	 public void read(org.apache.thrift.protocol.TProtocol prot, list_roles_args struct) throws org.apache.thrift.TException {
		 TTupleProtocol iprot = (TTupleProtocol) prot;
		 BitSet incoming = iprot.readBitSet(2);
		 if (incoming.get(0)) {
			 struct.principal_name = iprot.readString();
			 struct.setPrincipal_nameIsSet(true);
		 }
		 if (incoming.get(1)) {
			 struct.principal_type = org.apache.hadoop.hive.metastore.api.PrincipalType.findByValue(iprot.readI32());
			 struct.setPrincipal_typeIsSet(true);
		 }
	 }
 }",0,0,0,0
"public JsonGenerator(LogIterator iter) {
	servers = new HashSet<Integer>();
	Pattern stateChangeP = Pattern.compile(""- (LOOKING|FOLLOWING|LEADING)"");
	Pattern newElectionP = Pattern.compile(""New election. My id = (\\d+), Proposed zxid = (\\d+)"");
	Pattern receivedProposalP = Pattern.compile(""Notification: (\\d+) \\(n.leader\\), (\\d+) \\(n.zxid\\), (\\d+) \\(n.round\\), .+ \\(n.state\\), (\\d+) \\(n.sid\\), .+ \\(my state\\)"");
	Pattern exceptionP = Pattern.compile(""xception"");
	root = new JSONObject();
	Matcher m = null;
	JSONArray events = new JSONArray();
	root.put(""events"", events);
	long starttime = Long.MAX_VALUE;
	long endtime = 0;
	int leader = 0;
	long curEpoch = 0;
	boolean newEpoch = false;
	while (iter.hasNext()) {
		 LogEntry ent = iter.next();
		 if (ent.getTimestamp() < starttime) {
			starttime = ent.getTimestamp();
		 }
		 if (ent.getTimestamp() > endtime) {
			endtime = ent.getTimestamp();
		 }
		 if (ent.getType() == LogEntry.Type.TXN) {
			events.add(txnEntry((TransactionEntry)ent));
		 }
		 else {
			Log4JEntry e = (Log4JEntry)ent;
			servers.add(e.getNode());
			if ((m = stateChangeP.matcher(e.getEntry())).find()) {
				 JSONObject stateChange = new JSONObject();
				 stateChange.put(""type"", ""stateChange"");
				 stateChange.put(""time"", e.getTimestamp());
				 stateChange.put(""server"", e.getNode());
				 stateChange.put(""state"", m.group(1));
				 events.add(stateChange);
				 if (m.group(1).equals(""LEADING"")) {
					leader = e.getNode();
				 }
			}
			 else if ((m = newElectionP.matcher(e.getEntry())).find()) {
				 Iterator<Integer> iterator = servers.iterator();
				 long zxid = Long.valueOf(m.group(2));
				 int count = (int)zxid;
				 int epoch = (int)Long.rotateRight(zxid, 32);
				 if (leader != 0 && epoch > curEpoch) {
					JSONObject stateChange = new JSONObject();
					stateChange.put(""type"", ""stateChange"");
					stateChange.put(""time"", e.getTimestamp());
					stateChange.put(""server"", leader);
					stateChange.put(""state"", ""INIT"");
					events.add(stateChange);
					leader = 0;
				 }
				 while (iterator.hasNext()) {
					int dst = iterator.next();
					if (dst != e.getNode()) {
						 JSONObject msg = new JSONObject();
						 msg.put(""type"", ""postmessage"");
						 msg.put(""src"", e.getNode());
						 msg.put(""dst"", dst);
						 msg.put(""time"", e.getTimestamp());
						 msg.put(""zxid"", m.group(2));
						 msg.put(""count"", count);
						 msg.put(""epoch"", epoch);
						 events.add(msg);
					}
				 }
			}
			 else if ((m = receivedProposalP.matcher(e.getEntry())).find()) {
				 int src = Integer.valueOf(m.group(4));
				 long zxid = Long.valueOf(m.group(2));
				 int dst = e.getNode();
				 long epoch2 = Long.valueOf(m.group(3));
				 int count = (int)zxid;
				 int epoch = (int)Long.rotateRight(zxid, 32);
				 if (leader != 0 && epoch > curEpoch) {
					JSONObject stateChange = new JSONObject();
					stateChange.put(""type"", ""stateChange"");
					stateChange.put(""time"", e.getTimestamp());
					stateChange.put(""server"", leader);
					stateChange.put(""state"", ""INIT"");
					events.add(stateChange);
					leader = 0;
				 }
				 if (src != dst) {
					JSONObject msg = new JSONObject();
					msg.put(""type"", ""delivermessage"");
					msg.put(""src"", src);
					msg.put(""dst"", dst);
					msg.put(""time"", e.getTimestamp());
					msg.put(""zxid"", zxid);
					msg.put(""epoch"", epoch);
					msg.put(""count"", count);
					msg.put(""epoch2"", epoch2);
					events.add(msg);
				 }
			}
			 else if ((m = exceptionP.matcher(e.getEntry())).find()) {
				 JSONObject ex = new JSONObject();
				 ex.put(""type"", ""exception"");
				 ex.put(""server"", e.getNode());
				 ex.put(""time"", e.getTimestamp());
				 ex.put(""text"", e.getEntry());
				 events.add(ex);
			}
		 }
		 JSONObject ex = new JSONObject();
		 ex.put(""type"", ""text"");
		 ex.put(""time"", ent.getTimestamp());
		 String txt = ent.toString();
		 ex.put(""text"", txt);
		 events.add(ex);
	}
	root.put(""starttime"", starttime);
	root.put(""endtime"", endtime);
	JSONArray serversarray = new JSONArray();
	root.put(""servers"", serversarray);
	Iterator<Integer> iterator = servers.iterator();
	while (iterator.hasNext()) {
		 serversarray.add(iterator.next());
	}
 }",0,0,1,0
"private boolean rowMatches(HStoreKey origin, HStoreKey target){
	 if (origin.getColumn().equals(new Text())){
		 return target.getRow().equals(origin.getRow());
	 }
	 return target.matchesRowCol(origin);
 }",0,0,0,0
"private static class updateWorkflow_argsStandardSchemeFactory implements SchemeFactory {
	 public updateWorkflow_argsStandardScheme getScheme() {
		 return new updateWorkflow_argsStandardScheme();
	 }
 }",0,0,0,0
"static public BufferedImage[] loadImages(File f) throws IOException {
	InputStream istream = new FileInputStream(f);
	 BufferedInputStream buffin = new BufferedInputStream(istream);
	BinaryInputStream in = new BinaryInputStream(buffin);
	try {
		 in.mark(32000);
		 IconDir dir = new IconDir(in);
		 IconEntry[] entries = new IconEntry[dir.idCount];
		 BufferedImage[] images = new BufferedImage[dir.idCount];
		 for (int i=0;
		 i<dir.idCount;
		 i++){
			 entries[i] = new IconEntry(in);
		}
		 IconEntry entry = entries[0];
		 for (int i=0;
		 i<dir.idCount;
		 i++){
			 in.reset();
			 in.skip(entries[i].dwImageOffset);
			 IconHeader header = new IconHeader(in);
			 long toskip = header.Size - 40;
			 if (toskip>0)in.skip((int)toskip);
			 BufferedImage image = new BufferedImage((int)header.Width, (int)header.Height/2, BufferedImage.TYPE_INT_ARGB);
			 switch(header.BitsPerPixel){
				case 4:case 8: loadPalettedImage(in, entries[i], header, image);
				 break;
				default: throw new Exception(""Unsupported ICO color depth: "" + header.BitsPerPixel);
			}
			 images[i] = image;
		}
		 return images;
	}
	 catch (Exception exc) {
		exc.printStackTrace();
	 }
	return null;
 }",0,0,1,0
"public class GlobalMetadataJsonMerger implements MetadataMerger<String> {
	 private GlobalMetadata mergedMetadata;
	 public GlobalMetadataJsonMerger() {
		 mergedMetadata = new GlobalMetadata();
	 }
	 public void update(String metadata) {
		 try {
			 GlobalMetadata parsedMetadata = GlobalMetadata.fromJson(metadata);
			 mergedMetadata.addAll(parsedMetadata);
		 }
		 catch (IOException e) {
			 throw new IllegalArgumentException(""Error parsing metadata"", e);
		 }
	 }
	 public void update(FsWriterMetrics metrics) {
		 long numRecords = mergedMetadata.getNumRecords();
		 int numFiles = mergedMetadata.getNumFiles();
		 for (FsWriterMetrics.FileInfo fileInfo: metrics.getFileInfos()) {
			 numRecords += fileInfo.getNumRecords();
			 numFiles += 1;
			 mergedMetadata.setFileMetadata(fileInfo.getFileName(), GlobalMetadata.NUM_RECORDS_KEY, Long.valueOf(fileInfo.getNumRecords()));
		 }
		 mergedMetadata.setNumRecords(numRecords);
		 mergedMetadata.setNumOutputFiles(numFiles);
	 }
	 public String getMergedMetadata() {
		 try {
			 return mergedMetadata.toJson();
		 }
		 catch (IOException e) {
			 throw new AssertionError(""Unexpected IOException serializing to JSON"", e);
		 }
	 }
}",0,0,0,0
"public static void main(String[] args) throws IOException {
	 Configuration conf = new Configuration();
	 String srcPath = null;
	 String destPath = null;
	 for (int idx = 0;
	 idx < args.length;
	 idx++) {
		 if (""-dfs"".equals(args[idx])) {
			 if (idx == (args.length-1)) {
				 System.out.println(usage);
				 return;
			 }
			 conf.set(""fs.default.name"", args[++idx]);
		 }
		 else if (""-jt"".equals(args[idx])) {
			 if (idx == (args.length-1)) {
				 System.out.println(usage);
				 return;
			 }
			 conf.set(""mapred.job.tracker"", args[++idx]);
		 }
		 else if (""-config"".equals(args[idx])) {
			 if (idx == (args.length-1)) {
				 System.out.println(usage);
				 return;
			 }
			 conf.addFinalResource(new Path(args[++idx]));
		 }
		 else {
			 if (srcPath == null) {
				 srcPath = args[idx];
			 }
			 else if (destPath == null) {
				 destPath = args[idx];
			 }
			 else {
				 System.out.println(usage);
				 return;
			 }
		 }
	 }
	 if (srcPath == null || destPath == null) {
		 System.out.println(usage);
		 return;
	 }
	 URI srcurl = null;
	 URI desturl = null;
	 try {
		 srcurl = new URI(srcPath);
		 desturl = new URI(destPath);
	 }
	 catch (URISyntaxException ex) {
		 throw new RuntimeException(""URL syntax error."", ex);
	 }
	 JobConf jobConf = new JobConf(conf, CopyFiles.class);
	 jobConf.setJobName(""copy-files"");
	 String srcFileSysName = getFileSysName(srcurl);
	 String destFileSysName = getFileSysName(desturl);
	 jobConf.set(""copy.src.fs"", srcFileSysName);
	 jobConf.set(""copy.dest.fs"", destFileSysName);
	 FileSystem srcfs;
	 srcfs = FileSystem.getNamed(srcFileSysName, conf);
	 FileSystem destfs = FileSystem.getNamed(destFileSysName, conf);
	 srcPath = srcurl.getPath();
	 if ("""".equals(srcPath)) {
		 srcPath = ""/"";
	 }
	 destPath = desturl.getPath();
	 if ("""".equals(destPath)) {
		 destPath = ""/"";
	 }
	 boolean isFile = false;
	 Path tmpPath = new Path(srcPath);
	 Path rootPath = new Path(srcPath);
	 if (srcfs.isFile(tmpPath)) {
		 isFile = true;
		 tmpPath = tmpPath.getParent();
		 rootPath = rootPath.getParent();
		 jobConf.set(""copy.src.path"", tmpPath.toString());
	 }
	 else {
		 jobConf.set(""copy.src.path"", srcPath);
	 }
	 jobConf.set(""copy.dest.path"", destPath);
	 if (!srcfs.exists(tmpPath)) {
		 System.out.println(srcPath+"" does not exist."");
		 return;
	 }
	 jobConf.setSpeculativeExecution(false);
	 jobConf.setInputKeyClass(UTF8.class);
	 jobConf.setInputValueClass(UTF8.class);
	 jobConf.setInputFormat(SequenceFileInputFormat.class);
	 jobConf.setOutputKeyClass(UTF8.class);
	 jobConf.setOutputValueClass(UTF8.class);
	 jobConf.setOutputFormat(SequenceFileOutputFormat.class);
	 jobConf.setMapperClass(CopyFilesMapper.class);
	 jobConf.setReducerClass(CopyFiles.class);
	 jobConf.setNumReduceTasks(1);
	 Path tmpDir = new Path(""copy-files"");
	 Path inDir = new Path(tmpDir, ""in"");
	 Path fakeOutDir = new Path(tmpDir, ""out"");
	 FileSystem fileSys = FileSystem.get(jobConf);
	 fileSys.delete(tmpDir);
	 fileSys.mkdirs(inDir);
	 jobConf.setInputPath(inDir);
	 jobConf.setOutputPath(fakeOutDir);
	 ArrayList pathList = new ArrayList();
	 ArrayList finalPathList = new ArrayList();
	 pathList.add(new Path(srcPath));
	 long totalBytes = 0;
	 int part = 0;
	 while(!pathList.isEmpty()) {
		 Path top = (Path) pathList.remove(0);
		 if (srcfs.isFile(top)) {
			 totalBytes += srcfs.getLength(top);
			 top = makeRelative(rootPath, top);
			 finalPathList.add(top.toString());
		 }
		 else {
			 Path[] paths = srcfs.listPaths(top);
			 for (int idx = 0;
			 idx < paths.length;
			 idx++) {
				 pathList.add(paths[idx]);
			 }
		 }
	 }
	 int nFiles = finalPathList.size();
	 int numMaps = nFiles;
	 if (numMaps > MAX_NUM_MAPS) {
		 numMaps = MAX_NUM_MAPS;
	 }
	 if (numMaps > (int) (totalBytes / MIN_BYTES_PER_MAP)) {
		 numMaps = (int) (totalBytes / MIN_BYTES_PER_MAP);
	 }
	 JobClient client = new JobClient(jobConf);
	 ClusterStatus cluster = client.getClusterStatus();
	 int tmpMaps = cluster.getTaskTrackers() * MAX_MAPS_PER_NODE;
	 if (numMaps > tmpMaps) {
		 numMaps = tmpMaps;
	 }
	 if (numMaps == 0) {
		 numMaps = 1;
	 }
	 jobConf.setNumMapTasks(numMaps);
	 for(int idx=0;
	 idx < numMaps;
	 ++idx) {
		 Path file = new Path(inDir, ""part""+idx);
		 SequenceFile.Writer writer = new SequenceFile.Writer(fileSys, file, UTF8.class, UTF8.class);
		 for (int ipath = idx;
		 ipath < nFiles;
		 ipath += numMaps) {
			 String path = (String) finalPathList.get(ipath);
			 writer.append(new UTF8(path), new UTF8(""""));
		 }
		 writer.close();
	 }
	 finalPathList = null;
	 try {
		 JobClient.runJob(jobConf);
	 }
	 finally {
		 fileSys.delete(tmpDir);
	 }
 }",0,0,1,0
"private void processEmail(EmailData emailData) {
	 if (logger.isTraceEnabled()) {
		 logger.trace(""Entered MailManager:processEmail"");
	 }
	 if (mailHost == null || mailHost.length() == 0 || emailData == null || mailToAddresses.length == 0) {
		 logger.error(""Required mail server configuration is not specfied."");
		 if (logger.isDebugEnabled()) {
			 logger.debug(""Exited MailManager:processEmail: Not sending email as conditions not met"");
		 }
		 return;
	 }
	 Session session = Session.getDefaultInstance(getMailHostConfiguration());
	 MimeMessage mimeMessage = new MimeMessage(session);
	 String subject = emailData.subject;
	 String message = emailData.message;
	 String mailToList = getMailToAddressesAsString();
	 try {
		 for (int i = 0;
		 i < mailToAddresses.length;
		 i++) {
			 mimeMessage.addRecipient(Message.RecipientType.TO, new InternetAddress(mailToAddresses[i]));
		 }
		 if (subject == null) {
			 subject = ""Alert from GemFire Admin Agent"";
		 }
		 mimeMessage.setSubject(subject);
		 if (message == null) {
			 message = """";
		 }
		 mimeMessage.setText(message);
		 Transport.send(mimeMessage);
		 logger.info(""Email sent to {
		}
		. Subject: {
		}
		, Content: {
		}
		"", new Object[] {
		mailToList, subject, message}
		);
	 }
	 catch (VirtualMachineError err) {
		 SystemFailure.initiateFailure(err);
		 throw err;
	 }
	 catch (Throwable ex) {
		 SystemFailure.checkFailure();
		 StringBuilder buf = new StringBuilder();
		 buf.append(""An exception occurred while sending email."");
		 buf.append( ""Unable to send email. Please check your mail settings and the log file."");
		 buf.append(""\n\n"").append( String.format(""Exception message: %s"", ex.getMessage()));
		 buf.append(""\n\n"").append( ""Following email was not delivered:"");
		 buf.append(""\n\t"") .append(String.format(""Mail Host: %s"", mailHost));
		 buf.append(""\n\t"").append(String.format(""From: %s"", mailFrom));
		 buf.append(""\n\t"").append(String.format(""To: %s"", mailToList));
		 buf.append(""\n\t"").append(String.format(""Subject: %s"", subject));
		 buf.append(""\n\t"").append(String.format(""Content: %s"", message));
		 logger.error(buf.toString(), ex);
	 }
	 if (logger.isTraceEnabled()) {
		 logger.trace(""Exited MailManager:processEmail"");
	 }
 }",0,0,1,0
"public int run(String[] args) throws Exception {
	 boolean dumpText = false;
	 boolean force = false;
	 String contentType = null;
	 String url = null;
	 String usage = ""Usage: ParserChecker [-dumpText] [-forceAs mimeType] url"";
	 if (args.length == 0) {
		 System.err.println(usage);
		 System.exit(-1);
	 }
	 for (int i = 0;
	 i < args.length;
	 i++) {
		 if (args[i].equals(""-forceAs"")) {
			 force = true;
			 contentType = args[++i];
		 }
		 else if (args[i].equals(""-dumpText"")) {
			 dumpText = true;
		 }
		 else if (i != args.length - 1) {
			 System.err.println(usage);
			 System.exit(-1);
		 }
		 else {
			 url = args[i];
		 }
	 }
	 if (LOG.isInfoEnabled()) {
		 LOG.info(""fetching: "" + url);
	 }
	 ProtocolFactory factory = new ProtocolFactory(conf);
	 Protocol protocol = factory.getProtocol(url);
	 Content content = protocol.getProtocolOutput(new Text(url), new CrawlDatum()).getContent();
	 if (content == null) {
		 System.err.println(""Can't fetch URL successfully"");
		 return (-1);
	 }
	 if (force) {
		 content.setContentType(contentType);
	 }
	 else {
		 contentType = content.getContentType();
	 }
	 if (contentType == null) {
		 System.err.println("""");
		 return (-1);
	 }
	 if (LOG.isInfoEnabled()) {
		 LOG.info(""parsing: "" + url);
		 LOG.info(""contentType: "" + contentType);
	 }
	 ParseResult parseResult = new ParseUtil(conf).parse(content);
	 for (java.util.Map.Entry<Text, Parse> entry : parseResult) {
		 Parse parse = entry.getValue();
		 System.out.print(""---------\nUrl\n---------------\n"");
		 System.out.print(entry.getKey());
		 System.out.print(""---------\nParseData\n---------\n"");
		 System.out.print(parse.getData().toString());
		 if (dumpText) {
			 System.out.print(""---------\nParseText\n---------\n"");
			 System.out.print(parse.getText());
		 }
	 }
	 return 0;
 }",0,0,0,0
"public void reportItems(CaldavRequest request) throws IOException {
	 String folderPath = request.getFolderPath();
	 List<ExchangeSession.Event> events;
	 List<String> notFound = new ArrayList<String>();
	 CaldavResponse response = new CaldavResponse(HttpStatus.SC_MULTI_STATUS);
	 response.startMultistatus();
	 if (request.isMultiGet()) {
		 int count = 0;
		 int total = request.getHrefs().size();
		 for (String href : request.getHrefs()) {
			 DavGatewayTray.debug(new BundleMessage(""LOG_REPORT_ITEM"", ++count, total));
			 DavGatewayTray.switchIcon();
			 String eventName = getEventFileNameFromPath(href);
			 try {
				 if (eventName != null && eventName.length() > 0 && !""inbox"".equals(eventName) && !""calendar"".equals(eventName)) {
					 ExchangeSession.Item item;
					 try {
						 item = session.getItem(folderPath, eventName);
					 }
					 catch (HttpNotFoundException e) {
						 if (request.isBrokenLightning() && eventName.indexOf('%') >= 0) {
							 item = session.getItem(folderPath, URIUtil.decode(StringUtil.encodePlusSign(eventName)));
						 }
						 else {
							 throw e;
						 }
					 }
					 appendItemResponse(response, request, item);
				 }
			 }
			 catch (SocketException e) {
				 throw e;
			 }
			 catch (Exception e) {
				 wireLogger.debug(e.getMessage(), e);
				 DavGatewayTray.warn(new BundleMessage(""LOG_ITEM_NOT_AVAILABLE"", eventName, href));
				 notFound.add(href);
			 }
		 }
	 }
	 else if (request.isPath(1, ""users"") && request.isPath(3, ""inbox"")) {
		 events = session.getEventMessages(request.getFolderPath());
		 appendEventsResponses(response, request, events);
	 }
	 else {
		 if (request.vTodoOnly) {
			 events = session.searchTasksOnly(request.getFolderPath());
		 }
		 else if (request.vEventOnly) {
			 events = session.searchEventsOnly(request.getFolderPath(), request.timeRangeStart, request.timeRangeEnd);
		 }
		 else {
			 events = session.searchEvents(request.getFolderPath(), request.timeRangeStart, request.timeRangeEnd);
		 }
		 appendEventsResponses(response, request, events);
	 }
	 for (String href : notFound) {
		 response.startResponse(encodePath(request, href));
		 response.appendPropstatNotFound();
		 response.endResponse();
	 }
	 response.endMultistatus();
	 response.close();
 }",0,0,1,0
"public class OntModelImpl extends ModelCom implements OntModel{
	 static public String owlSyntaxCheckerClassName = ""org.apache.jena.ontology.tidy.JenaChecker"";
	 static private Logger s_log = LoggerFactory.getLogger( OntModelImpl.class );
	 static private Class<?> owlSyntaxCheckerClass;
	 protected OntModelSpec m_spec;
	 protected Set<String> m_imported = new HashSet<>();
	 protected boolean m_strictMode = true;
	 protected MultiUnion m_union = new MultiUnion();
	 protected ImportsListener m_importsListener = null;
	 private Model m_deductionsModel = null;
	 public OntModelImpl( OntModelSpec spec, Model model ) {
		 this( spec, makeBaseModel( spec, model ), true );
	 }
	 public OntModelImpl( OntModelSpec spec ) {
		 this( spec, spec.createBaseModel(), true );
	 }
	 private OntModelImpl( OntModelSpec spec, Model model, boolean withImports ) {
		 super( generateGraph( spec, model.getGraph() ), BuiltinPersonalities.model );
		 m_spec = spec;
		 m_union = (getGraph() instanceof MultiUnion) ? ((MultiUnion) getGraph()) : (MultiUnion) ((InfGraph) getGraph()).getRawGraph();
		 if (withImports) {
			 loadImports();
		 }
		 if (spec != null && spec.getKnownPrefixes() != null) {
			 try {
				 String[][] p = spec.getKnownPrefixes();
				 for ( String[] pair : p ) {
					 setNsPrefix( pair[0], pair[1] );
				 }
			 }
			 catch (Exception ex) {
			}
		 }
		 rebind();
	 }
	 public OntDocumentManager getDocumentManager() {
		 return m_spec.getDocumentManager();
	 }
	 public ExtendedIterator<Ontology> listOntologies() {
		 checkProfileEntry( getProfile().ONTOLOGY(), ""ONTOLOGY"" );
		 return findByTypeAs( getProfile().ONTOLOGY(), Ontology.class ) .filterKeep( new UniqueFilter<Ontology>());
	 }
	 public ExtendedIterator<OntProperty> listOntProperties() {
		 ExtendedIterator<OntProperty> i = findByTypeAs( RDF.Property, OntProperty.class ) .filterKeep( new UniqueFilter<OntProperty>());
		 if (getReasoner() != null && getProfile().equals( ProfileRegistry.getInstance().getProfile( ProfileRegistry.OWL_LANG ) )) {
			 i = i.andThen( listAnnotationProperties() );
		 }
		 return i;
	 }
	 public ExtendedIterator<OntProperty> listAllOntProperties() {
		 ExtendedIterator<OntProperty> i = findByTypeAs( RDF.Property, OntProperty.class ) .andThen( listObjectProperties() ) .andThen( listDatatypeProperties() ) .andThen( listAnnotationProperties() ) .andThen( listFunctionalProperties() ) .andThen( listTransitiveProperties() ) .andThen( listSymmetricProperties() );
		 return i.filterKeep( new UniqueFilter<OntProperty>());
	 }
	 public ExtendedIterator<ObjectProperty> listObjectProperties() {
		 checkProfileEntry( getProfile().OBJECT_PROPERTY(), ""OBJECT_PROPERTY"" );
		 return findByTypeAs( getProfile().OBJECT_PROPERTY(), ObjectProperty.class ) .filterKeep( new UniqueFilter<ObjectProperty>());
	 }
	 public ExtendedIterator<DatatypeProperty> listDatatypeProperties() {
		 checkProfileEntry( getProfile().DATATYPE_PROPERTY(), ""DATATYPE_PROPERTY"" );
		 return findByTypeAs( getProfile().DATATYPE_PROPERTY(), DatatypeProperty.class ) .filterKeep( new UniqueFilter<DatatypeProperty>());
	 }
	 public ExtendedIterator<FunctionalProperty> listFunctionalProperties() {
		 checkProfileEntry( getProfile().FUNCTIONAL_PROPERTY(), ""FUNCTIONAL_PROPERTY"" );
		 return findByTypeAs( getProfile().FUNCTIONAL_PROPERTY(), FunctionalProperty.class ) .filterKeep( new UniqueFilter<FunctionalProperty>());
	 }
	 public ExtendedIterator<TransitiveProperty> listTransitiveProperties() {
		 checkProfileEntry( getProfile().TRANSITIVE_PROPERTY(), ""TRANSITIVE_PROPERTY"" );
		 return findByTypeAs( getProfile().TRANSITIVE_PROPERTY(), TransitiveProperty.class ) .filterKeep( new UniqueFilter<TransitiveProperty>());
	 }
	 public ExtendedIterator<SymmetricProperty> listSymmetricProperties() {
		 checkProfileEntry( getProfile().SYMMETRIC_PROPERTY(), ""SYMMETRIC_PROPERTY"" );
		 return findByTypeAs( getProfile().SYMMETRIC_PROPERTY(), SymmetricProperty.class ) .filterKeep( new UniqueFilter<SymmetricProperty>());
	 }
	 public ExtendedIterator<InverseFunctionalProperty> listInverseFunctionalProperties() {
		 checkProfileEntry( getProfile().INVERSE_FUNCTIONAL_PROPERTY(), ""INVERSE_FUNCTIONAL_PROPERTY"" );
		 return findByTypeAs( getProfile().INVERSE_FUNCTIONAL_PROPERTY(), InverseFunctionalProperty.class ) .filterKeep( new UniqueFilter<InverseFunctionalProperty>());
	 }
	 public ExtendedIterator<Individual> listIndividuals() {
		 boolean supportsIndAsThing = false;
		 if (getGraph() instanceof InfGraph) {
			 supportsIndAsThing = ((InfGraph) getGraph()).getReasoner() .getReasonerCapabilities() .contains( null, ReasonerVocabulary.supportsP, ReasonerVocabulary.individualAsThingP );
		 }
		 if (!supportsIndAsThing || (getProfile().THING() == null) || getProfile().CLASS().equals( RDFS.Class )) {
			 Set<Individual> results = new HashSet<>();
			 for (Iterator<Statement> i = listStatements( null, RDF.type, (RDFNode) null);
			 i.hasNext();
			 ) {
				 OntResource r = i.next().getSubject().as( OntResource.class );
				 if (r.isIndividual()) {
					 results.add( r.as( Individual.class ) );
				 }
			 }
			 return WrappedIterator.create( results.iterator() );
		 }
		 else {
			 return findByTypeAs( getProfile().THING(), Individual.class ).filterKeep( new UniqueFilter<Individual>());
		 }
	 }
	 public ExtendedIterator<Individual> listIndividuals( Resource cls ) {
		 return findByTypeAs( cls, Individual.class ) .filterKeep( new UniqueFilter<Individual>());
	 }
	 public ExtendedIterator<OntClass> listClasses() {
		 return findByTypeAs( getProfile().getClassDescriptionTypes(), OntClass.class ) .filterKeep( new UniqueFilter<OntClass>());
	 }
	 public ExtendedIterator<OntClass> listHierarchyRootClasses() {
		 if (getReasoner() != null) {
			 Model conf = getReasoner().getReasonerCapabilities();
			 if (conf != null && conf.contains( null, ReasonerVocabulary.supportsP, ReasonerVocabulary.directSubClassOf ) && getProfile().THING() != null) {
				 return listStatements( null, ReasonerVocabulary.directSubClassOf, getProfile().THING() ) .mapWith( s -> s.getSubject().as( OntClass.class ));
			 }
		 }
		 return listClasses() .filterDrop( OntResource::isOntLanguageTerm ) .filterKeep( OntClass::isHierarchyRoot );
	 }
	 public ExtendedIterator<EnumeratedClass> listEnumeratedClasses() {
		 checkProfileEntry( getProfile().ONE_OF(), ""ONE_OF"" );
		 return findByDefiningPropertyAs( getProfile().ONE_OF(), EnumeratedClass.class ) .filterKeep( new UniqueFilter<EnumeratedClass>());
	 }
	 public ExtendedIterator<UnionClass> listUnionClasses() {
		 checkProfileEntry( getProfile().UNION_OF(), ""UNION_OF"" );
		 return findByDefiningPropertyAs( getProfile().UNION_OF(), UnionClass.class ) .filterKeep( new UniqueFilter<UnionClass>());
	 }
	 public ExtendedIterator<ComplementClass> listComplementClasses() {
		 checkProfileEntry( getProfile().COMPLEMENT_OF(), ""COMPLEMENT_OF"" );
		 return findByDefiningPropertyAs( getProfile().COMPLEMENT_OF(), ComplementClass.class ) .filterKeep( new UniqueFilter<ComplementClass>());
	 }
	 public ExtendedIterator<IntersectionClass> listIntersectionClasses() {
		 checkProfileEntry( getProfile().INTERSECTION_OF(), ""INTERSECTION_OF"" );
		 return findByDefiningPropertyAs( getProfile().INTERSECTION_OF(), IntersectionClass.class ) .filterKeep( new UniqueFilter<IntersectionClass>());
	 }
	 public ExtendedIterator<OntClass> listNamedClasses() {
		 return listClasses().filterDrop( OntClass::isAnon );
	 }
	 public ExtendedIterator<Restriction> listRestrictions() {
		 checkProfileEntry( getProfile().RESTRICTION(), ""RESTRICTION"" );
		 return findByTypeAs( getProfile().RESTRICTION(), Restriction.class ) .filterKeep( new UniqueFilter<Restriction>());
	 }
	 public ExtendedIterator<AllDifferent> listAllDifferent() {
		 checkProfileEntry( getProfile().ALL_DIFFERENT(), ""ALL_DIFFERENT"" );
		 return findByTypeAs( getProfile().ALL_DIFFERENT(), AllDifferent.class ) .filterKeep( new UniqueFilter<AllDifferent>());
	 }
	 public ExtendedIterator<DataRange> listDataRanges() {
		 checkProfileEntry( getProfile().DATARANGE(), ""DATARANGE"" );
		 return findByTypeAs( getProfile().DATARANGE(), DataRange.class ) .filterKeep( new UniqueFilter<DataRange>());
	 }
	 public ExtendedIterator<AnnotationProperty> listAnnotationProperties() {
		 checkProfileEntry( getProfile().ANNOTATION_PROPERTY(), ""ANNOTATION_PROPERTY"" );
		 Resource r = getProfile().ANNOTATION_PROPERTY();
		 if (r == null) {
			 return new NullIterator<>();
		 }
		 else {
			 return findByType( r ) .mapWith( p -> getNodeAs( p.getSubject(), AnnotationProperty.class ) ) .filterKeep( new UniqueFilter<AnnotationProperty>());
		 }
	 }
	 public Ontology getOntology( String uri ) {
		 return (Ontology) findByURIAs( uri, Ontology.class );
	 }
	 public Individual getIndividual( String uri ) {
		 return (Individual) findByURIAs( uri, Individual.class );
	 }
	 public OntProperty getOntProperty( String uri ) {
		 return (OntProperty) findByURIAs( uri, OntProperty.class );
	 }
	 public ObjectProperty getObjectProperty( String uri ) {
		 return (ObjectProperty) findByURIAs( uri, ObjectProperty.class );
	 }
	 public TransitiveProperty getTransitiveProperty( String uri ) {
		 return (TransitiveProperty) findByURIAs( uri, TransitiveProperty.class );
	 }
	 public SymmetricProperty getSymmetricProperty( String uri ) {
		 return (SymmetricProperty) findByURIAs( uri, SymmetricProperty.class );
	 }
	 public InverseFunctionalProperty getInverseFunctionalProperty( String uri ) {
		 return (InverseFunctionalProperty) findByURIAs( uri, InverseFunctionalProperty.class );
	 }
	 public DatatypeProperty getDatatypeProperty( String uri ) {
		 return (DatatypeProperty) findByURIAs( uri, DatatypeProperty.class );
	 }
	 public AnnotationProperty getAnnotationProperty( String uri ) {
		 return (AnnotationProperty) findByURIAs( uri, AnnotationProperty.class );
	 }
	 public OntClass getOntClass( String uri ) {
		 OntClass c = (OntClass) findByURIAs( uri, OntClass.class );
		 if (c == null) {
			 Resource thing = getProfile().THING();
			 if (thing != null && thing.getURI().equals( uri )) {
				 c = thing.inModel( this ).as( OntClass.class );
			 }
			 Resource nothing = getProfile().NOTHING();
			 if (nothing != null && nothing.getURI().equals( uri )) {
				 c = nothing.inModel( this ).as( OntClass.class );
			 }
		 }
		 return c;
	 }
	 public ComplementClass getComplementClass( String uri ) {
		 return (ComplementClass) findByURIAs( uri, ComplementClass.class );
	 }
	 public EnumeratedClass getEnumeratedClass( String uri ) {
		 return (EnumeratedClass) findByURIAs( uri, EnumeratedClass.class );
	 }
	 public UnionClass getUnionClass( String uri ) {
		 return (UnionClass) findByURIAs( uri, UnionClass.class );
	 }
	 public IntersectionClass getIntersectionClass( String uri ) {
		 return (IntersectionClass) findByURIAs( uri, IntersectionClass.class );
	 }
	 public Restriction getRestriction( String uri ) {
		 return (Restriction) findByURIAs( uri, Restriction.class );
	 }
	 public HasValueRestriction getHasValueRestriction( String uri ) {
		 return (HasValueRestriction) findByURIAs( uri, HasValueRestriction.class );
	 }
	 public SomeValuesFromRestriction getSomeValuesFromRestriction( String uri ) {
		 return (SomeValuesFromRestriction) findByURIAs( uri, SomeValuesFromRestriction.class );
	 }
	 public AllValuesFromRestriction getAllValuesFromRestriction( String uri ) {
		 return (AllValuesFromRestriction) findByURIAs( uri, AllValuesFromRestriction.class );
	 }
	 public CardinalityRestriction getCardinalityRestriction( String uri ) {
		 return (CardinalityRestriction) findByURIAs( uri, CardinalityRestriction.class );
	 }
	 public MinCardinalityRestriction getMinCardinalityRestriction( String uri ) {
		 return (MinCardinalityRestriction) findByURIAs( uri, MinCardinalityRestriction.class );
	 }
	 public MaxCardinalityRestriction getMaxCardinalityRestriction( String uri ) {
		 return (MaxCardinalityRestriction) findByURIAs( uri, MaxCardinalityRestriction.class );
	 }
	 public QualifiedRestriction getQualifiedRestriction( String uri ) {
		 return (QualifiedRestriction) findByURIAs( uri, QualifiedRestriction.class );
	 }
	 public CardinalityQRestriction getCardinalityQRestriction( String uri ) {
		 return (CardinalityQRestriction) findByURIAs( uri, CardinalityQRestriction.class );
	 }
	 public MinCardinalityQRestriction getMinCardinalityQRestriction( String uri ) {
		 return (MinCardinalityQRestriction) findByURIAs( uri, MinCardinalityQRestriction.class );
	 }
	 public MaxCardinalityQRestriction getMaxCardinalityQRestriction( String uri ) {
		 return (MaxCardinalityQRestriction) findByURIAs( uri, MaxCardinalityQRestriction.class );
	 }
	 public Ontology createOntology( String uri ) {
		 checkProfileEntry( getProfile().ONTOLOGY(), ""ONTOLOGY"" );
		 return createOntResource( Ontology.class, getProfile().ONTOLOGY(), uri );
	 }
	 public Individual createIndividual( Resource cls ) {
		 return createOntResource( Individual.class, cls, null );
	 }
	 public Individual createIndividual( String uri, Resource cls ) {
		 return createOntResource( Individual.class, cls, uri );
	 }
	 public OntProperty createOntProperty( String uri ) {
		 Property p = createProperty( uri );
		 p.addProperty( RDF.type, getProfile().PROPERTY() );
		 return p.as( OntProperty.class );
	 }
	 public ObjectProperty createObjectProperty( String uri ) {
		 return createObjectProperty( uri, false );
	 }
	 public ObjectProperty createObjectProperty( String uri, boolean functional ) {
		 checkProfileEntry( getProfile().OBJECT_PROPERTY(), ""OBJECT_PROPERTY"" );
		 ObjectProperty p = createOntResource( ObjectProperty.class, getProfile().OBJECT_PROPERTY(), uri );
		 if (functional) {
			 checkProfileEntry( getProfile().FUNCTIONAL_PROPERTY(), ""FUNCTIONAL_PROPERTY"" );
			 p.addProperty( RDF.type, getProfile().FUNCTIONAL_PROPERTY() );
		 }
		 return p;
	 }
	 public TransitiveProperty createTransitiveProperty( String uri ) {
		 return createTransitiveProperty( uri, false );
	 }
	 public TransitiveProperty createTransitiveProperty( String uri, boolean functional ) {
		 checkProfileEntry( getProfile().TRANSITIVE_PROPERTY(), ""TRANSITIVE_PROPERTY"" );
		 TransitiveProperty p = createOntResource( TransitiveProperty.class, getProfile().TRANSITIVE_PROPERTY(), uri );
		 if (functional) {
			 checkProfileEntry( getProfile().FUNCTIONAL_PROPERTY(), ""FUNCTIONAL_PROPERTY"" );
			 p.addProperty( RDF.type, getProfile().FUNCTIONAL_PROPERTY() );
		 }
		 return p;
	 }
	 public SymmetricProperty createSymmetricProperty( String uri ) {
		 return createSymmetricProperty( uri, false );
	 }
	 public SymmetricProperty createSymmetricProperty( String uri, boolean functional ) {
		 checkProfileEntry( getProfile().SYMMETRIC_PROPERTY(), ""SYMMETRIC_PROPERTY"" );
		 SymmetricProperty p = createOntResource( SymmetricProperty.class, getProfile().SYMMETRIC_PROPERTY(), uri );
		 if (functional) {
			 checkProfileEntry( getProfile().FUNCTIONAL_PROPERTY(), ""FUNCTIONAL_PROPERTY"" );
			 p.addProperty( RDF.type, getProfile().FUNCTIONAL_PROPERTY() );
		 }
		 return p;
	 }
	 public InverseFunctionalProperty createInverseFunctionalProperty( String uri ) {
		 return createInverseFunctionalProperty( uri, false );
	 }
	 public InverseFunctionalProperty createInverseFunctionalProperty( String uri, boolean functional ) {
		 checkProfileEntry( getProfile().INVERSE_FUNCTIONAL_PROPERTY(), ""INVERSE_FUNCTIONAL_PROPERTY"" );
		 InverseFunctionalProperty p = createOntResource( InverseFunctionalProperty.class, getProfile().INVERSE_FUNCTIONAL_PROPERTY(), uri );
		 if (functional) {
			 checkProfileEntry( getProfile().FUNCTIONAL_PROPERTY(), ""FUNCTIONAL_PROPERTY"" );
			 p.addProperty( RDF.type, getProfile().FUNCTIONAL_PROPERTY() );
		 }
		 return p;
	 }
	 public DatatypeProperty createDatatypeProperty( String uri ) {
		 return createDatatypeProperty( uri, false );
	 }
	 public DatatypeProperty createDatatypeProperty( String uri, boolean functional ) {
		 checkProfileEntry( getProfile().DATATYPE_PROPERTY(), ""DATATYPE_PROPERTY"" );
		 DatatypeProperty p = createOntResource( DatatypeProperty.class, getProfile().DATATYPE_PROPERTY(), uri );
		 if (functional) {
			 checkProfileEntry( getProfile().FUNCTIONAL_PROPERTY(), ""FUNCTIONAL_PROPERTY"" );
			 p.addProperty( RDF.type, getProfile().FUNCTIONAL_PROPERTY() );
		 }
		 return p;
	 }
	 public AnnotationProperty createAnnotationProperty( String uri ) {
		 checkProfileEntry( getProfile().ANNOTATION_PROPERTY(), ""ANNOTATION_PROPERTY"" );
		 return createOntResource( AnnotationProperty.class, getProfile().ANNOTATION_PROPERTY(), uri );
	 }
	 public OntClass createClass() {
		 checkProfileEntry( getProfile().CLASS(), ""CLASS"" );
		 return createOntResource( OntClass.class, getProfile().CLASS(), null );
	 }
	 public OntClass createClass( String uri ) {
		 checkProfileEntry( getProfile().CLASS(), ""CLASS"" );
		 return createOntResource( OntClass.class, getProfile().CLASS(), uri );
	 }
	 public ComplementClass createComplementClass( String uri, Resource cls ) {
		 checkProfileEntry( getProfile().CLASS(), ""CLASS"" );
		 OntClass c = createOntResource( OntClass.class, getProfile().CLASS(), uri );
		 checkProfileEntry( getProfile().COMPLEMENT_OF(), ""COMPLEMENT_OF"" );
		 c.addProperty( getProfile().COMPLEMENT_OF(), (cls == null) ? getProfile().NOTHING() : cls );
		 return c.as( ComplementClass.class );
	 }
	 public EnumeratedClass createEnumeratedClass( String uri, RDFList members ) {
		 checkProfileEntry( getProfile().CLASS(), ""CLASS"" );
		 OntClass c = createOntResource( OntClass.class, getProfile().CLASS(), uri );
		 checkProfileEntry( getProfile().ONE_OF(), ""ONE_OF"" );
		 c.addProperty( getProfile().ONE_OF(), (members == null) ? createList() : members );
		 return c.as( EnumeratedClass.class );
	 }
	 public UnionClass createUnionClass( String uri, RDFList members ) {
		 checkProfileEntry( getProfile().CLASS(), ""CLASS"" );
		 OntClass c = createOntResource( OntClass.class, getProfile().CLASS(), uri );
		 checkProfileEntry( getProfile().UNION_OF(), ""UNION_OF"" );
		 c.addProperty( getProfile().UNION_OF(), (members == null) ? createList() : members );
		 return c.as( UnionClass.class );
	 }
	 public IntersectionClass createIntersectionClass( String uri, RDFList members ) {
		 checkProfileEntry( getProfile().CLASS(), ""CLASS"" );
		 OntClass c = createOntResource( OntClass.class, getProfile().CLASS(), uri );
		 checkProfileEntry( getProfile().INTERSECTION_OF(), ""INTERSECTION_OF"" );
		 c.addProperty( getProfile().INTERSECTION_OF(), (members == null) ? createList() : members );
		 return c.as( IntersectionClass.class );
	 }
	 public Restriction createRestriction( Property p ) {
		 checkProfileEntry( getProfile().RESTRICTION(), ""RESTRICTION"" );
		 Restriction r = createOntResource( Restriction.class, getProfile().RESTRICTION(), null );
		 if (p != null) {
			 r.setOnProperty( p );
		 }
		 return r;
	 }
	 public Restriction createRestriction( String uri, Property p ) {
		 checkProfileEntry( getProfile().RESTRICTION(), ""RESTRICTION"" );
		 Restriction r = createOntResource( Restriction.class, getProfile().RESTRICTION(), uri );
		 if (p != null) {
			 r.setOnProperty( p );
		 }
		 return r;
	 }
	 public HasValueRestriction createHasValueRestriction( String uri, Property prop, RDFNode value ) {
		 checkProfileEntry( getProfile().RESTRICTION(), ""RESTRICTION"" );
		 Restriction r = createOntResource( Restriction.class, getProfile().RESTRICTION(), uri );
		 if (prop == null || value == null) {
			 throw new IllegalArgumentException( ""Cannot create hasValueRestriction with a null property or value"" );
		 }
		 checkProfileEntry( getProfile().HAS_VALUE(), ""HAS_VALUE"" );
		 r.addProperty( getProfile().ON_PROPERTY(), prop );
		 r.addProperty( getProfile().HAS_VALUE(), value );
		 return r.as( HasValueRestriction.class );
	 }
	 public SomeValuesFromRestriction createSomeValuesFromRestriction( String uri, Property prop, Resource cls ) {
		 checkProfileEntry( getProfile().RESTRICTION(), ""RESTRICTION"" );
		 Restriction r = createOntResource( Restriction.class, getProfile().RESTRICTION(), uri );
		 if (prop == null || cls == null) {
			 throw new IllegalArgumentException( ""Cannot create someValuesFromRestriction with a null property or class"" );
		 }
		 checkProfileEntry( getProfile().SOME_VALUES_FROM(), ""SOME_VALUES_FROM"" );
		 r.addProperty( getProfile().ON_PROPERTY(), prop );
		 r.addProperty( getProfile().SOME_VALUES_FROM(), cls );
		 return r.as( SomeValuesFromRestriction.class );
	 }
	 public AllValuesFromRestriction createAllValuesFromRestriction( String uri, Property prop, Resource cls ) {
		 checkProfileEntry( getProfile().RESTRICTION(), ""RESTRICTION"" );
		 Restriction r = createOntResource( Restriction.class, getProfile().RESTRICTION(), uri );
		 if (prop == null || cls == null) {
			 throw new IllegalArgumentException( ""Cannot create allValuesFromRestriction with a null property or class"" );
		 }
		 checkProfileEntry( getProfile().ALL_VALUES_FROM(), ""ALL_VALUES_FROM"" );
		 r.addProperty( getProfile().ON_PROPERTY(), prop );
		 r.addProperty( getProfile().ALL_VALUES_FROM(), cls );
		 return r.as( AllValuesFromRestriction.class );
	 }
	 public CardinalityRestriction createCardinalityRestriction( String uri, Property prop, int cardinality ) {
		 checkProfileEntry( getProfile().RESTRICTION(), ""RESTRICTION"" );
		 Restriction r = createOntResource( Restriction.class, getProfile().RESTRICTION(), uri );
		 if (prop == null) {
			 throw new IllegalArgumentException( ""Cannot create cardinalityRestriction with a null property"" );
		 }
		 checkProfileEntry( getProfile().CARDINALITY(), ""CARDINALITY"" );
		 r.addProperty( getProfile().ON_PROPERTY(), prop );
		 r.addProperty( getProfile().CARDINALITY(), createTypedLiteral( cardinality ) );
		 return r.as( CardinalityRestriction.class );
	 }
	 public MinCardinalityRestriction createMinCardinalityRestriction( String uri, Property prop, int cardinality ) {
		 checkProfileEntry( getProfile().RESTRICTION(), ""RESTRICTION"" );
		 Restriction r = createOntResource( Restriction.class, getProfile().RESTRICTION(), uri );
		 if (prop == null) {
			 throw new IllegalArgumentException( ""Cannot create minCardinalityRestriction with a null property"" );
		 }
		 checkProfileEntry( getProfile().MIN_CARDINALITY(), ""MIN_CARDINALITY"" );
		 r.addProperty( getProfile().ON_PROPERTY(), prop );
		 r.addProperty( getProfile().MIN_CARDINALITY(), createTypedLiteral( cardinality ) );
		 return r.as( MinCardinalityRestriction.class );
	 }
	 public MaxCardinalityRestriction createMaxCardinalityRestriction( String uri, Property prop, int cardinality ) {
		 checkProfileEntry( getProfile().RESTRICTION(), ""RESTRICTION"" );
		 Restriction r = createOntResource( Restriction.class, getProfile().RESTRICTION(), uri );
		 if (prop == null) {
			 throw new IllegalArgumentException( ""Cannot create maxCardinalityRestriction with a null property"" );
		 }
		 checkProfileEntry( getProfile().MAX_CARDINALITY(), ""MAX_CARDINALITY"" );
		 r.addProperty( getProfile().ON_PROPERTY(), prop );
		 r.addProperty( getProfile().MAX_CARDINALITY(), createTypedLiteral( cardinality ) );
		 return r.as( MaxCardinalityRestriction.class );
	 }
	 public MaxCardinalityQRestriction createMaxCardinalityQRestriction( String uri, Property prop, int cardinality, OntClass cls ) {
		 checkProfileEntry( getProfile().RESTRICTION(), ""RESTRICTION"" );
		 checkProfileEntry( getProfile().ON_PROPERTY(), ""ON_PROPERTY"" );
		 checkProfileEntry( getProfile().MAX_CARDINALITY_Q(), ""MAX_CARDINALITY_Q"" );
		 checkProfileEntry( getProfile().HAS_CLASS_Q(), ""HAS_CLASS_Q"" );
		 if (prop == null) {
			 throw new IllegalArgumentException( ""Cannot create MaxCardinalityQRestriction with a null property"" );
		 }
		 if (cls == null) {
			 throw new IllegalArgumentException( ""Cannot create MaxCardinalityQRestriction with a null class"" );
		 }
		 Restriction r = createOntResource( Restriction.class, getProfile().RESTRICTION(), uri );
		 r.addProperty( getProfile().ON_PROPERTY(), prop );
		 r.addProperty( getProfile().MAX_CARDINALITY_Q(), createTypedLiteral( cardinality ) );
		 r.addProperty( getProfile().HAS_CLASS_Q(), cls );
		 return r.as( MaxCardinalityQRestriction.class );
	 }
	 public MinCardinalityQRestriction createMinCardinalityQRestriction( String uri, Property prop, int cardinality, OntClass cls ) {
		 checkProfileEntry( getProfile().RESTRICTION(), ""RESTRICTION"" );
		 checkProfileEntry( getProfile().ON_PROPERTY(), ""ON_PROPERTY"" );
		 checkProfileEntry( getProfile().MIN_CARDINALITY_Q(), ""MIN_CARDINALITY_Q"" );
		 checkProfileEntry( getProfile().HAS_CLASS_Q(), ""HAS_CLASS_Q"" );
		 if (prop == null) {
			 throw new IllegalArgumentException( ""Cannot create MinCardinalityQRestriction with a null property"" );
		 }
		 if (cls == null) {
			 throw new IllegalArgumentException( ""Cannot create MinCardinalityQRestriction with a null class"" );
		 }
		 Restriction r = createOntResource( Restriction.class, getProfile().RESTRICTION(), uri );
		 r.addProperty( getProfile().ON_PROPERTY(), prop );
		 r.addProperty( getProfile().MIN_CARDINALITY_Q(), createTypedLiteral( cardinality ) );
		 r.addProperty( getProfile().HAS_CLASS_Q(), cls );
		 return r.as( MinCardinalityQRestriction.class );
	 }
	 public CardinalityQRestriction createCardinalityQRestriction( String uri, Property prop, int cardinality, OntClass cls ) {
		 checkProfileEntry( getProfile().RESTRICTION(), ""RESTRICTION"" );
		 checkProfileEntry( getProfile().ON_PROPERTY(), ""ON_PROPERTY"" );
		 checkProfileEntry( getProfile().CARDINALITY_Q(), ""CARDINALITY_Q"" );
		 checkProfileEntry( getProfile().HAS_CLASS_Q(), ""HAS_CLASS_Q"" );
		 if (prop == null) {
			 throw new IllegalArgumentException( ""Cannot create CardinalityQRestriction with a null property"" );
		 }
		 if (cls == null) {
			 throw new IllegalArgumentException( ""Cannot create CardinalityQRestriction with a null class"" );
		 }
		 Restriction r = createOntResource( Restriction.class, getProfile().RESTRICTION(), uri );
		 r.addProperty( getProfile().ON_PROPERTY(), prop );
		 r.addProperty( getProfile().CARDINALITY_Q(), createTypedLiteral( cardinality ) );
		 r.addProperty( getProfile().HAS_CLASS_Q(), cls );
		 return r.as( CardinalityQRestriction.class );
	 }
	 public DataRange createDataRange( RDFList literals ) {
		 checkProfileEntry( getProfile().DATARANGE(), ""DATARANGE"" );
		 DataRange d = createOntResource( DataRange.class, getProfile().DATARANGE(), null );
		 checkProfileEntry( getProfile().ONE_OF(), ""ONE_OF"" );
		 d.addProperty( getProfile().ONE_OF(), (literals == null) ? createList() : literals );
		 return d;
	 }
	 public AllDifferent createAllDifferent() {
		 return createAllDifferent( null );
	 }
	 public AllDifferent createAllDifferent( RDFList differentMembers ) {
		 checkProfileEntry( getProfile().ALL_DIFFERENT(), ""ALL_DIFFERENT"" );
		 AllDifferent ad = createOntResource( AllDifferent.class, getProfile().ALL_DIFFERENT(), null );
		 ad.setDistinctMembers( (differentMembers == null) ? createList() : differentMembers );
		 return ad;
	 }
	 public <T extends OntResource> T createOntResource( Class<T> javaClass, Resource rdfType, String uri ) {
		 return getResourceWithType( uri, rdfType ).as( javaClass );
	 }
	 public OntResource createOntResource( String uri ) {
		 return getResource( uri ).as( OntResource.class );
	 }
	 public RDFList createList() {
		 Resource list = getResource( getProfile().NIL().getURI() );
		 return list.as( RDFList.class );
	 }
	 public Profile getProfile() {
		 return m_spec.getProfile();
	 }
	 public void loadImports() {
		 getDocumentManager().loadImports( this );
	 }
	 public boolean hasLoadedImport( String uri ) {
		 uri = OntResolve.resolve(uri);
		 return m_imported.contains( uri );
	 }
	 public void addLoadedImport( String uri ) {
		 uri = OntResolve.resolve(uri);
		 m_imported.add( uri );
	 }
	 public void removeLoadedImport( String uri ) {
		 uri = OntResolve.resolve(uri);
		 m_imported.remove( uri );
	 }
	 public Set<String> listImportedOntologyURIs() {
		 return listImportedOntologyURIs( false );
	 }
	 public Set<String> listImportedOntologyURIs( boolean closure ) {
		 Set<String> results = new HashSet<>();
		 List<Model> queue = new ArrayList<>();
		 queue.add( getBaseModel() );
		 while (!queue.isEmpty()) {
			 Model m = queue.remove( 0 );
			 if (getProfile().ONTOLOGY() != null && getProfile().IMPORTS() != null) {
				 StmtIterator i = m.listStatements(null, getProfile().IMPORTS(), (RDFNode)null);
				 while (i.hasNext()) {
					 Statement s = i.nextStatement();
					 String uri = s.getResource().getURI();
					 if (!results.contains( uri )) {
						 results.add( uri );
						 Model mi = getDocumentManager().getModel( uri );
						 if (closure && mi != null && !queue.contains( mi )) {
							 queue.add( mi );
						 }
					 }
				 }
			 }
		 }
		 return results;
	 }
	 public ModelMaker getImportModelMaker() {
		 return m_spec.getImportModelMaker();
	 }
	 public ModelMaker getModelMaker() {
		 return getImportModelMaker();
	 }
	 public Model read( String uri ) {
		 return read( uri, null, null );
	 }
	 public Model read( Reader reader, String base ) {
		 super.read( reader, base );
		 loadImports();
		 rebind();
		 return this;
	 }
	 public Model read(InputStream reader, String base) {
		 super.read( reader, base );
		 loadImports();
		 rebind();
		 return this;
	 }
	 public Model read( String uri, String syntax ) {
		 return read( uri, null, syntax );
	 }
	 public Model read( String uri, String base, String syntax ) {
		 addLoadedImport( uri );
		 OntDocumentManager odm = getDocumentManager();
		 String sourceURL = odm.doAltURLMapping( uri );
		 String source = odm.getReadHook().beforeRead( this, sourceURL, odm );
		 if (source == null) {
			 s_log.warn( ""ReadHook returned null, so skipping assuming previous value: "" + sourceURL );
			 source = sourceURL;
		 }
		 else {
			 if (base == null && !ignoreFileURI( source ) && source.equals( uri ) ) {
				 if (syntax == null ) {
					 readDelegate( source );
				 }
				 else {
					 readDelegate( source, syntax );
				 }
			 }
			 else {
				 readDelegate( source, (base == null ? uri : base), syntax );
			 }
		 }
		 odm.getReadHook().afterRead( this, source, odm );
		 getDocumentManager().addModel( uri, this );
		 loadImports();
		 rebind();
		 return this;
	 }
	 public Model read(Reader reader, String base, String syntax) {
		 super.read( reader, base, syntax );
		 loadImports();
		 rebind();
		 return this;
	 }
	 public Model read(InputStream reader, String base, String syntax) {
		 super.read( reader, base, syntax );
		 loadImports();
		 rebind();
		 return this;
	 }
	 public List<Graph> getSubGraphs() {
		 return getUnionGraph().getSubGraphs();
	 }
	 public ExtendedIterator<OntModel> listImportedModels() {
		 return listSubModels( true );
	 }
	 public ExtendedIterator<OntModel> listSubModels( final boolean withImports ) {
		 ExtendedIterator<Graph> i = WrappedIterator.create( getSubGraphs().iterator() );
		 return i.mapWith( o -> {
			 Model base = ModelFactory.createModelForGraph( o );
			 OntModel om = new OntModelImpl( m_spec, base, withImports );
			 return om;
		 }
		 );
	 }
	 public ExtendedIterator<OntModel> listSubModels() {
		 return listSubModels( false );
	 }
	 public int countSubModels() {
		 int count = 0;
		 for ( Graph graph1 : getSubGraphs() ) {
			 count++;
		 }
		 return count;
	 }
	 public OntModel getImportedModel( String uri ) {
		 uri = OntResolve.resolve(uri);
		 if (listImportedOntologyURIs( true ).contains( uri )) {
			 Model mi = getDocumentManager().getModel( uri );
			 if (mi != null) {
				 if (mi instanceof OntModel) {
					 return (OntModel) mi;
				 }
				 else {
					 return ModelFactory.createOntologyModel( m_spec, mi );
				 }
			 }
		 }
		 return null;
	 }
	 public Graph getBaseGraph() {
		 return getUnionGraph().getBaseGraph();
	 }
	 public Model getBaseModel() {
		 return ModelFactory.createModelForGraph( getBaseGraph() );
	 }
	 public void addSubModel( Model model) {
		 addSubModel( model, true );
	 }
	 public void addSubModel( Model model, boolean rebind ) {
		 getUnionGraph().addGraph( model.getGraph() );
		 if (rebind) {
			 rebind();
		 }
	 }
	 public void removeSubModel( Model model ) {
		 removeSubModel( model, true );
	 }
	 public void removeSubModel( Model model, boolean rebind ) {
		 Graph subG = model.getGraph();
		 getUnionGraph().removeGraph( subG );
		 if (subG instanceof MultiUnion) {
			 getUnionGraph().removeGraph( ((MultiUnion) subG).getBaseGraph() );
		 }
		 if (rebind) {
			 rebind();
		 }
	 }
	 public boolean isInBaseModel( RDFNode node ) {
		 Node n = node.asNode();
		 Graph b = getBaseGraph();
		 return b.contains( n, Node.ANY, Node.ANY ) || b.contains( Node.ANY, n, Node.ANY ) || b.contains( Node.ANY, Node.ANY, n );
	 }
	 public boolean isInBaseModel( Statement stmt ) {
		 Node s = stmt.getSubject().asNode();
		 Node p = stmt.getPredicate().asNode();
		 Node o = stmt.getObject().asNode();
		 Graph b = getBaseGraph();
		 return b.contains( s, p, o );
	 }
	 public boolean strictMode() {
		 return m_strictMode;
	 }
	 public void setStrictMode( boolean strict ) {
		 m_strictMode = strict;
	 }
	 public void setDynamicImports( boolean dynamic ) {
		 if (dynamic) {
			 if (m_importsListener == null) {
				 m_importsListener = new ImportsListener();
				 register( m_importsListener );
			 }
		 }
		 else {
			 if (m_importsListener != null) {
				 unregister( m_importsListener );
				 m_importsListener = null;
			 }
		 }
	 }
	 public boolean getDynamicImports() {
		 return m_importsListener != null;
	 }
	 public OntModelSpec getSpecification() {
		 return m_spec;
	 }
	 public Model write( Writer writer ) {
		 return getBaseModel().write( writer );
	 }
	 public Model write( Writer writer, String lang ) {
		 return getBaseModel().write( writer, lang );
	 }
	 public Model write( Writer writer, String lang, String base ) {
		 return getBaseModel().write( writer, lang, base );
	 }
	 public Model write( OutputStream out ) {
		 return getBaseModel().write( out );
	 }
	 public Model write( OutputStream out, String lang ) {
		 return getBaseModel().write( out, lang );
	 }
	 public Model write( OutputStream out, String lang, String base) {
		 return getBaseModel().write( out, lang, base );
	 }
	 public Model writeAll( Writer writer, String lang, String base ) {
		 return super.write( writer, lang, base );
	 }
	 public Model writeAll( OutputStream out, String lang, String base ) {
		 return super.write( out, lang, base );
	 }
	 public Model writeAll( Writer writer, String lang ) {
		 return super.write( writer, lang );
	 }
	 public Model writeAll( OutputStream out, String lang) {
		 return super.write( out, lang );
	 }
	 public Model getRawModel() {
		 return getBaseModel();
	 }
	 public Reasoner getReasoner() {
		 return (getGraph() instanceof InfGraph) ? ((InfGraph) getGraph()).getReasoner() : null;
	 }
	 public void rebind() {
		 if (getGraph() instanceof InfGraph) {
			 ((InfGraph) getGraph()).rebind();
		 }
	 }
	 public void prepare() {
		 if (getGraph() instanceof InfGraph) {
			 ((InfGraph) getGraph()).prepare();
		 }
	 }
	 public void reset() {
		 if (getGraph() instanceof InfGraph) {
			 ((InfGraph) getGraph()).reset();
		 }
	 }
	 public Model getDeductionsModel() {
		 if (m_deductionsModel == null) {
			 InfGraph infGraph = getInfGraph();
			 if (infGraph != null) {
				 Graph deductionsGraph = infGraph.getDeductionsGraph();
				 if (deductionsGraph != null) {
					 m_deductionsModel = ModelFactory.createModelForGraph( deductionsGraph );
				 }
			 }
		 }
		 else {
			 getInfGraph().prepare();
		 }
		 return m_deductionsModel;
	 }
	 public ValidityReport validate() {
		 return (getGraph() instanceof InfGraph) ? ((InfGraph) getGraph()).validate() : null;
	 }
	 public StmtIterator listStatements( Resource subject, Property predicate, RDFNode object, Model posit ) {
		 if (getGraph() instanceof InfGraph) {
			 Graph gp = posit == null ? ModelFactory.createDefaultModel().getGraph() : posit.getGraph();
			 Iterator<Triple> iter = getInfGraph().find( asNode(subject), asNode(predicate), asNode(object), gp );
			 return IteratorFactory.asStmtIterator(iter,this);
		 }
		 else {
			 return null;
		 }
	 }
	 public void setDerivationLogging(boolean logOn) {
		 if (getGraph() instanceof InfGraph) {
			 ((InfGraph) getGraph()).setDerivationLogging( logOn );
		 }
	 }
	 public Iterator<Derivation> getDerivation(Statement statement) {
		 return (getGraph() instanceof InfGraph) ? ((InfGraph) getGraph()).getDerivation( statement.asTriple() ) : null;
	 }
	 private static void initSyntaxCheckerClass() {
		 if (owlSyntaxCheckerClass == null ) {
			 try {
				 owlSyntaxCheckerClass = Class.forName(owlSyntaxCheckerClassName);
				 owlSyntaxCheckerClass.getDeclaredConstructor().newInstance();
			 }
			 catch (Exception e){
				 throw new ConfigException(""owlsyntax.jar must be on the classpath."",e);
			 }
		 }
	 }
	 private static Graph generateGraph( OntModelSpec spec, Graph base ) {
		 MultiUnion u = new MultiUnion();
		 u.addGraph( base );
		 u.setBaseGraph( base );
		 Reasoner r = spec.getReasoner();
		 return r == null ? (Graph) u : r.bind( u );
	 }
	 protected MultiUnion getUnionGraph() {
		 return m_union;
	 }
	 protected <T extends Resource> Resource findByURIAs( String uri, Class<T> asKey ) {
		 if (uri == null) {
			 throw new IllegalArgumentException( ""Cannot get() ontology value with a null URI"" );
		 }
		 Node n = NodeFactory.createURI( uri );
		 if (getGraph().contains( n, Node.ANY, Node.ANY )) {
			 try {
				 return getNodeAs( n, asKey );
			 }
			 catch (ConversionException ignore) {
			}
		 }
		 return null;
	 }
	 protected ExtendedIterator<Triple> findByType( Resource type ) {
		 return getGraph().find( null, RDF.type.asNode(), type.asNode() );
	 }
	 protected ExtendedIterator<Triple> findByType( Resource type, Iterator<Resource> alternates ) {
		 ExtendedIterator<Triple> i = findByType( type );
		 if (alternates != null) {
			 while (alternates.hasNext()) {
				 i = i.andThen( findByType( alternates.next() ) );
			 }
		 }
		 return i.filterKeep( new UniqueFilter<Triple>());
	 }
	 protected <T extends RDFNode> ExtendedIterator<T> findByTypeAs( Resource type, Iterator<Resource> types, Class<T> asKey ) {
		 return findByType( type, types ).mapWith( p -> getNodeAs( p.getSubject(), asKey ) );
	 }
	 protected <T extends RDFNode> ExtendedIterator<T> findByTypeAs( Iterator<Resource> types, Class<T> asKey ) {
		 return findByTypeAs( types.next(), types, asKey );
	 }
	 protected <T extends RDFNode> ExtendedIterator<T> findByTypeAs( Resource type, Class<T> asKey ) {
		 return findByType( type ).mapWith( p -> getNodeAs( p.getSubject(), asKey ) );
	 }
	 protected ExtendedIterator<Triple> findByDefiningProperty( Property p ) {
		 return getGraph().find( null, p.asNode(), null );
	 }
	 protected <T extends RDFNode> ExtendedIterator<T> findByDefiningPropertyAs( Property p, Class<T> asKey ) {
		 return findByDefiningProperty( p ).mapWith( x -> getNodeAs( x.getSubject(), asKey ) );
	 }
	 protected Resource getResourceWithType( String uri, Resource rdfType ) {
		 Resource r = getResource( uri );
		 if (rdfType != null) {
			 r.addProperty( RDF.type, rdfType );
		 }
		 return r;
	 }
	 public OntResource getOntResource( String uri ) {
		 Resource r = getResource( uri );
		 if (containsResource( r )) {
			 return r.as( OntResource.class );
		 }
		 return null;
	 }
	 public OntResource getOntResource( Resource res ) {
		 return res.inModel( this ).as( OntResource.class );
	 }
	 protected void checkProfileEntry( Object profileTerm, String desc ) {
		 if (profileTerm == null) {
			 throw new ProfileException( desc, getProfile() );
		 }
	 }
	 protected void checkListMembersRdfType( RDFList list, Resource rdfType ) {
		 if (strictMode() && ! ((Boolean) list.reduce( new RdfTypeTestFn( rdfType), Boolean.TRUE )).booleanValue()) {
			 throw new LanguageConsistencyException( ""The members of the given list are expected to be of rdf:type "" + rdfType.toString() );
		 }
	 }
	 private static Model makeBaseModel( OntModelSpec spec, Model model ) {
		 return model == null ? spec.createBaseModel() : model;
	 }
	 private InfGraph getInfGraph() {
		 return (getGraph() instanceof InfGraph) ? ((InfGraph) getGraph()) : null;
	 }
	 protected boolean ignoreFileURI( String source ) {
		 return source.startsWith( ""file:"" );
	 }
	 protected Model readDelegate( String url ) {
		 return super.read( url );
	 }
	 protected Model readDelegate( String url, String lang ) {
		 return super.read( url, lang );
	 }
	 protected Model readDelegate( String url, String base, String lang ) {
		 return super.read( url, base, lang );
	 }
	 protected class NodeCanAs<T extends RDFNode> implements Predicate<Node> {
		 protected Class<T> m_asKey;
		 protected NodeCanAs( Class<T> asKey ) {
			 m_asKey = asKey;
		 }
		 public boolean test( Node x ) {
			 try {
				 getNodeAs( x, m_asKey );
			 }
			 catch (Exception ignore) {
				 return false;
			 }
			 return true;
		 }
	 }
	 protected class SubjectNodeCanAs<T extends RDFNode> implements Predicate<T> {
		 protected Class<T> m_asKey;
		 protected SubjectNodeCanAs( Class<T> asKey ) {
			 m_asKey = asKey;
		 }
		 public boolean test( T x ) {
			 Node n = (x instanceof Triple) ? ((Triple) x).getSubject() : ((x instanceof EnhNode) ? ((EnhNode) x).asNode() : (Node) x);
			 try {
				 getNodeAs( n, m_asKey );
			 }
			 catch (Exception ignore) {
				 return false;
			 }
			 return true;
		 }
	 }
	 protected class RdfTypeTestFn implements RDFList.ReduceFn {
		 protected Resource m_type;
		 protected RdfTypeTestFn( Resource type ) {
			 m_type = type;
		 }
		 public Object reduce( RDFNode node, Object accumulator ) {
			 Boolean acc = (Boolean) accumulator;
			 if (acc.booleanValue()) {
				 Resource r = (Resource) node;
				 return Boolean.valueOf( r.hasProperty( RDF.type, m_type ) );
			 }
			 else {
				 return acc;
			 }
		 }
	 }
	 protected class ImportsListener extends StatementListener {
		 public void addedStatement( Statement added ) {
			 if (added.getPredicate().equals( getProfile().IMPORTS() )) {
				 getDocumentManager().loadImport( OntModelImpl.this, added.getResource().getURI() );
			 }
		 }
		 public void removedStatement( Statement removed ) {
			 if (removed.getPredicate().equals( getProfile().IMPORTS() )) {
				 getDocumentManager().unloadImport( OntModelImpl.this, removed.getResource().getURI() );
			 }
		 }
	 }
}",1,0,0,0
"public CqlResult execute_cql_query(ByteBuffer query, Compression compression) throws InvalidRequestException, UnavailableException, TimedOutException, SchemaDisagreementException, TException {
	 String queryString = null;
	 try {
		 switch (compression) {
			 case GZIP: ByteArrayOutputStream byteArray = new ByteArrayOutputStream();
			 byte[] outBuffer = new byte[1024], inBuffer = new byte[1024];
			 Inflater decompressor = new Inflater();
			 int lenRead = 0;
			 while (true) {
				 if (decompressor.needsInput()) lenRead = query.remaining() < 1024 ? query.remaining() : 1024;
				 query.get(inBuffer, 0, lenRead);
				 decompressor.setInput(inBuffer, 0, lenRead);
				 int lenWrite = 0;
				 while ((lenWrite = decompressor.inflate(outBuffer)) !=0) byteArray.write(outBuffer, 0, lenWrite);
				 if (decompressor.finished()) break;
			 }
			 decompressor.end();
			 queryString = new String(byteArray.toByteArray(), 0, byteArray.size(), ""UTF-8"");
			 break;
			 case NONE: try {
				 queryString = ByteBufferUtil.string(query);
			 }
			 catch (CharacterCodingException ex) {
				 throw new InvalidRequestException(ex.getMessage());
			 }
			 break;
		 }
	 }
	 catch (DataFormatException e) {
		 throw new InvalidRequestException(""Error deflating query string."");
	 }
	 catch (UnsupportedEncodingException e) {
		 throw new InvalidRequestException(""Unknown query string encoding."");
	 }
	 try {
		 return QueryProcessor.process(queryString, state());
	 }
	 catch (RecognitionException e) {
		 InvalidRequestException ire = new InvalidRequestException(""Invalid or malformed CQL query string"");
		 ire.initCause(e);
		 throw ire;
	 }
 }",0,0,0,0
"private void applyWeightChanges() {
	 List<Layer> layers = neuralNetwork.getLayers();
	 for (int i = neuralNetwork.getLayersCount() - 1;
	 i > 0;
	 i--) {
		 for (Neuron neuron : layers.get(i).getNeurons()) {
			 for (Connection connection : neuron.getInputConnections()) {
				 Weight weight = connection.getWeight();
				 if (!isBatchMode()) {
					 weight.value += weight.weightChange;
				 }
				 else {
					 weight.value += (weight.weightChange / getTrainingSet().size());
				 }
				 weight.weightChange = 0;
			 }
		 }
	 }
 }",0,0,0,0
"public void run() {
	 while (true) {
		 SSTableDeletingReference r;
		 try {
			 r = (SSTableDeletingReference) finalizerQueue.remove();
			 finalizers.remove(r);
		 }
		 catch (InterruptedException e) {
			 throw new RuntimeException(e);
		 }
		 try {
			 r.cleanup();
		 }
		 catch (IOException e) {
			 logger.error(""Error deleting "" + r.desc, e);
		 }
	 }
 }",0,0,0,0
"protected boolean downloadLog(HttpServletRequest request,HttpServletResponse response, ILogService logService,String appenderName) throws ServletException {
	FileAppender<ILoggingEvent> appender = logService.getFileAppender(appenderName);
	if (appender == null) {
		String msg = NLS.bind(""Appender not found: {
		0}
		"", appenderName);
		final ServerStatus error = new ServerStatus(IStatus.ERROR,HttpServletResponse.SC_NOT_FOUND, msg, null);
		return statusHandler.handleRequest(request, response, error);
	}
	File logFile = new File(appender.getFile());
	try {
		LogUtils.provideLogFile(logFile, response);
	}
	 catch (Exception ex) {
		String msg = NLS.bind(""An error occured when looking for log {
		0}
		."",logFile.getName());
		final ServerStatus error = new ServerStatus(IStatus.ERROR,HttpServletResponse.SC_INTERNAL_SERVER_ERROR, msg, ex);
		LogHelper.log(error);
		return statusHandler.handleRequest(request, response, error);
	}
	return true;
}",0,0,1,0
"public void init(BrowserProxyInfo paramBrowserProxyInfo) throws Exception {
	if (!isSupported(paramBrowserProxyInfo.getType())) {
		throw new Exception(""Unable to support proxy type: ""+ paramBrowserProxyInfo.getType());
	}
	this.bpi = paramBrowserProxyInfo;
	this.autoProxyScript = new StringBuffer();
	this.autoProxyScript.append(""var _mon = new Array('JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC');
	\nvar _day = new Array('SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT');
	\nfunction _isGmt(i) {
		\n return typeof i == 'string' && i == 'GMT';
	 }
	"");
	this.autoProxyScript.append(""function dnsDomainIs(host, domain) {
		\nif (domain != null && domain.charAt(0) != '.')\nreturn shExpMatch(host, domain);
		\nreturn shExpMatch(host, '*' + domain);
	 }
	"");
	this.autoProxyScript.append(""function isPlainHostName(host){
		\nreturn (dnsDomainLevels(host) == 0);
	 }
	"");
	this.autoProxyScript.append(""function convert_addr(ipchars) {
		\n var bytes = ipchars.split('.');
		\n var result = ((bytes[0] & 0xff) << 24) |\n ((bytes[1] & 0xff) << 16) |\n ((bytes[2] & 0xff) << 8) |\n (bytes[3] & 0xff);
		\n return result;
	\n}
	\n"");
	this.autoProxyScript.append(""function isInNet(ipaddr, pattern, maskstr) {
		\n var ipPattern = /^(\\d{
		1,3}
		)\\.(\\d{
		1,3}
		)\\.(\\d{
		1,3}
		)\\.(\\d{
		1,3}
		)$/;
		\n var test = ipaddr.match(ipPattern);
		\n if (test == null) {
			\n ipaddr = dnsResolve(ipaddr);
			\n if (ipaddr == null)\n return false;
		\n }
		 else if ((test[1] > 255) || (test[2] > 255) || \n (test[3] > 255) || (test[4] > 255) ) {
			\n return false;
		\n }
		\n var host = convert_addr(ipaddr);
		\n var pat = convert_addr(pattern);
		\n var mask = convert_addr(maskstr);
		\n return ((host & mask) == (pat & mask));
	\n \n}
	\n"");
	this.autoProxyScript.append(getBrowserSpecificAutoProxy());
	this.autoProxyScript.append(""function isResolvable(host){
		\nreturn (dnsResolve(host) != '');
	 }
	"");
	this.autoProxyScript.append(""function localHostOrDomainIs(host, hostdom){
		\nreturn shExpMatch(hostdom, host + '*');
	 }
	"");
	this.autoProxyScript.append(""function dnsDomainLevels(host){
		\nvar s = host + '';
		\nfor (var i=0, j=0;
		 i < s.length;
		 i++)\nif (s.charAt(i) == '.')\nj++;
		\nreturn j;
	 }
	"");
	this.autoProxyScript.append(""function myIpAddress(){
		\nreturn '"");
		try {
			InetAddress localInetAddress = InetAddress.getLocalHost();
			this.autoProxyScript.append(localInetAddress.getHostAddress());
		}
		 catch (Throwable localThrowable) {
			localThrowable.printStackTrace();
			this.autoProxyScript.append(""127.0.0.1"");
		}
		this.autoProxyScript.append(""';
	 }
	"");
	this.autoProxyScript.append(""function shExpMatch(str, shexp){
		 \n if (typeof str != 'string' || typeof shexp != 'string') return false;
		 \n if (shexp == '*') return true;
		 \n if (str == '' && shexp == '') return true;
		 \n str = str.toLowerCase();
		\n shexp = shexp.toLowerCase();
		\n var index = shexp.indexOf('*');
		\n if (index == -1) {
			 return (str == shexp);
		 }
		 \n else if (index == 0) {
			 \n for (var i=0;
			 i <= str.length;
			 i++) {
				 \n if (shExpMatch(str.substring(i), shexp.substring(1))) return true;
			 \n }
			 return false;
		 }
		 \nelse {
			 \nvar sub = null, sub2 = null;
			 \nsub = shexp.substring(0, index);
			\nif (index <= str.length) sub2 = str.substring(0, index);
			 \nif (sub != '' && sub2 != '' && sub == sub2) {
				 \nreturn shExpMatch(str.substring(index), shexp.substring(index));
			 }
			\nelse {
				 return false;
			 }
		\n}
	 }
	"");
	this.autoProxyScript.append(""function _dateRange(day1, month1, year1, day2, month2, year2, gmt){
		\nif (typeof day1 != 'number' || day1 <= 0 || typeof month1 != 'string' || typeof year1 != 'number' || year1 <= 0\n || typeof day2 != 'number' || day2 <= 0 || typeof month2 != 'string' || typeof year2 != 'number' || year2 <= 0\n || typeof gmt != 'boolean') return false;
		 \nvar m1 = -1, m2 = -1;
		\nfor (var i=0;
		 i < _mon.length;
		 i++){
			\nif (_mon[i] == month1)\nm1 = i;
			\nif (_mon[i] == month2)\nm2 = i;
		\n}
		\nvar cur = new Date();
		\nvar d1 = new Date(year1, m1, day1, 0, 0, 0);
		\nvar d2 = new Date(year2, m2, day2, 23, 59, 59);
		\nif (gmt == true)\ncur = new Date(cur.getTime() - cur.getTimezoneOffset() * 60 * 1000);
		\nreturn ((d1.getTime() <= cur.getTime()) && (cur.getTime() <= d2.getTime()));
	\n}
	\nfunction dateRange(p1, p2, p3, p4, p5, p6, p7){
		\nvar cur = new Date();
		\nif (typeof p1 == 'undefined')\nreturn false;
		\nelse if (typeof p2 == 'undefined' || _isGmt(p2))\n{
			\nif ((typeof p1) == 'string')\nreturn _dateRange(1, p1, cur.getFullYear(), 31, p1, cur.getFullYear(), _isGmt(p2));
			\nelse if (typeof p1 == 'number' && p1 > 31)\nreturn _dateRange(1, 'JAN', p1, 31, 'DEC', p1, _isGmt(p2));
			\nelse {
				\nfor (var i=0;
				 i < _mon.length;
				 i++)\nif (_dateRange(p1, _mon[i], cur.getFullYear(), p1, _mon[i], cur.getFullYear(), _isGmt(p2)))\n return true;
				\nreturn false;
			\n}
		\n}
		\nelse if (typeof p3 == 'undefined' || _isGmt(p3))\n{
			\nif ((typeof p1) == 'string')\nreturn _dateRange(1, p1, cur.getFullYear(), 31, p2, cur.getFullYear(), _isGmt(p3));
			\nelse if (typeof p1 == 'number' && typeof p2 == 'number' && (p1 > 31 || p2 > 31))\nreturn _dateRange(1, 'JAN', p1, 31, 'DEC', p2, _isGmt(p3));
			\nelse \n{
				\nif ((typeof p2) == 'string')\n{
					\nreturn _dateRange(p1, p2, cur.getFullYear(), p1, p2, cur.getFullYear(), _isGmt(p3));
				\n}
				\nelse \n{
					\nfor (var i=0;
					 i < _mon.length;
					 i++)\nif (_dateRange(p1, _mon[i], cur.getFullYear(), p2, _mon[i], cur.getFullYear(), _isGmt(p3)))\nreturn true;
					\nreturn false;
				\n}
			\n}
		\n}
		\nelse if (typeof p4 == 'undefined' || _isGmt(p4))\nreturn _dateRange(p1, p2, p3, p1, p2, p3, _isGmt(p4));
		\nelse if (typeof p5 == 'undefined' || _isGmt(p5))\n{
			\nif (typeof p2 == 'number')\nreturn _dateRange(1, p1, p2, 31, p3, p4, _isGmt(p5));
		\nelse \nreturn _dateRange(p1, p2, cur.getFullYear(), p3, p4, cur.getFullYear(), _isGmt(p5))\n}
		\nelse if (typeof p6 == 'undefined')\nreturn false;
		\nelse \nreturn _dateRange(p1, p2, p3, p4, p5, p6, _isGmt(p7));
	\n}
	"");
	this.autoProxyScript.append(""function timeRange(p1, p2, p3, p4, p5, p6, p7) {
		\nif (typeof p1 == 'undefined')\nreturn false;
		\nelse if (typeof p2 == 'undefined' || _isGmt(p2))\nreturn _timeRange(p1, 0, 0, p1, 59, 59, _isGmt(p2));
		\nelse if (typeof p3 == 'undefined' || _isGmt(p3))\nreturn _timeRange(p1, 0, 0, p2, 0, 0, _isGmt(p3));
		\nelse if (typeof p4 == 'undefined')\nreturn false;
		\nelse if (typeof p5 == 'undefined' || _isGmt(p5))\nreturn _timeRange(p1, p2, 0, p3, p4, 0, _isGmt(p5));
		\nelse if (typeof p6 == 'undefined')\nreturn false;
		\nelse \nreturn _timeRange(p1, p2, p3, p4, p5, p6, _isGmt(p7));
	\n}
	\nfunction _timeRange(hour1, min1, sec1, hour2, min2, sec2, gmt) {
		\nif (typeof hour1 != 'number' || typeof min1 != 'number' || typeof sec1 != 'number' \n|| hour1 < 0 || min1 < 0 || sec1 < 0 \n|| typeof hour2 != 'number' || typeof min2 != 'number' || typeof sec2 != 'number' \n|| hour2 < 0 || min2 < 0 || sec2 < 0 \n|| typeof gmt != 'boolean') return false;
		 \nvar cur = new Date();
		\nvar d1 = new Date();
		\nvar d2 = new Date();
		\nd1.setHours(hour1);
		\nd1.setMinutes(min1);
		\nd1.setSeconds(sec1);
		\nd2.setHours(hour2);
		\nd2.setMinutes(min2);
		\nd2.setSeconds(sec2);
		\nif (gmt == true)\ncur = new Date(cur.getTime() - cur.getTimezoneOffset() * 60 * 1000);
		\nreturn ((d1.getTime() <= cur.getTime()) && (cur.getTime() <= d2.getTime()));
	\n}
	"");
	this.autoProxyScript.append(""function weekdayRange(wd1, wd2, gmt){
		\nif (typeof wd1 == 'undefined') \nreturn false;
		\nelse if (typeof wd2 == 'undefined' || _isGmt(wd2)) \nreturn _weekdayRange(wd1, wd1, _isGmt(wd2));
		 \nelse \nreturn _weekdayRange(wd1, wd2, _isGmt(gmt));
	 }
	\nfunction _weekdayRange(wd1, wd2, gmt) {
		\nif (typeof wd1 != 'string' || typeof wd2 != 'string' || typeof gmt != 'boolean') return false;
		 \nvar w1 = -1, w2 = -1;
		\nfor (var i=0;
		 i < _day.length;
		 i++) {
			\nif (_day[i] == wd1)\nw1 = i;
			\nif (_day[i] == wd2)\nw2 = i;
		 }
		\nvar cur = new Date();
		\nif (gmt == true)\ncur = new Date(cur.getTime() - cur.getTimezoneOffset() * 60 * 1000);
		\nvar w3 = cur.getDay();
		\nif (w1 > w2)\nw2 = w2 + 7;
		\nif (w1 > w3)\nw3 = w3 + 7;
		\nreturn (w1 <= w3 && w3 <= w2);
	 }
	"");
	this.autoProxyScript.append("" function alert() {
	}
	 "");
	URL localURL1 = null;
	try {
		localURL1 = new URL(this.bpi.getAutoConfigURL());
	}
	 catch (MalformedURLException localMalformedURLException) {
		throw new Exception(""Auto config URL is malformed"");
	}
	URLConnection localURLConnection = getDirectURLConnection(localURL1);
	if (localURLConnection != null) {
		if (isSupportedINSFile(localURLConnection) == true) {
			URL localURL2 = getAutoConfigURLFromINS(localURLConnection);
			localURLConnection = getDirectURLConnection(localURL2);
		}
		this.jsPacScript = getJSFileFromURL(localURLConnection);
		this.autoProxyScript.append(this.jsPacScript);
	}
}",0,0,1,0
"public class Echo extends Task {
	 protected String message = """";
	 protected File file = null;
	 protected boolean append = false;
	 private String encoding = """";
	 protected int logLevel = Project.MSG_WARN;
	 public void execute() throws BuildException {
		 if (file == null) {
			 log(message, logLevel);
		 }
		 else {
			 Writer out = null;
			 try {
				 String filename = file.getAbsolutePath();
				 if (encoding == null || encoding.length() == 0) {
					 out = new FileWriter(filename, append);
				 }
				 else {
					 out = new BufferedWriter( new OutputStreamWriter( new FileOutputStream(filename, append), encoding));
				 }
				 out.write(message, 0, message.length());
			 }
			 catch (IOException ioe) {
				 throw new BuildException(ioe, getLocation());
			 }
			 finally {
				 FileUtils.close(out);
			 }
		 }
	 }
	 public void setMessage(String msg) {
		 this.message = msg;
	 }
	 public void setFile(File file) {
		 this.file = file;
	 }
	 public void setAppend(boolean append) {
		 this.append = append;
	 }
	 public void addText(String msg) {
		 message += getProject().replaceProperties(msg);
	 }
	 public void setLevel(EchoLevel echoLevel) {
		 logLevel = echoLevel.getLevel();
	 }
	 public void setEncoding(String encoding) {
		 this.encoding = encoding;
	 }
	 public static class EchoLevel extends LogLevel {
	 }
}",0,0,0,0
"public void setLog4jLevel(String classQualifier, String level);
 public String getOperationMode();
 public String getDrainProgress();
 public void drain() throws IOException, InterruptedException, ExecutionException;
 public void truncate(String keyspace, String columnFamily) throws UnavailableException, TimeoutException, IOException;
 public void deliverHints(String host) throws UnknownHostException;
 public void saveCaches() throws ExecutionException, InterruptedException;
 public Map<Token, Float> getOwnership();
 public List<String> getKeyspaces();
 public void updateSnitch(String epSnitchClassName, Boolean dynamic, Integer dynamicUpdateInterval, Integer dynamicResetInterval, Double dynamicBadnessThreshold) throws ConfigurationException;
 public void stopGossiping();
 public void startGossiping();
 public boolean isInitialized();
 public void stopRPCServer();
 public void startRPCServer();
 public boolean isRPCServerRunning();
 public void invalidateKeyCaches(String ks, String... cfs) throws IOException;
 public void invalidateRowCaches(String ks, String... cfs) throws IOException;
 public void joinRing() throws IOException, org.apache.cassandra.config.ConfigurationException;
 public boolean isJoined();
 public int getExceptionCount();
 public void setCompactionThroughputMbPerSec(int value);
 public void bulkLoad(String directory);
}",0,0,0,0
"public class XmlUtils {
	 public static boolean isValidXml(String input) {
		 boolean result = true;
		 try {
			 if (StringUtils.isBlank(input)) {
				 result = false;
			 }
			 else {
				 DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
				 dbFactory.setFeature(""http: DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
				 dBuilder.parse(new ByteArrayInputStream(input.getBytes(""UTF-8"")));
			 }
		 }
		 catch (Exception e) {
			 result = false;
		 }
		 return result;
	 }
}",0,0,0,0
"public class DittoRuntimeException extends RuntimeException implements Jsonifiable.WithPredicate<JsonObject, JsonField>, WithDittoHeaders<DittoRuntimeException>, WithManifest {
	 private static final long serialVersionUID = -7010323324132561106L;
	 private final String errorCode;
	 private final HttpStatusCode statusCode;
	 private final String description;
	 private final URI href;
	 private final transient DittoHeaders dittoHeaders;
	 protected DittoRuntimeException(final String errorCode, final HttpStatusCode statusCode, final DittoHeaders dittoHeaders, final String message, final String description, final Throwable cause, final URI href) {
		 super(message, cause);
		 this.errorCode = checkNotNull(errorCode, ""error code"");
		 this.statusCode = checkNotNull(statusCode, ""HTTP status"");
		 this.dittoHeaders = checkNotNull(dittoHeaders, ""Ditto headers"");
		 this.description = description;
		 this.href = href;
	 }
	 protected DittoRuntimeExceptionBuilder<? extends DittoRuntimeException> getEmptyBuilder() {
		 return new Builder(errorCode, statusCode);
	 }
	 public DittoRuntimeExceptionBuilder<? extends DittoRuntimeException> getBuilder() {
		 return getEmptyBuilder() .dittoHeaders(dittoHeaders) .message(getMessage()) .cause(getCause()) .description(description) .href(href);
	 }
	 public static Builder newBuilder(final String errorCode, final HttpStatusCode statusCode) {
		 return new Builder(errorCode, statusCode);
	 }
	 public static DittoRuntimeExceptionBuilder<? extends DittoRuntimeException> newBuilder( final DittoRuntimeException dittoRuntimeException) {
		 checkNotNull(dittoRuntimeException, ""dittoRuntimeException to be copied"");
		 return dittoRuntimeException.getBuilder() .dittoHeaders(dittoRuntimeException.dittoHeaders) .message(dittoRuntimeException.getMessage()) .description(dittoRuntimeException.description) .cause(dittoRuntimeException.getCause()) .href(dittoRuntimeException.href);
	 }
	 protected static Optional<URI> readHRef(final JsonObject jsonObject) {
		 checkNotNull(jsonObject, ""JSON object"");
		 return jsonObject.getValue(JsonFields.HREF).map(URI::create);
	 }
	 protected static String readMessage(final JsonObject jsonObject) {
		 checkNotNull(jsonObject, ""JSON object"");
		 return jsonObject.getValueOrThrow(JsonFields.MESSAGE);
	 }
	 protected static Optional<String> readDescription(final JsonObject jsonObject) {
		 checkNotNull(jsonObject, ""JSON object"");
		 return jsonObject.getValue(JsonFields.DESCRIPTION);
	 }
	 public String getErrorCode() {
		 return errorCode;
	 }
	 public HttpStatusCode getStatusCode() {
		 return statusCode;
	 }
	 public DittoHeaders getDittoHeaders() {
		 return dittoHeaders;
	 }
	 public DittoRuntimeException setDittoHeaders(final DittoHeaders dittoHeaders) {
		 return newBuilder(this).dittoHeaders(dittoHeaders).build();
	 }
	 public JsonSchemaVersion getImplementedSchemaVersion() {
		 return dittoHeaders.getSchemaVersion().orElse(getLatestSchemaVersion());
	 }
	 public Optional<String> getDescription() {
		 return Optional.ofNullable(description);
	 }
	 public Optional<URI> getHref() {
		 return Optional.ofNullable(href);
	 }
	 public String getManifest() {
		 return getErrorCode();
	 }
	 public boolean equals( final Object o) {
		 if (this == o) {
			 return true;
		 }
		 if (o == null || getClass() != o.getClass()) {
			 return false;
		 }
		 final DittoRuntimeException that = (DittoRuntimeException) o;
		 return Objects.equals(errorCode, that.errorCode) && statusCode == that.statusCode && Objects.equals(description, that.description) && Objects.equals(href, that.href);
	 }
	 public int hashCode() {
		 return Objects.hash(errorCode, statusCode, description, href);
	 }
	 public JsonObject toJson() {
		 return toJson(FieldType.notHidden());
	 }
	 public JsonObject toJson(final JsonSchemaVersion schemaVersion, final Predicate<JsonField> thePredicate) {
		 final Predicate<JsonField> predicate = schemaVersion.and(thePredicate);
		 final Predicate<JsonField> nonNullAndCustomDefined = predicate.and(JsonField.isValueNonNull());
		 final JsonObjectBuilder jsonObjectBuilder = JsonFactory.newObjectBuilder() .set(JsonFields.STATUS, statusCode.toInt(), nonNullAndCustomDefined) .set(JsonFields.ERROR_CODE, errorCode, nonNullAndCustomDefined) .set(JsonFields.MESSAGE, getMessage(), nonNullAndCustomDefined) .set(JsonFields.DESCRIPTION, description, nonNullAndCustomDefined) .set(JsonFields.HREF, href != null ? href.toString() : null, nonNullAndCustomDefined);
		 appendToJson(jsonObjectBuilder, nonNullAndCustomDefined);
		 return jsonObjectBuilder.build();
	 }
	 protected void appendToJson(final JsonObjectBuilder jsonObjectBuilder, final Predicate<JsonField> predicate) {
	 }
	 public static Optional<DittoRuntimeException> fromUnknownErrorJson(final JsonObject jsonObject, final DittoHeaders headers) {
		 return jsonObject.getValue(JsonFields.ERROR_CODE).flatMap(errorCode -> jsonObject.getValue(JsonFields.STATUS).flatMap(HttpStatusCode::forInt).map(status -> {
			 final Builder builder = new Builder(errorCode, status);
			 builder.dittoHeaders(headers);
			 jsonObject.getValue(JsonFields.MESSAGE).ifPresent(builder::message);
			 jsonObject.getValue(JsonFields.DESCRIPTION).ifPresent(builder::description);
			 jsonObject.getValue(JsonFields.HREF) .flatMap(uriString -> {
				 try {
					 return Optional.of(new URI(uriString));
				 }
				 catch (URISyntaxException e) {
					 return Optional.empty();
				 }
			 }
			) .ifPresent(builder::href);
			 return builder.build();
		 }
		) );
	 }
	 public String toString() {
		 return this.getClass().getName() + "" ["" + ""message='"" + getMessage() + '\'' + "", errorCode="" + errorCode + "", statusCode="" + statusCode + "", description='"" + description + '\'' + "", href="" + href + "", dittoHeaders="" + dittoHeaders + ']';
	 }
	 public static final class Builder extends DittoRuntimeExceptionBuilder<DittoRuntimeException> {
		 private final String errorCode;
		 private final HttpStatusCode statusCode;
		 private Builder(final String theErrorCode, final HttpStatusCode theStatusCode) {
			 checkNotNull(theErrorCode, ""exception error code"");
			 errorCode = checkNotEmpty(theErrorCode, ""exception error code"");
			 statusCode = checkNotNull(theStatusCode, ""exception HTTP status code"");
		 }
		 protected DittoRuntimeException doBuild(final DittoHeaders dittoHeaders, final String message, final String description, final Throwable cause, final URI href) {
			 return new DittoRuntimeException(errorCode, statusCode, dittoHeaders, message, description, cause, href);
		 }
	 }
	 public static final class JsonFields {
		 public static final JsonFieldDefinition<Integer> STATUS = JsonFactory.newIntFieldDefinition(""status"", FieldType.REGULAR, JsonSchemaVersion.V_1, JsonSchemaVersion.V_2);
		 public static final JsonFieldDefinition<String> ERROR_CODE = JsonFactory.newStringFieldDefinition(""error"", FieldType.REGULAR, JsonSchemaVersion.V_1, JsonSchemaVersion.V_2);
		 public static final JsonFieldDefinition<String> MESSAGE = JsonFactory.newStringFieldDefinition(""message"", FieldType.REGULAR, JsonSchemaVersion.V_1, JsonSchemaVersion.V_2);
		 public static final JsonFieldDefinition<String> DESCRIPTION = JsonFactory.newStringFieldDefinition(""description"", FieldType.REGULAR, JsonSchemaVersion.V_1, JsonSchemaVersion.V_2);
		 public static final JsonFieldDefinition<String> HREF = JsonFactory.newStringFieldDefinition(""href"", FieldType.REGULAR, JsonSchemaVersion.V_1, JsonSchemaVersion.V_2);
		 private JsonFields() {
			 throw new AssertionError();
		 }
	 }
}",0,0,0,0
"private void parseArray(NameSegment nameSeg) {
	 String name = nameSeg.getPath();
	 ArraySegment arraySeg = ((ArraySegment) nameSeg.getChild());
	 int index = arraySeg.getIndex();
	 RequestedColumnImpl member = getImpl(name);
	 if (member == null) {
		 member = new RequestedColumnImpl(this, name);
		 projection.add(name, member);
	 }
	 else if (member.isSimple()) {
		 member.projectAllElements();
		 return;
	 }
	 else if (member.hasIndex(index)) {
		 throw UserException .validationError() .message(""Duplicate array index in project list: %s[%d]"", member.fullName(), index) .build(logger);
	 }
	 member.addIndex(index);
	 if (! arraySeg.isLastPath()) {
		 parseInternal(nameSeg);
	 }
 }",0,0,1,0
"public List<? extends E> getChoices(){
	List<? extends E> choices = (this.choices != null) ? this.choices.getObject() : null;
	if (choices == null){
		throw new NullPointerException(""List of choices is null - Was the supplied 'Choices' model empty?"");
	}
	return choices;
}",0,0,0,0
"public class Javac extends MatchingTask {
	 private static final String FAIL_MSG = ""Compile failed;
	 see the compiler error output for details."";
	 private static final String JAVAC18 = ""javac1.8"";
	 private static final String JAVAC17 = ""javac1.7"";
	 private static final String JAVAC16 = ""javac1.6"";
	 private static final String JAVAC15 = ""javac1.5"";
	 private static final String JAVAC14 = ""javac1.4"";
	 private static final String JAVAC13 = ""javac1.3"";
	 private static final String JAVAC12 = ""javac1.2"";
	 private static final String JAVAC11 = ""javac1.1"";
	 private static final String MODERN = ""modern"";
	 private static final String CLASSIC = ""classic"";
	 private static final String EXTJAVAC = ""extJavac"";
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private Path src;
	 private File destDir;
	 private Path compileClasspath;
	 private Path compileSourcepath;
	 private String encoding;
	 private boolean debug = false;
	 private boolean optimize = false;
	 private boolean deprecation = false;
	 private boolean depend = false;
	 private boolean verbose = false;
	 private String targetAttribute;
	 private Path bootclasspath;
	 private Path extdirs;
	 private Boolean includeAntRuntime;
	 private boolean includeJavaRuntime = false;
	 private boolean fork = false;
	 private String forkedExecutable = null;
	 private boolean nowarn = false;
	 private String memoryInitialSize;
	 private String memoryMaximumSize;
	 private FacadeTaskHelper facade = null;
	 protected boolean failOnError = true;
	 protected boolean listFiles = false;
	 protected File[] compileList = new File[0];
	 private Map packageInfos = new HashMap();
	 private String source;
	 private String debugLevel;
	 private File tmpDir;
	 private String updatedProperty;
	 private String errorProperty;
	 private boolean taskSuccess = true;
	 private boolean includeDestClasses = true;
	 private CompilerAdapter nestedAdapter = null;
	 private boolean createMissingPackageInfoClass = true;
	 public Javac() {
		 facade = new FacadeTaskHelper(assumedJavaVersion());
	 }
	 private String assumedJavaVersion() {
		 if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_4)) {
			 return JAVAC14;
		 }
		 else if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_5)) {
			 return JAVAC15;
		 }
		 else if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_6)) {
			 return JAVAC16;
		 }
		 else if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_7)) {
			 return JAVAC17;
		 }
		 else if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_8)) {
			 return JAVAC18;
		 }
		 else {
			 return CLASSIC;
		 }
	 }
	 public String getDebugLevel() {
		 return debugLevel;
	 }
	 public void setDebugLevel(String v) {
		 this.debugLevel = v;
	 }
	 public String getSource() {
		 return source != null ? source : getProject().getProperty(MagicNames.BUILD_JAVAC_SOURCE);
	 }
	 public void setSource(String v) {
		 this.source = v;
	 }
	 public Path createSrc() {
		 if (src == null) {
			 src = new Path(getProject());
		 }
		 return src.createPath();
	 }
	 protected Path recreateSrc() {
		 src = null;
		 return createSrc();
	 }
	 public void setSrcdir(Path srcDir) {
		 if (src == null) {
			 src = srcDir;
		 }
		 else {
			 src.append(srcDir);
		 }
	 }
	 public Path getSrcdir() {
		 return src;
	 }
	 public void setDestdir(File destDir) {
		 this.destDir = destDir;
	 }
	 public File getDestdir() {
		 return destDir;
	 }
	 public void setSourcepath(Path sourcepath) {
		 if (compileSourcepath == null) {
			 compileSourcepath = sourcepath;
		 }
		 else {
			 compileSourcepath.append(sourcepath);
		 }
	 }
	 public Path getSourcepath() {
		 return compileSourcepath;
	 }
	 public Path createSourcepath() {
		 if (compileSourcepath == null) {
			 compileSourcepath = new Path(getProject());
		 }
		 return compileSourcepath.createPath();
	 }
	 public void setSourcepathRef(Reference r) {
		 createSourcepath().setRefid(r);
	 }
	 public void setClasspath(Path classpath) {
		 if (compileClasspath == null) {
			 compileClasspath = classpath;
		 }
		 else {
			 compileClasspath.append(classpath);
		 }
	 }
	 public Path getClasspath() {
		 return compileClasspath;
	 }
	 public Path createClasspath() {
		 if (compileClasspath == null) {
			 compileClasspath = new Path(getProject());
		 }
		 return compileClasspath.createPath();
	 }
	 public void setClasspathRef(Reference r) {
		 createClasspath().setRefid(r);
	 }
	 public void setBootclasspath(Path bootclasspath) {
		 if (this.bootclasspath == null) {
			 this.bootclasspath = bootclasspath;
		 }
		 else {
			 this.bootclasspath.append(bootclasspath);
		 }
	 }
	 public Path getBootclasspath() {
		 return bootclasspath;
	 }
	 public Path createBootclasspath() {
		 if (bootclasspath == null) {
			 bootclasspath = new Path(getProject());
		 }
		 return bootclasspath.createPath();
	 }
	 public void setBootClasspathRef(Reference r) {
		 createBootclasspath().setRefid(r);
	 }
	 public void setExtdirs(Path extdirs) {
		 if (this.extdirs == null) {
			 this.extdirs = extdirs;
		 }
		 else {
			 this.extdirs.append(extdirs);
		 }
	 }
	 public Path getExtdirs() {
		 return extdirs;
	 }
	 public Path createExtdirs() {
		 if (extdirs == null) {
			 extdirs = new Path(getProject());
		 }
		 return extdirs.createPath();
	 }
	 public void setListfiles(boolean list) {
		 listFiles = list;
	 }
	 public boolean getListfiles() {
		 return listFiles;
	 }
	 public void setFailonerror(boolean fail) {
		 failOnError = fail;
	 }
	 public void setProceed(boolean proceed) {
		 failOnError = !proceed;
	 }
	 public boolean getFailonerror() {
		 return failOnError;
	 }
	 public void setDeprecation(boolean deprecation) {
		 this.deprecation = deprecation;
	 }
	 public boolean getDeprecation() {
		 return deprecation;
	 }
	 public void setMemoryInitialSize(String memoryInitialSize) {
		 this.memoryInitialSize = memoryInitialSize;
	 }
	 public String getMemoryInitialSize() {
		 return memoryInitialSize;
	 }
	 public void setMemoryMaximumSize(String memoryMaximumSize) {
		 this.memoryMaximumSize = memoryMaximumSize;
	 }
	 public String getMemoryMaximumSize() {
		 return memoryMaximumSize;
	 }
	 public void setEncoding(String encoding) {
		 this.encoding = encoding;
	 }
	 public String getEncoding() {
		 return encoding;
	 }
	 public void setDebug(boolean debug) {
		 this.debug = debug;
	 }
	 public boolean getDebug() {
		 return debug;
	 }
	 public void setOptimize(boolean optimize) {
		 this.optimize = optimize;
	 }
	 public boolean getOptimize() {
		 return optimize;
	 }
	 public void setDepend(boolean depend) {
		 this.depend = depend;
	 }
	 public boolean getDepend() {
		 return depend;
	 }
	 public void setVerbose(boolean verbose) {
		 this.verbose = verbose;
	 }
	 public boolean getVerbose() {
		 return verbose;
	 }
	 public void setTarget(String target) {
		 this.targetAttribute = target;
	 }
	 public String getTarget() {
		 return targetAttribute != null ? targetAttribute : getProject().getProperty(MagicNames.BUILD_JAVAC_TARGET);
	 }
	 public void setIncludeantruntime(boolean include) {
		 includeAntRuntime = Boolean.valueOf(include);
	 }
	 public boolean getIncludeantruntime() {
		 return includeAntRuntime != null ? includeAntRuntime.booleanValue() : true;
	 }
	 public void setIncludejavaruntime(boolean include) {
		 includeJavaRuntime = include;
	 }
	 public boolean getIncludejavaruntime() {
		 return includeJavaRuntime;
	 }
	 public void setFork(boolean f) {
		 fork = f;
	 }
	 public void setExecutable(String forkExec) {
		 forkedExecutable = forkExec;
	 }
	 public String getExecutable() {
		 return forkedExecutable;
	 }
	 public boolean isForkedJavac() {
		 return fork || EXTJAVAC.equalsIgnoreCase(getCompiler());
	 }
	 public String getJavacExecutable() {
		 if (forkedExecutable == null && isForkedJavac()) {
			 forkedExecutable = getSystemJavac();
		 }
		 else if (forkedExecutable != null && !isForkedJavac()) {
			 forkedExecutable = null;
		 }
		 return forkedExecutable;
	 }
	 public void setNowarn(boolean flag) {
		 this.nowarn = flag;
	 }
	 public boolean getNowarn() {
		 return nowarn;
	 }
	 public ImplementationSpecificArgument createCompilerArg() {
		 ImplementationSpecificArgument arg = new ImplementationSpecificArgument();
		 facade.addImplementationArgument(arg);
		 return arg;
	 }
	 public String[] getCurrentCompilerArgs() {
		 String chosen = facade.getExplicitChoice();
		 try {
			 String appliedCompiler = getCompiler();
			 facade.setImplementation(appliedCompiler);
			 String[] result = facade.getArgs();
			 String altCompilerName = getAltCompilerName(facade.getImplementation());
			 if (result.length == 0 && altCompilerName != null) {
				 facade.setImplementation(altCompilerName);
				 result = facade.getArgs();
			 }
			 return result;
		 }
		 finally {
			 facade.setImplementation(chosen);
		 }
	 }
	 private String getAltCompilerName(String anImplementation) {
		 if (JAVAC17.equalsIgnoreCase(anImplementation) || JAVAC18.equalsIgnoreCase(anImplementation) || JAVAC16.equalsIgnoreCase(anImplementation) || JAVAC15.equalsIgnoreCase(anImplementation) || JAVAC14.equalsIgnoreCase(anImplementation) || JAVAC13.equalsIgnoreCase(anImplementation)) {
			 return MODERN;
		 }
		 if (JAVAC12.equalsIgnoreCase(anImplementation) || JAVAC11.equalsIgnoreCase(anImplementation)) {
			 return CLASSIC;
		 }
		 if (MODERN.equalsIgnoreCase(anImplementation)) {
			 String nextSelected = assumedJavaVersion();
			 if (JAVAC17.equalsIgnoreCase(nextSelected) || JAVAC18.equalsIgnoreCase(nextSelected) || JAVAC16.equalsIgnoreCase(nextSelected) || JAVAC15.equalsIgnoreCase(nextSelected) || JAVAC14.equalsIgnoreCase(nextSelected) || JAVAC13.equalsIgnoreCase(nextSelected)) {
				 return nextSelected;
			 }
		 }
		 if (CLASSIC.equalsIgnoreCase(anImplementation)) {
			 return assumedJavaVersion();
		 }
		 if (EXTJAVAC.equalsIgnoreCase(anImplementation)) {
			 return assumedJavaVersion();
		 }
		 return null;
	 }
	 public void setTempdir(File tmpDir) {
		 this.tmpDir = tmpDir;
	 }
	 public File getTempdir() {
		 return tmpDir;
	 }
	 public void setUpdatedProperty(String updatedProperty) {
		 this.updatedProperty = updatedProperty;
	 }
	 public void setErrorProperty(String errorProperty) {
		 this.errorProperty = errorProperty;
	 }
	 public void setIncludeDestClasses(boolean includeDestClasses) {
		 this.includeDestClasses = includeDestClasses;
	 }
	 public boolean isIncludeDestClasses() {
		 return includeDestClasses;
	 }
	 public boolean getTaskSuccess() {
		 return taskSuccess;
	 }
	 public Path createCompilerClasspath() {
		 return facade.getImplementationClasspath(getProject());
	 }
	 public void add(CompilerAdapter adapter) {
		 if (nestedAdapter != null) {
			 throw new BuildException(""Can't have more than one compiler"" + "" adapter"");
		 }
		 nestedAdapter = adapter;
	 }
	 public void setCreateMissingPackageInfoClass(boolean b) {
		 createMissingPackageInfoClass = b;
	 }
	 public void execute() throws BuildException {
		 checkParameters();
		 resetFileLists();
		 String[] list = src.list();
		 for (int i = 0;
		 i < list.length;
		 i++) {
			 File srcDir = getProject().resolveFile(list[i]);
			 if (!srcDir.exists()) {
				 throw new BuildException(""srcdir \"""" + srcDir.getPath() + ""\"" does not exist!"", getLocation());
			 }
			 DirectoryScanner ds = this.getDirectoryScanner(srcDir);
			 String[] files = ds.getIncludedFiles();
			 scanDir(srcDir, destDir != null ? destDir : srcDir, files);
		 }
		 compile();
		 if (updatedProperty != null && taskSuccess && compileList.length != 0) {
			 getProject().setNewProperty(updatedProperty, ""true"");
		 }
	 }
	 protected void resetFileLists() {
		 compileList = new File[0];
		 packageInfos = new HashMap();
	 }
	 protected void scanDir(File srcDir, File destDir, String[] files) {
		 GlobPatternMapper m = new GlobPatternMapper();
		 String[] extensions = findSupportedFileExtensions();
		 for (int i = 0;
		 i < extensions.length;
		 i++) {
			 m.setFrom(extensions[i]);
			 m.setTo(""*.class"");
			 SourceFileScanner sfs = new SourceFileScanner(this);
			 File[] newFiles = sfs.restrictAsFiles(files, srcDir, destDir, m);
			 if (newFiles.length > 0) {
				 lookForPackageInfos(srcDir, newFiles);
				 File[] newCompileList = new File[compileList.length + newFiles.length];
				 System.arraycopy(compileList, 0, newCompileList, 0, compileList.length);
				 System.arraycopy(newFiles, 0, newCompileList, compileList.length, newFiles.length);
				 compileList = newCompileList;
			 }
		 }
	 }
	 private String[] findSupportedFileExtensions() {
		 String compilerImpl = getCompiler();
		 CompilerAdapter adapter = nestedAdapter != null ? nestedAdapter : CompilerAdapterFactory.getCompiler(compilerImpl, this, createCompilerClasspath());
		 String[] extensions = null;
		 if (adapter instanceof CompilerAdapterExtension) {
			 extensions = ((CompilerAdapterExtension) adapter).getSupportedFileExtensions();
		 }
		 if (extensions == null) {
			 extensions = new String[] {
			 ""java"" }
			;
		 }
		 for (int i = 0;
		 i < extensions.length;
		 i++) {
			 if (!extensions[i].startsWith(""*."")) {
				 extensions[i] = ""*."" + extensions[i];
			 }
		 }
		 return extensions;
	 }
	 public File[] getFileList() {
		 return compileList;
	 }
	 protected boolean isJdkCompiler(String compilerImpl) {
		 return MODERN.equals(compilerImpl) || CLASSIC.equals(compilerImpl) || JAVAC18.equals(compilerImpl) || JAVAC17.equals(compilerImpl) || JAVAC16.equals(compilerImpl) || JAVAC15.equals(compilerImpl) || JAVAC14.equals(compilerImpl) || JAVAC13.equals(compilerImpl) || JAVAC12.equals(compilerImpl) || JAVAC11.equals(compilerImpl);
	 }
	 protected String getSystemJavac() {
		 return JavaEnvUtils.getJdkExecutable(""javac"");
	 }
	 public void setCompiler(String compiler) {
		 facade.setImplementation(compiler);
	 }
	 public String getCompiler() {
		 String compilerImpl = getCompilerVersion();
		 if (fork) {
			 if (isJdkCompiler(compilerImpl)) {
				 compilerImpl = EXTJAVAC;
			 }
			 else {
				 log(""Since compiler setting isn't classic or modern, "" + ""ignoring fork setting."", Project.MSG_WARN);
			 }
		 }
		 return compilerImpl;
	 }
	 public String getCompilerVersion() {
		 facade.setMagicValue(getProject().getProperty(""build.compiler""));
		 return facade.getImplementation();
	 }
	 protected void checkParameters() throws BuildException {
		 if (src == null) {
			 throw new BuildException(""srcdir attribute must be set!"", getLocation());
		 }
		 if (src.size() == 0) {
			 throw new BuildException(""srcdir attribute must be set!"", getLocation());
		 }
		 if (destDir != null && !destDir.isDirectory()) {
			 throw new BuildException(""destination directory \"""" + destDir + ""\"" does not exist "" + ""or is not a directory"", getLocation());
		 }
		 if (includeAntRuntime == null && getProject().getProperty(""build.sysclasspath"") == null) {
			 log(getLocation() + ""warning: 'includeantruntime' was not set, "" + ""defaulting to build.sysclasspath=last;
			 set to false for repeatable builds"", Project.MSG_WARN);
		 }
	 }
	 protected void compile() {
		 String compilerImpl = getCompiler();
		 if (compileList.length > 0) {
			 log(""Compiling "" + compileList.length + "" source file"" + (compileList.length == 1 ? """" : ""s"") + (destDir != null ? "" to "" + destDir : """"));
			 if (listFiles) {
				 for (int i = 0;
				 i < compileList.length;
				 i++) {
					 String filename = compileList[i].getAbsolutePath();
					 log(filename);
				 }
			 }
			 CompilerAdapter adapter = nestedAdapter != null ? nestedAdapter : CompilerAdapterFactory.getCompiler(compilerImpl, this, createCompilerClasspath());
			 adapter.setJavac(this);
			 if (adapter.execute()) {
				 if (createMissingPackageInfoClass) {
					 try {
						 generateMissingPackageInfoClasses(destDir != null ? destDir : getProject() .resolveFile(src.list()[0]));
					 }
					 catch (IOException x) {
						 throw new BuildException(x, getLocation());
					 }
				 }
			 }
			 else {
				 this.taskSuccess = false;
				 if (errorProperty != null) {
					 getProject().setNewProperty( errorProperty, ""true"");
				 }
				 if (failOnError) {
					 throw new BuildException(FAIL_MSG, getLocation());
				 }
				 else {
					 log(FAIL_MSG, Project.MSG_ERR);
				 }
			 }
		 }
	 }
	 public class ImplementationSpecificArgument extends org.apache.tools.ant.util.facade.ImplementationSpecificArgument {
		 public void setCompiler(String impl) {
			 super.setImplementation(impl);
		 }
	 }
	 private void lookForPackageInfos(File srcDir, File[] newFiles) {
		 for (int i = 0;
		 i < newFiles.length;
		 i++) {
			 File f = newFiles[i];
			 if (!f.getName().equals(""package-info.java"")) {
				 continue;
			 }
			 String path = FILE_UTILS.removeLeadingPath(srcDir, f). replace(File.separatorChar, '/');
			 String suffix = ""/package-info.java"";
			 if (!path.endsWith(suffix)) {
				 log(""anomalous package-info.java path: "" + path, Project.MSG_WARN);
				 continue;
			 }
			 String pkg = path.substring(0, path.length() - suffix.length());
			 packageInfos.put(pkg, new Long(f.lastModified()));
		 }
	 }
	 private void generateMissingPackageInfoClasses(File dest) throws IOException {
		 for (Iterator i = packageInfos.entrySet().iterator();
		 i.hasNext();
		 ) {
			 Map.Entry entry = (Map.Entry) i.next();
			 String pkg = (String) entry.getKey();
			 Long sourceLastMod = (Long) entry.getValue();
			 File pkgBinDir = new File(dest, pkg.replace('/', File.separatorChar));
			 pkgBinDir.mkdirs();
			 File pkgInfoClass = new File(pkgBinDir, ""package-info.class"");
			 if (pkgInfoClass.isFile() && pkgInfoClass.lastModified() >= sourceLastMod.longValue()) {
				 continue;
			 }
			 log(""Creating empty "" + pkgInfoClass);
			 OutputStream os = new FileOutputStream(pkgInfoClass);
			 try {
				 os.write(PACKAGE_INFO_CLASS_HEADER);
				 byte[] name = pkg.getBytes(""UTF-8"");
				 int length = name.length + 13;
				 os.write((byte) length / 256);
				 os.write((byte) length % 256);
				 os.write(name);
				 os.write(PACKAGE_INFO_CLASS_FOOTER);
			 }
			 finally {
				 os.close();
			 }
		 }
	 }
	 private static final byte[] PACKAGE_INFO_CLASS_HEADER = {
	 (byte) 0xca, (byte) 0xfe, (byte) 0xba, (byte) 0xbe, 0x00, 0x00, 0x00, 0x31, 0x00, 0x07, 0x07, 0x00, 0x05, 0x07, 0x00, 0x06, 0x01, 0x00, 0x0a, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x01, 0x00, 0x11, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x2d, 0x69, 0x6e, 0x66, 0x6f, 0x2e, 0x6a, 0x61, 0x76, 0x61, 0x01 }
	;
	 private static final byte[] PACKAGE_INFO_CLASS_FOOTER = {
	 0x2f, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x2d, 0x69, 0x6e, 0x66, 0x6f, 0x01, 0x00, 0x10, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x02, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x04 }
	;
}",0,0,0,0
"public void rebuildProperties() {
	m_skel = null;
	if (m_currentSkelName != null) m_skel = Main.SKELETONS.getSkeleton(m_currentSkelName);
	SkeletonProperty[] sprops = null;
	if (m_skel != null) sprops = m_skel.getSkeletonProperties();
	else sprops = new SkeletonProperty[0];
	m_panel.removeAll();
	m_editors.clear();
	for (int i=0;
	 i<sprops.length;
	 i++) {
		SkelPropEditor spe = null;
		if (sprops[i].getType().equalsIgnoreCase(SkeletonProperty.TYPE_STRING)) {
			spe = new StringEditor();
		 }
		else if (sprops[i].getType().equalsIgnoreCase(SkeletonProperty.TYPE_TEXTAREA)) {
			spe = new TextAreaEditor();
		 }
		else if (sprops[i].getType().equalsIgnoreCase(SkeletonProperty.TYPE_BOOLEAN)) {
			spe = new CheckBoxEditor();
		 }
		else if (sprops[i].getType().equalsIgnoreCase(SkeletonProperty.TYPE_AUTODOWNLOADURL)) {
			spe = new AutoDownloadURLEditor();
		 }
		if (spe == null) {
			spe = new StringEditor();
		 }
		m_editors.add(spe);
		spe.bind(sprops[i]);
		if (spe.labelAtLeft()) {
			m_panel.add(""br"", new JLabel(Main.local(sprops[i].getLabel())));
			m_panel.add(""tab"", new HelpButton(Main.local(sprops[i].getDescription())));
			m_panel.add(""tab hfill"", spe.getGUI());
		 }
		else {
			m_panel.add(""br right"", spe.getGUI());
			m_panel.add(""tab"", new HelpButton(Main.local(sprops[i].getDescription())));
			m_panel.add(""tab hfill"", new JLabel(Main.local(sprops[i].getLabel())));
		 }
	 }
	revalidate();
	m_panel.revalidate();
	doLayout();
	m_panel.doLayout();
 }",0,0,1,0
"public void start(Stage stage) {
	 try {
		 SplitPane splitPane = new SplitPane();
		 splitPane.setOrientation(Orientation.VERTICAL);
		 Scene fxScene = new Scene(splitPane);
		 stage.setTitle(""Feature Layer Rendering Mode Map Sample"");
		 stage.setWidth(800);
		 stage.setHeight(700);
		 stage.setScene(fxScene);
		 stage.show();
		 ArcGISMap mapTop = new ArcGISMap();
		 mapTop.getLoadSettings().setPreferredPointFeatureRenderingMode(FeatureLayer.RenderingMode.STATIC);
		 mapTop.getLoadSettings().setPreferredPolylineFeatureRenderingMode(FeatureLayer.RenderingMode.STATIC);
		 mapTop.getLoadSettings().setPreferredPolygonFeatureRenderingMode(FeatureLayer.RenderingMode.STATIC);
		 ArcGISMap mapBottom = new ArcGISMap();
		 mapBottom.getLoadSettings().setPreferredPointFeatureRenderingMode(FeatureLayer.RenderingMode.DYNAMIC);
		 mapBottom.getLoadSettings().setPreferredPolylineFeatureRenderingMode(FeatureLayer.RenderingMode.DYNAMIC);
		 mapBottom.getLoadSettings().setPreferredPolygonFeatureRenderingMode(FeatureLayer.RenderingMode.DYNAMIC);
		 mapViewTop = new MapView();
		 mapViewTop.setMap(mapTop);
		 splitPane.getItems().add(mapViewTop);
		 mapViewBottom = new MapView();
		 mapViewBottom.setMap(mapBottom);
		 splitPane.getItems().add(mapViewBottom);
		 ServiceFeatureTable pointServiceFeatureTable = new ServiceFeatureTable(""http: ServiceFeatureTable polylineServiceFeatureTable = new ServiceFeatureTable(""http: ServiceFeatureTable polygonServiceFeatureTable = new ServiceFeatureTable(""http: FeatureLayer pointFeatureLayer = new FeatureLayer(pointServiceFeatureTable);
		 FeatureLayer polylineFeatureLayer = new FeatureLayer(polylineServiceFeatureTable);
		 FeatureLayer polygonFeatureLayer = new FeatureLayer(polygonServiceFeatureTable);
		 mapTop.getOperationalLayers().addAll(Arrays.asList(pointFeatureLayer, polylineFeatureLayer, polygonFeatureLayer));
		 mapBottom.getOperationalLayers().addAll(Arrays.asList(pointFeatureLayer.copy(), polylineFeatureLayer.copy(), polygonFeatureLayer.copy()));
		 Viewpoint zoomOutPoint = new Viewpoint(new Point(-118.37, 34.46, SpatialReferences.getWgs84()), 650000, 0);
		 Viewpoint zoomInPoint = new Viewpoint(new Point(-118.45, 34.395, SpatialReferences.getWgs84()), 50000, 90);
		 mapViewTop.setViewpoint(zoomOutPoint);
		 mapViewBottom.setViewpoint(zoomOutPoint);
		 timeline = new Timeline();
		 timeline.setCycleCount(Animation.INDEFINITE);
		 timeline.getKeyFrames().add(new KeyFrame(Duration.seconds(7), event -> zoomTo(zoomInPoint)));
		 timeline.getKeyFrames().add(new KeyFrame(Duration.seconds(14), event -> zoomTo(zoomOutPoint)));
		 timeline.play();
	 }
	 catch (Exception e) {
		 e.printStackTrace();
	 }
 }",0,0,1,0
"public class AptExternalCompilerAdapter extends DefaultCompilerAdapter {
	 protected Apt getApt() {
		 return (Apt) getJavac();
	 }
	 public boolean execute() throws BuildException {
		 attributes.log(""Using external apt compiler"", Project.MSG_VERBOSE);
		 Apt apt = getApt();
		 Commandline cmd = new Commandline();
		 cmd.setExecutable(apt.getAptExecutable());
		 setupModernJavacCommandlineSwitches(cmd);
		 AptCompilerAdapter.setAptCommandlineSwitches(apt, cmd);
		 int firstFileName = cmd.size();
		 logAndAddFilesToCompile(cmd);
		 return 0 == executeExternalCompile(cmd.getCommandline(), firstFileName, true);
	 }
}",0,0,0,0
"public abstract class P4Base extends org.apache.tools.ant.Task {
	 protected Perl5Util util = null;
	 protected String shell;
	 protected String P4Port = """";
	 protected String P4Client = """";
	 protected String P4User = """";
	 protected String P4View = """";
	 protected boolean failOnError = true;
	 protected String P4Opts = """";
	 protected String P4CmdOpts = """";
	 private boolean inError = false;
	 private String errorMessage = """";
	 public boolean getInError() {
		 return inError;
	 }
	 public void setInError(boolean inError) {
		 this.inError = inError;
	 }
	 public String getErrorMessage() {
		 return errorMessage;
	 }
	 public void setErrorMessage(String errorMessage) {
		 this.errorMessage = errorMessage;
	 }
	 public void setPort(String p4Port) {
		 this.P4Port = ""-p"" + p4Port;
	 }
	 public void setClient(String p4Client) {
		 this.P4Client = ""-c"" + p4Client;
	 }
	 public void setUser(String p4User) {
		 this.P4User = ""-u"" + p4User;
	 }
	 public void setGlobalopts(String p4Opts) {
		 this.P4Opts = p4Opts;
	 }
	 public void setView(String p4View) {
		 this.P4View = p4View;
	 }
	 public void setCmdopts(String p4CmdOpts) {
		 this.P4CmdOpts = p4CmdOpts;
	 }
	 public void setFailonerror(boolean fail) {
		 failOnError = fail;
	 }
	 public void init() {
		 util = new Perl5Util();
		 String tmpprop;
		 if ((tmpprop = getProject().getProperty(""p4.port"")) != null) {
			 setPort(tmpprop);
		 }
		 if ((tmpprop = getProject().getProperty(""p4.client"")) != null) {
			 setClient(tmpprop);
		 }
		 if ((tmpprop = getProject().getProperty(""p4.user"")) != null) {
			 setUser(tmpprop);
		 }
	 }
	 protected void execP4Command(String command) throws BuildException {
		 execP4Command(command, null);
	 }
	 protected void execP4Command(String command, P4Handler handler) throws BuildException {
		 try {
			 inError = false;
			 errorMessage = """";
			 Commandline commandline = new Commandline();
			 commandline.setExecutable(""p4"");
			 if (P4Port != null && P4Port.length() != 0) {
				 commandline.createArgument().setValue(P4Port);
			 }
			 if (P4User != null && P4User.length() != 0) {
				 commandline.createArgument().setValue(P4User);
			 }
			 if (P4Client != null && P4Client.length() != 0) {
				 commandline.createArgument().setValue(P4Client);
			 }
			 if (P4Opts != null && P4Opts.length() != 0) {
				 commandline.createArgument().setLine(P4Opts);
			 }
			 commandline.createArgument().setLine(command);
			 log(commandline.describeCommand(), Project.MSG_VERBOSE);
			 if (handler == null) {
				 handler = new SimpleP4OutputHandler(this);
			 }
			 Execute exe = new Execute(handler, null);
			 exe.setAntRun(getProject());
			 exe.setCommandline(commandline.getCommandline());
			 try {
				 exe.execute();
				 if (inError && failOnError) {
					 throw new BuildException(errorMessage);
				 }
			 }
			 catch (IOException e) {
				 throw new BuildException(e);
			 }
			 finally {
				 try {
					 handler.stop();
				 }
				 catch (Exception e) {
					 log(""Error stopping execution framework: "" + e.toString(), Project.MSG_ERR);
				 }
			 }
		 }
		 catch (Exception e) {
			 String failMsg = ""Problem exec'ing P4 command: "" + e.getMessage();
			 if (failOnError) {
				 if (e instanceof BuildException) {
					 throw (BuildException) e;
				 }
				 else {
					 throw new BuildException(failMsg, e);
				 }
			 }
			 else {
				 log(failMsg, Project.MSG_ERR);
			 }
		 }
	 }
}",0,0,0,0
"public final class CallResolverDialog extends JDialog {
	 private final IconPanel[] panels = new IconPanel[] {
	new IconPanel(""1. Loading target""), new IconPanel(""2. Find indirect calls""), new IconPanel(""3. Start debugger"", new ResumeButton()), new IconPanel(""4. Set breakpoints""), new IconPanel(""5. Resolving breakpoints""), new IconPanel(""6. Stop call resolving"")}
	;
	 private final JTextArea outputArea = new JTextArea();
	 private final JButton listResolvedFunctionsButton = new JButton(new ListResolvedFunctionsAction());
	 private final JButton graphResolvedFunctionsButton = new JButton(new GraphResolvedFunctionsAction());
	 private final JButton portResultsButton = new JButton(new GraphAllFunctionsAction());
	 private final NextAction nextAction = new NextAction();
	 private final CallResolver callResolver;
	 private CallResolverDialog(final JFrame parent, final ICallResolverTarget target) {
		 super(parent, ""Call Resolver"");
		 assert parent != null;
		 assert target != null;
		 callResolver = new InternalCallResolver(target, parent);
		 setLayout(new BorderLayout());
		 add(new LabelPanel(), BorderLayout.NORTH);
		 add(new OutputPanel());
		 add(new ButtonPanel(), BorderLayout.SOUTH);
		 setSize(700, 600);
		 setResizable(false);
		 setLocationRelativeTo(parent);
		 Settings.setShowDialogs(false);
		 setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		 addWindowListener(new WindowAdapter() {
			 public void windowClosed(final WindowEvent e) {
				 close();
			 }
			 public void windowClosing(final WindowEvent e) {
				 setVisible(false);
				 dispose();
			 }
		 }
		);
		 updateGui();
	 }
	 public static void show(final JFrame parent, final ICallResolverTarget target) {
		 final CallResolverDialog dialog = new CallResolverDialog(parent, target);
		 dialog.setVisible(true);
	 }
	 private void appendOutput(final String string) {
		 outputArea.setText(outputArea.getText() + string + ""\n"");
		 outputArea.setCaretPosition(outputArea.getDocument().getLength());
	 }
	 private void close() {
		 Settings.setShowDialogs(true);
		 callResolver.dispose();
		 setVisible(false);
	 }
	 private void graphAllFunctions() {
		 new Thread() {
			 public void run() {
				 final View view = OutputGraphGenerator.createCompleteView( callResolver.getTarget(), callResolver.getIndirectAddresses(), callResolver.getResolvedAddresses());
				 final View2D view2d = PluginInterface.instance().showInLastWindow(view);
				 view2d.doHierarchicalLayout();
				 try {
					 view.save();
				 }
				 catch (final CouldntSaveDataException e) {
					 e.printStackTrace();
				 }
			 }
		 }
		.start();
	 }
	 private void graphResolvedFunctions() {
		 new Thread() {
			 public void run() {
				 final View view = OutputGraphGenerator.createLoggedView( callResolver.getTarget(), callResolver.getIndirectAddresses(), callResolver.getResolvedAddresses());
				 final View2D view2d = PluginInterface.instance().showInLastWindow(view);
				 view2d.doHierarchicalLayout();
				 try {
					 view.save();
				 }
				 catch (final CouldntSaveDataException e) {
					 e.printStackTrace();
				 }
			 }
		 }
		.start();
	 }
	 private void listResolvedFunctions() {
		 outputArea.setText(OutputListGenerator.generate(callResolver.getResolvedAddresses()));
		 outputArea.setCaretPosition(0);
	 }
	 private void updateGui() {
		 final int currentStep = callResolver.getCurrentStep();
		 for (int i = 0;
		 i < panels.length;
		 i++) {
			 panels[i].setEnabled(i <= currentStep);
			 panels[i].setDone(i < currentStep);
		 }
		 listResolvedFunctionsButton.setEnabled(currentStep == panels.length);
		 graphResolvedFunctionsButton.setEnabled(currentStep == panels.length);
		 portResultsButton.setEnabled(currentStep == panels.length);
		 nextAction.putValue(Action.NAME, currentStep == panels.length ? ""Reset"" : ""Next"");
	 }
	 private class ButtonPanel extends JPanel {
		 public ButtonPanel() {
			 super(new BorderLayout());
			 final JPanel innerButtonPanel = new JPanel(new BorderLayout());
			 innerButtonPanel.add(new JButton(nextAction), BorderLayout.WEST);
			 innerButtonPanel.add(new JButton(new CancelAction()), BorderLayout.EAST);
			 add(innerButtonPanel, BorderLayout.EAST);
		 }
	 }
	 private class CancelAction extends AbstractAction {
		 public CancelAction() {
			 super(""Cancel"");
		 }
		 public void actionPerformed(final ActionEvent e) {
			 close();
		 }
	 }
	 private class GraphAllFunctionsAction extends AbstractAction {
		 public GraphAllFunctionsAction() {
			 super(""Create complete call graph view"");
		 }
		 public void actionPerformed(final ActionEvent e) {
			 graphAllFunctions();
		 }
	 }
	 private class GraphResolvedFunctionsAction extends AbstractAction {
		 public GraphResolvedFunctionsAction() {
			 super(""Create limited call graph view"");
		 }
		 public void actionPerformed(final ActionEvent e) {
			 graphResolvedFunctions();
		 }
	 }
	 private static class IconPanel extends JPanel {
		 private final JLabel textLabel;
		 private JComponent additionalComponent;
		 private static ImageIcon ACCEPT_IMAGE;
		 private static ImageIcon BULLET_IMAGE;
		 public IconPanel(final String text) {
			 this(text, null);
		 }
		 public IconPanel(final String text, final JComponent additionalComponent) {
			 super(new BorderLayout());
			 if (ACCEPT_IMAGE == null) {
				 try {
					 ACCEPT_IMAGE = new ImageIcon(CallResolverDialog.class.getResource(""accept.png"").toURI().toURL());
					 BULLET_IMAGE = new ImageIcon( CallResolverDialog.class.getResource(""bullet_blue.png"").toURI().toURL());
				 }
				 catch (MalformedURLException | URISyntaxException e) {
					 e.printStackTrace();
				 }
			 }
			 textLabel = new JLabel(text);
			 textLabel.setEnabled(false);
			 add(textLabel);
			 if (additionalComponent != null) {
				 this.additionalComponent = additionalComponent;
				 add(additionalComponent, BorderLayout.EAST);
			 }
			 setPreferredSize(new Dimension(200, 20));
		 }
		 public void setDone(final boolean done) {
			 textLabel.setIcon(done ? ACCEPT_IMAGE : BULLET_IMAGE);
		 }
		 public void setEnabled(final boolean enabled) {
			 super.setEnabled(enabled);
			 if (additionalComponent != null) {
				 additionalComponent.setEnabled(enabled);
			 }
			 textLabel.setEnabled(enabled);
		 }
	 }
	 private class InternalCallResolver extends CallResolver {
		 public InternalCallResolver(final ICallResolverTarget target, final JFrame parent) {
			 super(target, parent);
		 }
		 protected void debuggerChanged() {
			 appendOutput(""Error: Target debugger changed. Resetting."");
			 updateGui();
		 }
		 protected void debuggerClosed() {
			 appendOutput(""Target debugger was closed."");
			 updateGui();
		 }
		 protected void errorConnectingDebugger(final DebugException e) {
			 appendOutput(""Error: Could not start the debugger."");
		 }
		 protected void errorLoadingModule(final Module module, final CouldntLoadDataException e) {
			 appendOutput( String.format(""Error loading module '%s' (%s)"", module.getName(), e.getMessage()));
		 }
		 protected void errorNoDebugger() {
			 appendOutput(""Error: No debugger configured for the selected target."");
		 }
		 protected void errorNotAttached() {
			 appendOutput(""Error: The debugger is not attached to the target process."");
		 }
		 protected void errorResuming(final DebugException e) {
			 appendOutput(""Error: Debugger could not be resumed after a breakpoint was hit."");
		 }
		 protected void foundIndirectCallAddresses(final List<IndirectCall> indirectCallAddresses) {
			 appendOutput(String.format(""Found %d indirect calls"", indirectCallAddresses.size()));
			 if (indirectCallAddresses.isEmpty()) {
				 appendOutput(""No indirect function calls found: The resolving process is complete"");
			 }
		 }
		 protected void resolvedCall( final BigInteger lastIndirectCall, final ResolvedFunction resolvedFunction) {
			 final Function function = resolvedFunction.getFunction();
			 final Address functionAddress = function == null ? resolvedFunction.getAddress() : function.getAddress();
			 final String functionName = function == null ? resolvedFunction.getMemoryModule().getName() + ""!???"" : function.getModule().getName() + ""!"" + function.getName();
			 appendOutput(String.format(""Done resolving: %08X -> %08X (%s)"", lastIndirectCall.longValue(), functionAddress.toLong(), functionName));
		 }
	 }
	 private class LabelPanel extends JPanel {
		 public LabelPanel() {
			 super(new GridLayout(panels.length + 1, 1));
			 for (final IconPanel panel : panels) {
				 add(panel);
			 }
			 final JPanel resultsPanel = new JPanel();
			 resultsPanel.add(listResolvedFunctionsButton);
			 resultsPanel.add(graphResolvedFunctionsButton);
			 resultsPanel.add(portResultsButton);
			 add(resultsPanel);
			 setBorder(new TitledBorder(""""));
		 }
	 }
	 private class ListResolvedFunctionsAction extends AbstractAction {
		 public ListResolvedFunctionsAction() {
			 super(""Show resolved functions"");
		 }
		 public void actionPerformed(final ActionEvent e) {
			 listResolvedFunctions();
		 }
	 }
	 private class NextAction extends AbstractAction {
		 public NextAction() {
			 super(""Next"");
		 }
		 public void actionPerformed(final ActionEvent event) {
			 callResolver.next();
			 updateGui();
		 }
	 }
	 private class OutputPanel extends JPanel {
		 public OutputPanel() {
			 super(new BorderLayout());
			 outputArea.setEditable(false);
			 outputArea.setFont(GuiHelper.MONOSPACED_FONT);
			 add(new JScrollPane(outputArea));
		 }
	 }
	 private class ResumeAction extends AbstractAction {
		 public ResumeAction() {
			 super(""Resume"");
		 }
		 public void actionPerformed(final ActionEvent event) {
			 try {
				 callResolver.getTarget().getDebugger().resume();
			 }
			 catch (final DebugException exception) {
				 appendOutput( String.format(""Error: Could not resume the debugger (%s)"", exception.toString()));
			 }
		 }
	 }
	 private class ResumeButton extends JButton {
		 public ResumeButton() {
			 super(new ResumeAction());
			 setPreferredSize(new Dimension(100, 20));
		 }
	 }
}",1,0,0,0
"public void loadDownloadList(File file) {
	if (!file.exists()) {
		return;
	}
	SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
	BufferedReader reader = null;
	try {
		reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), Charset.forName(""UTF-8"")));
		int count = Integer.parseInt(reader.readLine().trim());
		for (int i = 0;
		 i < count;
		 i++) {
			int fieldCount = Integer.parseInt(reader.readLine().trim());
			DownloadEntry ent = new DownloadEntry();
			for (int j = 0;
			 j < fieldCount;
			 j++) {
				String ln = reader.readLine();
				int index = ln.indexOf("":"");
				if (index > 0) {
					String key = ln.substring(0, index).trim();
					String val = ln.substring(index + 1).trim();
					if (key.equals(""id"")) {
						ent.setId(val);
					}
					if (key.equals(""file"")) {
						ent.setFile(val);
					}
					if (key.equals(""category"")) {
						ent.setCategory(Integer.parseInt(val));
					}
					if (key.equals(""state"")) {
						int state = Integer.parseInt(val);
						ent.setState(state == XDMConstants.FINISHED ? state : XDMConstants.PAUSED);
					}
					if (key.equals(""folder"")) {
						ent.setFolder(val);
					}
					if (key.equals(""date"")) {
						ent.setDate(dateFormat.parse(val).getTime());
					}
					if (key.equals(""downloaded"")) {
						ent.setDownloaded(Long.parseLong(val));
					}
					if (key.equals(""size"")) {
						ent.setSize(Long.parseLong(val));
					}
					if (key.equals(""progress"")) {
						ent.setProgress(Integer.parseInt(val));
					}
					if (key.equals(""queueid"")) {
						ent.setQueueId(val);
					}
					if (key.equals(""formatIndex"")) {
						ent.setOutputFormatIndex(Integer.parseInt(val));
					}
				}
			}
			downloads.put(ent.getId(), ent);
		}
		reader.close();
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	try {
		reader.close();
	}
	 catch (Exception e1) {
	}
}",0,0,1,0
"public class Logger {
	 private static final Handler emptyHandlers[] = new Handler[0];
	 private static final int offValue = Level.OFF.intValue();
	 private LogManager manager;
	 private String name;
	 private final CopyOnWriteArrayList<Handler> handlers = new CopyOnWriteArrayList<>();
	 private String resourceBundleName;
	 private volatile boolean useParentHandlers = true;
	 private volatile Filter filter;
	 private boolean anonymous;
	 private ResourceBundle catalog;
	 private String catalogName;
	 private Locale catalogLocale;
	 private static Object treeLock = new Object();
	 private volatile Logger parent;
	 private ArrayList<LogManager.LoggerWeakRef> kids;
	 private volatile Level levelObject;
	 private volatile int levelValue;
	 private WeakReference<ClassLoader> callersClassLoaderRef;
	 public static final String GLOBAL_LOGGER_NAME = ""global"";
	 public static final Logger getGlobal() {
		 return global;
	 }
	 public static final Logger global = new Logger(GLOBAL_LOGGER_NAME);
	 protected Logger(String name, String resourceBundleName) {
		 this(name, resourceBundleName, null);
	 }
	 Logger(String name, String resourceBundleName, Class<?> caller) {
		 this.manager = LogManager.getLogManager();
		 setupResourceInfo(resourceBundleName, caller);
		 this.name = name;
		 levelValue = Level.INFO.intValue();
	 }
	 private ClassLoader getCallersClassLoader() {
		 return (callersClassLoaderRef != null) ? callersClassLoaderRef.get() : null;
	 }
	 private Logger(String name) {
		 this.name = name;
		 levelValue = Level.INFO.intValue();
	 }
	 void setLogManager(LogManager manager) {
		 this.manager = manager;
	 }
	 private void checkPermission() throws SecurityException {
		 if (!anonymous) {
			 if (manager == null) {
				 manager = LogManager.getLogManager();
			 }
			 manager.checkPermission();
		 }
	 }
	 private static class LoggerHelper {
		 static boolean disableCallerCheck = getBooleanProperty(""sun.util.logging.disableCallerCheck"");
		 static boolean allowStackWalkSearch = getBooleanProperty(""jdk.logging.allowStackWalkSearch"");
		 private static boolean getBooleanProperty(final String key) {
			 String s = System.getProperty(key);
			 return Boolean.valueOf(s);
		 }
	 }
	 private static Logger demandLogger(String name, String resourceBundleName, Class<?> caller) {
		 LogManager manager = LogManager.getLogManager();
		 if (caller != null && !LoggerHelper.disableCallerCheck) {
			 if (caller.getClassLoader() == null) {
				 return manager.demandSystemLogger(name, resourceBundleName);
			 }
		 }
		 return manager.demandLogger(name, resourceBundleName, caller);
	 }
	 public static Logger getLogger(String name) {
		 return demandLogger(name, null, null);
	 }
	 public static Logger getLogger(String name, String resourceBundleName) {
		 Class<?> callerClass = null;
		 Logger result = demandLogger(name, resourceBundleName, callerClass);
		 if (result.resourceBundleName == null) {
			 result.setupResourceInfo(resourceBundleName, callerClass);
		 }
		 else if (!result.resourceBundleName.equals(resourceBundleName)) {
			 throw new IllegalArgumentException(result.resourceBundleName + "" != "" + resourceBundleName);
		 }
		 return result;
	 }
	 static Logger getPlatformLogger(String name) {
		 LogManager manager = LogManager.getLogManager();
		 Logger result = manager.demandSystemLogger(name, SYSTEM_LOGGER_RB_NAME);
		 return result;
	 }
	 public static Logger getAnonymousLogger() {
		 return getAnonymousLogger(null);
	 }
	 public static Logger getAnonymousLogger(String resourceBundleName) {
		 LogManager manager = LogManager.getLogManager();
		 manager.drainLoggerRefQueueBounded();
		 Logger result = new Logger(null, resourceBundleName, null);
		 result.anonymous = true;
		 Logger root = manager.getLogger("""");
		 result.doSetParent(root);
		 return result;
	 }
	 public ResourceBundle getResourceBundle() {
		 return findResourceBundle(getResourceBundleName(), true);
	 }
	 public String getResourceBundleName() {
		 return resourceBundleName;
	 }
	 public void setFilter(Filter newFilter) throws SecurityException {
		 checkPermission();
		 filter = newFilter;
	 }
	 public Filter getFilter() {
		 return filter;
	 }
	 public void log(LogRecord record) {
		 if (record.getLevel().intValue() < levelValue || levelValue == offValue) {
			 return;
		 }
		 Filter theFilter = filter;
		 if (theFilter != null && !theFilter.isLoggable(record)) {
			 return;
		 }
		 Logger logger = this;
		 while (logger != null) {
			 for (Handler handler : logger.getHandlers()) {
				 handler.publish(record);
			 }
			 if (!logger.getUseParentHandlers()) {
				 break;
			 }
			 logger = logger.getParent();
		 }
	 }
	 private void doLog(LogRecord lr) {
		 lr.setLoggerName(name);
		 String ebname = getEffectiveResourceBundleName();
		 if (ebname != null && !ebname.equals(SYSTEM_LOGGER_RB_NAME)) {
			 lr.setResourceBundleName(ebname);
			 lr.setResourceBundle(findResourceBundle(ebname, true));
		 }
		 log(lr);
	 }
	 public void log(Level level, String msg) {
		 if (level.intValue() < levelValue || levelValue == offValue) {
			 return;
		 }
		 LogRecord lr = new LogRecord(level, msg);
		 doLog(lr);
	 }
	 public void log(Level level, String msg, Object param1) {
		 if (level.intValue() < levelValue || levelValue == offValue) {
			 return;
		 }
		 LogRecord lr = new LogRecord(level, msg);
		 Object params[] = {
		 param1 }
		;
		 lr.setParameters(params);
		 doLog(lr);
	 }
	 public void log(Level level, String msg, Object params[]) {
		 if (level.intValue() < levelValue || levelValue == offValue) {
			 return;
		 }
		 LogRecord lr = new LogRecord(level, msg);
		 lr.setParameters(params);
		 doLog(lr);
	 }
	 public void log(Level level, String msg, Throwable thrown) {
		 if (level.intValue() < levelValue || levelValue == offValue) {
			 return;
		 }
		 LogRecord lr = new LogRecord(level, msg);
		 lr.setThrown(thrown);
		 doLog(lr);
	 }
	 public void logp(Level level, String sourceClass, String sourceMethod, String msg) {
		 if (level.intValue() < levelValue || levelValue == offValue) {
			 return;
		 }
		 LogRecord lr = new LogRecord(level, msg);
		 lr.setSourceClassName(sourceClass);
		 lr.setSourceMethodName(sourceMethod);
		 doLog(lr);
	 }
	 public void logp(Level level, String sourceClass, String sourceMethod, String msg, Object param1) {
		 if (level.intValue() < levelValue || levelValue == offValue) {
			 return;
		 }
		 LogRecord lr = new LogRecord(level, msg);
		 lr.setSourceClassName(sourceClass);
		 lr.setSourceMethodName(sourceMethod);
		 Object params[] = {
		 param1 }
		;
		 lr.setParameters(params);
		 doLog(lr);
	 }
	 public void logp(Level level, String sourceClass, String sourceMethod, String msg, Object params[]) {
		 if (level.intValue() < levelValue || levelValue == offValue) {
			 return;
		 }
		 LogRecord lr = new LogRecord(level, msg);
		 lr.setSourceClassName(sourceClass);
		 lr.setSourceMethodName(sourceMethod);
		 lr.setParameters(params);
		 doLog(lr);
	 }
	 public void logp(Level level, String sourceClass, String sourceMethod, String msg, Throwable thrown) {
		 if (level.intValue() < levelValue || levelValue == offValue) {
			 return;
		 }
		 LogRecord lr = new LogRecord(level, msg);
		 lr.setSourceClassName(sourceClass);
		 lr.setSourceMethodName(sourceMethod);
		 lr.setThrown(thrown);
		 doLog(lr);
	 }
	 private void doLog(LogRecord lr, String rbname) {
		 lr.setLoggerName(name);
		 if (rbname != null) {
			 lr.setResourceBundleName(rbname);
			 lr.setResourceBundle(findResourceBundle(rbname, false));
		 }
		 log(lr);
	 }
	 public void logrb(Level level, String sourceClass, String sourceMethod, String bundleName, String msg) {
		 if (level.intValue() < levelValue || levelValue == offValue) {
			 return;
		 }
		 LogRecord lr = new LogRecord(level, msg);
		 lr.setSourceClassName(sourceClass);
		 lr.setSourceMethodName(sourceMethod);
		 doLog(lr, bundleName);
	 }
	 public void logrb(Level level, String sourceClass, String sourceMethod, String bundleName, String msg, Object param1) {
		 if (level.intValue() < levelValue || levelValue == offValue) {
			 return;
		 }
		 LogRecord lr = new LogRecord(level, msg);
		 lr.setSourceClassName(sourceClass);
		 lr.setSourceMethodName(sourceMethod);
		 Object params[] = {
		 param1 }
		;
		 lr.setParameters(params);
		 doLog(lr, bundleName);
	 }
	 public void logrb(Level level, String sourceClass, String sourceMethod, String bundleName, String msg, Object params[]) {
		 if (level.intValue() < levelValue || levelValue == offValue) {
			 return;
		 }
		 LogRecord lr = new LogRecord(level, msg);
		 lr.setSourceClassName(sourceClass);
		 lr.setSourceMethodName(sourceMethod);
		 lr.setParameters(params);
		 doLog(lr, bundleName);
	 }
	 public void logrb(Level level, String sourceClass, String sourceMethod, String bundleName, String msg, Throwable thrown) {
		 if (level.intValue() < levelValue || levelValue == offValue) {
			 return;
		 }
		 LogRecord lr = new LogRecord(level, msg);
		 lr.setSourceClassName(sourceClass);
		 lr.setSourceMethodName(sourceMethod);
		 lr.setThrown(thrown);
		 doLog(lr, bundleName);
	 }
	 public void entering(String sourceClass, String sourceMethod) {
		 if (Level.FINER.intValue() < levelValue) {
			 return;
		 }
		 logp(Level.FINER, sourceClass, sourceMethod, ""ENTRY"");
	 }
	 public void entering(String sourceClass, String sourceMethod, Object param1) {
		 if (Level.FINER.intValue() < levelValue) {
			 return;
		 }
		 Object params[] = {
		 param1 }
		;
		 logp(Level.FINER, sourceClass, sourceMethod, ""ENTRY {
		0}
		"", params);
	 }
	 public void entering(String sourceClass, String sourceMethod, Object params[]) {
		 if (Level.FINER.intValue() < levelValue) {
			 return;
		 }
		 String msg = ""ENTRY"";
		 if (params == null ) {
			 logp(Level.FINER, sourceClass, sourceMethod, msg);
			 return;
		 }
		 for (int i = 0;
		 i < params.length;
		 i++) {
			 msg = msg + "" {
			"" + i + ""}
			"";
		 }
		 logp(Level.FINER, sourceClass, sourceMethod, msg, params);
	 }
	 public void exiting(String sourceClass, String sourceMethod) {
		 if (Level.FINER.intValue() < levelValue) {
			 return;
		 }
		 logp(Level.FINER, sourceClass, sourceMethod, ""RETURN"");
	 }
	 public void exiting(String sourceClass, String sourceMethod, Object result) {
		 if (Level.FINER.intValue() < levelValue) {
			 return;
		 }
		 Object params[] = {
		 result }
		;
		 logp(Level.FINER, sourceClass, sourceMethod, ""RETURN {
		0}
		"", result);
	 }
	 public void throwing(String sourceClass, String sourceMethod, Throwable thrown) {
		 if (Level.FINER.intValue() < levelValue || levelValue == offValue ) {
			 return;
		 }
		 LogRecord lr = new LogRecord(Level.FINER, ""THROW"");
		 lr.setSourceClassName(sourceClass);
		 lr.setSourceMethodName(sourceMethod);
		 lr.setThrown(thrown);
		 doLog(lr);
	 }
	 public void severe(String msg) {
		 if (Level.SEVERE.intValue() < levelValue) {
			 return;
		 }
		 log(Level.SEVERE, msg);
	 }
	 public void warning(String msg) {
		 if (Level.WARNING.intValue() < levelValue) {
			 return;
		 }
		 log(Level.WARNING, msg);
	 }
	 public void info(String msg) {
		 if (Level.INFO.intValue() < levelValue) {
			 return;
		 }
		 log(Level.INFO, msg);
	 }
	 public void config(String msg) {
		 if (Level.CONFIG.intValue() < levelValue) {
			 return;
		 }
		 log(Level.CONFIG, msg);
	 }
	 public void fine(String msg) {
		 if (Level.FINE.intValue() < levelValue) {
			 return;
		 }
		 log(Level.FINE, msg);
	 }
	 public void finer(String msg) {
		 if (Level.FINER.intValue() < levelValue) {
			 return;
		 }
		 log(Level.FINER, msg);
	 }
	 public void finest(String msg) {
		 if (Level.FINEST.intValue() < levelValue) {
			 return;
		 }
		 log(Level.FINEST, msg);
	 }
	 public void setLevel(Level newLevel) throws SecurityException {
		 checkPermission();
		 synchronized (treeLock) {
			 levelObject = newLevel;
			 updateEffectiveLevel();
		 }
	 }
	 public Level getLevel() {
		 return levelObject;
	 }
	 public boolean isLoggable(Level level) {
		 if (level.intValue() < levelValue || levelValue == offValue) {
			 return false;
		 }
		 return true;
	 }
	 public String getName() {
		 return name;
	 }
	 public void addHandler(Handler handler) throws SecurityException {
		 handler.getClass();
		 checkPermission();
		 handlers.add(handler);
	 }
	 public void removeHandler(Handler handler) throws SecurityException {
		 checkPermission();
		 if (handler == null) {
			 return;
		 }
		 handlers.remove(handler);
	 }
	 public Handler[] getHandlers() {
		 return handlers.toArray(emptyHandlers);
	 }
	 public void setUseParentHandlers(boolean useParentHandlers) {
		 checkPermission();
		 this.useParentHandlers = useParentHandlers;
	 }
	 public boolean getUseParentHandlers() {
		 return useParentHandlers;
	 }
	 static final String SYSTEM_LOGGER_RB_NAME = ""sun.util.logging.resources.logging"";
	 private static ResourceBundle findSystemResourceBundle(final Locale locale) {
		 return new ListResourceBundle() {
			 protected Object[][] getContents() {
				 return new Object[][] {
					 {
					 ""ALL"", ""ALL"" }
					, {
					 ""SEVERE"", ""SEVERE"" }
					, {
					 ""WARNING"", ""WARNING"" }
					, {
					 ""INFO"", ""INFO"" }
					, {
					 ""CONFIG"", ""CONFIG"" }
					, {
					 ""FINE"", ""FINE"" }
					, {
					 ""FINER"", ""FINER"" }
					, {
					 ""FINEST"", ""FINEST"" }
					, {
					 ""OFF"", ""OFF"" }
				 }
				;
			 }
		 }
		;
	 }
	 private synchronized ResourceBundle findResourceBundle(String name, boolean useCallersClassLoader) {
		 if (name == null) {
			 return null;
		 }
		 Locale currentLocale = Locale.getDefault();
		 if (catalog != null && currentLocale.equals(catalogLocale) && name.equals(catalogName)) {
			 return catalog;
		 }
		 if (name.equals(SYSTEM_LOGGER_RB_NAME)) {
			 catalog = findSystemResourceBundle(currentLocale);
			 catalogName = name;
			 catalogLocale = currentLocale;
			 return catalog;
		 }
		 ClassLoader cl = Thread.currentThread().getContextClassLoader();
		 if (cl == null) {
			 cl = ClassLoader.getSystemClassLoader();
		 }
		 try {
			 catalog = ResourceBundle.getBundle(name, currentLocale, cl);
			 catalogName = name;
			 catalogLocale = currentLocale;
			 return catalog;
		 }
		 catch (MissingResourceException ex) {
		 }
		 return null;
	 }
	 private synchronized void setupResourceInfo(String name, Class<?> callersClass) {
		 if (name == null) {
			 return;
		 }
		 if (findResourceBundle(name, true) == null) {
			 this.callersClassLoaderRef = null;
			 throw new MissingResourceException(""Can't find "" + name + "" bundle"", name, """");
		 }
		 resourceBundleName = name;
	 }
	 public Logger getParent() {
		 return parent;
	 }
	 public void setParent(Logger parent) {
		 if (parent == null) {
			 throw new NullPointerException();
		 }
		 manager.checkPermission();
		 doSetParent(parent);
	 }
	 private void doSetParent(Logger newParent) {
		 synchronized (treeLock) {
			 LogManager.LoggerWeakRef ref = null;
			 if (parent != null) {
				 for (Iterator<LogManager.LoggerWeakRef> iter = parent.kids.iterator();
				 iter.hasNext();
				 ) {
					 ref = iter.next();
					 Logger kid = ref.get();
					 if (kid == this) {
						 iter.remove();
						 break;
					 }
					 else {
						 ref = null;
					 }
				 }
			 }
			 parent = newParent;
			 if (parent.kids == null) {
				 parent.kids = new ArrayList<>(2);
			 }
			 if (ref == null) {
				 ref = manager.new LoggerWeakRef(this);
			 }
			 ref.setParentRef(new WeakReference<Logger>(parent));
			 parent.kids.add(ref);
			 updateEffectiveLevel();
		 }
	 }
	 final void removeChildLogger(LogManager.LoggerWeakRef child) {
		 synchronized (treeLock) {
			 for (Iterator<LogManager.LoggerWeakRef> iter = kids.iterator();
			 iter.hasNext();
			 ) {
				 LogManager.LoggerWeakRef ref = iter.next();
				 if (ref == child) {
					 iter.remove();
					 return;
				 }
			 }
		 }
	 }
	 private void updateEffectiveLevel() {
		 int newLevelValue;
		 if (levelObject != null) {
			 newLevelValue = levelObject.intValue();
		 }
		 else {
			 if (parent != null) {
				 newLevelValue = parent.levelValue;
			 }
			 else {
				 newLevelValue = Level.INFO.intValue();
			 }
		 }
		 if (levelValue == newLevelValue) {
			 return;
		 }
		 levelValue = newLevelValue;
		 if (kids != null) {
			 for (int i = 0;
			 i < kids.size();
			 i++) {
				 LogManager.LoggerWeakRef ref = kids.get(i);
				 Logger kid = ref.get();
				 if (kid != null) {
					 kid.updateEffectiveLevel();
				 }
			 }
		 }
	 }
	 private String getEffectiveResourceBundleName() {
		 Logger target = this;
		 while (target != null) {
			 String rbn = target.getResourceBundleName();
			 if (rbn != null) {
				 return rbn;
			 }
			 target = target.getParent();
		 }
		 return null;
	 }
}",1,0,0,0
"private DatanodeInfo bestNode(DFSClient dfs, DatanodeInfo[] nodes, TreeSet deadNodes) throws IOException {
	 if ((nodes == null) || (nodes.length - deadNodes.size() < 1)) {
		 throw new IOException(""No live nodes contain current block"");
	 }
	 DatanodeInfo chosenNode = null;
	 for (int i = 0;
	 i < nodes.length;
	 i++) {
		 if (deadNodes.contains(nodes[i])) {
			 continue;
		 }
		 String nodename = nodes[i].getName();
		 int colon = nodename.indexOf(':');
		 if (colon >= 0) {
			 nodename = nodename.substring(0, colon);
		 }
		 if (dfs.localName.equals(nodename)) {
			 chosenNode = nodes[i];
			 break;
		 }
	 }
	 if (chosenNode == null) {
		 do {
			 chosenNode = nodes[Math.abs(r.nextInt()) % nodes.length];
		 }
		 while (deadNodes.contains(chosenNode));
	 }
	 return chosenNode;
 }",0,0,0,0
"public final class DateUtils {
	 private static final int ONE_SECOND = 1000;
	 private static final int ONE_MINUTE = 60;
	 private static final int ONE_HOUR = 60;
	 private static final int TEN = 10;
	 public static final String ISO8601_DATETIME_PATTERN = ""yyyy-MM-dd'T'HH:mm:ss"";
	 public static final String ISO8601_DATE_PATTERN = ""yyyy-MM-dd"";
	 public static final String ISO8601_TIME_PATTERN = ""HH:mm:ss"";
	 public static final DateFormat DATE_HEADER_FORMAT = new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss "", Locale.US);
	 private static final MessageFormat MINUTE_SECONDS = new MessageFormat(""{
	0}
	{
	1}
	"");
	 private static final double[] LIMITS = {
	0, 1, 2}
	;
	 private static final String[] MINUTES_PART = {
		"""", ""1 minute "", ""{
		0,number}
	 minutes ""}
	;
	 private static final String[] SECONDS_PART = {
		""0 seconds"", ""1 second"", ""{
		1,number}
	 seconds""}
	;
	 private static final ChoiceFormat MINUTES_FORMAT = new ChoiceFormat(LIMITS, MINUTES_PART);
	 private static final ChoiceFormat SECONDS_FORMAT = new ChoiceFormat(LIMITS, SECONDS_PART);
	 static {
		 MINUTE_SECONDS.setFormat(0, MINUTES_FORMAT);
		 MINUTE_SECONDS.setFormat(1, SECONDS_FORMAT);
	 }
	 private DateUtils() {
	 }
	 public static String format(long date, String pattern) {
		 return format(new Date(date), pattern);
	 }
	 public static String format(Date date, String pattern) {
		 DateFormat df = createDateFormat(pattern);
		 return df.format(date);
	 }
	 public static String formatElapsedTime(long millis) {
		 long seconds = millis / ONE_SECOND;
		 long minutes = seconds / ONE_MINUTE;
		 Object[] args = {
		new Long(minutes), new Long(seconds % ONE_MINUTE)}
		;
		 return MINUTE_SECONDS.format(args);
	 }
	 private static DateFormat createDateFormat(String pattern) {
		 SimpleDateFormat sdf = new SimpleDateFormat(pattern);
		 TimeZone gmt = TimeZone.getTimeZone(""GMT"");
		 sdf.setTimeZone(gmt);
		 sdf.setLenient(true);
		 return sdf;
	 }
	 public static int getPhaseOfMoon(Calendar cal) {
		 int dayOfTheYear = cal.get(Calendar.DAY_OF_YEAR);
		 int yearInMetonicCycle = ((cal.get(Calendar.YEAR) - 1900) % 19) + 1;
		 int epact = (11 * yearInMetonicCycle + 18) % 30;
		 if ((epact == 25 && yearInMetonicCycle > 11) || epact == 24) {
			 epact++;
		 }
		 return (((((dayOfTheYear + epact) * 6) + 11) % 177) / 22) & 7;
	 }
	 public static String getDateForHeader() {
		 Calendar cal = Calendar.getInstance();
		 TimeZone tz = cal.getTimeZone();
		 int offset = tz.getOffset(cal.get(Calendar.ERA), cal.get(Calendar.YEAR), cal.get(Calendar.MONTH), cal.get(Calendar.DAY_OF_MONTH), cal.get(Calendar.DAY_OF_WEEK), cal.get(Calendar.MILLISECOND));
		 StringBuffer tzMarker = new StringBuffer(offset < 0 ? ""-"" : ""+"");
		 offset = Math.abs(offset);
		 int hours = offset / (ONE_HOUR * ONE_MINUTE * ONE_SECOND);
		 int minutes = offset / (ONE_MINUTE * ONE_SECOND) - ONE_HOUR * hours;
		 if (hours < TEN) {
			 tzMarker.append(""0"");
		 }
		 tzMarker.append(hours);
		 if (minutes < TEN) {
			 tzMarker.append(""0"");
		 }
		 tzMarker.append(minutes);
		 return DATE_HEADER_FORMAT.format(cal.getTime()) + tzMarker.toString();
	 }
	 public static Date parseIso8601DateTime(String datestr) throws ParseException {
		 return new SimpleDateFormat(ISO8601_DATETIME_PATTERN).parse(datestr);
	 }
	 public static Date parseIso8601Date(String datestr) throws ParseException {
		 return new SimpleDateFormat(ISO8601_DATE_PATTERN).parse(datestr);
	 }
	 public static Date parseIso8601DateTimeOrDate(String datestr) throws ParseException {
		 try {
			 return parseIso8601DateTime(datestr);
		 }
		 catch (ParseException px) {
			 return parseIso8601Date(datestr);
		 }
	 }
}",0,0,0,0
"public String[] mapFileName(String sourceFileName) {
	 if (handleDirSep) {
		 if (sourceFileName.indexOf(""\\"") != -1) {
			 sourceFileName = sourceFileName.replace('\\', '/');
		 }
	 }
	 if (reg == null || to == null || !reg.matches(sourceFileName, regexpOptions)) {
		 return null;
	 }
	 return new String[] {
	replaceReferences(sourceFileName)}
	;
 }",0,0,0,0
"private static class VmdkDatastoreDiscoveredCallbackHandler extends AbstractCallbackServiceHandler {
	 private final BiConsumer<CallbackServiceHandlerState, ServiceErrorResponse> consumer;
	 public VmdkDatastoreDiscoveredCallbackHandler( BiConsumer<CallbackServiceHandlerState, ServiceErrorResponse> consumer) {
		 this.consumer = consumer;
	 }
	 protected void handleFailedStagePatch(CallbackServiceHandlerState state) {
		 ServiceErrorResponse err = state.taskInfo.failure;
		 logWarning(""Failed updating host info"");
		 if (err != null && err.stackTrace != null) {
			 logFine(""Task failure stack trace: %s"", err.stackTrace);
			 logWarning(""Task failure error message: %s"", err.message);
			 consumer.accept(state, err);
			 if (completionCallback != null) {
				 completionCallback.run();
			 }
		 }
	 }
	 protected void handleFinishedStagePatch(CallbackServiceHandlerState state) {
		 consumer.accept(state, null);
		 if (completionCallback != null) {
			 completionCallback.run();
		 }
	 }
 }",0,0,0,0
"public final class HeaderSection extends UniformItemSection {
	 private final List<HeaderItem> list;
	 public HeaderSection(DexFile file) {
		 super(null, file, 4);
		 HeaderItem item = new HeaderItem();
		 item.setIndex(0);
		 this.list = Collections.singletonList(item);
	 }
	 public IndexedItem get(Constant cst) {
		 return null;
	 }
	 public Collection<? extends Item> items() {
		 return list;
	 }
	 protected void orderItems() {
	 }
}",0,1,0,0
"private int addManualRecord(Airing recAir, UIClient uiClient) {
	 Set<EncoderState> tryUs = new HashSet<EncoderState>(encoderStateMap.values());
	 Iterator<EncoderState> walker = tryUs.iterator();
	 Set<Integer> unifiedStationSet = new HashSet<Integer>();
	 boolean encoderExists = false;
	 while (walker.hasNext()) {
		 EncoderState es = walker.next();
		 synchronized (es.stationSet) {
			 if (es.stationSet.contains(recAir.stationID)) {
				 encoderExists = true;
				 unifiedStationSet.addAll(es.stationSet);
				 walker.remove();
				 break;
			 }
		 }
	 }
	 if (!encoderExists) return VideoFrame.WATCH_FAILED_NO_ENCODERS_HAVE_STATION;
	 int lastSetSize;
	 do {
		 lastSetSize = unifiedStationSet.size();
		 walker = tryUs.iterator();
		 while (walker.hasNext()) {
			 EncoderState es = walker.next();
			 synchronized (es.stationSet) {
				 if (unifiedStationSet.removeAll(es.stationSet)) {
					 unifiedStationSet.addAll(es.stationSet);
					 walker.remove();
				 }
			 }
		 }
	 }
	 while (lastSetSize != unifiedStationSet.size() && !tryUs.isEmpty());
	 long defaultStartPadding = Sage.getLong(""default_mr_start_padding"", 0);
	 long defaultStopPadding = Sage.getLong(""default_mr_stop_padding"", 0);
	 long requestedStart = recAir.getStartTime() - defaultStartPadding;
	 long requestedStop = recAir.getEndTime() + defaultStopPadding;
	 long requestedDuration = requestedStop - requestedStart;
	 Airing schedAir = recAir;
	 if (defaultStartPadding != 0 || defaultStopPadding != 0) {
		 schedAir = new Airing(0);
		 schedAir.time = requestedStart;
		 schedAir.duration = requestedDuration;
		 schedAir.stationID = recAir.stationID;
		 schedAir.showID = recAir.showID;
	 }
	 Vector<Airing> parallelRecords = new Vector<Airing>();
	 Vector<Airing> lastParallel = null;
	 do {
		 parallelRecords.clear();
		 ManualRecord[] manualMustSee = wiz.getManualRecordsSortedByTime();
		 Vector<ManualRecord> parallelRecurs = new Vector<ManualRecord>();
		 for (int i = 0;
		 i < manualMustSee.length;
		 i++) {
			 ManualRecord currRec = manualMustSee[i];
			 if (currRec.getContentAiring() == recAir) return VideoFrame.WATCH_OK;
			 if (currRec.getEndTime() <= Sage.time()) continue;
			 if (currRec.doRecurrencesOverlap(requestedStart, requestedDuration, 0)) {
				 parallelRecords.addElement(manualMustSee[i].getSchedulingAiring());
				 if (currRec.recur != 0) parallelRecurs.add(currRec);
				 else parallelRecurs.add(null);
			 }
		 }
		 if (parallelRecords.isEmpty()) break;
		 parallelRecords.addElement(schedAir);
		 parallelRecurs.add(null);
		 if (sched.testMultiTunerSchedulingPermutation(parallelRecords)) break;
		 for (int i = 0;
		 i < parallelRecurs.size();
		 i++) {
			 ManualRecord currRecur = parallelRecurs.get(i);
			 if (currRecur == null) continue;
			 for (int j = 0;
			 j < parallelRecords.size();
			 j++) {
				 if (i == j || parallelRecurs.get(j) == null) continue;
				 ManualRecord otherRecur = parallelRecurs.get(j);
				 if (currRecur.stationID == otherRecur.stationID && currRecur.duration == otherRecur.duration && currRecur.recur == otherRecur.recur && currRecur.isSameRecurrence(otherRecur.startTime)) {
					 parallelRecurs.remove(j);
					 parallelRecords.remove(j);
					 j--;
				 }
			 }
		 }
		 parallelRecords.remove(schedAir);
		 for (int i = 0;
		 i < parallelRecords.size();
		 i++) if (!unifiedStationSet.contains(parallelRecords.get(i).stationID)) parallelRecords.remove(i--);
		 if (lastParallel != null && parallelRecords.equals(lastParallel)) return VideoFrame.WATCH_FAILED_USER_REJECTED_CONFLICT;
		 Object hookRes = (uiClient == null) ? null : uiClient.processUIClientHook(""RecordRequestScheduleConflict"", new Object[] {
		 recAir, parallelRecords }
		);
		 if (!(hookRes instanceof Boolean) || !((Boolean) hookRes)) return VideoFrame.WATCH_FAILED_USER_REJECTED_CONFLICT;
		 lastParallel = new Vector<Airing>(parallelRecords);
	 }
	 while (true);
	 ManualRecord newMR;
	 if (schedAir.getStartTime() < Sage.time()) {
		 int[] errorReturn = new int[1];
		 EncoderState es = findBestEncoderForNow(schedAir, true, uiClient, errorReturn);
		 if (es == null) {
			 if (errorReturn[0] == 0) errorReturn[0] = VideoFrame.WATCH_FAILED_GENERAL_CANT_FIND_ENCODER;
			 return errorReturn[0];
		 }
		 synchronized (this) {
			 es = checkForFoundBestEncoderNowRecordSwitch(es, recAir);
			 MediaFile mf = wiz.getFileForAiring(recAir);
			 if (mf != null) mf.setAcquisitionTech(MediaFile.ACQUISITION_MANUAL);
			 newMR = wiz.addManualRecord(requestedStart, requestedDuration, 0, recAir.stationID, """", """", recAir.id, 0);
			 es.forceWatch = newMR.getSchedulingAiring();
			 es.forceProcessed = false;
			 work();
		 }
	 }
	 else newMR = wiz.addManualRecord(requestedStart, requestedDuration, 0, recAir.stationID, """", """", recAir.id, 0);
	 PluginEventManager.postEvent(PluginEventManager.MANUAL_RECORD_ADDED, new Object[] {
	 PluginEventManager.VAR_AIRING, newMR.getSchedulingAiring() }
	);
	 return VideoFrame.WATCH_OK;
 }",0,0,1,0
"protected static class CallbackCompleteResponse extends ServiceTaskCallbackResponse {
	 Set<String> resourceLinks;
 }",0,0,0,0
"public class SerializationRegistrationType {
	 protected List<Serializer> serializers;
	 protected List<Instantiator> instantiators;
	 public List<Serializer> getSerializers() {
		 if (serializers == null) {
			 serializers = new ArrayList<Serializer>();
		 }
		 return this.serializers;
	 }
	 public List<Instantiator> getInstantiators() {
		 if (instantiators == null) {
			 instantiators = new ArrayList<Instantiator>();
		 }
		 return this.instantiators;
	 }
	 public static class Instantiator {
		 protected String className;
		 protected String id;
		 public String getClassName() {
			 return className;
		 }
		 public void setClassName(String value) {
			 this.className = value;
		 }
		 public String getId() {
			 return id;
		 }
		 public void setId(String value) {
			 this.id = value;
		 }
	 }
	 public static class Serializer {
		 protected String className;
		 public String getClassName() {
			 return className;
		 }
		 public void setClassName(String value) {
			 this.className = value;
		 }
	 }
}",1,1,0,0
"protected VectorizedRowBatch setupOverflowBatch() throws HiveException {
	 int initialColumnCount = vContext.firstOutputColumnIndex();
	 VectorizedRowBatch overflowBatch;
	 int totalNumColumns = initialColumnCount + vOutContext.getScratchColumnTypeNames().length;
	 overflowBatch = new VectorizedRowBatch(totalNumColumns);
	 for (int i = 0;
	 i < outputProjectionColumnMap.length;
	 i++) {
		 int outputColumn = outputProjectionColumnMap[i];
		 String typeName = outputTypeInfos[i].getTypeName();
		 allocateOverflowBatchColumnVector(overflowBatch, outputColumn, typeName);
	 }
	 int outputColumn = initialColumnCount;
	 for (String typeName : vOutContext.getScratchColumnTypeNames()) {
		 allocateOverflowBatchColumnVector(overflowBatch, outputColumn++, typeName);
	 }
	 overflowBatch.projectedColumns = outputProjectionColumnMap;
	 overflowBatch.projectionSize = outputProjectionColumnMap.length;
	 overflowBatch.reset();
	 return overflowBatch;
 }",0,0,1,0
"static class DelayedTimer implements Delayed {
	 private static final AtomicLong sequencer = new AtomicLong(0);
	 private final long sequenceNumber;
	 private volatile long time;
	 private final Timer timer;
	 DelayedTimer(Timer timer, long nanos) {
		 this.timer = timer;
		 time = nanos;
		 sequenceNumber = sequencer.getAndIncrement();
	 }
	 public final long getDelay(TimeUnit unit) {
		 return unit.convert(time - now(), TimeUnit.NANOSECONDS);
	 }
	 final void setTime(long nanos) {
		 time = nanos;
	 }
	 final Timer getTimer() {
		 return timer;
	 }
	 public int compareTo(Delayed other) {
		 if (other == this) {
			 return 0;
		 }
		 if (other instanceof DelayedTimer) {
			 DelayedTimer x = (DelayedTimer)other;
			 long diff = time - x.time;
			 if (diff < 0) {
				 return -1;
			 }
			 else if (diff > 0) {
				 return 1;
			 }
			 else if (sequenceNumber < x.sequenceNumber) {
				 return -1;
			 }
			 else {
				 return 1;
			 }
		 }
		 long d = (getDelay(TimeUnit.NANOSECONDS) - other.getDelay(TimeUnit.NANOSECONDS));
		 return (d == 0) ? 0 : ((d < 0) ? -1 : 1);
	 }
 }",0,0,0,0
"public class BatchWriterReplicationReplayer implements AccumuloReplicationReplayer {
	 private static final Logger log = LoggerFactory.getLogger(BatchWriterReplicationReplayer.class);
	 public long replicateLog(ClientContext context, String tableName, WalEdits data) throws RemoteReplicationException {
		 final LogFileKey key = new LogFileKey();
		 final LogFileValue value = new LogFileValue();
		 final long memoryInBytes = context.getConfiguration() .getAsBytes(Property.TSERV_REPLICATION_BW_REPLAYER_MEMORY);
		 BatchWriter bw = null;
		 long mutationsApplied = 0L;
		 try {
			 for (ByteBuffer edit : data.getEdits()) {
				 DataInputStream dis = new DataInputStream(ByteBufferUtil.toByteArrayInputStream(edit));
				 try {
					 key.readFields(dis);
					 value.readFields(dis);
				 }
				 catch (IOException e) {
					 log.error(""Could not deserialize edit from stream"", e);
					 throw new RemoteReplicationException(RemoteReplicationErrorCode.COULD_NOT_DESERIALIZE, ""Could not deserialize edit from stream"");
				 }
				 if (bw == null) {
					 BatchWriterConfig bwConfig = new BatchWriterConfig();
					 bwConfig.setMaxMemory(memoryInBytes);
					 try {
						 bw = context.createBatchWriter(tableName, bwConfig);
					 }
					 catch (TableNotFoundException e) {
						 throw new RemoteReplicationException(RemoteReplicationErrorCode.TABLE_DOES_NOT_EXIST, ""Table "" + tableName + "" does not exist"");
					 }
				 }
				 log.info(""Applying {
				}
				 mutations to table {
				}
				 as part of batch"", value.mutations.size(), tableName);
				 List<Mutation> mutationsCopy = new ArrayList<>(value.mutations.size());
				 long mutationsCopied = 0L;
				 for (Mutation orig : value.mutations) {
					 if (orig instanceof ServerMutation) {
						 mutationsCopied++;
						 ServerMutation origServer = (ServerMutation) orig;
						 Mutation copy = new Mutation(orig.getRow());
						 for (ColumnUpdate update : orig.getUpdates()) {
							 long timestamp;
							 if (!update.hasTimestamp()) {
								 timestamp = origServer.getSystemTimestamp();
							 }
							 else {
								 timestamp = update.getTimestamp();
							 }
							 if (update.isDeleted()) {
								 copy.putDelete(update.getColumnFamily(), update.getColumnQualifier(), new ColumnVisibility(update.getColumnVisibility()), timestamp);
							 }
							 else {
								 copy.put(update.getColumnFamily(), update.getColumnQualifier(), new ColumnVisibility(update.getColumnVisibility()), timestamp, update.getValue());
							 }
						 }
						 Set<String> replicationSources = orig.getReplicationSources();
						 if (replicationSources != null && !replicationSources.isEmpty()) {
							 for (String replicationSource : replicationSources) {
								 copy.addReplicationSource(replicationSource);
							 }
						 }
						 mutationsCopy.add(copy);
					 }
					 else {
						 mutationsCopy.add(orig);
					 }
				 }
				 log.debug(""Copied {
				}
				 mutations to ensure server-assigned timestamps are propagated"", mutationsCopied);
				 try {
					 bw.addMutations(mutationsCopy);
				 }
				 catch (MutationsRejectedException e) {
					 log.error(""Could not apply mutations to {
					}
					"", tableName);
					 throw new RemoteReplicationException(RemoteReplicationErrorCode.COULD_NOT_APPLY, ""Could not apply mutations to "" + tableName);
				 }
				 log.debug(""{
				}
				 mutations added to the BatchScanner"", mutationsCopy.size());
				 mutationsApplied += mutationsCopy.size();
			 }
		 }
		 finally {
			 if (bw != null) {
				 try {
					 bw.close();
				 }
				 catch (MutationsRejectedException e) {
					 log.error(""Could not apply mutations to {
					}
					"", tableName);
					 throw new RemoteReplicationException(RemoteReplicationErrorCode.COULD_NOT_APPLY, ""Could not apply mutations to "" + tableName);
				 }
			 }
		 }
		 log.info(""Applied {
		}
		 mutations in total to {
		}
		"", mutationsApplied, tableName);
		 return mutationsApplied;
	 }
}",1,0,0,0
"private static byte[] decodeUrl( byte[] bytes ) throws UrlDecoderException {
	 if ( bytes == null ) {
		 return Strings.EMPTY_BYTES;
	 }
	 ByteArrayOutputStream buffer = new ByteArrayOutputStream();
	 for ( int i = 0;
	 i < bytes.length;
	 i++ ) {
		 int b = bytes[i];
		 if ( b == '%' ) {
			 try {
				 int u = Character.digit( ( char ) bytes[++i], 16 );
				 int l = Character.digit( ( char ) bytes[++i], 16 );
				 if ( ( u == -1 ) || ( l == -1 ) ) {
					 throw new UrlDecoderException( I18n.err( I18n.ERR_13040_INVALID_URL_ENCODING ) );
				 }
				 buffer.write( ( char ) ( ( u << 4 ) + l ) );
			 }
			 catch ( ArrayIndexOutOfBoundsException aioobe ) {
				 throw new UrlDecoderException( I18n.err( I18n.ERR_13040_INVALID_URL_ENCODING ), aioobe );
			 }
		 }
		 else {
			 buffer.write( b );
		 }
	 }
	 return buffer.toByteArray();
 }",0,0,1,0
"private class FirstPaintListener implements PaintListener {
	 public void paintControl(final PaintEvent e) {
		 ((Composite) e.widget).removePaintListener(this);
		 hookDialogIsOpen();
	 }
 }",0,0,0,0
"public void assureSufficientLiveNodes() throws UnavailableException {
	 int liveNodes = 0;
	 for (InetAddress destination : writeEndpoints) {
		 if (localdc.equals(snitch.getDatacenter(destination)) && FailureDetector.instance.isAlive(destination)) liveNodes++;
	 }
	 if (liveNodes < responses.get()) {
		 throw new UnavailableException();
	 }
 }",0,0,0,0
"public void updateNeuronWeights(Neuron neuron) {
	 double delta = neuron.getError();
	 for (Connection con : neuron.getInputConnections()) {
		 Weight<QuickPropData> w = con.getWeight();
		 QuickPropData qpData = w.getTrainingData();
		 double input = con.getInput();
		 if (input == 0) continue;
		 double gradient = delta * input;
		 double previousWeightChange = qpData.previousWeightChange;
		 double prevGradient = qpData.prevGradient;
		 double currentWeightChange = 0;
		 if ((prevGradient * gradient > 0) && (gradient < prevGradient)) {
			 currentWeightChange = (gradient / (prevGradient - gradient)) * previousWeightChange;
			 if (Math.abs(currentWeightChange) >= Math.abs((maximumGrowthFactor * previousWeightChange))) {
				 currentWeightChange = maximumGrowthFactor * previousWeightChange;
			 }
		 }
		 else if ((prevGradient * gradient > 0) && (gradient >= prevGradient)) {
			 currentWeightChange = maximumGrowthFactor * previousWeightChange;
		 }
		 else if (prevGradient * gradient < 0) {
			 currentWeightChange = (gradient / (prevGradient - gradient)) * previousWeightChange;
			 if (Math.abs(currentWeightChange) >= Math.abs((maximumGrowthFactor * previousWeightChange))) {
				 currentWeightChange = maximumGrowthFactor * previousWeightChange;
			 }
		 }
		 else {
			 currentWeightChange = -learningRate * delta * input;
		 }
		 w.weightChange += currentWeightChange;
		 qpData.previousWeightChange = currentWeightChange;
		 qpData.prevGradient = gradient;
	 }
 }",0,0,1,0
"public class AddMembersCommand {
	public static final String ACTION_SEARCH = ""Search"";
	public static final String ACTION_CANCEL = ""Cancel"";
	public static final String ACTION_ADD_MEMBERS = ""Add"";
	public static final String ACTION_REMOVE = ""Remove"";
	public static final String SESSION_SELECTIONS = ""GroupMemberSelections"";
	public static final String PARAM_SELECTIONS = ""selections"";
	private String search = null;
	private int pageNumber = 0;
	private String selectedPageSize;
	private String actionCmd = null;
	private long[] memberOids = null;
	private int memberIndex = 0;
	private int selectedCount = 0;
	public AddMembersCommand(){
		memberOids = new long[0];
	}
	public String getActionCmd() {
		return actionCmd;
	}
	public void setActionCmd(String action) {
		this.actionCmd = action;
	}
	public int getPageNumber() {
		return pageNumber;
	}
	public void setPageNumber(int pageNumber) {
		this.pageNumber = pageNumber;
	}
	public String getSelectedPageSize() {
		return selectedPageSize;
	}
	public void setSelectedPageSize(String selectedPageSize) {
		this.selectedPageSize = selectedPageSize;
	}
	public String getSearch() {
		return search;
	}
	public void setSearch(String search) {
		this.search = search;
	}
	public long[] getMemberOids() {
		return memberOids;
	}
	public void setMemberOids(long[] memberOids) {
		this.memberOids = memberOids;
	}
	public int getMemberIndex() {
		return memberIndex;
	}
	public void setMemberIndex(int memberIndex) {
		this.memberIndex = memberIndex;
	}
	public int getSelectedCount() {
		return selectedCount;
	}
	public void setSelectedCount(int selectedCount) {
		this.selectedCount = selectedCount;
	}
}",0,1,0,0
"public final class ServiceLocation {
	 private final String location;
	 private final String name;
	 ServiceLocation(Element serviceLocationElement, String location) throws ServiceConfigException {
		 String name = serviceLocationElement.getAttribute(""name"").intern();
		 if (name.isEmpty()) {
			 throw new ServiceConfigException(""<service-location> element name attribute is empty"");
		 }
		 this.name = name;
		 if (location.isEmpty()) {
			 throw new ServiceConfigException(""<service-location> element location attribute is empty"");
		 }
		 this.location = location;
	 }
	 public String getLocation() {
		 return location;
	 }
	 public String getName() {
		 return name;
	 }
}",0,1,0,0
"public class FacebookPageFeedDataCollector extends FacebookDataCollector {
	 private static final Logger LOGGER = LoggerFactory.getLogger(FacebookPageFeedDataCollector.class);
	 private static final int MAX_ATTEMPTS = 5;
	 private static final ObjectMapper MAPPER = StreamsJacksonMapper.getInstance();
	 private static final int LIMIT = 100;
	 public FacebookPageFeedDataCollector(BlockingQueue<StreamsDatum> queue, FacebookConfiguration configuration) {
		 super(configuration, queue);
	 }
	 protected void getData(IdConfig id) throws Exception {
		 boolean exit = false;
		 ResponseList<Post> facebookPosts = getPosts(id.getId());
		 LOGGER.debug(""Post received : {
		}
		"", facebookPosts.size());
		 backOff.reset();
		 do {
			 for (Post post : facebookPosts) {
				 if (id.getBeforeDate() != null && id.getAfterDate() != null) {
					 if (id.getBeforeDate().isAfter(post.getCreatedTime().getTime()) && id.getAfterDate().isBefore(post.getCreatedTime().getTime())) {
						 super.outputData(MAPPER.readValue(DataObjectFactory.getRawJSON(post), org.apache.streams.facebook.Post.class), post.getId());
					 }
				 }
				 else if (id.getBeforeDate() != null && id.getBeforeDate().isAfter(post.getCreatedTime().getTime())) {
					 super.outputData(MAPPER.readValue(DataObjectFactory.getRawJSON(post), org.apache.streams.facebook.Post.class), post.getId());
				 }
				 else if (id.getAfterDate() != null && id.getAfterDate().isBefore(post.getCreatedTime().getTime())) {
					 super.outputData(MAPPER.readValue(DataObjectFactory.getRawJSON(post), org.apache.streams.facebook.Post.class), post.getId());
				 }
				 else if (id.getBeforeDate() == null && id.getAfterDate() == null) {
					 super.outputData(MAPPER.readValue(DataObjectFactory.getRawJSON(post), org.apache.streams.facebook.Post.class), post.getId());
				 }
				 else {
					 exit = true;
					 LOGGER.debug(""Breaking on post, {
					}
					, with createdAtDate {
					}
					"", post.getId(), post.getCreatedTime());
					 break;
				 }
			 }
			 if (facebookPosts.getPaging() != null && !exit) {
				 LOGGER.debug(""Paging. . ."");
				 facebookPosts = getPosts(facebookPosts.getPaging());
				 backOff.reset();
				 LOGGER.debug(""Paging received {
				}
				 posts*"", facebookPosts.size());
			 }
			 else {
				 LOGGER.debug(""No more paging."");
				 facebookPosts = null;
			 }
		 }
		 while (facebookPosts != null && facebookPosts.size() != 0);
	 }
	 private ResponseList<Post> getPosts(Paging<Post> paging) throws Exception {
		 return getPosts(null, paging);
	 }
	 private ResponseList<Post> getPosts(String pageId) throws Exception {
		 return getPosts(pageId, null);
	 }
	 private ResponseList<Post> getPosts(String pageId, Paging<Post> paging) throws Exception {
		 int attempt = 0;
		 while (attempt < MAX_ATTEMPTS) {
			 ++attempt;
			 try {
				 if (pageId != null) {
					 Reading reading = new Reading();
					 reading.limit(LIMIT);
					 return getNextFacebookClient().getPosts(pageId, reading);
				 }
				 else {
					 return getNextFacebookClient().fetchNext(paging);
				 }
			 }
			 catch (FacebookException fe) {
				 LOGGER.error(""Facebook returned an exception : {
				}
				"", fe);
				 LOGGER.error(""Facebook returned an exception while trying to get feed for page, {
				}
				 : {
				}
				"", pageId, fe.getMessage());
				 int errorCode = fe.getErrorCode();
				 if (errorCode == 17 || errorCode == 4 || errorCode == 341) {
					 super.backOff.backOff();
				 }
			 }
		 }
		 throw new Exception(""Failed to get data from facebook after "" + MAX_ATTEMPTS);
	 }
}",1,0,0,0
"public void invalidate() {
	 try {
		 valid = false;
		 unregisterMBean();
		 data.unreferenceSSTables();
		 indexManager.invalidate();
	 }
	 catch (Exception e) {
		 logger.warn(""Failed unregistering mbean: "" + mbeanName, e);
	 }
 }",0,0,0,0
"public class InstantTypeAdapter implements JsonSerializer<Instant>, JsonDeserializer<Instant>{
	 public static final InstantTypeAdapter DEFAULT_INSTANCE = new InstantTypeAdapter ();
	 private final DateTimeFormatter formatter;
	 public InstantTypeAdapter ( final DateTimeFormatter formatter ) {
		 this.formatter = formatter.withLocale ( Locale.US );
	 }
	 public InstantTypeAdapter () {
		 this ( DateTimeFormatter.ISO_INSTANT.withLocale ( Locale.US ) );
	 }
	 public Instant deserialize ( final JsonElement json, final Type typeOfT, final JsonDeserializationContext context ) throws JsonParseException {
		 if ( ! ( json instanceof JsonPrimitive ) ) {
			 throw new JsonParseException ( ""Timestamps should be encoded as JSON strings"" );
		 }
		 return Instant.from ( this.formatter.parse ( json.getAsString () ) );
	 }
	 public JsonElement serialize ( final Instant src, final Type typeOfSrc, final JsonSerializationContext context ) {
		 return new JsonPrimitive ( this.formatter.format ( src ) );
	 }
}",0,0,0,0
"class KeyGeneratorAdapter implements KeyGenerator {
	private final JCacheOperationSource cacheOperationSource;
	private KeyGenerator keyGenerator;
	private CacheKeyGenerator cacheKeyGenerator;
	public KeyGeneratorAdapter(JCacheOperationSource cacheOperationSource, KeyGenerator target) {
		Assert.notNull(cacheOperationSource, ""JCacheOperationSource must not be null"");
		Assert.notNull(target, ""KeyGenerator must not be null"");
		this.cacheOperationSource = cacheOperationSource;
		this.keyGenerator = target;
	}
	public KeyGeneratorAdapter(JCacheOperationSource cacheOperationSource, CacheKeyGenerator target) {
		Assert.notNull(cacheOperationSource, ""JCacheOperationSource must not be null"");
		Assert.notNull(target, ""CacheKeyGenerator must not be null"");
		this.cacheOperationSource = cacheOperationSource;
		this.cacheKeyGenerator = target;
	}
	public Object getTarget() {
		if (this.cacheKeyGenerator != null) {
			return this.cacheKeyGenerator;
		}
		Assert.state(this.keyGenerator != null, ""No key generator"");
		return this.keyGenerator;
	}
	public Object generate(Object target, Method method, Object... params) {
		JCacheOperation<?> operation = this.cacheOperationSource.getCacheOperation(method, target.getClass());
		if (!(AbstractJCacheKeyOperation.class.isInstance(operation))) {
			throw new IllegalStateException(""Invalid operation, should be a key-based operation "" + operation);
		}
		CacheKeyInvocationContext<?> invocationContext = createCacheKeyInvocationContext(target, operation, params);
		if (this.cacheKeyGenerator != null) {
			return this.cacheKeyGenerator.generateCacheKey(invocationContext);
		}
		else {
			Assert.state(this.keyGenerator != null, ""No key generator"");
			return doGenerate(this.keyGenerator, invocationContext);
		}
	}
	private static Object doGenerate(KeyGenerator keyGenerator, CacheKeyInvocationContext<?> context) {
		List<Object> parameters = new ArrayList<>();
		for (CacheInvocationParameter param : context.getKeyParameters()) {
			Object value = param.getValue();
			if (param.getParameterPosition() == context.getAllParameters().length - 1 &&context.getMethod().isVarArgs()) {
				parameters.addAll((List<Object>) CollectionUtils.arrayToList(value));
			}
			else {
				parameters.add(value);
			}
		}
		return keyGenerator.generate(context.getTarget(), context.getMethod(), parameters.toArray());
	}
	private CacheKeyInvocationContext<?> createCacheKeyInvocationContext(Object target, JCacheOperation<?> operation, Object[] params) {
		AbstractJCacheKeyOperation<Annotation> keyCacheOperation = (AbstractJCacheKeyOperation<Annotation>) operation;
		return new DefaultCacheKeyInvocationContext<>(keyCacheOperation, target, params);
	}
}",0,0,0,0
"public class SubProcessCommandLineArgs {
	 private List<Command> parameters = Lists.newArrayList();
	 public void addCommand(Integer position, String value) {
		 parameters.add(new Command(position, value));
	 }
	 public void putCommand(Command command) {
		 parameters.add(command);
	 }
	 public List<Command> getParameters() {
		 return parameters;
	 }
	 public static class Command {
		 int ordinalPosition;
		 String value;
		 private Command() {
		}
		 public Command(int ordinalPosition, String value) {
			 this.ordinalPosition = ordinalPosition;
			 this.value = value;
		 }
		 public int getKey() {
			 return ordinalPosition;
		 }
		 public void setKey(int key) {
			 this.ordinalPosition = key;
		 }
		 public String getValue() {
			 return value;
		 }
		 public void setValue(String value) {
			 this.value = value;
		 }
	 }
}",0,1,0,0
"public AdaptiveResultTreeImpl(XSLTCDTMManager dtmManager, int documentID, DTMWSFilter wsfilter, int initSize, boolean buildIdIndex);",0,0,0,1
"public synchronized String getName() {
	 return super.getName();
 }",0,0,0,0
"public final class DateTimeType extends DTIType {
	 public final boolean withTimeZone;
	 public DateTimeType(int typeGroup, int type, int scale) {
		 super(typeGroup, type, 0, scale);
		 withTimeZone = type == Types.SQL_TIME_WITH_TIME_ZONE || type == Types.SQL_TIMESTAMP_WITH_TIME_ZONE;
	 }
	 public int displaySize() {
		 switch (typeCode) {
			 case Types.SQL_DATE : return 10;
			 case Types.SQL_TIME : return 8 + (scale == 0 ? 0 : scale + 1);
			 case Types.SQL_TIME_WITH_TIME_ZONE : return 8 + (scale == 0 ? 0 : scale + 1) + 6;
			 case Types.SQL_TIMESTAMP : return 19 + (scale == 0 ? 0 : scale + 1);
			 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : return 19 + (scale == 0 ? 0 : scale + 1) + 6;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
		 }
	 }
	 public int getJDBCTypeCode() {
		 return typeCode;
	 }
	 public Class getJDBCClass() {
		 switch (typeCode) {
			 case Types.SQL_DATE : return java.sql.Date.class;
			 case Types.SQL_TIME : case Types.SQL_TIME_WITH_TIME_ZONE : return java.sql.Time.class;
			 case Types.SQL_TIMESTAMP : case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : return java.sql.Timestamp.class;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
		 }
	 }
	 public String getJDBCClassName() {
		 switch (typeCode) {
			 case Types.SQL_DATE : return ""java.sql.Date"";
			 case Types.SQL_TIME : case Types.SQL_TIME_WITH_TIME_ZONE : return ""java.sql.Time"";
			 case Types.SQL_TIMESTAMP : case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : return ""java.sql.Timestamp"";
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
		 }
	 }
	 public int getJDBCPrecision() {
		 return this.displaySize();
	 }
	 public int getSQLGenericTypeCode() {
		 return Types.SQL_DATETIME;
	 }
	 public String getNameString() {
		 switch (typeCode) {
			 case Types.SQL_DATE : return Tokens.T_DATE;
			 case Types.SQL_TIME : return Tokens.T_TIME;
			 case Types.SQL_TIME_WITH_TIME_ZONE : return Tokens.T_TIME + ' ' + Tokens.T_WITH + ' ' + Tokens.T_TIME + ' ' + Tokens.T_ZONE;
			 case Types.SQL_TIMESTAMP : return Tokens.T_TIMESTAMP;
			 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : return Tokens.T_TIMESTAMP + ' ' + Tokens.T_WITH + ' ' + Tokens.T_TIME + ' ' + Tokens.T_ZONE;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
		 }
	 }
	 public String getDefinition() {
		 if (scale == DTIType.defaultTimeFractionPrecision) {
			 return getNameString();
		 }
		 String token;
		 switch (typeCode) {
			 case Types.SQL_DATE : return Tokens.T_DATE;
			 case Types.SQL_TIME_WITH_TIME_ZONE : case Types.SQL_TIME : if (scale == DTIType.defaultTimeFractionPrecision) {
				 return getNameString();
			 }
			 token = Tokens.T_TIME;
			 break;
			 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : case Types.SQL_TIMESTAMP : if (scale == DTIType.defaultTimestampFractionPrecision) {
				 return getNameString();
			 }
			 token = Tokens.T_TIMESTAMP;
			 break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
		 }
		 StringBuffer sb = new StringBuffer(16);
		 sb.append(token);
		 sb.append('(');
		 sb.append(scale);
		 sb.append(')');
		 if (withTimeZone) {
			 sb.append(' ' + Tokens.T_WITH + ' ' + Tokens.T_TIME + ' ' + Tokens.T_ZONE);
		 }
		 return sb.toString();
	 }
	 public boolean isDateTimeType() {
		 return true;
	 }
	 public boolean isDateTimeTypeWithZone() {
		 return withTimeZone;
	 }
	 public boolean acceptsFractionalPrecision() {
		 return typeCode != Types.SQL_DATE;
	 }
	 public Type getAggregateType(Type other) {
		 if (typeCode == other.typeCode) {
			 return scale >= other.scale ? this : other;
		 }
		 if (other.typeCode == Types.SQL_ALL_TYPES) {
			 return this;
		 }
		 if (other.isCharacterType()) {
			 return other.getAggregateType(this);
		 }
		 if (!other.isDateTimeType()) {
			 throw Error.error(ErrorCode.X_42562);
		 }
		 DateTimeType otherType = (DateTimeType) other;
		 if (otherType.startIntervalType > endIntervalType || startIntervalType > otherType.endIntervalType) {
			 throw Error.error(ErrorCode.X_42562);
		 }
		 int newType = typeCode;
		 int scale = this.scale > otherType.scale ? this.scale : otherType.scale;
		 boolean zone = withTimeZone || otherType.withTimeZone;
		 int startType = otherType.startIntervalType > startIntervalType ? startIntervalType : otherType.startIntervalType;
		 if (startType == Types.SQL_INTERVAL_HOUR) {
			 newType = zone ? Types.SQL_TIME_WITH_TIME_ZONE : Types.SQL_TIME;
		 }
		 else {
			 newType = zone ? Types.SQL_TIMESTAMP_WITH_TIME_ZONE : Types.SQL_TIMESTAMP;
		 }
		 return getDateTimeType(newType, scale);
	 }
	 public Type getCombinedType(Type other, int operation) {
		 switch (operation) {
			 case OpTypes.EQUAL : case OpTypes.GREATER : case OpTypes.GREATER_EQUAL : case OpTypes.SMALLER_EQUAL : case OpTypes.SMALLER : case OpTypes.NOT_EQUAL : {
				 if (typeCode == other.typeCode) {
					 return this;
				 }
				 if (other.typeCode == Types.SQL_ALL_TYPES) {
					 return this;
				 }
				 if (!other.isDateTimeType()) {
					 throw Error.error(ErrorCode.X_42562);
				 }
				 DateTimeType otherType = (DateTimeType) other;
				 if (otherType.startIntervalType > endIntervalType || startIntervalType > otherType.endIntervalType) {
					 throw Error.error(ErrorCode.X_42562);
				 }
				 int newType = typeCode;
				 int scale = this.scale > otherType.scale ? this.scale : otherType .scale;
				 boolean zone = withTimeZone || otherType.withTimeZone;
				 int startType = otherType.startIntervalType > startIntervalType ? startIntervalType : otherType .startIntervalType;
				 if (startType == Types.SQL_INTERVAL_HOUR) {
					 newType = zone ? Types.SQL_TIME_WITH_TIME_ZONE : Types.SQL_TIME;
				 }
				 else {
					 newType = zone ? Types.SQL_TIMESTAMP_WITH_TIME_ZONE : Types.SQL_TIMESTAMP;
				 }
				 return getDateTimeType(newType, scale);
			 }
			 case OpTypes.ADD : case OpTypes.SUBTRACT : if (other.isIntervalType()) {
				 if (typeCode != Types.SQL_DATE && other.scale > scale) {
					 return getDateTimeType(typeCode, other.scale);
				 }
				 return this;
			 }
			 break;
		 default : }
		 throw Error.error(ErrorCode.X_42562);
	 }
	 public int compare(Session session, Object a, Object b) {
		 long diff;
		 if (a == b) {
			 return 0;
		 }
		 if (a == null) {
			 return -1;
		 }
		 if (b == null) {
			 return 1;
		 }
		 switch (typeCode) {
			 case Types.SQL_TIME : case Types.SQL_TIME_WITH_TIME_ZONE : {
				 diff = ((TimeData) a).getSeconds() - ((TimeData) b).getSeconds();
				 if (diff == 0) {
					 diff = ((TimeData) a).getNanos() - ((TimeData) b).getNanos();
				 }
				 return diff == 0 ? 0 : diff > 0 ? 1 : -1;
			 }
			 case Types.SQL_DATE : case Types.SQL_TIMESTAMP : case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : {
				 diff = ((TimestampData) a).getSeconds() - ((TimestampData) b).getSeconds();
				 if (diff == 0) {
					 diff = ((TimestampData) a).getNanos() - ((TimestampData) b).getNanos();
				 }
				 return diff == 0 ? 0 : diff > 0 ? 1 : -1;
			 }
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
		 }
	 }
	 public Object convertToTypeLimits(SessionInterface session, Object a) {
		 if (a == null) {
			 return null;
		 }
		 if (scale == maxFractionPrecision) {
			 return a;
		 }
		 switch (typeCode) {
			 case Types.SQL_DATE : return a;
			 case Types.SQL_TIME_WITH_TIME_ZONE : case Types.SQL_TIME : {
				 TimeData ti = (TimeData) a;
				 int nanos = ti.getNanos();
				 int newNanos = scaleNanos(nanos);
				 if (newNanos == nanos) {
					 return ti;
				 }
				 return new TimeData(ti.getSeconds(), newNanos, ti.getZone());
			 }
			 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : case Types.SQL_TIMESTAMP : {
				 TimestampData ts = (TimestampData) a;
				 int nanos = ts.getNanos();
				 int newNanos = scaleNanos(nanos);
				 if (newNanos == nanos) {
					 return ts;
				 }
				 return new TimestampData(ts.getSeconds(), newNanos, ts.getZone());
			 }
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
		 }
	 }
	 int scaleNanos(int nanos) {
		 int divisor = nanoScaleFactors[scale];
		 return (nanos / divisor) * divisor;
	 }
	 public Object convertToType(SessionInterface session, Object a, Type otherType) {
		 if (a == null) {
			 return a;
		 }
		 switch (otherType.typeCode) {
			 case Types.SQL_CLOB : a = a.toString();
			 case Types.SQL_CHAR : case Types.SQL_VARCHAR : case Types.VARCHAR_IGNORECASE : switch (this.typeCode) {
				 case Types.SQL_DATE : case Types.SQL_TIME_WITH_TIME_ZONE : case Types.SQL_TIME : case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : case Types.SQL_TIMESTAMP : {
					 return session.getScanner().convertToDatetimeInterval( session, (String) a, this);
				 }
			 }
			 break;
			 case Types.SQL_DATE : case Types.SQL_TIME : case Types.SQL_TIME_WITH_TIME_ZONE : case Types.SQL_TIMESTAMP : case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : break;
			 default : throw Error.error(ErrorCode.X_42561);
		 }
		 switch (this.typeCode) {
			 case Types.SQL_DATE : switch (otherType.typeCode) {
				 case Types.SQL_DATE : return a;
				 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : {
					 long seconds = ((TimestampData) a).getSeconds() + ((TimestampData) a).getZone();
					 long l = HsqlDateTime.getNormalisedDate(seconds return new TimestampData(l / 1000);
				 }
				 case Types.SQL_TIMESTAMP : {
					 long l = HsqlDateTime.getNormalisedDate( ((TimestampData) a).getSeconds() * 1000);
					 return new TimestampData(l / 1000);
				 }
				 default : throw Error.error(ErrorCode.X_42561);
			 }
			 case Types.SQL_TIME_WITH_TIME_ZONE : switch (otherType.typeCode) {
				 case Types.SQL_TIME_WITH_TIME_ZONE : return convertToTypeLimits(session, a);
				 case Types.SQL_TIME : {
					 TimeData ti = (TimeData) a;
					 return new TimeData( ti.getSeconds() - session.getZoneSeconds(), scaleNanos(ti.getNanos()), session.getZoneSeconds());
				 }
				 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : {
					 TimestampData ts = (TimestampData) a;
					 long seconds = HsqlDateTime.convertToNormalisedTime( ts.getSeconds() * 1000) / 1000;
					 return new TimeData((int) (seconds), scaleNanos(ts.getNanos()), ts.getZone());
				 }
				 case Types.SQL_TIMESTAMP : {
					 TimestampData ts = (TimestampData) a;
					 long seconds = ts.getSeconds() - session.getZoneSeconds();
					 seconds = HsqlDateTime.convertToNormalisedTime( seconds * 1000) / 1000;
					 return new TimeData((int) (seconds), scaleNanos(ts.getNanos()), session.getZoneSeconds());
				 }
				 default : throw Error.error(ErrorCode.X_42561);
			 }
			 case Types.SQL_TIME : switch (otherType.typeCode) {
				 case Types.SQL_TIME_WITH_TIME_ZONE : {
					 TimeData ti = (TimeData) a;
					 return new TimeData(ti.getSeconds() + ti.getZone(), scaleNanos(ti.getNanos()), 0);
				 }
				 case Types.SQL_TIME : return convertToTypeLimits(session, a);
				 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : {
					 TimestampData ts = (TimestampData) a;
					 long seconds = ts.getSeconds() + ts.getZone();
					 seconds = HsqlDateTime.convertToNormalisedTime( seconds * 1000) / 1000;
					 return new TimeData((int) (seconds), scaleNanos(ts.getNanos()), 0);
				 }
				 case Types.SQL_TIMESTAMP : TimestampData ts = (TimestampData) a;
				 long seconds = HsqlDateTime.convertToNormalisedTime( ts.getSeconds() * 1000) / 1000;
				 return new TimeData((int) (seconds), scaleNanos(ts.getNanos()));
				 default : throw Error.error(ErrorCode.X_42561);
			 }
			 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : switch (otherType.typeCode) {
				 case Types.SQL_TIME_WITH_TIME_ZONE : {
					 TimeData ti = (TimeData) a;
					 long seconds = session.getCurrentDate().getSeconds() + ti.getSeconds();
					 return new TimestampData(seconds, scaleNanos(ti.getNanos()), ti.getZone());
				 }
				 case Types.SQL_TIME : {
					 TimeData ti = (TimeData) a;
					 long seconds = session.getCurrentDate().getSeconds() + ti.getSeconds() - session.getZoneSeconds();
					 return new TimestampData(seconds, scaleNanos(ti.getNanos()), session.getZoneSeconds());
				 }
				 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : return convertToTypeLimits(session, a);
				 case Types.SQL_TIMESTAMP : {
					 TimestampData ts = (TimestampData) a;
					 long seconds = ts.getSeconds() - session.getZoneSeconds();
					 return new TimestampData(seconds, scaleNanos(ts.getNanos()), session.getZoneSeconds());
				 }
				 case Types.SQL_DATE : {
					 TimestampData ts = (TimestampData) a;
					 return new TimestampData(ts.getSeconds(), 0, session.getZoneSeconds());
				 }
				 default : throw Error.error(ErrorCode.X_42561);
			 }
			 case Types.SQL_TIMESTAMP : switch (otherType.typeCode) {
				 case Types.SQL_TIME_WITH_TIME_ZONE : {
					 TimeData ti = (TimeData) a;
					 long seconds = session.getCurrentDate().getSeconds() + ti.getSeconds() - session.getZoneSeconds();
					 return new TimestampData(seconds, scaleNanos(ti.getNanos()), session.getZoneSeconds());
				 }
				 case Types.SQL_TIME : {
					 TimeData ti = (TimeData) a;
					 long seconds = session.getCurrentDate().getSeconds() + ti.getSeconds();
					 return new TimestampData(seconds, scaleNanos(ti.getNanos()));
				 }
				 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : {
					 TimestampData ts = (TimestampData) a;
					 long seconds = ts.getSeconds() + ts.getZone();
					 return new TimestampData(seconds, scaleNanos(ts.getNanos()));
				 }
				 case Types.SQL_TIMESTAMP : return convertToTypeLimits(session, a);
				 case Types.SQL_DATE : return a;
				 default : throw Error.error(ErrorCode.X_42561);
			 }
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
		 }
	 }
	 public Object convertToDefaultType(SessionInterface session, Object a) {
		 throw Error.error(ErrorCode.X_42561);
	 }
	 public Object convertJavaToSQL(SessionInterface session, Object a) {
		 if (a == null) {
			 return null;
		 }
		 switch (typeCode) {
			 case Types.SQL_TIME : case Types.SQL_TIME_WITH_TIME_ZONE : if (a instanceof java.sql.Date) {
				 break;
			 }
			 if (a instanceof java.util.Date) {
				 long millis;
				 int nanos = 0;
				 int zoneSeconds = 0;
				 if (typeCode == Types.SQL_TIME) {
					 millis = HsqlDateTime.convertMillisFromCalendar( session.getCalendar(), ((java.util.Date) a).getTime());
				 }
				 else {
					 millis = ((java.util.Date) a).getTime();
					 zoneSeconds = session.getZoneSeconds();
				 }
				 millis = HsqlDateTime.getNormalisedTime(millis);
				 if (a instanceof java.sql.Timestamp) {
					 nanos = ((java.sql.Timestamp) a).getNanos();
					 nanos = normaliseFraction(nanos, scale);
				 }
				 return new TimeData((int) millis / 1000, nanos, zoneSeconds);
			 }
			 break;
			 case Types.SQL_DATE : {
				 if (a instanceof java.sql.Time) {
					 break;
				 }
				 if (a instanceof java.util.Date) {
					 long millis;
					 millis = HsqlDateTime.convertMillisFromCalendar( session.getCalendar(), ((java.util.Date) a).getTime());
					 millis = HsqlDateTime.getNormalisedDate(millis);
					 return new TimestampData(millis / 1000);
				 }
				 break;
			 }
			 case Types.SQL_TIMESTAMP : case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : {
				 if (a instanceof java.sql.Time) {
					 break;
				 }
				 if (a instanceof java.util.Date) {
					 long millis;
					 int nanos = 0;
					 int zoneSeconds = 0;
					 if (typeCode == Types.SQL_TIMESTAMP) {
						 millis = HsqlDateTime.convertMillisFromCalendar( session.getCalendar(), ((java.util.Date) a).getTime());
					 }
					 else {
						 millis = ((java.util.Date) a).getTime();
						 zoneSeconds = session.getZoneSeconds();
					 }
					 if (a instanceof java.sql.Timestamp) {
						 nanos = ((java.sql.Timestamp) a).getNanos();
						 nanos = this.normaliseFraction(nanos, scale);
					 }
					 return new TimestampData(millis / 1000, nanos, zoneSeconds);
				 }
				 break;
			 }
		 }
		 throw Error.error(ErrorCode.X_42561);
	 }
	 public Object convertSQLToJavaGMT(SessionInterface session, Object a) {
		 long millis;
		 switch (typeCode) {
			 case Types.SQL_TIME : case Types.SQL_TIME_WITH_TIME_ZONE : millis = ((TimeData) a).getSeconds() * 1000;
			 return new java.sql.Time(millis);
			 case Types.SQL_DATE : millis = ((TimestampData) a).getSeconds() * 1000;
			 return new java.sql.Date(millis);
			 case Types.SQL_TIMESTAMP : case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : millis = ((TimestampData) a).getSeconds() * 1000;
			 java.sql.Timestamp value = new java.sql.Timestamp(millis);
			 value.setNanos(((TimestampData) a).getNanos());
			 return value;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
		 }
	 }
	 public Object convertSQLToJava(SessionInterface session, Object a) {
		 if (a == null) {
			 return null;
		 }
		 switch (typeCode) {
			 case Types.SQL_TIME : {
				 Calendar cal = session.getCalendar();
				 long millis = HsqlDateTime.convertMillisToCalendar(cal, ((TimeData) a).getSeconds() * 1000);
				 millis = HsqlDateTime.getNormalisedTime(cal, millis);
				 java.sql.Time value = new java.sql.Time(millis);
				 return value;
			 }
			 case Types.SQL_TIME_WITH_TIME_ZONE : {
				 int seconds = ((TimeData) a).getSeconds();
				 return new java.sql.Time(seconds * 1000);
			 }
			 case Types.SQL_DATE : {
				 Calendar cal = session.getCalendar();
				 long millis = HsqlDateTime.convertMillisToCalendar(cal, ((TimestampData) a).getSeconds() * 1000);
				 java.sql.Date value = new java.sql.Date(millis);
				 return value;
			 }
			 case Types.SQL_TIMESTAMP : {
				 Calendar cal = session.getCalendar();
				 long millis = HsqlDateTime.convertMillisToCalendar(cal, ((TimestampData) a).getSeconds() * 1000);
				 java.sql.Timestamp value = new java.sql.Timestamp(millis);
				 value.setNanos(((TimestampData) a).getNanos());
				 return value;
			 }
			 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : {
				 long seconds = ((TimestampData) a).getSeconds();
				 java.sql.Timestamp value = new java.sql.Timestamp(seconds value.setNanos(((TimestampData) a).getNanos());
				 return value;
			 }
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
		 }
	 }
	 public static int normaliseTime(int seconds) {
		 while (seconds < 0) {
			 seconds += 24 * 60 * 60;
		 }
		 if (seconds > 24 * 60 * 60) {
			 seconds %= 24 * 60 * 60;
		 }
		 return seconds;
	 }
	 public String convertToString(Object a) {
		 boolean zone = false;
		 String s;
		 StringBuffer sb;
		 if (a == null) {
			 return null;
		 }
		 switch (typeCode) {
			 case Types.SQL_DATE : return HsqlDateTime.getDateString( ((TimestampData) a).getSeconds());
			 case Types.SQL_TIME_WITH_TIME_ZONE : case Types.SQL_TIME : {
				 TimeData t = (TimeData) a;
				 int seconds = normaliseTime(t.getSeconds() + t.getZone());
				 s = intervalSecondToString(seconds, t.getNanos(), false);
				 if (!withTimeZone) {
					 return s;
				 }
				 sb = new StringBuffer(s);
				 s = Type.SQL_INTERVAL_HOUR_TO_MINUTE.intervalSecondToString( ((TimeData) a).getZone(), 0, true);
				 sb.append(s);
				 return sb.toString();
			 }
			 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : case Types.SQL_TIMESTAMP : {
				 TimestampData ts = (TimestampData) a;
				 sb = new StringBuffer();
				 HsqlDateTime.getTimestampString(sb, ts.getSeconds() + ts.getZone(), ts.getNanos(), scale);
				 if (!withTimeZone) {
					 return sb.toString();
				 }
				 s = Type.SQL_INTERVAL_HOUR_TO_MINUTE.intervalSecondToString( ((TimestampData) a).getZone(), 0, true);
				 sb.append(s);
				 return sb.toString();
			 }
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
		 }
	 }
	 public String convertToSQLString(Object a) {
		 if (a == null) {
			 return Tokens.T_NULL;
		 }
		 StringBuffer sb = new StringBuffer(32);
		 switch (typeCode) {
			 case Types.SQL_DATE : sb.append(Tokens.T_DATE);
			 break;
			 case Types.SQL_TIME_WITH_TIME_ZONE : case Types.SQL_TIME : sb.append(Tokens.T_TIME);
			 break;
			 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : case Types.SQL_TIMESTAMP : sb.append(Tokens.T_TIMESTAMP);
			 break;
		 }
		 sb.append(StringConverter.toQuotedString(convertToString(a), '\'', false));
		 return sb.toString();
	 }
	 public boolean canConvertFrom(Type otherType) {
		 if (otherType.typeCode == Types.SQL_ALL_TYPES) {
			 return true;
		 }
		 if (otherType.isCharacterType()) {
			 return true;
		 }
		 if (!otherType.isDateTimeType()) {
			 return false;
		 }
		 if (otherType.typeCode == Types.SQL_DATE) {
			 return typeCode != Types.SQL_TIME;
		 }
		 else if (otherType.typeCode == Types.SQL_TIME) {
			 return typeCode != Types.SQL_DATE;
		 }
		 return true;
	 }
	 public Object add(Object a, Object b, Type otherType) {
		 if (a == null || b == null) {
			 return null;
		 }
		 switch (typeCode) {
			 case Types.SQL_TIME_WITH_TIME_ZONE : case Types.SQL_TIME : if (b instanceof IntervalMonthData) {
				 throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
			 }
			 else if (b instanceof IntervalSecondData) {
				 return addSeconds((TimeData) a, (int) ((IntervalSecondData) b).units, ((IntervalSecondData) b).nanos);
			 }
			 break;
			 case Types.SQL_DATE : case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : case Types.SQL_TIMESTAMP : if (b instanceof IntervalMonthData) {
				 return addMonths((TimestampData) a, (int) ((IntervalMonthData) b).units);
			 }
			 else if (b instanceof IntervalSecondData) {
				 return addSeconds((TimestampData) a, (int) ((IntervalSecondData) b).units, ((IntervalSecondData) b).nanos);
			 }
			 break;
		 default : }
		 throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
	 }
	 public Object subtract(Object a, Object b, Type otherType) {
		 if (a == null || b == null) {
			 return null;
		 }
		 switch (typeCode) {
			 case Types.SQL_TIME_WITH_TIME_ZONE : case Types.SQL_TIME : if (b instanceof IntervalMonthData) {
				 throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
			 }
			 else if (b instanceof IntervalSecondData) {
				 return addSeconds((TimeData) a, -(int) ((IntervalSecondData) b).units, -((IntervalSecondData) b).nanos);
			 }
			 break;
			 case Types.SQL_DATE : case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : case Types.SQL_TIMESTAMP : if (b instanceof IntervalMonthData) {
				 return addMonths((TimestampData) a, -(int) ((IntervalMonthData) b).units);
			 }
			 else if (b instanceof IntervalSecondData) {
				 return addSeconds((TimestampData) a, -(int) ((IntervalSecondData) b).units, -((IntervalSecondData) b).nanos);
			 }
			 break;
		 default : }
		 throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
	 }
	 public boolean equals(Object other) {
		 if (other instanceof Type) {
			 return super.equals(other) && ((DateTimeType) other).withTimeZone == withTimeZone;
		 }
		 return false;
	 }
	 public int getPart(Session session, Object dateTime, int part) {
		 int calendarPart;
		 int increment = 0;
		 int divisor = 1;
		 switch (part) {
			 case Types.SQL_INTERVAL_YEAR : calendarPart = Calendar.YEAR;
			 break;
			 case Types.SQL_INTERVAL_MONTH : increment = 1;
			 calendarPart = Calendar.MONTH;
			 break;
			 case Types.SQL_INTERVAL_DAY : case DAY_OF_MONTH : calendarPart = Calendar.DAY_OF_MONTH;
			 break;
			 case Types.SQL_INTERVAL_HOUR : calendarPart = Calendar.HOUR_OF_DAY;
			 break;
			 case Types.SQL_INTERVAL_MINUTE : calendarPart = Calendar.MINUTE;
			 break;
			 case Types.SQL_INTERVAL_SECOND : calendarPart = Calendar.SECOND;
			 break;
			 case DAY_OF_WEEK : calendarPart = Calendar.DAY_OF_WEEK;
			 break;
			 case WEEK_OF_YEAR : calendarPart = Calendar.WEEK_OF_YEAR;
			 break;
			 case SECONDS_MIDNIGHT : {
				 if (typeCode == Types.SQL_TIME || typeCode == Types.SQL_TIME_WITH_TIME_ZONE) {
				}
				 else {
					 try {
						 Type target = withTimeZone ? Type.SQL_TIME_WITH_TIME_ZONE : Type.SQL_TIME;
						 dateTime = target.castToType(session, dateTime, this);
					 }
					 catch (HsqlException e) {
					}
				 }
				 return ((TimeData) dateTime).getSeconds();
			 }
			 case TIMEZONE_HOUR : if (typeCode == Types.SQL_TIMESTAMP_WITH_TIME_ZONE) {
				 return ((TimestampData) dateTime).getZone() / 3600;
			 }
			 else {
				 return ((TimeData) dateTime).getZone() / 3600;
			 }
			 case TIMEZONE_MINUTE : if (typeCode == Types.SQL_TIMESTAMP_WITH_TIME_ZONE) {
				 return ((TimestampData) dateTime).getZone() / 60 % 60;
			 }
			 else {
				 return ((TimeData) dateTime).getZone() / 60 % 60;
			 }
			 case QUARTER : increment = 1;
			 divisor = 3;
			 calendarPart = Calendar.MONTH;
			 break;
			 case DAY_OF_YEAR : calendarPart = Calendar.DAY_OF_YEAR;
			 break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType - "" + part);
		 }
		 long millis;
		 if (typeCode == Types.SQL_TIME || typeCode == Types.SQL_TIME_WITH_TIME_ZONE) {
			 millis = (((TimeData) dateTime).getSeconds() + ((TimeData) dateTime) .getZone()) * 1000;
		 }
		 else {
			 millis = (((TimestampData) dateTime) .getSeconds() + ((TimestampData) dateTime).getZone()) * 1000;
		 }
		 return HsqlDateTime.getDateTimePart(millis, calendarPart) / divisor + increment;
	 }
	 public BigDecimal getSecondPart(Object dateTime) {
		 long seconds = getPart(null, dateTime, Types.SQL_INTERVAL_SECOND);
		 int nanos = 0;
		 if (typeCode == Types.SQL_TIMESTAMP) {
			 nanos = ((TimestampData) dateTime).getNanos();
		 }
		 else if (typeCode == Types.SQL_TIME) {
			 nanos = ((TimeData) dateTime).getNanos();
		 }
		 return getSecondPart(seconds, nanos);
	 }
	 public String getPartString(Session session, Object dateTime, int part) {
		 String javaPattern = """";
		 switch (part) {
			 case DAY_NAME : javaPattern = ""EEEE"";
			 break;
			 case MONTH_NAME : javaPattern = ""MMMM"";
			 break;
		 }
		 SimpleDateFormat format = session.getSimpleDateFormatGMT();
		 try {
			 format.applyPattern(javaPattern);
		 }
		 catch (Exception e) {
		}
		 Date date = (Date) convertSQLToJavaGMT(session, dateTime);
		 return format.format(date);
	 }
	 public Object getValue(long seconds, int nanos, int zoneSeconds) {
		 switch (typeCode) {
			 case Types.SQL_DATE : seconds = HsqlDateTime.getNormalisedDate( (seconds + zoneSeconds) * 1000) / 1000;
			 return new TimestampData(seconds);
			 case Types.SQL_TIME_WITH_TIME_ZONE : seconds = HsqlDateTime.getNormalisedDate(seconds * 1000) / 1000;
			 return new TimeData((int) seconds, nanos, zoneSeconds);
			 case Types.SQL_TIME : seconds = HsqlDateTime.getNormalisedTime( (seconds + zoneSeconds) * 1000) / 1000;
			 return new TimeData((int) seconds, nanos);
			 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : return new TimestampData(seconds, nanos, zoneSeconds);
			 case Types.SQL_TIMESTAMP : return new TimestampData(seconds + zoneSeconds, nanos);
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
		 }
	 }
	 public DateTimeType getDateTimeTypeWithoutZone() {
		 if (this.withTimeZone) {
			 switch (typeCode) {
				 case Types.SQL_TIME_WITH_TIME_ZONE : if (scale != DTIType.defaultTimeFractionPrecision) {
					 return new DateTimeType(Types.SQL_TIME, Types.SQL_TIME, scale);
				 }
				 return SQL_TIME;
				 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : if (scale != DTIType.defaultTimestampFractionPrecision) {
					 return new DateTimeType(Types.SQL_TIMESTAMP, Types.SQL_TIMESTAMP, scale);
				 }
				 return SQL_TIMESTAMP;
				 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
			 }
		 }
		 return this;
	 }
	 public static DateTimeType getDateTimeType(int type, int scale) {
		 if (scale > DTIType.maxFractionPrecision) {
			 throw Error.error(ErrorCode.X_42592);
		 }
		 switch (type) {
			 case Types.SQL_DATE : return SQL_DATE;
			 case Types.SQL_TIME : if (scale != DTIType.defaultTimeFractionPrecision) {
				 return new DateTimeType(Types.SQL_TIME, type, scale);
			 }
			 return SQL_TIME;
			 case Types.SQL_TIME_WITH_TIME_ZONE : if (scale != DTIType.defaultTimeFractionPrecision) {
				 return new DateTimeType(Types.SQL_TIME, type, scale);
			 }
			 return SQL_TIME_WITH_TIME_ZONE;
			 case Types.SQL_TIMESTAMP : if (scale != DTIType.defaultTimestampFractionPrecision) {
				 return new DateTimeType(Types.SQL_TIMESTAMP, type, scale);
			 }
			 return SQL_TIMESTAMP;
			 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : if (scale != DTIType.defaultTimestampFractionPrecision) {
				 return new DateTimeType(Types.SQL_TIMESTAMP, type, scale);
			 }
			 return SQL_TIMESTAMP_WITH_TIME_ZONE;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""DateTimeType"");
		 }
	 }
	 public Object changeZone(Object a, Type otherType, int targetZone, int localZone) {
		 if (a == null) {
			 return null;
		 }
		 if (otherType.typeCode == Types.SQL_TIMESTAMP_WITH_TIME_ZONE || otherType.typeCode == Types.SQL_TIME_WITH_TIME_ZONE) {
			 localZone = 0;
		 }
		 if (targetZone > DTIType.timezoneSecondsLimit || -targetZone > DTIType.timezoneSecondsLimit) {
			 throw Error.error(ErrorCode.X_22009);
		 }
		 switch (typeCode) {
			 case Types.SQL_TIME_WITH_TIME_ZONE : {
				 TimeData value = (TimeData) a;
				 if (localZone != 0 || value.zone != targetZone) {
					 return new TimeData(value.getSeconds() - localZone, value.getNanos(), targetZone);
				 }
				 break;
			 }
			 case Types.SQL_TIMESTAMP_WITH_TIME_ZONE : {
				 TimestampData value = (TimestampData) a;
				 if (localZone != 0 || value.zone != targetZone) {
					 return new TimestampData(value.getSeconds() - localZone, value.getNanos(), targetZone);
				 }
				 break;
			 }
		 }
		 return a;
	 }
	 public boolean canAdd(IntervalType other) {
		 return other.startPartIndex >= startPartIndex && other.endPartIndex <= endPartIndex;
	 }
	 public int getSqlDateTimeSub() {
		 switch (typeCode) {
			 case Types.SQL_DATE : return 1;
			 case Types.SQL_TIME : return 2;
			 case Types.SQL_TIMESTAMP : return 3;
			 default : return 0;
		 }
	 }
	 public static Boolean overlaps(Session session, Object[] a, Type[] ta, Object[] b, Type[] tb) {
		 if (a == null || b == null) {
			 return null;
		 }
		 if (a[0] == null || b[0] == null) {
			 return null;
		 }
		 if (a[1] == null) {
			 a[1] = a[0];
		 }
		 if (b[1] == null) {
			 b[1] = b[0];
		 }
		 Type commonType = ta[0].getCombinedType(tb[0], OpTypes.EQUAL);
		 a[0] = commonType.castToType(session, a[0], ta[0]);
		 b[0] = commonType.castToType(session, b[0], tb[0]);
		 if (ta[1].isIntervalType()) {
			 a[1] = commonType.add(a[0], a[1], ta[1]);
		 }
		 else {
			 a[1] = commonType.castToType(session, a[1], ta[1]);
		 }
		 if (tb[1].isIntervalType()) {
			 b[1] = commonType.add(b[0], b[1], tb[1]);
		 }
		 else {
			 b[1] = commonType.castToType(session, b[1], tb[1]);
		 }
		 if (commonType.compare(session, a[0], a[1]) > 0) {
			 Object temp = a[0];
			 a[0] = a[1];
			 a[1] = temp;
		 }
		 if (commonType.compare(session, b[0], b[1]) > 0) {
			 Object temp = b[0];
			 b[0] = b[1];
			 b[1] = temp;
		 }
		 if (commonType.compare(session, a[0], b[0]) > 0) {
			 Object[] temp = a;
			 a = b;
			 b = temp;
		 }
		 if (commonType.compare(session, a[1], b[0]) > 0) {
			 return Boolean.TRUE;
		 }
		 return Boolean.FALSE;
	 }
	 public static int subtractMonths(TimestampData a, TimestampData b, boolean isYear) {
		 synchronized (HsqlDateTime.tempCalGMT) {
			 boolean negate = false;
			 if (b.getSeconds() > a.getSeconds()) {
				 negate = true;
				 TimestampData temp = a;
				 a = b;
				 b = temp;
			 }
			 HsqlDateTime.setTimeInMillis(HsqlDateTime.tempCalGMT, a.getSeconds() * 1000);
			 int months = HsqlDateTime.tempCalGMT.get(Calendar.MONTH);
			 int years = HsqlDateTime.tempCalGMT.get(Calendar.YEAR);
			 HsqlDateTime.setTimeInMillis(HsqlDateTime.tempCalGMT, b.getSeconds() * 1000);
			 months -= HsqlDateTime.tempCalGMT.get(Calendar.MONTH);
			 years -= HsqlDateTime.tempCalGMT.get(Calendar.YEAR);
			 if (isYear) {
				 months = years * 12;
			 }
			 else {
				 if (months < 0) {
					 months += 12;
					 years--;
				 }
				 months += years * 12;
				 if (negate) {
					 months = -months;
				 }
			 }
			 return months;
		 }
	 }
	 public static TimeData addSeconds(TimeData source, int seconds, int nanos) {
		 nanos += source.getNanos();
		 seconds += nanos / limitNanoseconds;
		 nanos %= limitNanoseconds;
		 if (nanos < 0) {
			 nanos += DTIType.limitNanoseconds;
			 seconds--;
		 }
		 seconds += source.getSeconds();
		 seconds %= (24 * 60 * 60);
		 TimeData ti = new TimeData(seconds, nanos, source.getZone());
		 return ti;
	 }
	 public static TimestampData addMonths(TimestampData source, int months) {
		 int n = source.getNanos();
		 synchronized (HsqlDateTime.tempCalGMT) {
			 HsqlDateTime.setTimeInMillis(HsqlDateTime.tempCalGMT, source.getSeconds() * 1000);
			 HsqlDateTime.tempCalGMT.add(Calendar.MONTH, months);
			 TimestampData ts = new TimestampData(HsqlDateTime.tempCalGMT.getTimeInMillis() / 1000, n, source.getZone());
			 return ts;
		 }
	 }
	 public static TimestampData addSeconds(TimestampData source, int seconds, int nanos) {
		 nanos += source.getNanos();
		 seconds += nanos / limitNanoseconds;
		 nanos %= limitNanoseconds;
		 if (nanos < 0) {
			 nanos += limitNanoseconds;
			 seconds--;
		 }
		 long newSeconds = source.getSeconds() + seconds;
		 TimestampData ts = new TimestampData(newSeconds, nanos, source.getZone());
		 return ts;
	 }
}",1,0,0,0
"jsXe.java:tabSize=4:indentSize=4:noTabs=true::folding=explicit:collapseFolds=1:jsXe is the Java Simple XML EditorjsXe is a gui application that creates a tree view of an XML document.The user can then edit this tree and the content in the tree.Copyright (C) 2002 Ian Lewis (IanLewis)This program is free software;
 you can redistribute it and/ormodify it under the terms of the GNU General Public Licenseas published by the Free Software Foundation;
 either version 2of the License, or (at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY;
 without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program;
 if not, write to the Free SoftwareFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.Optionally, you may find a copy of the GNU General Public Licensefrom http:public class jsXe {
	 public static final String MIN_JAVA_VERSION = ""1.4.2"";
	 public static final String MIN_XERCES_VERSION = ""Xerces-J 2.7.0"";
	 public static void main(String args[]) {
		 try {
			 long startTime = System.currentTimeMillis();
			 String javaVersion = System.getProperty(""java.version"");
			 if(javaVersion.compareTo(MIN_JAVA_VERSION) < 0) {
				 System.err.println(getAppTitle() + "": ERROR: You are running Java version "" + javaVersion + ""."");
				 System.err.println(getAppTitle() + "": ERROR:"" + getAppTitle()+"" requires Java ""+MIN_JAVA_VERSION+"" or later."");
				 System.exit(1);
			 }
			 m_homeDirectory = System.getProperty(""user.home"");
			 String fileSep = System.getProperty(""file.separator"");
			 m_settingsDirectory = m_homeDirectory+fileSep+"".jsxe"";
			 File _settingsDirectory = new File(m_settingsDirectory);
			 if(!_settingsDirectory.exists()) _settingsDirectory.mkdirs();
			 String pluginsDirectory = m_settingsDirectory+""/jars"";
			 File _pluginsDirectory = new File(pluginsDirectory);
			 if(!_pluginsDirectory.exists()) _pluginsDirectory.mkdirs();
			 String jsXeHome = System.getProperty(""jsxe.home"");
			 if (jsXeHome == null) {
				 String classpath = System.getProperty(""java.class.path"");
				 int index = classpath.toLowerCase().indexOf(""jsxe.jar"");
				 int start = classpath.lastIndexOf(File.pathSeparator,index) + 1;
				 if (classpath.equalsIgnoreCase(""jsxe.jar"")) {
					 jsXeHome = System.getProperty(""user.dir"");
				 }
				 else {
					 if(index > start) {
						 jsXeHome = classpath.substring(start, index - 1);
					 }
					 else {
						 jsXeHome = System.getProperty(""user.dir"");
					 }
				 }
			 }
			 Messages.initializePropertiesObject(null, jsXeHome+fileSep+""messages"");
			 initDefaultProps();
			 String viewname = null;
			 ArrayList files = new ArrayList();
			 boolean debug = false;
			 for (int i=0;
			 i<args.length;
			 i++) {
				 if (args[i].equals(""--help"") || args[i].equals(""-h"")) {
					 printUsage();
					 System.exit(0);
				 }
				 if (args[i].equals(""--version"") || args[i].equals(""-V"")) {
					 System.out.println(getVersion());
					 System.exit(0);
				 }
				 if (args[i].equals(""--debug"")) {
					 debug = true;
				 }
				 else {
					 files.add(args[i]);
				 }
			 }
			 ProgressSplashScreenWindow progressScreen = new ProgressSplashScreenWindow();
			 int w = progressScreen.getSize().width;
			 int h = progressScreen.getSize().height;
			 Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
			 int x = (dim.width-w)/2;
			 int y = (dim.height-h)/2;
			 progressScreen.setLocation(x, y);
			 progressScreen.setVisible(true);
			 Log.init(true, Log.ERROR, debug);
			 try {
				 BufferedWriter stream = new BufferedWriter(new FileWriter(getSettingsDirectory()+fileSep+""jsXe.log""));
				 stream.flush();
				 stream.write(""Log file created on "" + new Date());
				 stream.write(System.getProperty(""line.separator""));
				 Log.setLogWriter(stream);
			 }
			 catch (IOException ioe) {
				 Log.log(Log.ERROR, jsXe.class, ioe);
			 }
			 progressScreen.updateSplashScreenDialog(10);
			 String xercesVersion = org.apache.xerces.impl.Version.getVersion();
			 if (MiscUtilities.compareStrings(xercesVersion, MIN_XERCES_VERSION, false) < 0) {
				 String msg = Messages.getMessage(""No.Xerces.Error"", new String[] {
				 MIN_XERCES_VERSION }
				);
				 Log.log(Log.ERROR, jsXe.class, msg);
				 JOptionPane.showMessageDialog(null, msg, Messages.getMessage(""No.Xerces.Error.Title"", new String[] {
				 MIN_XERCES_VERSION }
				), JOptionPane.WARNING_MESSAGE);
				 System.exit(1);
			 }
			 progressScreen.updateSplashScreenDialog(20);
			 File recentFiles = new File(getSettingsDirectory(), ""recent.xml"");
			 m_bufferHistory = new BufferHistory();
			 try {
				 m_bufferHistory.load(recentFiles);
			 }
			 catch (IOException ioe) {
				 System.err.println(getAppTitle() + "": I/O ERROR: Could not open recent files list"");
				 System.err.println(getAppTitle() + "": I/O ERROR: ""+ioe.toString());
			 }
			 catch (SAXException saxe) {
				 System.err.println(getAppTitle() + "": I/O ERROR: recent.xml not formatted properly"");
				 System.err.println(getAppTitle() + "": I/O ERROR: ""+saxe.toString());
			 }
			 catch (ParserConfigurationException pce) {
				 System.err.println(getAppTitle() + "": I/O ERROR: Could not parse recent.xml"");
				 System.err.println(getAppTitle() + "": I/O ERROR: ""+pce.toString());
			 }
			 progressScreen.updateSplashScreenDialog(30);
			 Log.log(Log.NOTICE, jsXe.class, ""Loading plugins"");
			 m_pluginLoader = new JARClassLoader();
			 Log.log(Log.NOTICE, jsXe.class, ""Adding to plugin search path: ""+pluginsDirectory);
			 ArrayList pluginMessages = m_pluginLoader.addDirectory(pluginsDirectory);
			 Log.log(Log.NOTICE, jsXe.class, ""Adding to plugin search path: ""+jsXeHome+fileSep+""jars"");
			 pluginMessages.addAll(m_pluginLoader.addDirectory(jsXeHome+fileSep+""jars""));
			 progressScreen.updateSplashScreenDialog(40);
			 Log.log(Log.NOTICE, jsXe.class, ""Starting plugins"");
			 pluginMessages.addAll(m_pluginLoader.startPlugins());
			 Vector pluginErrors = new Vector();
			 if (pluginMessages.size() != 0) {
				 for (int i=0;
				 i<pluginMessages.size();
				 i++) {
					 Object error = pluginMessages.get(i);
					 if ((error instanceof IOException) || (error instanceof PluginDependencyException)) {
						 Log.log(Log.ERROR, jsXe.class, ((Exception)error).getMessage());
						 pluginErrors.add(((Exception)error).getMessage());
					 }
					 else {
						 if (error instanceof PluginLoadException) {
							 Log.log(Log.WARNING, jsXe.class, ((PluginLoadException)error).getMessage());
						 }
						 else {
							 Log.log(Log.WARNING, jsXe.class, error.toString());
						 }
					 }
				 }
			 }
			 progressScreen.updateSplashScreenDialog(50);
			 Iterator pluginItr = m_pluginLoader.getAllPlugins().iterator();
			 while (pluginItr.hasNext()) {
				 ActionPlugin plugin = (ActionPlugin)pluginItr.next();
				 Properties props = plugin.getProperties();
				 Enumeration names = props.propertyNames();
				 while (names.hasMoreElements()) {
					 String name = names.nextElement().toString();
					 setProperty(name, props.getProperty(name));
				 }
				 addActionSet(plugin.getActionSet());
			 }
			 progressScreen.updateSplashScreenDialog(60);
			 File properties = new File(getSettingsDirectory(),""properties"");
			 try {
				 FileInputStream filestream = new FileInputStream(properties);
				 props.load(filestream);
			 }
			 catch (FileNotFoundException fnfe) {
				 Log.log(Log.MESSAGE, jsXe.class, ""User has no properties file. Running jsXe for the first time?"");
			 }
			 catch (IOException ioe) {
				 System.err.println(getAppTitle() + "": I/O ERROR: Could not open settings file"");
				 System.err.println(getAppTitle() + "": I/O ERROR: ""+ioe.toString());
			 }
			 CatalogManager.propertiesChanged();
			 progressScreen.updateSplashScreenDialog(70);
			 Log.log(Log.NOTICE, jsXe.class, ""Starting the main window"");
			 TabbedView tabbedview = null;
			 DocumentBuffer defaultBuffer = null;
			 try {
				 defaultBuffer = new DocumentBuffer();
				 m_buffers.add(defaultBuffer);
				 if (viewname == null) {
					 tabbedview = new TabbedView(defaultBuffer);
				 }
				 else {
					 try {
						 tabbedview = new TabbedView(defaultBuffer, viewname);
					 }
					 catch (UnrecognizedPluginException e) {
						 Log.log(Log.ERROR, jsXe.class, e.getMessage());
						 System.exit(1);
					 }
				 }
			 }
			 catch (IOException ioe) {
				 Log.log(Log.ERROR, jsXe.class, ioe);
				 JOptionPane.showMessageDialog(null, ioe.getMessage()+""."", Messages.getMessage(""IO.Error.Title""), JOptionPane.WARNING_MESSAGE);
				 System.exit(1);
			 }
			 m_activeView = tabbedview;
			 progressScreen.updateSplashScreenDialog(85);
			 Log.log(Log.NOTICE, jsXe.class, ""Parsing files to open on command line"");
			 if (files.size() > 0) {
				 if (openXMLDocuments(tabbedview, (String[])files.toArray(new String[] {
				}
				))) {
					 try {
						 closeDocumentBuffer(tabbedview, defaultBuffer);
					 }
					 catch (IOException ioe) {
					 }
				 }
			 }
			 progressScreen.updateSplashScreenDialog(100);
			 tabbedview.setVisible(true);
			 progressScreen.dispose();
			 if (pluginErrors.size() > 0) {
				 new ErrorListDialog(tabbedview, ""Plugin Error"", ""The following plugins could not be loaded:"", new Vector(pluginErrors), true);
			 }
			 Log.log(Log.NOTICE, jsXe.class, ""jsXe started in ""+(System.currentTimeMillis()-startTime)+"" milliseconds"");
		 }
		 catch (Throwable e) {
			 exiterror(null, e, 1);
		 }
	 }
	 public static String getBuild() {
		 String major = buildProps.getProperty(""major.version"");
		 String minor = buildProps.getProperty(""minor.version"");
		 String beta = buildProps.getProperty(""beta.version"");
		 String bugfix = buildProps.getProperty(""build.version"");
		 if (major.length() == 1) {
			 major = ""0""+major;
		 }
		 if (minor.length() == 1) {
			 minor = ""0""+minor;
		 }
		 if (beta.length() == 1) {
			 beta = ""0""+beta;
		 }
		 if (bugfix.length() == 1) {
			 bugfix = ""0""+bugfix;
		 }
		 return major+"".""+ minor+"".""+ beta+"".""+ bugfix;
	 }
	 public static Date getBuildDate() {
		 String buildTime = buildProps.getProperty(""build.time"");
		 try {
			 SimpleDateFormat format = new SimpleDateFormat(""MM.dd.yyyy HH:mm:ss z"");
			 return format.parse(buildTime);
		 }
		 catch (ParseException e) {
			 Log.log(Log.ERROR, jsXe.class, e);
		 }
		 return null;
	 }
	 public static String getVersion() {
		 return MiscUtilities.buildToVersion(getBuild());
	 }
	 public static ImageIcon getIcon() {
		 return jsXeIcon;
	 }
	 public static String getSettingsDirectory() {
		 return m_settingsDirectory;
	 }
	 public static String getAppTitle() {
		 return buildProps.getProperty(""application.name"");
	 }
	 public static TabbedView getActiveView() {
		 return m_activeView;
	 }
	 public static boolean showOpenFileDialog(TabbedView view) throws IOException {
		 DocumentBuffer buffer = view.getDocumentBuffer();
		 File docFile = buffer.getFile();
		 JFileChooser loadDialog;
		 if (docFile == null) {
			 loadDialog = new jsxeFileDialog(m_homeDirectory);
		 }
		 else {
			 loadDialog = new jsxeFileDialog(docFile);
		 }
		 loadDialog.setMultiSelectionEnabled(true);
		 int returnVal = loadDialog.showOpenDialog(view);
		 if (returnVal == JFileChooser.APPROVE_OPTION) {
			 boolean success = false;
			 File[] files = loadDialog.getSelectedFiles();
			 for (int i = 0;
			 i < files.length;
			 i++) {
				 if (files[i] != null) {
					 try {
						 success = openXMLDocument(view, files[i]) || success;
					 }
					 catch (IOException ioe) {
						 Log.log(Log.WARNING, jsXe.class, ioe);
						 JOptionPane.showMessageDialog(view, ioe, Messages.getMessage(""IO.Error.Title""), JOptionPane.WARNING_MESSAGE);
					 }
				 }
			 }
			 return success;
		 }
		 return false;
	 }
	 public static boolean openXMLDocument(TabbedView view, File file) throws IOException {
		 BufferHistory.BufferHistoryEntry entry = m_bufferHistory.getEntry(file.getPath());
		 if (entry != null) {
			 return openXMLDocument(view, file, entry.getProperties(), entry.getViewName());
		 }
		 else {
			 return openXMLDocument(view, file, new Properties(), null);
		 }
	 }
	 public static boolean openXMLDocument(TabbedView view, File file, Properties properties, String viewName) throws IOException {
		 if (file == null) return false;
		 DocumentBuffer buffer = getOpenBuffer(file);
		 if (buffer != null) {
			 view.setDocumentBuffer(buffer);
			 return true;
		 }
		 else {
			 Log.log(Log.NOTICE, jsXe.class, ""Loading file ""+file.getName());
			 try {
				 buffer = new DocumentBuffer(file, properties);
				 m_buffers.add(buffer);
				 if (viewName != null) {
					 try {
						 view.addDocumentBuffer(buffer, viewName);
					 }
					 catch (IOException ioe) {
						 view.addDocumentBuffer(buffer);
					 }
					 catch (UnrecognizedPluginException e) {
						 view.addDocumentBuffer(buffer);
					 }
				 }
				 else {
					 view.addDocumentBuffer(buffer);
				 }
				 DocumentBuffer[] buffers = getDocumentBuffers();
				 if (buffers.length == 2 && buffers[0].isUntitled() && !buffers[0].getStatus(DocumentBuffer.DIRTY)) {
					 closeDocumentBuffer(view, buffers[0]);
				 }
				 return true;
			 }
			 catch (IOException ioe) {
				 m_buffers.remove(buffer);
				 throw ioe;
			 }
		 }
	 }
	 public static boolean openXMLDocument(TabbedView view, String doc) throws IOException {
		 return openXMLDocument(view, new ByteArrayInputStream(doc.getBytes(""UTF-8"")));
	 }
	 public static boolean openXMLDocument(TabbedView view, InputStream stream) throws IOException {
		 Log.log(Log.NOTICE, jsXe.class, ""Loading Untitled Document"");
		 DocumentBuffer buffer = new DocumentBuffer(stream);
		 try {
			 m_buffers.add(buffer);
			 view.addDocumentBuffer(buffer);
			 return true;
		 }
		 catch (IOException ioe) {
			 m_buffers.remove(buffer);
			 throw ioe;
		 }
	 }
	 public static DocumentBuffer getOpenBuffer(File file) {
		 boolean caseInsensitiveFilesystem = (File.separatorChar == '\\' || File.separatorChar == ':' );
		 for(int i=0;
		 i < m_buffers.size();
		i++) {
			 try {
				 DocumentBuffer buffer = (DocumentBuffer)m_buffers.get(i);
				 if (buffer.equalsOnDisk(file)) {
					 return buffer;
				 }
			 }
			 catch (IOException ioe) {
				 exiterror(null, ioe, 1);
			 }
		 }
		 return null;
	 }
	 public static boolean closeDocumentBuffer(TabbedView view, DocumentBuffer buffer) throws IOException {
		 return closeDocumentBuffer(view, buffer, true);
	 }
	 public static boolean closeDocumentBuffer(TabbedView view, DocumentBuffer buffer, boolean confirmClose) throws IOException {
		 if (m_buffers.contains(buffer)) {
			 if (buffer.close(view, confirmClose)) {
				 Log.log(Log.NOTICE, jsXe.class, ""Closing ""+buffer.getName());
				 m_bufferHistory.setEntry(buffer, getPluginLoader().getPluginProperty(view.getDocumentView().getViewPlugin(), JARClassLoader.PLUGIN_NAME));
				 view.removeDocumentBuffer(buffer);
				 m_buffers.remove(buffer);
				 if (view.getBufferCount() == 0) {
					 if (!m_exiting) {
						 try {
							 openXMLDocument(view, getDefaultDocument());
						 }
						 catch (IOException ioe) {
							 exiterror(view, ""Could not open default document."", 1);
						 }
					 }
				 }
				 return true;
			 }
			 else {
				 return false;
			 }
		 }
		 else {
			 return false;
		 }
	 }
	 public static boolean closeAllDocumentBuffers(TabbedView view) throws IOException {
		 DocumentBuffer[] buffers = jsXe.getDocumentBuffers();
		 ArrayList dirtyBufferList = new ArrayList();
		 for (int i=0;
		 i < buffers.length;
		 i++) {
			 DocumentBuffer db= buffers[i];
			 if (db.getStatus(DocumentBuffer.DIRTY)) {
				 dirtyBufferList.add(db);
			 }
		 }
		 boolean closeFiles = true;
		 if (dirtyBufferList.size() > 0) {
			 if (dirtyBufferList.size() > 1) {
				 DirtyFilesDialog dirtyDialog = new DirtyFilesDialog(view, dirtyBufferList);
				 dirtyDialog.setSize(200, 400);
				 dirtyDialog.setResizable(true);
				 closeFiles = !dirtyDialog.getCancelFlag();
			 }
			 else {
				 closeFiles = closeDocumentBuffer(view, (DocumentBuffer)dirtyBufferList.get(0), true);
			 }
		 }
		 if (closeFiles) {
			 buffers = jsXe.getDocumentBuffers();
			 for (int i=0;
			 i < buffers.length;
			 i++) {
				 if (!closeDocumentBuffer(view, buffers[i], false)) {
					 return false;
				 }
			 }
		 }
		 return closeFiles;
	 }
	 public static BufferHistory getBufferHistory() {
		 return m_bufferHistory;
	 }
	 public static InputStream getDefaultDocument() {
		 try {
			 return new ByteArrayInputStream(DefaultDocument.getBytes(""UTF-8""));
		 }
		 catch (UnsupportedEncodingException e) {
			 Log.log(Log.ERROR, jsXe.class, ""Broken JVM doesn't support UTF-8"");
			 Log.log(Log.ERROR, jsXe.class, e);
			 return null;
		 }
	 }
	 public static DocumentBuffer[] getDocumentBuffers() {
		 DocumentBuffer[] buffers = new DocumentBuffer[m_buffers.size()];
		 for (int i=0;
		 i < m_buffers.size();
		 i++) {
			 buffers[i] = (DocumentBuffer)m_buffers.get(i);
		 }
		 return buffers;
	 }
	 public static void exit(TabbedView view) {
		 m_exiting = true;
		 try {
			 if (view.close()) {
				 Log.log(Log.NOTICE, jsXe.class, ""Exiting"");
				 CatalogManager.save();
				 String settingsDirectory = getSettingsDirectory();
				 try {
					 File properties = new File(settingsDirectory,""properties"");
					 FileOutputStream filestream = new FileOutputStream(properties);
					 props.store(filestream, ""Autogenerated jsXe properties""+System.getProperty(""line.separator"")+""#This file is not really meant to be edited."");
				 }
				 catch (IOException ioe) {
					 exiterror(view, ""Could not save jsXe properites.\n""+ioe.toString(), 1);
				 }
				 catch (ClassCastException cce) {
					 exiterror(view, ""Could not save jsXe properties.\n""+cce.toString(), 1);
				 }
				 try {
					 File recentFiles = new File(settingsDirectory, ""recent.xml"");
					 m_bufferHistory.save(recentFiles);
				 }
				 catch (IOException ioe) {
					 exiterror(view, ""Could not save jsXe recent files list.\n""+ioe.toString(), 1);
				 }
				 Log.closeStream();
				 System.exit(0);
			 }
			 else {
				 m_exiting = false;
			 }
		 }
		 catch (IOException ioe) {
			 Log.log(Log.ERROR, jsXe.class, ioe);
			 JOptionPane.showMessageDialog(view, ioe, Messages.getMessage(""IO.Error.Title""), JOptionPane.WARNING_MESSAGE);
			 m_exiting = false;
		 }
	 }
	 public static void exiterror(Object source, Object error, int errorcode) {
		 String errorhdr = ""jsXe has encountered a fatal error and is unable to continue.\n"";
		 errorhdr +=""This is most likely a bug and should be reported to the jsXe\n"";
		 errorhdr +=""developers. Please include your jsXe.log in a bug report at\n"";
		 errorhdr +=""http: Log.log(Log.ERROR, source, errorhdr);
		 Log.log(Log.ERROR, source, error);
		 if (source != null && source instanceof Component) {
			 JOptionPane.showMessageDialog((Component)source, errorhdr + error, ""Fatal Error"", JOptionPane.WARNING_MESSAGE);
		 }
		 Log.closeStream();
		 System.exit(errorcode);
	 }
	 public static Object setProperty(String key, String value) {
		 if (value == null) {
			 props.remove(key);
			 return null;
		 }
		 else {
			 return props.setProperty(key, value);
		 }
	 }
	 public static final String getDefaultProperty(String key) {
		 return defaultProps.getProperty(key);
	 }
	 public static final String getProperty(String key) {
		 return getProperty(key, null);
	 }
	 public static final String getProperty(String key, String defaultValue) {
		 return props.getProperty(key, defaultProps.getProperty(key, defaultValue));
	 }
	 public static final int getIntegerProperty(String key, int defaultValue) {
		 int intValue = defaultValue;
		 String value = getProperty(key);
		 if (value == null) {
			 return defaultValue;
		 }
		 else {
			 try {
				 return Integer.parseInt(value.trim());
			 }
			 catch(NumberFormatException nf) {
				 return defaultValue;
			 }
		 }
	 }
	 public static final void setIntegerProperty(String name, int value) {
		 setProperty(name, String.valueOf(value));
	 }
	 public static final boolean getBooleanProperty(String name, boolean defaultValue) {
		 boolean booleanValue = defaultValue;
		 String value = getProperty(name);
		 if (value == null) {
			 return defaultValue;
		 }
		 else {
			 return Boolean.valueOf(value).booleanValue();
		 }
	 }
	 public static final void setBooleanProperty(String name, boolean value) {
		 setProperty(name, String.valueOf(value));
	 }
	 public static void addActionSet(ActionSet set) {
		 m_actionSets.add(set);
	 }
	 public static Action getAction(String name) {
		 for (int i = 0;
		 i < m_actionSets.size();
		 i++) {
			 Action action = ((ActionSet)m_actionSets.get(i)).getAction(name);
			 if (action != null) {
				 return action;
			 }
		 }
		 return null;
	 }
	 public ArrayList getActionSets() {
		 return m_actionSets;
	 }
	 public static final OptionsPanel getOptionsPanel() {
		 jsXeOptions = new jsXeOptionsPanel();
		 return jsXeOptions;
	 }
	 public static JARClassLoader getPluginLoader() {
		 return m_pluginLoader;
	 }
	 public static final boolean isExiting() {
		 return m_exiting;
	 }
	 private jsXe() {
	}
	 private static boolean openXMLDocuments(TabbedView view, String args[]) {
		 boolean success = false;
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 if (args[i] != null) {
				 try {
					 Log.log(Log.NOTICE, jsXe.class, ""Trying to open ""+args[i]);
					 success = openXMLDocument(view, new File(args[i])) || success;
				 }
				 catch (IOException ioe) {
					 Log.log(Log.WARNING, jsXe.class, ioe);
					 JOptionPane.showMessageDialog(view, ioe, Messages.getMessage(""IO.Error.Title""), JOptionPane.WARNING_MESSAGE);
				 }
			 }
		 }
		 return success;
	 }
	 private static void initDefaultProps() {
		 InputStream inputstream = jsXe.class.getResourceAsStream(""/net/sourceforge/jsxe/properties"");
		 try {
			 defaultProps.load(inputstream);
		 }
		 catch (IOException ioe) {
			 Log.log(Log.ERROR, jsXe.class, ""**** Could not open default settings file ****"");
			 Log.log(Log.ERROR, jsXe.class, ""**** jsXe was probably not built correctly ****"");
			 exiterror(null, ioe, 1);
		 }
		 Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
		 int windowWidth = (int)(screenSize.getWidth() / 2);
		 int windowHeight = (int)(3 * screenSize.getHeight() / 4);
		 int x = (int)(screenSize.getWidth() / 4);
		 int y = (int)(screenSize.getHeight() / 8);
		 defaultProps.setProperty(""tabbedview.height"",Integer.toString(windowHeight));
		 defaultProps.setProperty(""tabbedview.width"",Integer.toString(windowWidth));
		 defaultProps.setProperty(""tabbedview.x"",Integer.toString(x));
		 defaultProps.setProperty(""tabbedview.y"",Integer.toString(y));
		 inputstream = jsXe.class.getResourceAsStream(""/net/sourceforge/jsxe/build.properties"");
		 try {
			 buildProps.load(inputstream);
		 }
		 catch (IOException ioe) {
			 Log.log(Log.ERROR, jsXe.class, ""**** Could not open build properties file ****"");
			 Log.log(Log.ERROR, jsXe.class, ""**** jsXe was probably not built correctly ****"");
			 exiterror(null, ioe, 1);
		 }
	 }
	 private static class jsXeOptionsPanel extends OptionsPanel {
		 public jsXeOptionsPanel() {
			 GridBagLayout layout = new GridBagLayout();
			 GridBagConstraints constraints = new GridBagConstraints();
			 setLayout(layout);
			 int gridY = 0;
			 int maxRecentFiles = 20;
			 try {
				 maxRecentFiles = Integer.parseInt(jsXe.getProperty(""max.recent.files""));
			 }
			 catch (NumberFormatException nfe) {
				 try {
					 maxRecentFiles = Integer.parseInt(jsXe.getDefaultProperty(""max.recent.files""));
				 }
				 catch (NumberFormatException nfe2) {
					 Log.log(Log.ERROR, jsXe.class, ""Could not read max.recent.files property"");
				 }
			 }
			 JLabel maxRecentFilesLabel = new JLabel(Messages.getMessage(""Global.Options.Max.Recent.Files""));
			 maxRecentFilesLabel.setToolTipText(Messages.getMessage(""Global.Options.Max.Recent.Files.ToolTip""));
			 Vector sizes = new Vector(4);
			 sizes.add(""10"");
			 sizes.add(""20"");
			 sizes.add(""30"");
			 sizes.add(""40"");
			 maxRecentFilesComboBox = new JComboBox(sizes);
			 maxRecentFilesComboBox.setEditable(true);
			 maxRecentFilesComboBox.setSelectedItem(Integer.toString(maxRecentFiles));
			 maxRecentFilesComboBox.setToolTipText(Messages.getMessage(""Global.Options.Max.Recent.Files.ToolTip""));
			 JLabel networkLabel = new JLabel(Messages.getMessage(""Global.Options.network""));
			 String[] networkValues = {
			 Messages.getMessage(""Global.Options.network-always""), Messages.getMessage(""Global.Options.network-cache""), Messages.getMessage(""Global.Options.network-off"") }
			;
			 network = new JComboBox(networkValues);
			 network.setSelectedIndex(jsXe.getIntegerProperty(""xml.cache"", 1));
			 constraints.gridy = gridY;
			 constraints.gridx = 0;
			 constraints.gridheight = 1;
			 constraints.gridwidth = 1;
			 constraints.weightx = 1.0f;
			 constraints.fill = GridBagConstraints.BOTH;
			 constraints.insets = new Insets(1,0,1,0);
			 layout.setConstraints(maxRecentFilesLabel, constraints);
			 add(maxRecentFilesLabel);
			 constraints.gridy = gridY++;
			 constraints.gridx = 1;
			 constraints.gridheight = 1;
			 constraints.gridwidth = 1;
			 constraints.weightx = 1.0f;
			 constraints.fill = GridBagConstraints.BOTH;
			 constraints.insets = new Insets(1,0,1,0);
			 layout.setConstraints(maxRecentFilesComboBox, constraints);
			 add(maxRecentFilesComboBox);
			 constraints.gridy = gridY;
			 constraints.gridx = 0;
			 constraints.gridheight = 1;
			 constraints.gridwidth = 1;
			 constraints.weightx = 1.0f;
			 constraints.fill = GridBagConstraints.BOTH;
			 constraints.insets = new Insets(1,0,1,0);
			 layout.setConstraints(networkLabel, constraints);
			 add(networkLabel);
			 constraints.gridy = gridY++;
			 constraints.gridx = 1;
			 constraints.gridheight = 1;
			 constraints.gridwidth = 1;
			 constraints.weightx = 1.0f;
			 constraints.fill = GridBagConstraints.BOTH;
			 constraints.insets = new Insets(1,0,1,0);
			 layout.setConstraints(network, constraints);
			 add(network);
		 }
		 public String getName() {
			 return ""jsxeoptions"";
		 }
		 public void save() {
			 try {
				 jsXe.setProperty(""max.recent.files"", (new Integer(maxRecentFilesComboBox.getSelectedItem().toString())).toString());
			 }
			 catch (NumberFormatException nfe) {
			 }
			 jsXe.setIntegerProperty(""xml.cache"",network.getSelectedIndex());
			 CatalogManager.propertiesChanged();
		 }
		 public String getTitle() {
			 return Messages.getMessage(""Global.Options.Title"");
		 }
		 public String toString() {
			 return getTitle();
		 }
		 private JComboBox maxRecentFilesComboBox;
		 private JComboBox network;
	 }
	 private static void printUsage() {
		 System.out.println(""jsXe ""+getVersion());
		 System.out.println(""The Java Simple XML Editor"");
		 System.out.println();
		 System.out.println(""Copyright 2004 Ian Lewis"");
		 System.out.println(""This is free software;
		 see the source for copying conditions. There is NO"");
		 System.out.println(""warranty;
		 not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."");
		 System.out.println();
		 System.out.println(""Usage: jsXe [<options>] [<files>]"");
		 System.out.println("" --debug print debug information"");
		 System.out.println("" -h, --help display this help and exit"");
		 System.out.println("" -V, --version print version information and exit"");
		 System.out.println();
		 System.out.println(""Report bugs to <ian_lewis>"");
	 }
	 private static ArrayList m_buffers = new ArrayList();
	 private static final String DefaultDocument = ""<?xml version='1.0' encoding='UTF-8'?>\n<default_element>default_node</default_element>"";
	 private static final ImageIcon jsXeIcon = new ImageIcon(jsXe.class.getResource(""/net/sourceforge/jsxe/icons/jsxe.jpg""), ""jsXe"");
	 private static final Properties buildProps = new Properties();
	 private static boolean m_exiting=false;
	 private static final Properties defaultProps = new Properties();
	 private static Properties props = new Properties();
	 private static BufferHistory m_bufferHistory;
	 private static ArrayList m_actionSets = new ArrayList();
	 private static JARClassLoader m_pluginLoader;
	 private static TabbedView m_activeView;
	 private static String m_settingsDirectory;
	 private static String m_homeDirectory;
	 private static OptionsPanel jsXeOptions;
}",0,0,0,0
"public class SkipNullRepresenter extends Representer{
	 protected NodeTuple representJavaBeanProperty(Object javaBean, Property property, Object propertyValue, Tag customTag) {
		 if (propertyValue == null) {
			 return null;
		 }
		 else {
			 return super.representJavaBeanProperty(javaBean, property, propertyValue, customTag);
		 }
	 }
}",0,0,0,0
"public class LocalToken extends Token<ByteBuffer>{
	 static final long serialVersionUID = 8437543776403014875L;
	 private final AbstractType comparator;
	 public LocalToken(AbstractType comparator, ByteBuffer token) {
		 super(token);
		 this.comparator = comparator;
	 }
	 public String toString() {
		 return comparator.getString(token);
	 }
	 public int compareTo(Token<ByteBuffer> o) {
		 return comparator.compare(token, o.token);
	 }
	 public int hashCode() {
		 final int prime = 31;
		 return prime + token.hashCode();
	 }
	 public boolean equals(Object obj) {
		 if (this == obj) return true;
		 if (!(obj instanceof LocalToken)) return false;
		 LocalToken other = (LocalToken) obj;
		 return token.equals(other.token);
	 }
}",0,0,0,0
"public class CounterMutation implements IMutation{
	 private static final Logger logger = LoggerFactory.getLogger(CounterMutation.class);
	 private static final CounterMutationSerializer serializer = new CounterMutationSerializer();
	 private final RowMutation rowMutation;
	 private final ConsistencyLevel consistency;
	 public CounterMutation(RowMutation rowMutation, ConsistencyLevel consistency) {
		 this.rowMutation = rowMutation;
		 this.consistency = consistency;
	 }
	 public String getTable() {
		 return rowMutation.getTable();
	 }
	 public Collection<Integer> getColumnFamilyIds() {
		 return rowMutation.getColumnFamilyIds();
	 }
	 public ByteBuffer key() {
		 return rowMutation.key();
	 }
	 public RowMutation rowMutation() {
		 return rowMutation;
	 }
	 public ConsistencyLevel consistency() {
		 return consistency;
	 }
	 public static CounterMutationSerializer serializer() {
		 return serializer;
	 }
	 public RowMutation makeReplicationMutation() throws IOException {
		 List<ReadCommand> readCommands = new LinkedList<ReadCommand>();
		 for (ColumnFamily columnFamily : rowMutation.getColumnFamilies()) {
			 if (!columnFamily.metadata().getReplicateOnWrite()) continue;
			 addReadCommandFromColumnFamily(rowMutation.getTable(), rowMutation.key(), columnFamily, readCommands);
		 }
		 RowMutation replicationMutation = new RowMutation(rowMutation.getTable(), rowMutation.key());
		 for (ReadCommand readCommand : readCommands) {
			 Table table = Table.open(readCommand.table);
			 Row row = readCommand.getRow(table);
			 if (row == null || row.cf == null) continue;
			 ColumnFamily cf = row.cf;
			 if (cf.isSuper()) cf.retainAll(rowMutation.getColumnFamily(cf.metadata().cfId));
			 replicationMutation.add(cf);
		 }
		 return replicationMutation;
	 }
	 private void addReadCommandFromColumnFamily(String table, ByteBuffer key, ColumnFamily columnFamily, List<ReadCommand> commands) {
		 QueryPath queryPath = new QueryPath(columnFamily.metadata().cfName);
		 commands.add(new SliceByNamesReadCommand(table, key, queryPath, columnFamily.getColumnNames()));
	 }
	 public Message makeMutationMessage(int version) throws IOException {
		 byte[] bytes = FBUtilities.serialize(this, serializer, version);
		 return new Message(FBUtilities.getBroadcastAddress(), StorageService.Verb.COUNTER_MUTATION, bytes, version);
	 }
	 public boolean shouldReplicateOnWrite() {
		 for (ColumnFamily cf : rowMutation.getColumnFamilies()) if (cf.metadata().getReplicateOnWrite()) return true;
		 return false;
	 }
	 public void apply() throws IOException {
		 RowMutation rm = new RowMutation(rowMutation.getTable(), ByteBufferUtil.clone(rowMutation.key()));
		 Table table = Table.open(rm.getTable());
		 for (ColumnFamily cf_ : rowMutation.getColumnFamilies()) {
			 ColumnFamily cf = cf_.cloneMeShallow();
			 ColumnFamilyStore cfs = table.getColumnFamilyStore(cf.id());
			 for (IColumn column : cf_) {
				 cf.addColumn(column.localCopy(cfs), HeapAllocator.instance);
			 }
			 rm.add(cf);
		 }
		 rm.apply();
	 }
	 public void addAll(IMutation m) {
		 if (!(m instanceof CounterMutation)) throw new IllegalArgumentException();
		 CounterMutation cm = (CounterMutation)m;
		 rowMutation.addAll(cm.rowMutation);
	 }
	 public String toString() {
		 return toString(false);
	 }
	 public String toString(boolean shallow) {
		 StringBuilder buff = new StringBuilder(""CounterMutation("");
		 buff.append(rowMutation.toString(shallow));
		 buff.append("", "").append(consistency.toString());
		 return buff.append("")"").toString();
	 }
}
class CounterMutationSerializer implements IVersionedSerializer<CounterMutation>{
	 public void serialize(CounterMutation cm, DataOutput dos, int version) throws IOException {
		 RowMutation.serializer().serialize(cm.rowMutation(), dos, version);
		 dos.writeUTF(cm.consistency().name());
	 }
	 public CounterMutation deserialize(DataInput dis, int version) throws IOException {
		 RowMutation rm = RowMutation.serializer().deserialize(dis, version);
		 ConsistencyLevel consistency = Enum.valueOf(ConsistencyLevel.class, dis.readUTF());
		 return new CounterMutation(rm, consistency);
	 }
	 public long serializedSize(CounterMutation cm, int version) {
		 return RowMutation.serializer().serializedSize(cm.rowMutation(), version) + DBConstants.shortSize + FBUtilities.encodedUTF8Length(cm.consistency().name());
	 }
}",0,0,0,0
"public void resetApplications() {
	 String jobPath = zkRoot + ""/jobs"";
	 InterProcessLock lock = new InterProcessReadWriteLock(curator,jobPath).writeLock();
	 try {
		 lock.acquire();
		 (curator.getChildren().forPath(jobPath)).forEach(appId -> {
			 String path = jobPath + ""/"" + appId;
			 try {
				 if (curator.checkExists().forPath(path) != null) {
					 String status = new String(curator.getData().forPath(path));
					 if (!ZKStateConstant.AppStatus.INIT.toString().equals(status)) {
						 curator.setData().forPath(path, ZKStateConstant.AppStatus.INIT.toString().getBytes(""UTF-8""));
					 }
				 }
			 }
			 catch (Exception e) {
				 LOG.error(""fail to read unprocessed job"", e);
				 throw new RuntimeException(e);
			 }
		 }
		);
	 }
	 catch (Exception e) {
		 LOG.error(""fail to read unprocessed jobs"", e);
		 throw new RuntimeException(e);
	 }
	 finally {
		 try {
			 lock.release();
		 }
		 catch (Exception e) {
			 LOG.error(""fail to release lock"", e);
		 }
	 }
 }",0,0,1,0
"public int getPrecision(UUID obj) {
	 return -1;
 }",0,0,0,0
"public class IncomingTcpConnection extends Thread{
	 private static Logger logger = LoggerFactory.getLogger(IncomingTcpConnection.class);
	 private static final int CHUNK_SIZE = 1024 * 1024;
	 private Socket socket;
	 public InetAddress from;
	 public IncomingTcpConnection(Socket socket) {
		 assert socket != null;
		 this.socket = socket;
	 }
	 public void run() {
		 DataInputStream input;
		 boolean isStream;
		 int version;
		 try {
			 input = new DataInputStream(socket.getInputStream());
			 MessagingService.validateMagic(input.readInt());
			 int header = input.readInt();
			 isStream = MessagingService.getBits(header, 3, 1) == 1;
			 version = MessagingService.getBits(header, 15, 8);
			 logger.debug(""Version for {
			}
			 is {
			}
			"", from, version);
			 if (isStream) {
				 if (version == MessagingService.version_) {
					 int size = input.readInt();
					 byte[] headerBytes = new byte[size];
					 input.readFully(headerBytes);
					 stream(StreamHeader.serializer().deserialize(new DataInputStream(new FastByteArrayInputStream(headerBytes)), version), input);
				 }
				 else {
					 logger.error(""Received stream using protocol version {
					}
					 (my version {
					}
					). Terminating connection"", version, MessagingService.version_);
				 }
				 return;
			 }
			 input = new DataInputStream(new BufferedInputStream(socket.getInputStream(), 4096));
			 from = receiveMessage(input, version);
			 if (version > MessagingService.version_) {
				 Gossiper.instance.addSavedEndpoint(from);
				 logger.info(""Received "" + (isStream ? ""streaming "" : """") + ""connection from newer protocol version. Ignoring"");
				 return;
			 }
			 Gossiper.instance.setVersion(from, version);
			 logger.debug(""set version for {
			}
			 to {
			}
			"", from, version);
			 while (true) {
				 MessagingService.validateMagic(input.readInt());
				 header = input.readInt();
				 assert isStream == (MessagingService.getBits(header, 3, 1) == 1) : ""Connections cannot change type: "" + isStream;
				 version = MessagingService.getBits(header, 15, 8);
				 logger.trace(""Version is now {
				}
				"", version);
				 receiveMessage(input, version);
			 }
		 }
		 catch (EOFException e) {
			 logger.trace(""eof reading from socket;
			 closing"", e);
		 }
		 catch (IOException e) {
			 logger.debug(""IOError reading from socket;
			 closing"", e);
		 }
		 finally {
			 close();
		 }
	 }
	 private InetAddress receiveMessage(DataInputStream input, int version) throws IOException {
		 int totalSize = input.readInt();
		 String id = input.readUTF();
		 Header header = Header.serializer().deserialize(input, version);
		 int bodySize = input.readInt();
		 byte[] body = new byte[bodySize];
		 int remainder = bodySize % CHUNK_SIZE;
		 for (int offset = 0;
		 offset < bodySize - remainder;
		 offset += CHUNK_SIZE) input.readFully(body, offset, CHUNK_SIZE);
		 input.readFully(body, bodySize - remainder, remainder);
		 long remaining = totalSize - OutboundTcpConnection.messageLength(header, id, body);
		 while (remaining > 0) remaining -= input.skip(remaining);
		 if (version <= MessagingService.version_) {
			 Message message = new Message(header, body, version);
			 MessagingService.instance().receive(message, id);
		 }
		 else {
			 logger.debug(""Received connection from newer protocol version {
			}
			. Ignoring message"", version);
		 }
		 return header.getFrom();
	 }
	 private void close() {
		 if (from != null) Gossiper.instance.resetVersion(from);
		 try {
			 socket.close();
		 }
		 catch (IOException e) {
			 if (logger.isDebugEnabled()) logger.debug(""error closing socket"", e);
		 }
	 }
	 private void stream(StreamHeader streamHeader, DataInputStream input) throws IOException {
		 new IncomingStreamReader(streamHeader, socket).read();
	 }
}",0,0,0,0
"public class ScriptRuntime {
	 protected ScriptRuntime() {
	 }
	 public final static Class BooleanClass = Kit.classOrNull(""java.lang.Boolean""), ByteClass = Kit.classOrNull(""java.lang.Byte""), CharacterClass = Kit.classOrNull(""java.lang.Character""), ClassClass = Kit.classOrNull(""java.lang.Class""), DoubleClass = Kit.classOrNull(""java.lang.Double""), FloatClass = Kit.classOrNull(""java.lang.Float""), IntegerClass = Kit.classOrNull(""java.lang.Integer""), LongClass = Kit.classOrNull(""java.lang.Long""), NumberClass = Kit.classOrNull(""java.lang.Number""), ObjectClass = Kit.classOrNull(""java.lang.Object""), ShortClass = Kit.classOrNull(""java.lang.Short""), StringClass = Kit.classOrNull(""java.lang.String""), DateClass = Kit.classOrNull(""java.util.Date"");
	 public final static Class ContextClass = Kit.classOrNull(""org.mozilla.javascript.Context""), ContextFactoryClass = Kit.classOrNull(""org.mozilla.javascript.ContextFactory""), FunctionClass = Kit.classOrNull(""org.mozilla.javascript.Function""), ScriptableClass = Kit.classOrNull(""org.mozilla.javascript.Scriptable""), ScriptableObjectClass = Kit.classOrNull(""org.mozilla.javascript.ScriptableObject"");
	 private static final String XML_INIT_CLASS = ""org.mozilla.javascript.xmlimpl.XMLLibImpl"";
	 private static final String[] lazilyNames = {
	 ""RegExp"", ""org.mozilla.javascript.regexp.NativeRegExp"", ""Packages"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""java"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""getClass"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""JavaAdapter"", ""org.mozilla.javascript.JavaAdapter"", ""JavaImporter"", ""org.mozilla.javascript.ImporterTopLevel"", ""XML"", XML_INIT_CLASS, ""XMLList"", XML_INIT_CLASS, ""Namespace"", XML_INIT_CLASS, ""QName"", XML_INIT_CLASS, }
	;
	 private static final Object LIBRARY_SCOPE_KEY = new Object();
	 public static boolean isRhinoRuntimeType(Class cl) {
		 if (cl.isPrimitive()) {
			 return (cl != Character.TYPE);
		 }
		 else {
			 return (cl == StringClass || cl == BooleanClass || NumberClass.isAssignableFrom(cl) || ScriptableClass.isAssignableFrom(cl));
		 }
	 }
	 public static ScriptableObject initStandardObjects(Context cx, ScriptableObject scope, boolean sealed) {
		 if (scope == null) {
			 scope = new NativeObject();
		 }
		 scope.associateValue(LIBRARY_SCOPE_KEY, scope);
		 (new ClassCache()).associate(scope);
		 BaseFunction.init(scope, sealed);
		 NativeObject.init(scope, sealed);
		 Scriptable objectProto = ScriptableObject.getObjectPrototype(scope);
		 Scriptable functionProto = ScriptableObject.getFunctionPrototype(scope);
		 functionProto.setPrototype(objectProto);
		 if (scope.getPrototype() == null) scope.setPrototype(objectProto);
		 NativeError.init(scope, sealed);
		 NativeGlobal.init(cx, scope, sealed);
		 NativeArray.init(scope, sealed);
		 NativeString.init(scope, sealed);
		 NativeBoolean.init(scope, sealed);
		 NativeNumber.init(scope, sealed);
		 NativeDate.init(scope, sealed);
		 NativeMath.init(scope, sealed);
		 NativeWith.init(scope, sealed);
		 NativeCall.init(scope, sealed);
		 NativeScript.init(scope, sealed);
		 boolean withXml = cx.hasFeature(Context.FEATURE_E4X);
		 for (int i = 0;
		 i != lazilyNames.length;
		 i += 2) {
			 String topProperty = lazilyNames[i];
			 String className = lazilyNames[i + 1];
			 if (!withXml && className == XML_INIT_CLASS) {
				 continue;
			 }
			 new LazilyLoadedCtor(scope, topProperty, className, sealed);
		 }
		 Continuation.init(scope, sealed);
		 return scope;
	 }
	 public static ScriptableObject getLibraryScopeOrNull(Scriptable scope) {
		 ScriptableObject libScope;
		 libScope = (ScriptableObject)ScriptableObject. getTopScopeValue(scope, LIBRARY_SCOPE_KEY);
		 return libScope;
	 }
	 public static boolean isJSLineTerminator(int c) {
		 if ((c & 0xDFD0) != 0) {
			 return false;
		 }
		 return c == '\n' || c == '\r' || c == 0x2028 || c == 0x2029;
	 }
	 public static Boolean wrapBoolean(boolean b) {
		 return b ? Boolean.TRUE : Boolean.FALSE;
	 }
	 public static Integer wrapInt(int i) {
		 return new Integer(i);
	 }
	 public static Number wrapNumber(double x) {
		 if (x != x) {
			 return ScriptRuntime.NaNobj;
		 }
		 return new Double(x);
	 }
	 public static boolean toBoolean(Object val) {
		 for (;
		;
		) {
			 if (val instanceof Boolean) return ((Boolean) val).booleanValue();
			 if (val == null || val == Undefined.instance) return false;
			 if (val instanceof String) return ((String) val).length() != 0;
			 if (val instanceof Number) {
				 double d = ((Number) val).doubleValue();
				 return (d == d && d != 0.0);
			 }
			 if (val instanceof Scriptable) {
				 if (Context.getContext().isVersionECMA1()) {
					 return true;
				 }
				 val = ((Scriptable) val).getDefaultValue(BooleanClass);
				 if (val instanceof Scriptable) throw errorWithClassName(""msg.primitive.expected"", val);
				 continue;
			 }
			 warnAboutNonJSObject(val);
			 return true;
		 }
	 }
	 public static boolean toBoolean(Object[] args, int index) {
		 return (index < args.length) ? toBoolean(args[index]) : false;
	 }
	 public static double toNumber(Object val) {
		 for (;
		;
		) {
			 if (val instanceof Number) return ((Number) val).doubleValue();
			 if (val == null) return +0.0;
			 if (val == Undefined.instance) return NaN;
			 if (val instanceof String) return toNumber((String) val);
			 if (val instanceof Boolean) return ((Boolean) val).booleanValue() ? 1 : +0.0;
			 if (val instanceof Scriptable) {
				 val = ((Scriptable) val).getDefaultValue(NumberClass);
				 if (val instanceof Scriptable) throw errorWithClassName(""msg.primitive.expected"", val);
				 continue;
			 }
			 warnAboutNonJSObject(val);
			 return NaN;
		 }
	 }
	 public static double toNumber(Object[] args, int index) {
		 return (index < args.length) ? toNumber(args[index]) : NaN;
	 }
	 public static final double NaN = Double.longBitsToDouble(0x7ff8000000000000L);
	 public static final double negativeZero = Double.longBitsToDouble(0x8000000000000000L);
	 public static final Double NaNobj = new Double(NaN);
	 static double stringToNumber(String s, int start, int radix) {
		 char digitMax = '9';
		 char lowerCaseBound = 'a';
		 char upperCaseBound = 'A';
		 int len = s.length();
		 if (radix < 10) {
			 digitMax = (char) ('0' + radix - 1);
		 }
		 if (radix > 10) {
			 lowerCaseBound = (char) ('a' + radix - 10);
			 upperCaseBound = (char) ('A' + radix - 10);
		 }
		 int end;
		 double sum = 0.0;
		 for (end=start;
		 end < len;
		 end++) {
			 char c = s.charAt(end);
			 int newDigit;
			 if ('0' <= c && c <= digitMax) newDigit = c - '0';
			 else if ('a' <= c && c < lowerCaseBound) newDigit = c - 'a' + 10;
			 else if ('A' <= c && c < upperCaseBound) newDigit = c - 'A' + 10;
			 else break;
			 sum = sum*radix + newDigit;
		 }
		 if (start == end) {
			 return NaN;
		 }
		 if (sum >= 9007199254740992.0) {
			 if (radix == 10) {
				 try {
					 return Double.valueOf(s.substring(start, end)).doubleValue();
				 }
				 catch (NumberFormatException nfe) {
					 return NaN;
				 }
			 }
			 else if (radix == 2 || radix == 4 || radix == 8 || radix == 16 || radix == 32) {
				 int bitShiftInChar = 1;
				 int digit = 0;
				 final int SKIP_LEADING_ZEROS = 0;
				 final int FIRST_EXACT_53_BITS = 1;
				 final int AFTER_BIT_53 = 2;
				 final int ZEROS_AFTER_54 = 3;
				 final int MIXED_AFTER_54 = 4;
				 int state = SKIP_LEADING_ZEROS;
				 int exactBitsLimit = 53;
				 double factor = 0.0;
				 boolean bit53 = false;
				 boolean bit54 = false;
				 for (;
				;
				) {
					 if (bitShiftInChar == 1) {
						 if (start == end) break;
						 digit = s.charAt(start++);
						 if ('0' <= digit && digit <= '9') digit -= '0';
						 else if ('a' <= digit && digit <= 'z') digit -= 'a' - 10;
						 else digit -= 'A' - 10;
						 bitShiftInChar = radix;
					 }
					 bitShiftInChar >>= 1;
					 boolean bit = (digit & bitShiftInChar) != 0;
					 switch (state) {
						 case SKIP_LEADING_ZEROS: if (bit) {
							 --exactBitsLimit;
							 sum = 1.0;
							 state = FIRST_EXACT_53_BITS;
						 }
						 break;
						 case FIRST_EXACT_53_BITS: sum *= 2.0;
						 if (bit) sum += 1.0;
						 --exactBitsLimit;
						 if (exactBitsLimit == 0) {
							 bit53 = bit;
							 state = AFTER_BIT_53;
						 }
						 break;
						 case AFTER_BIT_53: bit54 = bit;
						 factor = 2.0;
						 state = ZEROS_AFTER_54;
						 break;
						 case ZEROS_AFTER_54: if (bit) {
							 state = MIXED_AFTER_54;
						 }
						 case MIXED_AFTER_54: factor *= 2;
						 break;
					 }
				 }
				 switch (state) {
					 case SKIP_LEADING_ZEROS: sum = 0.0;
					 break;
					 case FIRST_EXACT_53_BITS: case AFTER_BIT_53: break;
					 case ZEROS_AFTER_54: if (bit54 & bit53) sum += 1.0;
					 sum *= factor;
					 break;
					 case MIXED_AFTER_54: if (bit54) sum += 1.0;
					 sum *= factor;
					 break;
				 }
			 }
		 }
		 return sum;
	 }
	 public static double toNumber(String s) {
		 int len = s.length();
		 int start = 0;
		 char startChar;
		 for (;
		;
		) {
			 if (start == len) {
				 return +0.0;
			 }
			 startChar = s.charAt(start);
			 if (!Character.isWhitespace(startChar)) break;
			 start++;
		 }
		 if (startChar == '0') {
			 if (start + 2 < len) {
				 int c1 = s.charAt(start + 1);
				 if (c1 == 'x' || c1 == 'X') {
					 return stringToNumber(s, start + 2, 16);
				 }
			 }
		 }
		 else if (startChar == '+' || startChar == '-') {
			 if (start + 3 < len && s.charAt(start + 1) == '0') {
				 int c2 = s.charAt(start + 2);
				 if (c2 == 'x' || c2 == 'X') {
					 double val = stringToNumber(s, start + 3, 16);
					 return startChar == '-' ? -val : val;
				 }
			 }
		 }
		 int end = len - 1;
		 char endChar;
		 while (Character.isWhitespace(endChar = s.charAt(end))) end--;
		 if (endChar == 'y') {
			 if (startChar == '+' || startChar == '-') start++;
			 if (start + 7 == end && s.regionMatches(start, ""Infinity"", 0, 8)) return startChar == '-' ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
			 return NaN;
		 }
		 String sub = s.substring(start, end+1);
		 if (MSJVM_BUG_WORKAROUNDS) {
			 for (int i=sub.length()-1;
			 i >= 0;
			 i--) {
				 char c = sub.charAt(i);
				 if (('0' <= c && c <= '9') || c == '.' || c == 'e' || c == 'E' || c == '+' || c == '-') continue;
				 return NaN;
			 }
		 }
		 try {
			 return Double.valueOf(sub).doubleValue();
		 }
		 catch (NumberFormatException ex) {
			 return NaN;
		 }
	 }
	 public static Object[] padArguments(Object[] args, int count) {
		 if (count < args.length) return args;
		 int i;
		 Object[] result = new Object[count];
		 for (i = 0;
		 i < args.length;
		 i++) {
			 result[i] = args[i];
		 }
		 for (;
		 i < count;
		 i++) {
			 result[i] = Undefined.instance;
		 }
		 return result;
	 }
	 private final static boolean MSJVM_BUG_WORKAROUNDS = true;
	 public static String escapeString(String s) {
		 return escapeString(s, '""');
	 }
	 public static String escapeString(String s, char escapeQuote) {
		 if (!(escapeQuote == '""' || escapeQuote == '\'')) Kit.codeBug();
		 StringBuffer sb = null;
		 for(int i = 0, L = s.length();
		 i != L;
		 ++i) {
			 int c = s.charAt(i);
			 if (' ' <= c && c <= '~' && c != escapeQuote && c != '\\') {
				 if (sb != null) {
					 sb.append((char)c);
				 }
				 continue;
			 }
			 if (sb == null) {
				 sb = new StringBuffer(L + 3);
				 sb.append(s);
				 sb.setLength(i);
			 }
			 int escape = -1;
			 switch (c) {
				 case '\b': escape = 'b';
				 break;
				 case '\f': escape = 'f';
				 break;
				 case '\n': escape = 'n';
				 break;
				 case '\r': escape = 'r';
				 break;
				 case '\t': escape = 't';
				 break;
				 case 0xb: escape = 'v';
				 break;
				 case ' ': escape = ' ';
				 break;
				 case '\\': escape = '\\';
				 break;
			 }
			 if (escape >= 0) {
				 sb.append('\\');
				 sb.append((char)escape);
			 }
			 else if (c == escapeQuote) {
				 sb.append('\\');
				 sb.append(escapeQuote);
			 }
			 else {
				 int hexSize;
				 if (c < 256) {
					 sb.append(""\\x"");
					 hexSize = 2;
				 }
				 else {
					 sb.append(""\\u"");
					 hexSize = 4;
				 }
				 for (int shift = (hexSize - 1) * 4;
				 shift >= 0;
				 shift -= 4) {
					 int digit = 0xf & (c >> shift);
					 int hc = (digit < 10) ? '0' + digit : 'a' - 10 + digit;
					 sb.append((char)hc);
				 }
			 }
		 }
		 return (sb == null) ? s : sb.toString();
	 }
	 static boolean isValidIdentifierName(String s) {
		 int L = s.length();
		 if (L == 0) return false;
		 if (!Character.isJavaIdentifierStart(s.charAt(0))) return false;
		 for (int i = 1;
		 i != L;
		 ++i) {
			 if (!Character.isJavaIdentifierPart(s.charAt(i))) return false;
		 }
		 return !TokenStream.isKeyword(s);
	 }
	 public static String toString(Object val) {
		 for (;
		;
		) {
			 if (val == null) {
				 return ""null"";
			 }
			 if (val == Undefined.instance) {
				 return ""undefined"";
			 }
			 if (val instanceof String) {
				 return (String)val;
			 }
			 if (val instanceof Number) {
				 return numberToString(((Number)val).doubleValue(), 10);
			 }
			 if (val instanceof Scriptable) {
				 val = ((Scriptable) val).getDefaultValue(StringClass);
				 if (val instanceof Scriptable) {
					 throw errorWithClassName(""msg.primitive.expected"", val);
				 }
				 continue;
			 }
			 return val.toString();
		 }
	 }
	 static String defaultObjectToString(Scriptable obj) {
		 return ""[object "" + obj.getClassName() + ']';
	 }
	 public static String toString(Object[] args, int index) {
		 return (index < args.length) ? toString(args[index]) : ""undefined"";
	 }
	 public static String toString(double val) {
		 return numberToString(val, 10);
	 }
	 public static String numberToString(double d, int base) {
		 if (d != d) return ""NaN"";
		 if (d == Double.POSITIVE_INFINITY) return ""Infinity"";
		 if (d == Double.NEGATIVE_INFINITY) return ""-Infinity"";
		 if (d == 0.0) return ""0"";
		 if ((base < 2) || (base > 36)) {
			 throw Context.reportRuntimeError1( ""msg.bad.radix"", Integer.toString(base));
		 }
		 if (base != 10) {
			 return DToA.JS_dtobasestr(base, d);
		 }
		 else {
			 StringBuffer result = new StringBuffer();
			 DToA.JS_dtostr(result, DToA.DTOSTR_STANDARD, 0, d);
			 return result.toString();
		 }
	 }
	 static String uneval(Context cx, Scriptable scope, Object value) {
		 if (value == null) {
			 return ""null"";
		 }
		 if (value == Undefined.instance) {
			 return ""undefined"";
		 }
		 if (value instanceof String) {
			 String escaped = escapeString((String)value);
			 StringBuffer sb = new StringBuffer(escaped.length() + 2);
			 sb.append('\""');
			 sb.append(escaped);
			 sb.append('\""');
			 return sb.toString();
		 }
		 if (value instanceof Number) {
			 double d = ((Number)value).doubleValue();
			 if (d == 0 && 1 / d < 0) {
				 return ""-0"";
			 }
			 return toString(d);
		 }
		 if (value instanceof Boolean) {
			 return toString(value);
		 }
		 if (value instanceof Scriptable) {
			 Scriptable obj = (Scriptable)value;
			 Object v = ScriptableObject.getProperty(obj, ""toSource"");
			 if (v instanceof Function) {
				 Function f = (Function)v;
				 return toString(f.call(cx, scope, obj, emptyArgs));
			 }
			 return toString(value);
		 }
		 warnAboutNonJSObject(value);
		 return value.toString();
	 }
	 static String defaultObjectToSource(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 boolean toplevel, iterating;
		 if (cx.iterating == null) {
			 toplevel = true;
			 iterating = false;
			 cx.iterating = new ObjToIntMap(31);
		 }
		 else {
			 toplevel = false;
			 iterating = cx.iterating.has(thisObj);
		 }
		 StringBuffer result = new StringBuffer(128);
		 if (toplevel) {
			 result.append(""("");
		 }
		 result.append('{
			');
			 try {
				 if (!iterating) {
					 cx.iterating.intern(thisObj);
					 Object[] ids = thisObj.getIds();
					 for(int i=0;
					 i < ids.length;
					 i++) {
						 if (i > 0) result.append("", "");
						 Object id = ids[i];
						 Object value;
						 if (id instanceof Integer) {
							 int intId = ((Integer)id).intValue();
							 value = thisObj.get(intId, thisObj);
							 result.append(intId);
						 }
						 else {
							 String strId = (String)id;
							 value = thisObj.get(strId, thisObj);
							 if (ScriptRuntime.isValidIdentifierName(strId)) {
								 result.append(strId);
							 }
							 else {
								 result.append('\'');
								 result.append( ScriptRuntime.escapeString(strId, '\''));
								 result.append('\'');
							 }
						 }
						 result.append(':');
						 result.append(ScriptRuntime.uneval(cx, scope, value));
					 }
				 }
			 }
			 finally {
				 if (toplevel) {
					 cx.iterating = null;
				 }
			 }
		 result.append('}
		');
		 if (toplevel) {
			 result.append(')');
		 }
		 return result.toString();
	 }
	 public static Scriptable toObject(Scriptable scope, Object val) {
		 if (val instanceof Scriptable) {
			 return (Scriptable)val;
		 }
		 return toObject(Context.getContext(), scope, val);
	 }
	 public static Scriptable toObjectOrNull(Context cx, Object obj) {
		 if (obj instanceof Scriptable) {
			 return (Scriptable)obj;
		 }
		 else if (obj != null && obj != Undefined.instance) {
			 return toObject(cx, getTopCallScope(cx), obj);
		 }
		 return null;
	 }
	 public static Scriptable toObject(Scriptable scope, Object val, Class staticClass) {
		 if (val instanceof Scriptable) {
			 return (Scriptable)val;
		 }
		 return toObject(Context.getContext(), scope, val);
	 }
	 public static Scriptable toObject(Context cx, Scriptable scope, Object val) {
		 if (val instanceof Scriptable) {
			 return (Scriptable) val;
		 }
		 if (val == null) {
			 throw typeError0(""msg.null.to.object"");
		 }
		 if (val == Undefined.instance) {
			 throw typeError0(""msg.undef.to.object"");
		 }
		 String className = val instanceof String ? ""String"" : val instanceof Number ? ""Number"" : val instanceof Boolean ? ""Boolean"" : null;
		 if (className != null) {
			 Object[] args = {
			 val }
			;
			 scope = ScriptableObject.getTopLevelScope(scope);
			 return newObject(cx, scope, className, args);
		 }
		 Object wrapped = cx.getWrapFactory().wrap(cx, scope, val, null);
		 if (wrapped instanceof Scriptable) return (Scriptable) wrapped;
		 throw errorWithClassName(""msg.invalid.type"", val);
	 }
	 public static Scriptable toObject(Context cx, Scriptable scope, Object val, Class staticClass) {
		 return toObject(cx, scope, val);
	 }
	 public static Object call(Context cx, Object fun, Object thisArg, Object[] args, Scriptable scope) {
		 if (!(fun instanceof Function)) {
			 throw notFunctionError(toString(fun));
		 }
		 Function function = (Function)fun;
		 Scriptable thisObj = toObjectOrNull(cx, thisArg);
		 if (thisObj == null) {
			 throw undefCallError(thisObj, ""function"");
		 }
		 return function.call(cx, scope, thisObj, args);
	 }
	 public static Scriptable newObject(Context cx, Scriptable scope, String constructorName, Object[] args) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 Function ctor = getExistingCtor(cx, scope, constructorName);
		 if (args == null) {
			 args = ScriptRuntime.emptyArgs;
		 }
		 return ctor.construct(cx, scope, args);
	 }
	 public static double toInteger(Object val) {
		 return toInteger(toNumber(val));
	 }
	 public static double toInteger(double d) {
		 if (d != d) return +0.0;
		 if (d == 0.0 || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) return d;
		 if (d > 0.0) return Math.floor(d);
		 else return Math.ceil(d);
	 }
	 public static double toInteger(Object[] args, int index) {
		 return (index < args.length) ? toInteger(args[index]) : +0.0;
	 }
	 public static int toInt32(Object val) {
		 if (val instanceof Integer) return ((Integer)val).intValue();
		 return toInt32(toNumber(val));
	 }
	 public static int toInt32(Object[] args, int index) {
		 return (index < args.length) ? toInt32(args[index]) : 0;
	 }
	 public static int toInt32(double d) {
		 int id = (int)d;
		 if (id == d) {
			 return id;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 double two32 = 4294967296.0;
		 d = Math.IEEEremainder(d, two32);
		 long l = (long)d;
		 return (int)l;
	 }
	 public static long toUint32(double d) {
		 long l = (long)d;
		 if (l == d) {
			 return l & 0xffffffffL;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 double two32 = 4294967296.0;
		 l = (long)Math.IEEEremainder(d, two32);
		 return l & 0xffffffffL;
	 }
	 public static long toUint32(Object val) {
		 return toUint32(toNumber(val));
	 }
	 public static char toUint16(Object val) {
		 double d = toNumber(val);
		 int i = (int)d;
		 if (i == d) {
			 return (char)i;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 int int16 = 0x10000;
		 i = (int)Math.IEEEremainder(d, int16);
		 return (char)i;
	 }
	 private static final String DEFAULT_NS_TAG = ""__default_namespace__"";
	 public static Object setDefaultNamespace(Object namespace, Context cx) {
		 Scriptable scope = cx.currentActivationCall;
		 if (scope == null) {
			 scope = getTopCallScope(cx);
		 }
		 XMLLib xmlLib = currentXMLLib(cx);
		 Object ns = xmlLib.toDefaultXmlNamespace(cx, namespace);
		 if (!scope.has(DEFAULT_NS_TAG, scope)) {
			 ScriptableObject.defineProperty(scope, DEFAULT_NS_TAG, ns, ScriptableObject.PERMANENT | ScriptableObject.DONTENUM);
		 }
		 else {
			 scope.put(DEFAULT_NS_TAG, scope, ns);
		 }
		 return Undefined.instance;
	 }
	 public static Object searchDefaultNamespace(Context cx) {
		 Scriptable scope = cx.currentActivationCall;
		 if (scope == null) {
			 scope = getTopCallScope(cx);
		 }
		 Object nsObject;
		 for (;
		;
		) {
			 Scriptable parent = scope.getParentScope();
			 if (parent == null) {
				 nsObject = ScriptableObject.getProperty(scope, DEFAULT_NS_TAG);
				 if (nsObject == Scriptable.NOT_FOUND) {
					 return null;
				 }
				 break;
			 }
			 nsObject = scope.get(DEFAULT_NS_TAG, scope);
			 if (nsObject != Scriptable.NOT_FOUND) {
				 break;
			 }
			 scope = parent;
		 }
		 return nsObject;
	 }
	 public static Object getTopLevelProp(Scriptable scope, String id) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 return ScriptableObject.getProperty(scope, id);
	 }
	 static Function getExistingCtor(Context cx, Scriptable scope, String constructorName) {
		 Object ctorVal = ScriptableObject.getProperty(scope, constructorName);
		 if (ctorVal instanceof Function) {
			 return (Function)ctorVal;
		 }
		 if (ctorVal == Scriptable.NOT_FOUND) {
			 throw Context.reportRuntimeError1( ""msg.ctor.not.found"", constructorName);
		 }
		 else {
			 throw Context.reportRuntimeError1( ""msg.not.ctor"", constructorName);
		 }
	 }
	 private static long indexFromString(String str) {
		 final int MAX_VALUE_LENGTH = 10;
		 int len = str.length();
		 if (len > 0) {
			 int i = 0;
			 boolean negate = false;
			 int c = str.charAt(0);
			 if (c == '-') {
				 if (len > 1) {
					 c = str.charAt(1);
					 i = 1;
					 negate = true;
				 }
			 }
			 c -= '0';
			 if (0 <= c && c <= 9 && len <= (negate ? MAX_VALUE_LENGTH + 1 : MAX_VALUE_LENGTH)) {
				 int index = -c;
				 int oldIndex = 0;
				 i++;
				 if (index != 0) {
					 while (i != len && 0 <= (c = str.charAt(i) - '0') && c <= 9) {
						 oldIndex = index;
						 index = 10 * index - c;
						 i++;
					 }
				 }
				 if (i == len && (oldIndex > (Integer.MIN_VALUE / 10) || (oldIndex == (Integer.MIN_VALUE / 10) && c <= (negate ? -(Integer.MIN_VALUE % 10) : (Integer.MAX_VALUE % 10))))) {
					 return 0xFFFFFFFFL & (negate ? index : -index);
				 }
			 }
		 }
		 return -1L;
	 }
	 public static long testUint32String(String str) {
		 final int MAX_VALUE_LENGTH = 10;
		 int len = str.length();
		 if (1 <= len && len <= MAX_VALUE_LENGTH) {
			 int c = str.charAt(0);
			 c -= '0';
			 if (c == 0) {
				 return (len == 1) ? 0L : -1L;
			 }
			 if (1 <= c && c <= 9) {
				 long v = c;
				 for (int i = 1;
				 i != len;
				 ++i) {
					 c = str.charAt(i) - '0';
					 if (!(0 <= c && c <= 9)) {
						 return -1;
					 }
					 v = 10 * v + c;
				 }
				 if ((v >>> 32) == 0) {
					 return v;
				 }
			 }
		 }
		 return -1;
	 }
	 static Object getIndexObject(String s) {
		 long indexTest = indexFromString(s);
		 if (indexTest >= 0) {
			 return new Integer((int)indexTest);
		 }
		 return s;
	 }
	 static Object getIndexObject(double d) {
		 int i = (int)d;
		 if ((double)i == d) {
			 return new Integer((int)i);
		 }
		 return toString(d);
	 }
	 static String toStringIdOrIndex(Context cx, Object id) {
		 if (id instanceof Number) {
			 double d = ((Number)id).doubleValue();
			 int index = (int)d;
			 if (((double)index) == d) {
				 storeIndexResult(cx, index);
				 return null;
			 }
			 return toString(id);
		 }
		 else {
			 String s;
			 if (id instanceof String) {
				 s = (String)id;
			 }
			 else {
				 s = toString(id);
			 }
			 long indexTest = indexFromString(s);
			 if (indexTest >= 0) {
				 storeIndexResult(cx, (int)indexTest);
				 return null;
			 }
			 return s;
		 }
	 }
	 public static Object getObjectElem(Object obj, Object elem, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, elem);
		 }
		 return getObjectElem(sobj, elem, cx);
	 }
	 public static Object getObjectElem(Scriptable obj, Object elem, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, elem);
		 }
		 Object result;
		 String s = toStringIdOrIndex(cx, elem);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 result = ScriptableObject.getProperty(obj, index);
		 }
		 else {
			 result = ScriptableObject.getProperty(obj, s);
		 }
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object getObjectProp(Object obj, String property, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, property);
		 }
		 return getObjectProp(sobj, property, cx);
	 }
	 public static Object getObjectProp(Scriptable obj, String property, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, property);
		 }
		 Object result = ScriptableObject.getProperty(obj, property);
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object getObjectIndex(Object obj, double dblIndex, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, toString(dblIndex));
		 }
		 int index = (int)dblIndex;
		 if ((double)index == dblIndex) {
			 return getObjectIndex(sobj, index, cx);
		 }
		 else {
			 String s = toString(dblIndex);
			 return getObjectProp(sobj, s, cx);
		 }
	 }
	 public static Object getObjectIndex(Scriptable obj, int index, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, new Integer(index));
		 }
		 Object result = ScriptableObject.getProperty(obj, index);
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object setObjectElem(Object obj, Object elem, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, elem, value);
		 }
		 return setObjectElem(sobj, elem, value, cx);
	 }
	 public static Object setObjectElem(Scriptable obj, Object elem, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, elem, value);
			 return value;
		 }
		 String s = toStringIdOrIndex(cx, elem);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 ScriptableObject.putProperty(obj, index, value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, s, value);
		 }
		 return value;
	 }
	 public static Object setObjectProp(Object obj, String property, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, property, value);
		 }
		 return setObjectProp(sobj, property, value, cx);
	 }
	 public static Object setObjectProp(Scriptable obj, String property, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, property, value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, property, value);
		 }
		 return value;
	 }
	 public static Object setObjectIndex(Object obj, double dblIndex, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, String.valueOf(dblIndex), value);
		 }
		 int index = (int)dblIndex;
		 if ((double)index == dblIndex) {
			 return setObjectIndex(sobj, index, value, cx);
		 }
		 else {
			 String s = toString(dblIndex);
			 return setObjectProp(sobj, s, value, cx);
		 }
	 }
	 public static Object setObjectIndex(Scriptable obj, int index, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, new Integer(index), value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, index, value);
		 }
		 return value;
	 }
	 public static boolean deleteObjectElem(Scriptable target, Object elem, Context cx) {
		 boolean result;
		 if (target instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)target;
			 result = xmlObject.ecmaDelete(cx, elem);
		 }
		 else {
			 String s = toStringIdOrIndex(cx, elem);
			 if (s == null) {
				 int index = lastIndexResult(cx);
				 result = ScriptableObject.deleteProperty(target, index);
			 }
			 else {
				 result = ScriptableObject.deleteProperty(target, s);
			 }
		 }
		 return result;
	 }
	 public static boolean hasObjectElem(Scriptable target, Object elem, Context cx) {
		 boolean result;
		 if (target instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)target;
			 result = xmlObject.ecmaHas(cx, elem);
		 }
		 else {
			 String s = toStringIdOrIndex(cx, elem);
			 if (s == null) {
				 int index = lastIndexResult(cx);
				 result = ScriptableObject.hasProperty(target, index);
			 }
			 else {
				 result = ScriptableObject.hasProperty(target, s);
			 }
		 }
		 return result;
	 }
	 public static Object refGet(Ref ref, Context cx) {
		 return ref.get(cx);
	 }
	 public static Object refSet(Ref ref, Object value, Context cx) {
		 return ref.set(cx, value);
	 }
	 public static Object refDel(Ref ref, Context cx) {
		 return wrapBoolean(ref.delete(cx));
	 }
	 static boolean isSpecialProperty(String s) {
		 return s.equals(""__proto__"") || s.equals(""__parent__"");
	 }
	 public static Ref specialRef(Object obj, String specialProperty, Context cx) {
		 return SpecialRef.createSpecial(cx, obj, specialProperty);
	 }
	 public static Object delete(Object obj, Object id, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 String idStr = (id == null) ? ""null"" : id.toString();
			 throw typeError2(""msg.undef.prop.delete"", toString(obj), idStr);
		 }
		 boolean result = deleteObjectElem(sobj, id, cx);
		 return wrapBoolean(result);
	 }
	 public static Object name(Context cx, Scriptable scope, String name) {
		 Scriptable parent = scope.getParentScope();
		 if (parent == null) {
			 Object result = topScopeName(cx, scope, name);
			 if (result == Scriptable.NOT_FOUND) {
				 throw notFoundError(scope, name);
			 }
			 return result;
		 }
		 return nameOrFunction(cx, scope, parent, name, false);
	 }
	 private static Object nameOrFunction(Context cx, Scriptable scope, Scriptable parentScope, String name, boolean asFunctionCall) {
		 Object result;
		 Scriptable thisObj = scope;
		 XMLObject firstXMLObject = null;
		 for (;
		;
		) {
			 if (scope instanceof NativeWith) {
				 Scriptable withObj = scope.getPrototype();
				 if (withObj instanceof XMLObject) {
					 XMLObject xmlObj = (XMLObject)withObj;
					 if (xmlObj.ecmaHas(cx, name)) {
						 thisObj = xmlObj;
						 result = xmlObj.ecmaGet(cx, name);
						 break;
					 }
					 if (firstXMLObject == null) {
						 firstXMLObject = xmlObj;
					 }
				 }
				 else {
					 result = ScriptableObject.getProperty(withObj, name);
					 if (result != Scriptable.NOT_FOUND) {
						 thisObj = withObj;
						 break;
					 }
				 }
			 }
			 else if (scope instanceof NativeCall) {
				 result = scope.get(name, scope);
				 if (result != Scriptable.NOT_FOUND) {
					 if (asFunctionCall) {
						 thisObj = ScriptableObject. getTopLevelScope(parentScope);
					 }
					 break;
				 }
			 }
			 else {
				 result = ScriptableObject.getProperty(scope, name);
				 if (result != Scriptable.NOT_FOUND) {
					 thisObj = scope;
					 break;
				 }
			 }
			 scope = parentScope;
			 parentScope = parentScope.getParentScope();
			 if (parentScope == null) {
				 result = topScopeName(cx, scope, name);
				 if (result == Scriptable.NOT_FOUND) {
					 if (firstXMLObject == null || asFunctionCall) {
						 throw notFoundError(scope, name);
					 }
					 result = firstXMLObject.ecmaGet(cx, name);
				 }
				 thisObj = scope;
				 break;
			 }
		 }
		 if (asFunctionCall) {
			 if (!(result instanceof Callable)) {
				 throw notFunctionError(result, name);
			 }
			 storeScriptable(cx, thisObj);
		 }
		 return result;
	 }
	 private static Object topScopeName(Context cx, Scriptable scope, String name) {
		 if (cx.useDynamicScope) {
			 scope = checkDynamicScope(cx.topCallScope, scope);
		 }
		 return ScriptableObject.getProperty(scope, name);
	 }
	 public static Scriptable bind(Context cx, Scriptable scope, String id) {
		 Scriptable firstXMLObject = null;
		 Scriptable parent = scope.getParentScope();
		 childScopesChecks: if (parent != null) {
			 while (scope instanceof NativeWith) {
				 Scriptable withObj = scope.getPrototype();
				 if (withObj instanceof XMLObject) {
					 XMLObject xmlObject = (XMLObject)withObj;
					 if (xmlObject.ecmaHas(cx, id)) {
						 return xmlObject;
					 }
					 if (firstXMLObject == null) {
						 firstXMLObject = xmlObject;
					 }
				 }
				 else {
					 if (ScriptableObject.hasProperty(withObj, id)) {
						 return withObj;
					 }
				 }
				 scope = parent;
				 parent = parent.getParentScope();
				 if (parent == null) {
					 break childScopesChecks;
				 }
			 }
			 for (;
			;
			) {
				 if (ScriptableObject.hasProperty(scope, id)) {
					 return scope;
				 }
				 scope = parent;
				 parent = parent.getParentScope();
				 if (parent == null) {
					 break childScopesChecks;
				 }
			 }
		 }
		 if (cx.useDynamicScope) {
			 scope = checkDynamicScope(cx.topCallScope, scope);
		 }
		 if (ScriptableObject.hasProperty(scope, id)) {
			 return scope;
		 }
		 return firstXMLObject;
	 }
	 public static Object setName(Scriptable bound, Object value, Context cx, Scriptable scope, String id) {
		 if (bound != null) {
			 if (bound instanceof XMLObject) {
				 XMLObject xmlObject = (XMLObject)bound;
				 xmlObject.ecmaPut(cx, id, value);
			 }
			 else {
				 ScriptableObject.putProperty(bound, id, value);
			 }
		 }
		 else {
			 if (cx.hasFeature(Context.FEATURE_STRICT_VARS)) {
				 throw Context.reportRuntimeError1(""msg.assn.create.strict"", id);
			 }
			 bound = ScriptableObject.getTopLevelScope(scope);
			 if (cx.useDynamicScope) {
				 bound = checkDynamicScope(cx.topCallScope, bound);
			 }
			 bound.put(id, bound, value);
		 }
		 return value;
	 }
	 private static class IdEnumeration {
		 Scriptable obj;
		 Object[] ids;
		 int index;
		 ObjToIntMap used;
		 String currentId;
		 boolean enumValues;
	 }
	 public static Object enumInit(Object value, Context cx, boolean enumValues) {
		 IdEnumeration x = new IdEnumeration();
		 x.obj = toObjectOrNull(cx, value);
		 if (x.obj != null) {
			 x.enumValues = enumValues;
			 enumChangeObject(x);
		 }
		 return x;
	 }
	 public static Boolean enumNext(Object enumObj) {
		 boolean result;
		 IdEnumeration x = (IdEnumeration)enumObj;
		 for (;
		;
		) {
			 if (x.obj == null) {
				 result = false;
				 break;
			 }
			 if (x.index == x.ids.length) {
				 x.obj = x.obj.getPrototype();
				 enumChangeObject(x);
				 continue;
			 }
			 Object id = x.ids[x.index++];
			 if (x.used != null && x.used.has(id)) {
				 continue;
			 }
			 if (id instanceof String) {
				 String strId = (String)id;
				 if (!x.obj.has(strId, x.obj)) continue;
				 x.currentId = strId;
			 }
			 else {
				 int intId = ((Number)id).intValue();
				 if (!x.obj.has(intId, x.obj)) continue;
				 x.currentId = String.valueOf(intId);
			 }
			 result = true;
			 break;
		 }
		 return wrapBoolean(result);
	 }
	 public static Object enumId(Object enumObj, Context cx) {
		 IdEnumeration x = (IdEnumeration)enumObj;
		 if (!x.enumValues) return x.currentId;
		 Object result;
		 String s = toStringIdOrIndex(cx, x.currentId);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 result = x.obj.get(index, x.obj);
		 }
		 else {
			 result = x.obj.get(s, x.obj);
		 }
		 return result;
	 }
	 private static void enumChangeObject(IdEnumeration x) {
		 Object[] ids = null;
		 while (x.obj != null) {
			 ids = x.obj.getIds();
			 if (ids.length != 0) {
				 break;
			 }
			 x.obj = x.obj.getPrototype();
		 }
		 if (x.obj != null && x.ids != null) {
			 Object[] previous = x.ids;
			 int L = previous.length;
			 if (x.used == null) {
				 x.used = new ObjToIntMap(L);
			 }
			 for (int i = 0;
			 i != L;
			 ++i) {
				 x.used.intern(previous[i]);
			 }
		 }
		 x.ids = ids;
		 x.index = 0;
	 }
	 public static Callable getNameFunctionAndThis(String name, Context cx, Scriptable scope) {
		 Scriptable parent = scope.getParentScope();
		 if (parent == null) {
			 Object result = topScopeName(cx, scope, name);
			 if (!(result instanceof Callable)) {
				 if (result == Scriptable.NOT_FOUND) {
					 throw notFoundError(scope, name);
				 }
				 else {
					 throw notFunctionError(result, name);
				 }
			 }
			 Scriptable thisObj = scope;
			 storeScriptable(cx, thisObj);
			 return (Callable)result;
		 }
		 return (Callable)nameOrFunction(cx, scope, parent, name, true);
	 }
	 public static Callable getElemFunctionAndThis(Object obj, Object elem, Context cx) {
		 String s = toStringIdOrIndex(cx, elem);
		 if (s != null) {
			 return getPropFunctionAndThis(obj, s, cx);
		 }
		 int index = lastIndexResult(cx);
		 Scriptable thisObj = toObjectOrNull(cx, obj);
		 if (thisObj == null) {
			 throw undefCallError(obj, String.valueOf(index));
		 }
		 Object value;
		 for (;
		;
		) {
			 value = ScriptableObject.getProperty(thisObj, index);
			 if (value != Scriptable.NOT_FOUND) {
				 break;
			 }
			 if (!(thisObj instanceof XMLObject)) {
				 break;
			 }
			 XMLObject xmlObject = (XMLObject)thisObj;
			 Scriptable extra = xmlObject.getExtraMethodSource(cx);
			 if (extra == null) {
				 break;
			 }
			 thisObj = extra;
		 }
		 if (!(value instanceof Callable)) {
			 throw notFunctionError(value, elem);
		 }
		 storeScriptable(cx, thisObj);
		 return (Callable)value;
	 }
	 public static Callable getPropFunctionAndThis(Object obj, String property, Context cx) {
		 Scriptable thisObj = toObjectOrNull(cx, obj);
		 if (thisObj == null) {
			 throw undefCallError(obj, property);
		 }
		 Object value;
		 for (;
		;
		) {
			 value = ScriptableObject.getProperty(thisObj, property);
			 if (value != Scriptable.NOT_FOUND) {
				 break;
			 }
			 if (!(thisObj instanceof XMLObject)) {
				 break;
			 }
			 XMLObject xmlObject = (XMLObject)thisObj;
			 Scriptable extra = xmlObject.getExtraMethodSource(cx);
			 if (extra == null) {
				 break;
			 }
			 thisObj = extra;
		 }
		 if (!(value instanceof Callable)) {
			 throw notFunctionError(value, property);
		 }
		 storeScriptable(cx, thisObj);
		 return (Callable)value;
	 }
	 public static Callable getValueFunctionAndThis(Object value, Context cx) {
		 if (!(value instanceof Callable)) {
			 throw notFunctionError(value);
		 }
		 Callable f = (Callable)value;
		 Scriptable thisObj;
		 if (f instanceof Scriptable) {
			 thisObj = ((Scriptable)f).getParentScope();
		 }
		 else {
			 if (cx.topCallScope == null) throw new IllegalStateException();
			 thisObj = cx.topCallScope;
		 }
		 if (thisObj.getParentScope() != null) {
			 if (thisObj instanceof NativeWith) {
			 }
			 else if (thisObj instanceof NativeCall) {
				 thisObj = ScriptableObject.getTopLevelScope(thisObj);
			 }
		 }
		 storeScriptable(cx, thisObj);
		 return f;
	 }
	 public static Ref callRef(Callable function, Scriptable thisObj, Object[] args, Context cx) {
		 if (function instanceof RefCallable) {
			 RefCallable rfunction = (RefCallable)function;
			 Ref ref = rfunction.refCall(cx, thisObj, args);
			 if (ref == null) {
				 throw new IllegalStateException(rfunction.getClass().getName()+"".refCall() returned null"");
			 }
			 return ref;
		 }
		 String msg = getMessage1(""msg.no.ref.from.function"", toString(function));
		 throw constructError(""ReferenceError"", msg);
	 }
	 public static Scriptable newObject(Object fun, Context cx, Scriptable scope, Object[] args) {
		 if (!(fun instanceof Function)) {
			 throw notFunctionError(fun);
		 }
		 Function function = (Function)fun;
		 return function.construct(cx, scope, args);
	 }
	 public static Object callSpecial(Context cx, Callable fun, Scriptable thisObj, Object[] args, Scriptable scope, Scriptable callerThis, int callType, String filename, int lineNumber) {
		 if (callType == Node.SPECIALCALL_EVAL) {
			 if (NativeGlobal.isEvalFunction(fun)) {
				 return evalSpecial(cx, scope, callerThis, args, filename, lineNumber);
			 }
		 }
		 else if (callType == Node.SPECIALCALL_WITH) {
			 if (NativeWith.isWithFunction(fun)) {
				 throw Context.reportRuntimeError1(""msg.only.from.new"", ""With"");
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
		 return fun.call(cx, scope, thisObj, args);
	 }
	 public static Object newSpecial(Context cx, Object fun, Object[] args, Scriptable scope, int callType) {
		 if (callType == Node.SPECIALCALL_EVAL) {
			 if (NativeGlobal.isEvalFunction(fun)) {
				 throw typeError1(""msg.not.ctor"", ""eval"");
			 }
		 }
		 else if (callType == Node.SPECIALCALL_WITH) {
			 if (NativeWith.isWithFunction(fun)) {
				 return NativeWith.newWithSpecial(cx, scope, args);
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
		 return newObject(fun, cx, scope, args);
	 }
	 public static Object applyOrCall(boolean isApply, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 int L = args.length;
		 Callable function;
		 if (thisObj instanceof Callable) {
			 function = (Callable)thisObj;
		 }
		 else {
			 Object value = thisObj.getDefaultValue(ScriptRuntime.FunctionClass);
			 if (!(value instanceof Callable)) {
				 throw ScriptRuntime.notFunctionError(value, thisObj);
			 }
			 function = (Callable)value;
		 }
		 Scriptable callThis = null;
		 if (L != 0) {
			 callThis = toObjectOrNull(cx, args[0]);
		 }
		 if (callThis == null) {
			 callThis = getTopCallScope(cx);
		 }
		 Object[] callArgs;
		 if (isApply) {
			 if (L <= 1) {
				 callArgs = ScriptRuntime.emptyArgs;
			 }
			 else {
				 Object arg1 = args[1];
				 if (arg1 == null || arg1 == Undefined.instance) {
					 callArgs = ScriptRuntime.emptyArgs;
				 }
				 else if (arg1 instanceof NativeArray || arg1 instanceof Arguments) {
					 callArgs = cx.getElements((Scriptable) arg1);
				 }
				 else {
					 throw ScriptRuntime.typeError0(""msg.arg.isnt.array"");
				 }
			 }
		 }
		 else {
			 if (L <= 1) {
				 callArgs = ScriptRuntime.emptyArgs;
			 }
			 else {
				 callArgs = new Object[L - 1];
				 System.arraycopy(args, 1, callArgs, 0, L - 1);
			 }
		 }
		 return function.call(cx, scope, callThis, callArgs);
	 }
	 public static Object evalSpecial(Context cx, Scriptable scope, Object thisArg, Object[] args, String filename, int lineNumber) {
		 if (args.length < 1) return Undefined.instance;
		 Object x = args[0];
		 if (!(x instanceof String)) {
			 if (cx.hasFeature(Context.FEATURE_STRICT_EVAL)) {
				 throw Context.reportRuntimeError0(""msg.eval.nonstring.strict"");
			 }
			 String message = ScriptRuntime.getMessage0(""msg.eval.nonstring"");
			 Context.reportWarning(message);
			 return x;
		 }
		 if (filename == null) {
			 int[] linep = new int[1];
			 filename = Context.getSourcePositionFromStack(linep);
			 if (filename != null) {
				 lineNumber = linep[0];
			 }
			 else {
				 filename = """";
			 }
		 }
		 String sourceName = ScriptRuntime. makeUrlForGeneratedScript(true, filename, lineNumber);
		 ErrorReporter reporter;
		 reporter = DefaultErrorReporter.forEval(cx.getErrorReporter());
		 Script script = cx.compileString((String)x, new Interpreter(), reporter, sourceName, 1, null);
		 ((InterpretedFunction)script).idata.evalScriptFlag = true;
		 Callable c = (Callable)script;
		 return c.call(cx, scope, (Scriptable)thisArg, ScriptRuntime.emptyArgs);
	 }
	 public static String typeof(Object value) {
		 if (value == null) return ""object"";
		 if (value == Undefined.instance) return ""undefined"";
		 if (value instanceof Scriptable) {
			 if (value instanceof XMLObject) return ""xml"";
			 return (value instanceof Callable) ? ""function"" : ""object"";
		 }
		 if (value instanceof String) return ""string"";
		 if (value instanceof Number) return ""number"";
		 if (value instanceof Boolean) return ""boolean"";
		 throw errorWithClassName(""msg.invalid.type"", value);
	 }
	 public static String typeofName(Scriptable scope, String id) {
		 Context cx = Context.getContext();
		 Scriptable val = bind(cx, scope, id);
		 if (val == null) return ""undefined"";
		 return typeof(getObjectProp(val, id, cx));
	 }
	 public static Object add(Object val1, Object val2, Context cx) {
		 if(val1 instanceof Number && val2 instanceof Number) {
			 return wrapNumber(((Number)val1).doubleValue() + ((Number)val2).doubleValue());
		 }
		 if (val1 instanceof XMLObject) {
			 Object test = ((XMLObject)val1).addValues(cx, true, val2);
			 if (test != Scriptable.NOT_FOUND) {
				 return test;
			 }
		 }
		 if (val2 instanceof XMLObject) {
			 Object test = ((XMLObject)val2).addValues(cx, false, val1);
			 if (test != Scriptable.NOT_FOUND) {
				 return test;
			 }
		 }
		 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(null);
		 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(null);
		 if (!(val1 instanceof String) && !(val2 instanceof String)) if ((val1 instanceof Number) && (val2 instanceof Number)) return wrapNumber(((Number)val1).doubleValue() + ((Number)val2).doubleValue());
		 else return wrapNumber(toNumber(val1) + toNumber(val2));
		 return toString(val1).concat(toString(val2));
	 }
	 public static Object nameIncrDecr(Scriptable scopeChain, String id, int incrDecrMask) {
		 Scriptable target;
		 Object value;
		 search: {
			 do {
				 target = scopeChain;
				 do {
					 value = target.get(id, scopeChain);
					 if (value != Scriptable.NOT_FOUND) {
						 break search;
					 }
					 target = target.getPrototype();
				 }
				 while (target != null);
				 scopeChain = scopeChain.getParentScope();
			 }
			 while (scopeChain != null);
			 throw notFoundError(scopeChain, id);
		 }
		 return doScriptableIncrDecr(target, id, scopeChain, value, incrDecrMask);
	 }
	 public static Object propIncrDecr(Object obj, String id, Context cx, int incrDecrMask) {
		 Scriptable start = toObjectOrNull(cx, obj);
		 if (start == null) {
			 throw undefReadError(obj, id);
		 }
		 Scriptable target = start;
		 Object value;
		 search: {
			 do {
				 value = target.get(id, start);
				 if (value != Scriptable.NOT_FOUND) {
					 break search;
				 }
				 target = target.getPrototype();
			 }
			 while (target != null);
			 start.put(id, start, NaNobj);
			 return NaNobj;
		 }
		 return doScriptableIncrDecr(target, id, start, value, incrDecrMask);
	 }
	 private static Object doScriptableIncrDecr(Scriptable target, String id, Scriptable protoChainStart, Object value, int incrDecrMask) {
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 target.put(id, protoChainStart, result);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 public static Object elemIncrDecr(Object obj, Object index, Context cx, int incrDecrMask) {
		 Object value = getObjectElem(obj, index, cx);
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 setObjectElem(obj, index, result, cx);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 public static Object refIncrDecr(Ref ref, Context cx, int incrDecrMask) {
		 Object value = ref.get(cx);
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 ref.set(cx, result);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 private static Object toPrimitive(Object val) {
		 if (!(val instanceof Scriptable)) {
			 return val;
		 }
		 Scriptable s = (Scriptable)val;
		 Object result = s.getDefaultValue(null);
		 if (result instanceof Scriptable) throw typeError0(""msg.bad.default.value"");
		 return result;
	 }
	 public static boolean eq(Object x, Object y) {
		 if (x == null || x == Undefined.instance) {
			 if (y == null || y == Undefined.instance) {
				 return true;
			 }
			 if (y instanceof ScriptableObject) {
				 Object test = ((ScriptableObject)y).equivalentValues(x);
				 if (test != Scriptable.NOT_FOUND) {
					 return ((Boolean)test).booleanValue();
				 }
			 }
			 return false;
		 }
		 else if (x instanceof Number) {
			 return eqNumber(((Number)x).doubleValue(), y);
		 }
		 else if (x instanceof String) {
			 return eqString((String)x, y);
		 }
		 else if (x instanceof Boolean) {
			 boolean b = ((Boolean)x).booleanValue();
			 if (y instanceof Boolean) {
				 return b == ((Boolean)y).booleanValue();
			 }
			 if (y instanceof ScriptableObject) {
				 Object test = ((ScriptableObject)y).equivalentValues(x);
				 if (test != Scriptable.NOT_FOUND) {
					 return ((Boolean)test).booleanValue();
				 }
			 }
			 return eqNumber(b ? 1.0 : 0.0, y);
		 }
		 else if (x instanceof Scriptable) {
			 if (y instanceof Scriptable) {
				 if (x == y) {
					 return true;
				 }
				 if (x instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)x).equivalentValues(y);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 if (y instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)y).equivalentValues(x);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 if (x instanceof Wrapper && y instanceof Wrapper) {
					 return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();
				 }
				 return false;
			 }
			 else if (y instanceof Boolean) {
				 if (x instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)x).equivalentValues(y);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 double d = ((Boolean)y).booleanValue() ? 1.0 : 0.0;
				 return eqNumber(d, x);
			 }
			 else if (y instanceof Number) {
				 return eqNumber(((Number)y).doubleValue(), x);
			 }
			 else if (y instanceof String) {
				 return eqString((String)y, x);
			 }
			 return false;
		 }
		 else {
			 warnAboutNonJSObject(x);
			 return x == y;
		 }
	 }
	 static boolean eqNumber(double x, Object y) {
		 for (;
		;
		) {
			 if (y == null || y == Undefined.instance) {
				 return false;
			 }
			 else if (y instanceof Number) {
				 return x == ((Number)y).doubleValue();
			 }
			 else if (y instanceof String) {
				 return x == toNumber(y);
			 }
			 else if (y instanceof Boolean) {
				 return x == (((Boolean)y).booleanValue() ? 1.0 : +0.0);
			 }
			 else if (y instanceof Scriptable) {
				 if (y instanceof ScriptableObject) {
					 Object xval = wrapNumber(x);
					 Object test = ((ScriptableObject)y).equivalentValues(xval);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 y = toPrimitive(y);
			 }
			 else {
				 warnAboutNonJSObject(y);
				 return false;
			 }
		 }
	 }
	 private static boolean eqString(String x, Object y) {
		 for (;
		;
		) {
			 if (y == null || y == Undefined.instance) {
				 return false;
			 }
			 else if (y instanceof String) {
				 return x.equals(y);
			 }
			 else if (y instanceof Number) {
				 return toNumber(x) == ((Number)y).doubleValue();
			 }
			 else if (y instanceof Boolean) {
				 return toNumber(x) == (((Boolean)y).booleanValue() ? 1.0 : 0.0);
			 }
			 else if (y instanceof Scriptable) {
				 if (y instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)y).equivalentValues(x);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 y = toPrimitive(y);
				 continue;
			 }
			 else {
				 warnAboutNonJSObject(y);
				 return false;
			 }
		 }
	 }
	 public static boolean shallowEq(Object x, Object y) {
		 if (x == y) {
			 if (!(x instanceof Number)) {
				 return true;
			 }
			 double d = ((Number)x).doubleValue();
			 return d == d;
		 }
		 if (x == null || x == Undefined.instance) {
			 return false;
		 }
		 else if (x instanceof Number) {
			 if (y instanceof Number) {
				 return ((Number)x).doubleValue() == ((Number)y).doubleValue();
			 }
		 }
		 else if (x instanceof String) {
			 if (y instanceof String) {
				 return x.equals(y);
			 }
		 }
		 else if (x instanceof Boolean) {
			 if (y instanceof Boolean) {
				 return x.equals(y);
			 }
		 }
		 else if (x instanceof Scriptable) {
			 if (x instanceof Wrapper && y instanceof Wrapper) {
				 return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();
			 }
		 }
		 else {
			 warnAboutNonJSObject(x);
			 return x == y;
		 }
		 return false;
	 }
	 public static boolean instanceOf(Object a, Object b, Context cx) {
		 if (! (b instanceof Scriptable)) {
			 throw typeError0(""msg.instanceof.not.object"");
		 }
		 if (! (a instanceof Scriptable)) return false;
		 return ((Scriptable)b).hasInstance((Scriptable)a);
	 }
	 protected static boolean jsDelegatesTo(Scriptable lhs, Scriptable rhs) {
		 Scriptable proto = lhs.getPrototype();
		 while (proto != null) {
			 if (proto.equals(rhs)) return true;
			 proto = proto.getPrototype();
		 }
		 return false;
	 }
	 public static boolean in(Object a, Object b, Context cx) {
		 if (!(b instanceof Scriptable)) {
			 throw typeError0(""msg.instanceof.not.object"");
		 }
		 return hasObjectElem((Scriptable)b, a, cx);
	 }
	 public static boolean cmp_LT(Object val1, Object val2) {
		 double d1, d2;
		 if (val1 instanceof Number && val2 instanceof Number) {
			 d1 = ((Number)val1).doubleValue();
			 d2 = ((Number)val2).doubleValue();
		 }
		 else {
			 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
			 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
			 if (val1 instanceof String && val2 instanceof String) {
				 return ((String)val1).compareTo((String)val2) < 0;
			 }
			 d1 = toNumber(val1);
			 d2 = toNumber(val2);
		 }
		 return d1 < d2;
	 }
	 public static boolean cmp_LE(Object val1, Object val2) {
		 double d1, d2;
		 if (val1 instanceof Number && val2 instanceof Number) {
			 d1 = ((Number)val1).doubleValue();
			 d2 = ((Number)val2).doubleValue();
		 }
		 else {
			 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
			 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
			 if (val1 instanceof String && val2 instanceof String) {
				 return ((String)val1).compareTo((String)val2) <= 0;
			 }
			 d1 = toNumber(val1);
			 d2 = toNumber(val2);
		 }
		 return d1 <= d2;
	 }
	 public static ScriptableObject getGlobal(Context cx) {
		 final String GLOBAL_CLASS = ""org.mozilla.javascript.tools.shell.Global"";
		 Class globalClass = Kit.classOrNull(GLOBAL_CLASS);
		 if (globalClass != null) {
			 try {
				 Class[] parm = {
				 ScriptRuntime.ContextClass }
				;
				 Constructor globalClassCtor = globalClass.getConstructor(parm);
				 Object[] arg = {
				 cx }
				;
				 return (ScriptableObject) globalClassCtor.newInstance(arg);
			 }
			 catch (Exception e) {
			 }
		 }
		 return new ImporterTopLevel(cx);
	 }
	 public static boolean hasTopCall(Context cx) {
		 return (cx.topCallScope != null);
	 }
	 public static Scriptable getTopCallScope(Context cx) {
		 Scriptable scope = cx.topCallScope;
		 if (scope == null) {
			 throw new IllegalStateException();
		 }
		 return scope;
	 }
	 public static Object doTopCall(Callable callable, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (scope == null) throw new IllegalArgumentException();
		 if (cx.topCallScope != null) throw new IllegalStateException();
		 Object result;
		 cx.topCallScope = ScriptableObject.getTopLevelScope(scope);
		 cx.useDynamicScope = cx.hasFeature(Context.FEATURE_DYNAMIC_SCOPE);
		 ContextFactory f = cx.getFactory();
		 try {
			 result = f.doTopCall(callable, cx, scope, thisObj, args);
		 }
		 finally {
			 cx.topCallScope = null;
			 cx.cachedXMLLib = null;
			 if (cx.currentActivationCall != null) {
				 throw new IllegalStateException();
			 }
		 }
		 return result;
	 }
	 static Scriptable checkDynamicScope(Scriptable possibleDynamicScope, Scriptable staticTopScope) {
		 if (possibleDynamicScope == staticTopScope) {
			 return possibleDynamicScope;
		 }
		 Scriptable proto = possibleDynamicScope;
		 for (;
		;
		) {
			 proto = proto.getPrototype();
			 if (proto == staticTopScope) {
				 return possibleDynamicScope;
			 }
			 if (proto == null) {
				 return staticTopScope;
			 }
		 }
	 }
	 public static void initScript(NativeFunction funObj, Scriptable thisObj, Context cx, Scriptable scope, boolean evalScript) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 int varCount = funObj.getParamAndVarCount();
		 if (varCount != 0) {
			 Scriptable varScope = scope;
			 while (varScope instanceof NativeWith) {
				 varScope = varScope.getParentScope();
			 }
			 for (int i = varCount;
			 i-- != 0;
			) {
				 String name = funObj.getParamOrVarName(i);
				 if (!ScriptableObject.hasProperty(scope, name)) {
					 if (!evalScript) {
						 ScriptableObject.defineProperty( varScope, name, Undefined.instance, ScriptableObject.PERMANENT);
					 }
					 else {
						 varScope.put(name, varScope, Undefined.instance);
					 }
				 }
			 }
		 }
	 }
	 public static Scriptable createFunctionActivation(NativeFunction funObj, Scriptable scope, Object[] args) {
		 return new NativeCall(funObj, scope, args);
	 }
	 public static void enterActivationFunction(Context cx, Scriptable activation) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 NativeCall call = (NativeCall)activation;
		 call.parentActivationCall = cx.currentActivationCall;
		 cx.currentActivationCall = call;
	 }
	 public static void exitActivationFunction(Context cx) {
		 NativeCall call = cx.currentActivationCall;
		 cx.currentActivationCall = call.parentActivationCall;
		 call.parentActivationCall = null;
	 }
	 static NativeCall findFunctionActivation(Context cx, Function f) {
		 NativeCall call = cx.currentActivationCall;
		 while (call != null) {
			 if (call.function == f) return call;
			 call = call.parentActivationCall;
		 }
		 return null;
	 }
	 public static Scriptable newCatchScope(Throwable t, Scriptable lastCatchScope, String exceptionName, Context cx, Scriptable scope) {
		 Object obj;
		 boolean cacheObj;
		 getObj: if (t instanceof JavaScriptException) {
			 cacheObj = false;
			 obj = ((JavaScriptException)t).getValue();
		 }
		 else {
			 cacheObj = true;
			 if (lastCatchScope != null) {
				 NativeObject last = (NativeObject)lastCatchScope;
				 obj = last.getAssociatedValue(t);
				 if (obj == null) Kit.codeBug();
				 break getObj;
			 }
			 RhinoException re;
			 String errorName;
			 String errorMsg;
			 Throwable javaException = null;
			 if (t instanceof EcmaError) {
				 EcmaError ee = (EcmaError)t;
				 re = ee;
				 errorName = ee.getName();
				 errorMsg = ee.getErrorMessage();
			 }
			 else if (t instanceof WrappedException) {
				 WrappedException we = (WrappedException)t;
				 re = we;
				 javaException = we.getWrappedException();
				 errorName = ""JavaException"";
				 errorMsg = javaException.getClass().getName() +"": ""+javaException.getMessage();
			 }
			 else if (t instanceof EvaluatorException) {
				 EvaluatorException ee = (EvaluatorException)t;
				 re = ee;
				 errorName = ""InternalError"";
				 errorMsg = ee.getMessage();
			 }
			 else {
				 throw Kit.codeBug();
			 }
			 String sourceUri = re.sourceName();
			 if (sourceUri == null) {
				 sourceUri = """";
			 }
			 int line = re.lineNumber();
			 Object args[];
			 if (line > 0) {
				 args = new Object[] {
				 errorMsg, sourceUri, new Integer(line) }
				;
			 }
			 else {
				 args = new Object[] {
				 errorMsg, sourceUri }
				;
			 }
			 Scriptable errorObject = cx.newObject(scope, errorName, args);
			 ScriptableObject.putProperty(errorObject, ""name"", errorName);
			 if (javaException != null) {
				 Object wrap = cx.getWrapFactory().wrap(cx, scope, javaException, null);
				 ScriptableObject.defineProperty( errorObject, ""javaException"", wrap, ScriptableObject.PERMANENT | ScriptableObject.READONLY);
			 }
			 if (re != null) {
				 Object wrap = cx.getWrapFactory().wrap(cx, scope, re, null);
				 ScriptableObject.defineProperty( errorObject, ""rhinoException"", wrap, ScriptableObject.PERMANENT | ScriptableObject.READONLY);
			 }
			 obj = errorObject;
		 }
		 NativeObject catchScopeObject = new NativeObject();
		 catchScopeObject.defineProperty( exceptionName, obj, ScriptableObject.PERMANENT);
		 if (cacheObj) {
			 catchScopeObject.associateValue(t, obj);
		 }
		 return catchScopeObject;
	 }
	 public static Scriptable enterWith(Object obj, Context cx, Scriptable scope) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw typeError1(""msg.undef.with"", toString(obj));
		 }
		 if (sobj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)sobj;
			 return xmlObject.enterWith(scope);
		 }
		 return new NativeWith(scope, sobj);
	 }
	 public static Scriptable leaveWith(Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.getParentScope();
	 }
	 public static Scriptable enterDotQuery(Object value, Scriptable scope) {
		 if (!(value instanceof XMLObject)) {
			 throw notXmlError(value);
		 }
		 XMLObject object = (XMLObject)value;
		 return object.enterDotQuery(scope);
	 }
	 public static Object updateDotQuery(boolean value, Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.updateDotQuery(value);
	 }
	 public static Scriptable leaveDotQuery(Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.getParentScope();
	 }
	 public static void setFunctionProtoAndParent(BaseFunction fn, Scriptable scope) {
		 fn.setParentScope(scope);
		 fn.setPrototype(ScriptableObject.getFunctionPrototype(scope));
	 }
	 public static void setObjectProtoAndParent(ScriptableObject object, Scriptable scope) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 object.setParentScope(scope);
		 Scriptable proto = ScriptableObject.getClassPrototype(scope, object.getClassName());
		 object.setPrototype(proto);
	 }
	 public static void initFunction(Context cx, Scriptable scope, NativeFunction function, int type, boolean fromEvalCode) {
		 if (type == FunctionNode.FUNCTION_STATEMENT) {
			 String name = function.getFunctionName();
			 if (name != null && name.length() != 0) {
				 if (!fromEvalCode) {
					 ScriptableObject.defineProperty (scope, name, function, ScriptableObject.PERMANENT);
				 }
				 else {
					 scope.put(name, scope, function);
				 }
			 }
		 }
		 else if (type == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
			 String name = function.getFunctionName();
			 if (name != null && name.length() != 0) {
				 while (scope instanceof NativeWith) {
					 scope = scope.getParentScope();
				 }
				 scope.put(name, scope, function);
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
	 }
	 public static Scriptable newArrayLiteral(Object[] objects, int[] skipIndexces, Context cx, Scriptable scope) {
		 int count = objects.length;
		 int skipCount = 0;
		 if (skipIndexces != null) {
			 skipCount = skipIndexces.length;
		 }
		 int length = count + skipCount;
		 Integer lengthObj = new Integer(length);
		 Scriptable arrayObj;
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) {
			 arrayObj = cx.newObject(scope, ""Array"", ScriptRuntime.emptyArgs);
			 ScriptableObject.putProperty(arrayObj, ""length"", lengthObj);
		 }
		 else {
			 arrayObj = cx.newObject(scope, ""Array"", new Object[] {
			 lengthObj }
			);
		 }
		 int skip = 0;
		 for (int i = 0, j = 0;
		 i != length;
		 ++i) {
			 if (skip != skipCount && skipIndexces[skip] == i) {
				 ++skip;
				 continue;
			 }
			 ScriptableObject.putProperty(arrayObj, i, objects[j]);
			 ++j;
		 }
		 return arrayObj;
	 }
	 public static Scriptable newObjectLiteral(Object[] propertyIds, Object[] propertyValues, Context cx, Scriptable scope) {
		 Scriptable object = cx.newObject(scope);
		 for (int i = 0, end = propertyIds.length;
		 i != end;
		 ++i) {
			 Object id = propertyIds[i];
			 Object value = propertyValues[i];
			 if (id instanceof String) {
				 ScriptableObject.putProperty(object, (String)id, value);
			 }
			 else {
				 int index = ((Integer)id).intValue();
				 ScriptableObject.putProperty(object, index, value);
			 }
		 }
		 return object;
	 }
	 public static boolean isArrayObject(Object obj) {
		 return obj instanceof NativeArray || obj instanceof Arguments;
	 }
	 public static Object[] getArrayElements(Scriptable object) {
		 Context cx = Context.getContext();
		 long longLen = NativeArray.getLengthProperty(cx, object);
		 if (longLen > Integer.MAX_VALUE) {
			 throw new IllegalArgumentException();
		 }
		 int len = (int) longLen;
		 if (len == 0) {
			 return ScriptRuntime.emptyArgs;
		 }
		 else {
			 Object[] result = new Object[len];
			 for (int i=0;
			 i < len;
			 i++) {
				 Object elem = ScriptableObject.getProperty(object, i);
				 result[i] = (elem == Scriptable.NOT_FOUND) ? Undefined.instance : elem;
			 }
			 return result;
		 }
	 }
	 static void checkDeprecated(Context cx, String name) {
		 int version = cx.getLanguageVersion();
		 if (version >= Context.VERSION_1_4 || version == Context.VERSION_DEFAULT) {
			 String msg = getMessage1(""msg.deprec.ctor"", name);
			 if (version == Context.VERSION_DEFAULT) Context.reportWarning(msg);
			 else throw Context.reportRuntimeError(msg);
		 }
	 }
	 public static String getMessage0(String messageId) {
		 return getMessage(messageId, null);
	 }
	 public static String getMessage1(String messageId, Object arg1) {
		 Object[] arguments = {
		arg1}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage2( String messageId, Object arg1, Object arg2) {
		 Object[] arguments = {
		arg1, arg2}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage3( String messageId, Object arg1, Object arg2, Object arg3) {
		 Object[] arguments = {
		arg1, arg2, arg3}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage4( String messageId, Object arg1, Object arg2, Object arg3, Object arg4) {
		 Object[] arguments = {
		arg1, arg2, arg3, arg4}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage(String messageId, Object[] arguments) {
		 final String defaultResource = ""org.mozilla.javascript.resources.Messages"";
		 Context cx = Context.getCurrentContext();
		 Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();
		 ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);
		 String formatString;
		 try {
			 formatString = rb.getString(messageId);
		 }
		 catch (java.util.MissingResourceException mre) {
			 throw new RuntimeException (""no message resource found for message property ""+ messageId);
		 }
		 MessageFormat formatter = new MessageFormat(formatString);
		 return formatter.format(arguments);
	 }
	 public static EcmaError constructError(String error, String message) {
		 int[] linep = new int[1];
		 String filename = Context.getSourcePositionFromStack(linep);
		 return constructError(error, message, filename, linep[0], null, 0);
	 }
	 public static EcmaError constructError(String error, String message, String sourceName, int lineNumber, String lineSource, int columnNumber) {
		 return new EcmaError(error, message, sourceName, lineNumber, lineSource, columnNumber);
	 }
	 public static EcmaError typeError(String message) {
		 return constructError(""TypeError"", message);
	 }
	 public static EcmaError typeError0(String messageId) {
		 String msg = getMessage0(messageId);
		 return typeError(msg);
	 }
	 public static EcmaError typeError1(String messageId, String arg1) {
		 String msg = getMessage1(messageId, arg1);
		 return typeError(msg);
	 }
	 public static EcmaError typeError2(String messageId, String arg1, String arg2) {
		 String msg = getMessage2(messageId, arg1, arg2);
		 return typeError(msg);
	 }
	 public static EcmaError typeError3(String messageId, String arg1, String arg2, String arg3) {
		 String msg = getMessage3(messageId, arg1, arg2, arg3);
		 return typeError(msg);
	 }
	 public static RuntimeException undefReadError(Object object, Object id) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 return typeError2(""msg.undef.prop.read"", toString(object), idStr);
	 }
	 public static RuntimeException undefCallError(Object object, Object id) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 return typeError2(""msg.undef.method.call"", toString(object), idStr);
	 }
	 public static RuntimeException undefWriteError(Object object, Object id, Object value) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 String valueStr = (value instanceof Scriptable) ? value.toString() : toString(value);
		 return typeError3(""msg.undef.prop.write"", toString(object), idStr, valueStr);
	 }
	 public static RuntimeException notFoundError(Scriptable object, String property) {
		 String msg = getMessage1(""msg.is.not.defined"", property);
		 throw constructError(""ReferenceError"", msg);
	 }
	 public static RuntimeException notFunctionError(Object value) {
		 return notFunctionError(value, value);
	 }
	 public static RuntimeException notFunctionError(Object value, Object messageHelper) {
		 String msg = (messageHelper == null) ? ""null"" : messageHelper.toString();
		 if (value == Scriptable.NOT_FOUND) {
			 return typeError1(""msg.function.not.found"", msg);
		 }
		 return typeError2(""msg.isnt.function"", msg, value == null ? ""null"" : value.getClass().getName());
	 }
	 private static RuntimeException notXmlError(Object value) {
		 throw typeError1(""msg.isnt.xml.object"", ScriptRuntime.toString(value));
	 }
	 private static void warnAboutNonJSObject(Object nonJSObject) {
		 String message =""RHINO USAGE WARNING: Missed Context.javaToJS() conversion:\n""+""Rhino runtime detected object ""+nonJSObject+"" of class ""+nonJSObject.getClass().getName()+"" where it expected String, Number, Boolean or Scriptable instance. Please check your code for missing Context.javaToJS() call."";
		 Context.reportWarning(message);
		 System.err.println(message);
	 }
	 public static RegExpProxy getRegExpProxy(Context cx) {
		 return cx.getRegExpProxy();
	 }
	 public static void setRegExpProxy(Context cx, RegExpProxy proxy) {
		 if (proxy == null) throw new IllegalArgumentException();
		 cx.regExpProxy = proxy;
	 }
	 public static RegExpProxy checkRegExpProxy(Context cx) {
		 RegExpProxy result = getRegExpProxy(cx);
		 if (result == null) {
			 throw Context.reportRuntimeError0(""msg.no.regexp"");
		 }
		 return result;
	 }
	 private static XMLLib currentXMLLib(Context cx) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 XMLLib xmlLib = cx.cachedXMLLib;
		 if (xmlLib == null) {
			 xmlLib = XMLLib.extractFromScope(cx.topCallScope);
			 if (xmlLib == null) throw new IllegalStateException();
			 cx.cachedXMLLib = xmlLib;
		 }
		 return xmlLib;
	 }
	 public static String escapeAttributeValue(Object value, Context cx) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.escapeAttributeValue(value);
	 }
	 public static String escapeTextValue(Object value, Context cx) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.escapeTextValue(value);
	 }
	 public static Ref memberRef(Object obj, Object elem, Context cx, int memberTypeFlags) {
		 if (!(obj instanceof XMLObject)) {
			 throw notXmlError(obj);
		 }
		 XMLObject xmlObject = (XMLObject)obj;
		 return xmlObject.memberRef(cx, elem, memberTypeFlags);
	 }
	 public static Ref memberRef(Object obj, Object namespace, Object elem, Context cx, int memberTypeFlags) {
		 if (!(obj instanceof XMLObject)) {
			 throw notXmlError(obj);
		 }
		 XMLObject xmlObject = (XMLObject)obj;
		 return xmlObject.memberRef(cx, namespace, elem, memberTypeFlags);
	 }
	 public static Ref nameRef(Object name, Context cx, Scriptable scope, int memberTypeFlags) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.nameRef(cx, name, scope, memberTypeFlags);
	 }
	 public static Ref nameRef(Object namespace, Object name, Context cx, Scriptable scope, int memberTypeFlags) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.nameRef(cx, namespace, name, scope, memberTypeFlags);
	 }
	 private static void storeIndexResult(Context cx, int index) {
		 cx.scratchIndex = index;
	 }
	 static int lastIndexResult(Context cx) {
		 return cx.scratchIndex;
	 }
	 public static void storeUint32Result(Context cx, long value) {
		 if ((value >>> 32) != 0) throw new IllegalArgumentException();
		 cx.scratchUint32 = value;
	 }
	 public static long lastUint32Result(Context cx) {
		 long value = cx.scratchUint32;
		 if ((value >>> 32) != 0) throw new IllegalStateException();
		 return value;
	 }
	 private static void storeScriptable(Context cx, Scriptable value) {
		 if (cx.scratchScriptable != null) throw new IllegalStateException();
		 cx.scratchScriptable = value;
	 }
	 public static Scriptable lastStoredScriptable(Context cx) {
		 Scriptable result = cx.scratchScriptable;
		 cx.scratchScriptable = null;
		 return result;
	 }
	 static String makeUrlForGeneratedScript (boolean isEval, String masterScriptUrl, int masterScriptLine) {
		 if (isEval) {
			 return masterScriptUrl+'#'+masterScriptLine+""(eval)"";
		 }
		 else {
			 return masterScriptUrl+'#'+masterScriptLine+""(Function)"";
		 }
	 }
	 static boolean isGeneratedScript(String sourceUrl) {
		 return sourceUrl.indexOf(""(eval)"") >= 0 || sourceUrl.indexOf(""(Function)"") >= 0;
	 }
	 private static RuntimeException errorWithClassName(String msg, Object val) {
		 return Context.reportRuntimeError1(msg, val.getClass().getName());
	 }
	 public static final Object[] emptyArgs = new Object[0];
	 public static final String[] emptyStrings = new String[0];
}",1,0,0,0
"public class ImportDsmlRunnable implements StudioConnectionBulkRunnableWithProgress{
	 private IBrowserConnection browserConnection;
	 private File dsmlFile;
	 private File responseFile;
	 private LdapApiService codec = LdapApiServiceFactory.getSingleton();
	 public ImportDsmlRunnable( IBrowserConnection connection, File dsmlFile, File saveFile ) {
		 this.browserConnection = connection;
		 this.dsmlFile = dsmlFile;
		 this.responseFile = saveFile;
	 }
	 public ImportDsmlRunnable( IBrowserConnection connection, File dsmlFile ) {
		 this( connection, dsmlFile, null );
	 }
	 public Connection[] getConnections() {
		 return new Connection[] {
		 browserConnection.getConnection() }
		;
	 }
	 public String getName() {
		 return BrowserCoreMessages.jobs__import_dsml_name;
	 }
	 public Object[] getLockedObjects() {
		 List<Object> l = new ArrayList<Object>();
		 l.add( browserConnection.getUrl() + ""_"" + DigestUtils.shaHex( dsmlFile.toString() ) );
		 return l.toArray();
	 }
	 public String getErrorMessage() {
		 return BrowserCoreMessages.jobs__import_dsml_error;
	 }
	 public void run( StudioProgressMonitor monitor ) {
		 monitor.beginTask( BrowserCoreMessages.jobs__import_dsml_task, 2 );
		 monitor.reportProgress( "" "" );
		 monitor.worked( 1 );
		 try {
			 Dsmlv2Grammar grammar = new Dsmlv2Grammar();
			 Dsmlv2Parser parser = new Dsmlv2Parser( grammar );
			 parser.setInput( new FileInputStream( dsmlFile ), ""UTF-8"" );
			 parser.parseAllRequests();
			 BatchRequestDsml batchRequest = parser.getBatchRequest();
			 BatchResponseDsml batchResponseDsml = null;
			 if ( responseFile != null ) {
				 batchResponseDsml = new BatchResponseDsml();
			 }
			 int errorsCount = 0;
			 StudioProgressMonitor dummyMonitor = new StudioProgressMonitor( monitor );
			 List<DsmlDecorator<? extends Request>> requests = batchRequest.getRequests();
			 for ( DsmlDecorator<? extends Request> request : requests ) {
				 processRequest( request, batchResponseDsml, dummyMonitor );
				 if ( dummyMonitor.errorsReported() ) {
					 errorsCount++;
				 }
				 dummyMonitor.reset();
			 }
			 if ( responseFile != null ) {
				 FileOutputStream fos = new FileOutputStream( responseFile );
				 OutputStreamWriter osw = new OutputStreamWriter( fos, ""UTF-8"" );
				 BufferedWriter bufferedWriter = new BufferedWriter( osw );
				 bufferedWriter.write( batchResponseDsml.toDsml() );
				 bufferedWriter.close();
				 osw.close();
				 fos.close();
			 }
			 if ( errorsCount > 0 ) {
				 monitor.reportError( BrowserCoreMessages.bind( BrowserCoreMessages.dsml__n_errors_see_responsefile, new String[] {
				 """" + errorsCount }
				 ) );
			 }
		 }
		 catch ( Exception e ) {
			 monitor.reportError( e );
		 }
	 }
	 public void runNotification( StudioProgressMonitor monitor ) {
		 EventRegistry.fireEntryUpdated( new BulkModificationEvent( browserConnection ), this );
	 }
	 private void processRequest( DsmlDecorator<? extends Request> request, BatchResponseDsml batchResponseDsml, StudioProgressMonitor monitor ) throws NamingException, LdapURLEncodingException, LdapException {
		 switch ( request.getDecorated().getType() ) {
			 case BIND_REQUEST: processBindRequest( ( BindRequest ) request, batchResponseDsml, monitor );
			 break;
			 case ADD_REQUEST: processAddRequest( ( AddRequest ) request, batchResponseDsml, monitor );
			 break;
			 case COMPARE_REQUEST: processCompareRequest( ( CompareRequest ) request, batchResponseDsml, monitor );
			 break;
			 case DEL_REQUEST: processDelRequest( ( DeleteRequest ) request, batchResponseDsml, monitor );
			 break;
			 case EXTENDED_REQUEST: processExtendedRequest( ( ExtendedRequest ) request, batchResponseDsml, monitor );
			 break;
			 case MODIFY_REQUEST: processModifyRequest( ( ModifyRequest ) request, batchResponseDsml, monitor );
			 break;
			 case MODIFYDN_REQUEST: processModifyDNRequest( ( ModifyDnRequest ) request, batchResponseDsml, monitor );
			 break;
			 case SEARCH_REQUEST: processSearchRequest( ( SearchRequest ) request, batchResponseDsml, monitor );
			 break;
			 default: throw new IllegalArgumentException( BrowserCoreMessages.dsml__should_not_be_encountering_request + request.getDecorated().getType() );
		 }
	 }
	 private void processBindRequest( BindRequest request, BatchResponseDsml batchResponseDsml, StudioProgressMonitor monitor ) {
		 if ( batchResponseDsml != null ) {
			 BindResponseDsml authResponseDsml = new BindResponseDsml( codec );
			 LdapResult ldapResult = authResponseDsml.getLdapResult();
			 ldapResult.setResultCode( ResultCodeEnum.UNWILLING_TO_PERFORM );
			 ldapResult.setDiagnosticMessage( BrowserCoreMessages.dsml__kind_request_not_supported );
			 batchResponseDsml.addResponse( authResponseDsml );
		 }
	 }
	 private void processAddRequest( AddRequest request, BatchResponseDsml batchResponseDsml, StudioProgressMonitor monitor ) {
		 Entry entry = request.getEntry();
		 browserConnection .getConnection() .getConnectionWrapper() .createEntry( entry.getDn().getName(), Utils.toAttributes( entry ), getControls( request ), monitor, null );
		 if ( batchResponseDsml != null ) {
			 AddResponseDsml addResponseDsml = new AddResponseDsml( codec );
			 LdapResult ldapResult = addResponseDsml.getLdapResult();
			 setLdapResultValuesFromMonitor( ldapResult, monitor, MessageTypeEnum.ADD_REQUEST );
			 ldapResult.setMatchedDn( entry.getDn() );
			 batchResponseDsml.addResponse( addResponseDsml );
		 }
		 Dn dn = entry.getDn();
		 IEntry e = browserConnection.getEntryFromCache( dn );
		 Dn parentDn = dn.getParent();
		 IEntry parentEntry = parentDn != null ? browserConnection.getEntryFromCache( parentDn ) : null;
		 if ( e != null ) {
			 e.setAttributesInitialized( false );
		 }
		 if ( parentEntry != null ) {
			 parentEntry.setChildrenInitialized( false );
		 }
	 }
	 private void processCompareRequest( CompareRequest request, BatchResponseDsml batchResponseDsml, StudioProgressMonitor monitor ) {
		 if ( batchResponseDsml != null ) {
			 CompareResponseDsml compareResponseDsml = new CompareResponseDsml( codec );
			 LdapResult ldapResult = compareResponseDsml.getLdapResult();
			 ldapResult.setResultCode( ResultCodeEnum.UNWILLING_TO_PERFORM );
			 ldapResult.setDiagnosticMessage( BrowserCoreMessages.dsml__kind_request_not_supported );
			 batchResponseDsml.addResponse( compareResponseDsml );
		 }
	 }
	 private void processDelRequest( DeleteRequest request, BatchResponseDsml batchResponseDsml, StudioProgressMonitor monitor ) {
		 browserConnection.getConnection().getConnectionWrapper() .deleteEntry( request.getName().getName(), getControls( request ), monitor, null );
		 if ( batchResponseDsml != null ) {
			 DelResponseDsml delResponseDsml = new DelResponseDsml( codec );
			 LdapResult ldapResult = delResponseDsml.getLdapResult();
			 setLdapResultValuesFromMonitor( ldapResult, monitor, MessageTypeEnum.ADD_REQUEST );
			 delResponseDsml.getLdapResult().setMatchedDn( request.getName() );
			 batchResponseDsml.addResponse( delResponseDsml );
		 }
		 Dn dn = request.getName();
		 IEntry e = browserConnection.getEntryFromCache( dn );
		 Dn parentDn = dn.getParent();
		 IEntry parentEntry = parentDn != null ? browserConnection.getEntryFromCache( parentDn ) : null;
		 if ( e != null ) {
			 e.setAttributesInitialized( false );
			 browserConnection.uncacheEntryRecursive( e );
		 }
		 if ( parentEntry != null ) {
			 parentEntry.setChildrenInitialized( false );
		 }
	 }
	 private void processExtendedRequest( ExtendedRequest request, BatchResponseDsml batchResponseDsml, StudioProgressMonitor monitor ) {
		 if ( batchResponseDsml != null ) {
			 ExtendedResponseDsml extendedResponseDsml = new ExtendedResponseDsml( codec );
			 LdapResult ldapResult = extendedResponseDsml.getLdapResult();
			 ldapResult.setResultCode( ResultCodeEnum.UNWILLING_TO_PERFORM );
			 ldapResult.setDiagnosticMessage( BrowserCoreMessages.dsml__kind_request_not_supported );
			 batchResponseDsml.addResponse( extendedResponseDsml );
		 }
	 }
	 private void processModifyRequest( ModifyRequest request, BatchResponseDsml batchResponseDsml, StudioProgressMonitor monitor ) {
		 List<ModificationItem> modificationItems = new ArrayList<ModificationItem>();
		 for ( Modification modification : request.getModifications() ) {
			 modificationItems.add( new ModificationItem( convertModificationOperation( modification.getOperation() ), AttributeUtils.toJndiAttribute( modification.getAttribute() ) ) );
		 }
		 browserConnection .getConnection() .getConnectionWrapper() .modifyEntry( request.getName().getName(), modificationItems.toArray( new ModificationItem[0] ), getControls( request ), monitor, null );
		 if ( batchResponseDsml != null ) {
			 ModifyResponseDsml modifyResponseDsml = new ModifyResponseDsml( codec );
			 LdapResult ldapResult = modifyResponseDsml.getLdapResult();
			 setLdapResultValuesFromMonitor( ldapResult, monitor, MessageTypeEnum.ADD_REQUEST );
			 modifyResponseDsml.getLdapResult().setMatchedDn( request.getName() );
			 batchResponseDsml.addResponse( modifyResponseDsml );
		 }
		 Dn dn = request.getName();
		 IEntry e = browserConnection.getEntryFromCache( dn );
		 if ( e != null ) {
			 e.setAttributesInitialized( false );
		 }
	 }
	 private int convertModificationOperation( ModificationOperation operation ) {
		 switch ( operation ) {
			 case ADD_ATTRIBUTE: return DirContext.ADD_ATTRIBUTE;
			 case REMOVE_ATTRIBUTE: return DirContext.REMOVE_ATTRIBUTE;
			 case REPLACE_ATTRIBUTE: return DirContext.REPLACE_ATTRIBUTE;
			 default: return 0;
		 }
	 }
	 private void processModifyDNRequest( ModifyDnRequest request, BatchResponseDsml batchResponseDsml, StudioProgressMonitor monitor ) {
		 browserConnection .getConnection() .getConnectionWrapper() .renameEntry( request.getName().getName(), request.getNewRdn().getName(), request.getDeleteOldRdn(), getControls( request ), monitor, null );
		 if ( batchResponseDsml != null ) {
			 ModDNResponseDsml modDNResponseDsml = new ModDNResponseDsml( codec );
			 LdapResult ldapResult = modDNResponseDsml.getLdapResult();
			 setLdapResultValuesFromMonitor( ldapResult, monitor, MessageTypeEnum.ADD_REQUEST );
			 modDNResponseDsml.getLdapResult().setMatchedDn( request.getName() );
			 batchResponseDsml.addResponse( modDNResponseDsml );
		 }
		 Dn dn = request.getName();
		 IEntry e = browserConnection.getEntryFromCache( dn );
		 Dn parentDn = dn.getParent();
		 IEntry parentEntry = parentDn != null ? browserConnection.getEntryFromCache( parentDn ) : null;
		 if ( e != null ) {
			 e.setAttributesInitialized( false );
			 browserConnection.uncacheEntryRecursive( e );
		 }
		 if ( parentEntry != null ) {
			 parentEntry.setChildrenInitialized( false );
		 }
		 if ( request.getNewSuperior() != null ) {
			 Dn newSuperiorDn = request.getNewSuperior();
			 IEntry newSuperiorEntry = browserConnection.getEntryFromCache( newSuperiorDn );
			 if ( newSuperiorEntry != null ) {
				 newSuperiorEntry.setChildrenInitialized( false );
			 }
		 }
	 }
	 private void processSearchRequest( SearchRequest request, BatchResponseDsml batchResponseDsml, StudioProgressMonitor monitor ) throws NamingException, LdapURLEncodingException, LdapException {
		 if ( batchResponseDsml != null ) {
			 StudioNamingEnumeration ne = browserConnection .getConnection() .getConnectionWrapper() .search( request.getBase().getName(), request.getFilter().toString(), getSearchControls( request ), getAliasDereferencingMethod( request ), ReferralHandlingMethod.IGNORE, getControls( request ), monitor, null );
			 SearchParameter sp = new SearchParameter();
			 sp.setReferralsHandlingMethod( browserConnection.getReferralsHandlingMethod() );
			 ExportDsmlRunnable.processAsDsmlResponse( ne, batchResponseDsml, monitor, sp );
		 }
	 }
	 private SearchControls getSearchControls( SearchRequest request ) {
		 SearchControls controls = new SearchControls();
		 switch ( request.getScope() ) {
			 case OBJECT: controls.setSearchScope( SearchControls.OBJECT_SCOPE );
			 break;
			 case ONELEVEL: controls.setSearchScope( SearchControls.ONELEVEL_SCOPE );
			 break;
			 case SUBTREE: controls.setSearchScope( SearchControls.SUBTREE_SCOPE );
			 break;
			 default: controls.setSearchScope( SearchControls.ONELEVEL_SCOPE );
		 }
		 List<String> returningAttributes = new ArrayList<String>();
		 for ( String attribute : request.getAttributes() ) {
			 returningAttributes.add( attribute );
		 }
		 if ( returningAttributes.size() == 0 ) {
			 returningAttributes.add( ""*"" );
		 }
		 controls.setReturningAttributes( returningAttributes.toArray( new String[0] ) );
		 controls.setCountLimit( request.getSizeLimit() );
		 controls.setTimeLimit( request.getTimeLimit() );
		 return controls;
	 }
	 private AliasDereferencingMethod getAliasDereferencingMethod( SearchRequest request ) {
		 switch ( request.getDerefAliases() ) {
			 case NEVER_DEREF_ALIASES: return AliasDereferencingMethod.NEVER;
			 case DEREF_ALWAYS: return AliasDereferencingMethod.ALWAYS;
			 case DEREF_FINDING_BASE_OBJ: return AliasDereferencingMethod.FINDING;
			 case DEREF_IN_SEARCHING: return AliasDereferencingMethod.SEARCH;
			 default: return AliasDereferencingMethod.NEVER;
		 }
	 }
	 private Control[] getControls( Message request ) {
		 Collection<org.apache.directory.api.ldap.model.message.Control> controls = request.getControls().values();
		 if ( controls != null ) {
			 List<Control> jndiControls = new ArrayList<Control>();
			 for ( org.apache.directory.api.ldap.model.message.Control control : controls ) {
				 try {
					 jndiControls.add( codec.toJndiControl( control ) );
				 }
				 catch ( EncoderException e ) {
					 throw new RuntimeException( e );
				 }
			 }
			 return jndiControls.toArray( new Control[jndiControls.size()] );
		 }
		 return null;
	 }
	 private void setLdapResultValuesFromMonitor( LdapResult ldapResult, StudioProgressMonitor monitor, MessageTypeEnum messageType ) {
		 if ( !monitor.errorsReported() ) {
			 ldapResult.setResultCode( ResultCodeEnum.SUCCESS );
		 }
		 else {
			 Throwable t = monitor.getException();
			 ldapResult.setResultCode( ResultCodeEnum.getBestEstimate( t, messageType ) );
			 if ( t.getMessage() != null ) {
				 ldapResult.setDiagnosticMessage( t.getMessage() );
			 }
		 }
	 }
}",1,0,0,0
"public class Project implements ResourceFactory {
	 public static final int MSG_ERR = 0;
	 public static final int MSG_WARN = 1;
	 public static final int MSG_INFO = 2;
	 public static final int MSG_VERBOSE = 3;
	 public static final int MSG_DEBUG = 4;
	 private static final String VISITING = ""VISITING"";
	 private static final String VISITED = ""VISITED"";
	 public static final String JAVA_1_0 = JavaEnvUtils.JAVA_1_0;
	 public static final String JAVA_1_1 = JavaEnvUtils.JAVA_1_1;
	 public static final String JAVA_1_2 = JavaEnvUtils.JAVA_1_2;
	 public static final String JAVA_1_3 = JavaEnvUtils.JAVA_1_3;
	 public static final String JAVA_1_4 = JavaEnvUtils.JAVA_1_4;
	 public static final String TOKEN_START = FilterSet.DEFAULT_TOKEN_START;
	 public static final String TOKEN_END = FilterSet.DEFAULT_TOKEN_END;
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private String name;
	 private String description;
	 private Hashtable references = new AntRefTable();
	 private HashMap idReferences = new HashMap();
	 private Project parentIdProject = null;
	 private String defaultTarget;
	 private Hashtable targets = new Hashtable();
	 private FilterSet globalFilterSet = new FilterSet();
	 {
		 globalFilterSet.setProject(this);
	 }
	 private FilterSetCollection globalFilters = new FilterSetCollection(globalFilterSet);
	 private File baseDir;
	 private final Object listenersLock = new Object();
	 private volatile BuildListener[] listeners = new BuildListener[0];
	 private final ThreadLocal isLoggingMessage = new ThreadLocal() {
		 protected Object initialValue() {
			 return Boolean.FALSE;
		 }
	 }
	;
	 private ClassLoader coreLoader = null;
	 private final Map threadTasks = Collections.synchronizedMap(new WeakHashMap());
	 private final Map threadGroupTasks = Collections.synchronizedMap(new WeakHashMap());
	 private InputHandler inputHandler = null;
	 private InputStream defaultInputStream = null;
	 private boolean keepGoingMode = false;
	 public void setInputHandler(InputHandler handler) {
		 inputHandler = handler;
	 }
	 public void setDefaultInputStream(InputStream defaultInputStream) {
		 this.defaultInputStream = defaultInputStream;
	 }
	 public InputStream getDefaultInputStream() {
		 return defaultInputStream;
	 }
	 public InputHandler getInputHandler() {
		 return inputHandler;
	 }
	 public Project() {
		 inputHandler = new DefaultInputHandler();
	 }
	 public Project createSubProject() {
		 Project subProject = null;
		 try {
			 subProject = (Project) (getClass().newInstance());
		 }
		 catch (Exception e) {
			 subProject = new Project();
		 }
		 initSubProject(subProject);
		 return subProject;
	 }
	 public void initSubProject(Project subProject) {
		 ComponentHelper.getComponentHelper(subProject) .initSubProject(ComponentHelper.getComponentHelper(this));
		 subProject.setDefaultInputStream(getDefaultInputStream());
		 subProject.setKeepGoingMode(this.isKeepGoingMode());
		 subProject.setExecutor(getExecutor().getSubProjectExecutor());
	 }
	 public void init() throws BuildException {
		 initProperties();
		 ComponentHelper.getComponentHelper(this).initDefaultDefinitions();
	 }
	 public void initProperties() throws BuildException {
		 setJavaVersionProperty();
		 setSystemProperties();
		 setPropertyInternal(MagicNames.ANT_VERSION, Main.getAntVersion());
		 setAntLib();
	 }
	 private void setAntLib() {
		 File antlib = org.apache.tools.ant.launch.Locator.getClassSource( Project.class);
		 if (antlib != null) {
			 setPropertyInternal(MagicNames.ANT_LIB, antlib.getAbsolutePath());
		 }
	 }
	 public AntClassLoader createClassLoader(Path path) {
		 return AntClassLoader .newAntClassLoader(getClass().getClassLoader(), this, path, true);
	 }
	 public AntClassLoader createClassLoader( ClassLoader parent, Path path) {
		 return AntClassLoader.newAntClassLoader(parent, this, path, true);
	 }
	 public void setCoreLoader(ClassLoader coreLoader) {
		 this.coreLoader = coreLoader;
	 }
	 public ClassLoader getCoreLoader() {
		 return coreLoader;
	 }
	 public void addBuildListener(BuildListener listener) {
		 synchronized (listenersLock) {
			 for (int i = 0;
			 i < listeners.length;
			 i++) {
				 if (listeners[i] == listener) {
					 return;
				 }
			 }
			 BuildListener[] newListeners = new BuildListener[listeners.length + 1];
			 System.arraycopy(listeners, 0, newListeners, 0, listeners.length);
			 newListeners[listeners.length] = listener;
			 listeners = newListeners;
		 }
	 }
	 public void removeBuildListener(BuildListener listener) {
		 synchronized (listenersLock) {
			 for (int i = 0;
			 i < listeners.length;
			 i++) {
				 if (listeners[i] == listener) {
					 BuildListener[] newListeners = new BuildListener[listeners.length - 1];
					 System.arraycopy(listeners, 0, newListeners, 0, i);
					 System.arraycopy(listeners, i + 1, newListeners, i, listeners.length - i - 1);
					 listeners = newListeners;
					 break;
				 }
			 }
		 }
	 }
	 public Vector getBuildListeners() {
		 synchronized (listenersLock) {
			 Vector r = new Vector(listeners.length);
			 for (int i = 0;
			 i < listeners.length;
			 i++) {
				 r.add(listeners[i]);
			 }
			 return r;
		 }
	 }
	 public void log(String message) {
		 log(message, MSG_INFO);
	 }
	 public void log(String message, int msgLevel) {
		 log(message, null, msgLevel);
	 }
	 public void log(String message, Throwable throwable, int msgLevel) {
		 fireMessageLogged(this, message, throwable, msgLevel);
	 }
	 public void log(Task task, String message, int msgLevel) {
		 fireMessageLogged(task, message, null, msgLevel);
	 }
	 public void log(Task task, String message, Throwable throwable, int msgLevel) {
		 fireMessageLogged(task, message, throwable, msgLevel);
	 }
	 public void log(Target target, String message, int msgLevel) {
		 log(target, message, null, msgLevel);
	 }
	 public void log(Target target, String message, Throwable throwable, int msgLevel) {
		 fireMessageLogged(target, message, throwable, msgLevel);
	 }
	 public FilterSet getGlobalFilterSet() {
		 return globalFilterSet;
	 }
	 public void setProperty(String name, String value) {
		 PropertyHelper.getPropertyHelper(this).setProperty(name, value, true);
	 }
	 public void setNewProperty(String name, String value) {
		 PropertyHelper.getPropertyHelper(this).setNewProperty(name, value);
	 }
	 public void setUserProperty(String name, String value) {
		 PropertyHelper.getPropertyHelper(this).setUserProperty(name, value);
	 }
	 public void setInheritedProperty(String name, String value) {
		 PropertyHelper.getPropertyHelper(this).setInheritedProperty(name, value);
	 }
	 private void setPropertyInternal(String name, String value) {
		 PropertyHelper.getPropertyHelper(this).setProperty(name, value, false);
	 }
	 public String getProperty(String propertyName) {
		 Object value = PropertyHelper.getPropertyHelper(this).getProperty(propertyName);
		 return value == null ? null : String.valueOf(value);
	 }
	 public String replaceProperties(String value) throws BuildException {
		 return PropertyHelper.getPropertyHelper(this).replaceProperties(null, value, null);
	 }
	 public String getUserProperty(String propertyName) {
		 return (String) PropertyHelper.getPropertyHelper(this).getUserProperty(propertyName);
	 }
	 public Hashtable getProperties() {
		 return PropertyHelper.getPropertyHelper(this).getProperties();
	 }
	 public Hashtable getUserProperties() {
		 return PropertyHelper.getPropertyHelper(this).getUserProperties();
	 }
	 public Hashtable getInheritedProperties() {
		 return PropertyHelper.getPropertyHelper(this).getInheritedProperties();
	 }
	 public void copyUserProperties(Project other) {
		 PropertyHelper.getPropertyHelper(this).copyUserProperties(other);
	 }
	 public void copyInheritedProperties(Project other) {
		 PropertyHelper.getPropertyHelper(this).copyInheritedProperties(other);
	 }
	 public void setDefaultTarget(String defaultTarget) {
		 setDefault(defaultTarget);
	 }
	 public String getDefaultTarget() {
		 return defaultTarget;
	 }
	 public void setDefault(String defaultTarget) {
		 if (defaultTarget != null) {
			 setUserProperty(MagicNames.PROJECT_DEFAULT_TARGET, defaultTarget);
		 }
		 this.defaultTarget = defaultTarget;
	 }
	 public void setName(String name) {
		 setUserProperty(MagicNames.PROJECT_NAME, name);
		 this.name = name;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setDescription(String description) {
		 this.description = description;
	 }
	 public String getDescription() {
		 if (description == null) {
			 description = Description.getDescription(this);
		 }
		 return description;
	 }
	 public void addFilter(String token, String value) {
		 if (token == null) {
			 return;
		 }
		 globalFilterSet.addFilter(new FilterSet.Filter(token, value));
	 }
	 public Hashtable getFilters() {
		 return globalFilterSet.getFilterHash();
	 }
	 public void setBasedir(String baseD) throws BuildException {
		 setBaseDir(new File(baseD));
	 }
	 public void setBaseDir(File baseDir) throws BuildException {
		 baseDir = FILE_UTILS.normalize(baseDir.getAbsolutePath());
		 if (!baseDir.exists()) {
			 throw new BuildException(""Basedir "" + baseDir.getAbsolutePath() + "" does not exist"");
		 }
		 if (!baseDir.isDirectory()) {
			 throw new BuildException(""Basedir "" + baseDir.getAbsolutePath() + "" is not a directory"");
		 }
		 this.baseDir = baseDir;
		 setPropertyInternal(MagicNames.PROJECT_BASEDIR, this.baseDir.getPath());
		 String msg = ""Project base dir set to: "" + this.baseDir;
		 log(msg, MSG_VERBOSE);
	 }
	 public File getBaseDir() {
		 if (baseDir == null) {
			 try {
				 setBasedir(""."");
			 }
			 catch (BuildException ex) {
				 ex.printStackTrace();
			 }
		 }
		 return baseDir;
	 }
	 public void setKeepGoingMode(boolean keepGoingMode) {
		 this.keepGoingMode = keepGoingMode;
	 }
	 public boolean isKeepGoingMode() {
		 return this.keepGoingMode;
	 }
	 public static String getJavaVersion() {
		 return JavaEnvUtils.getJavaVersion();
	 }
	 public void setJavaVersionProperty() throws BuildException {
		 String javaVersion = JavaEnvUtils.getJavaVersion();
		 setPropertyInternal(MagicNames.ANT_JAVA_VERSION, javaVersion);
		 if (!JavaEnvUtils.isAtLeastJavaVersion(JavaEnvUtils.JAVA_1_4)) {
			 throw new BuildException(""Ant cannot work on Java prior to 1.4"");
		 }
		 log(""Detected Java version: "" + javaVersion + "" in: "" + System.getProperty(""java.home""), MSG_VERBOSE);
		 log(""Detected OS: "" + System.getProperty(""os.name""), MSG_VERBOSE);
	 }
	 public void setSystemProperties() {
		 Properties systemP = System.getProperties();
		 Enumeration e = systemP.propertyNames();
		 while (e.hasMoreElements()) {
			 String propertyName = (String) e.nextElement();
			 String value = systemP.getProperty(propertyName);
			 if (value != null) {
				 this.setPropertyInternal(propertyName, value);
			 }
		 }
	 }
	 public void addTaskDefinition(String taskName, Class taskClass) throws BuildException {
		 ComponentHelper.getComponentHelper(this).addTaskDefinition(taskName, taskClass);
	 }
	 public void checkTaskClass(final Class taskClass) throws BuildException {
		 ComponentHelper.getComponentHelper(this).checkTaskClass(taskClass);
		 if (!Modifier.isPublic(taskClass.getModifiers())) {
			 final String message = taskClass + "" is not public"";
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message);
		 }
		 if (Modifier.isAbstract(taskClass.getModifiers())) {
			 final String message = taskClass + "" is abstract"";
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message);
		 }
		 try {
			 taskClass.getConstructor((Class[]) null);
		 }
		 catch (NoSuchMethodException e) {
			 final String message = ""No public no-arg constructor in "" + taskClass;
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message);
		 }
		 catch (LinkageError e) {
			 String message = ""Could not load "" + taskClass + "": "" + e;
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message, e);
		 }
		 if (!Task.class.isAssignableFrom(taskClass)) {
			 TaskAdapter.checkTaskClass(taskClass, this);
		 }
	 }
	 public Hashtable getTaskDefinitions() {
		 return ComponentHelper.getComponentHelper(this).getTaskDefinitions();
	 }
	 public Map getCopyOfTaskDefinitions() {
		 return new HashMap(getTaskDefinitions());
	 }
	 public void addDataTypeDefinition(String typeName, Class typeClass) {
		 ComponentHelper.getComponentHelper(this).addDataTypeDefinition(typeName, typeClass);
	 }
	 public Hashtable getDataTypeDefinitions() {
		 return ComponentHelper.getComponentHelper(this).getDataTypeDefinitions();
	 }
	 public Map getCopyOfDataTypeDefinitions() {
		 return new HashMap(getDataTypeDefinitions());
	 }
	 public void addTarget(Target target) throws BuildException {
		 addTarget(target.getName(), target);
	 }
	 public void addTarget(String targetName, Target target) throws BuildException {
		 if (targets.get(targetName) != null) {
			 throw new BuildException(""Duplicate target: `"" + targetName + ""'"");
		 }
		 addOrReplaceTarget(targetName, target);
	 }
	 public void addOrReplaceTarget(Target target) {
		 addOrReplaceTarget(target.getName(), target);
	 }
	 public void addOrReplaceTarget(String targetName, Target target) {
		 String msg = "" +Target: "" + targetName;
		 log(msg, MSG_DEBUG);
		 target.setProject(this);
		 targets.put(targetName, target);
	 }
	 public Hashtable getTargets() {
		 return targets;
	 }
	 public Map getCopyOfTargets() {
		 return new HashMap(targets);
	 }
	 public Task createTask(String taskType) throws BuildException {
		 return ComponentHelper.getComponentHelper(this).createTask(taskType);
	 }
	 public Object createDataType(String typeName) throws BuildException {
		 return ComponentHelper.getComponentHelper(this).createDataType(typeName);
	 }
	 public void setExecutor(Executor e) {
		 addReference(MagicNames.ANT_EXECUTOR_REFERENCE, e);
	 }
	 public Executor getExecutor() {
		 Object o = getReference(MagicNames.ANT_EXECUTOR_REFERENCE);
		 if (o == null) {
			 String classname = getProperty(MagicNames.ANT_EXECUTOR_CLASSNAME);
			 if (classname == null) {
				 classname = DefaultExecutor.class.getName();
			 }
			 log(""Attempting to create object of type "" + classname, MSG_DEBUG);
			 try {
				 o = Class.forName(classname, true, coreLoader).newInstance();
			 }
			 catch (ClassNotFoundException seaEnEfEx) {
				 try {
					 o = Class.forName(classname).newInstance();
				 }
				 catch (Exception ex) {
					 log(ex.toString(), MSG_ERR);
				 }
			 }
			 catch (Exception ex) {
				 log(ex.toString(), MSG_ERR);
			 }
			 if (o == null) {
				 throw new BuildException( ""Unable to obtain a Target Executor instance."");
			 }
			 setExecutor((Executor) o);
		 }
		 return (Executor) o;
	 }
	 public void executeTargets(Vector names) throws BuildException {
		 setUserProperty(MagicNames.PROJECT_INVOKED_TARGETS, CollectionUtils.flattenToString(names));
		 getExecutor().executeTargets(this, (String[]) (names.toArray(new String[names.size()])));
	 }
	 public void demuxOutput(String output, boolean isWarning) {
		 Task task = getThreadTask(Thread.currentThread());
		 if (task == null) {
			 log(output, isWarning ? MSG_WARN : MSG_INFO);
		 }
		 else {
			 if (isWarning) {
				 task.handleErrorOutput(output);
			 }
			 else {
				 task.handleOutput(output);
			 }
		 }
	 }
	 public int defaultInput(byte[] buffer, int offset, int length) throws IOException {
		 if (defaultInputStream != null) {
			 System.out.flush();
			 return defaultInputStream.read(buffer, offset, length);
		 }
		 else {
			 throw new EOFException(""No input provided for project"");
		 }
	 }
	 public int demuxInput(byte[] buffer, int offset, int length) throws IOException {
		 Task task = getThreadTask(Thread.currentThread());
		 if (task == null) {
			 return defaultInput(buffer, offset, length);
		 }
		 else {
			 return task.handleInput(buffer, offset, length);
		 }
	 }
	 public void demuxFlush(String output, boolean isError) {
		 Task task = getThreadTask(Thread.currentThread());
		 if (task == null) {
			 fireMessageLogged(this, output, isError ? MSG_ERR : MSG_INFO);
		 }
		 else {
			 if (isError) {
				 task.handleErrorFlush(output);
			 }
			 else {
				 task.handleFlush(output);
			 }
		 }
	 }
	 public void executeTarget(String targetName) throws BuildException {
		 if (targetName == null) {
			 String msg = ""No target specified"";
			 throw new BuildException(msg);
		 }
		 executeSortedTargets(topoSort(targetName, targets, false));
	 }
	 public void executeSortedTargets(Vector sortedTargets) throws BuildException {
		 Set succeededTargets = new HashSet();
		 BuildException buildException = null;
		 for (Enumeration iter = sortedTargets.elements();
		 iter.hasMoreElements();
		) {
			 Target curtarget = (Target) iter.nextElement();
			 boolean canExecute = true;
			 for (Enumeration depIter = curtarget.getDependencies();
			 depIter.hasMoreElements();
			) {
				 String dependencyName = ((String) depIter.nextElement());
				 if (!succeededTargets.contains(dependencyName)) {
					 canExecute = false;
					 log(curtarget, ""Cannot execute '"" + curtarget.getName() + ""' - '"" + dependencyName + ""' failed or was not executed."", MSG_ERR);
					 break;
				 }
			 }
			 if (canExecute) {
				 Throwable thrownException = null;
				 try {
					 curtarget.performTasks();
					 succeededTargets.add(curtarget.getName());
				 }
				 catch (RuntimeException ex) {
					 if (!(keepGoingMode)) {
						 throw ex;
					 }
					 thrownException = ex;
				 }
				 catch (Throwable ex) {
					 if (!(keepGoingMode)) {
						 throw new BuildException(ex);
					 }
					 thrownException = ex;
				 }
				 if (thrownException != null) {
					 if (thrownException instanceof BuildException) {
						 log(curtarget, ""Target '"" + curtarget.getName() + ""' failed with message '"" + thrownException.getMessage() + ""'."", MSG_ERR);
						 if (buildException == null) {
							 buildException = (BuildException) thrownException;
						 }
					 }
					 else {
						 log(curtarget, ""Target '"" + curtarget.getName() + ""' failed with message '"" + thrownException.getMessage() + ""'."", MSG_ERR);
						 thrownException.printStackTrace(System.err);
						 if (buildException == null) {
							 buildException = new BuildException(thrownException);
						 }
					 }
				 }
			 }
		 }
		 if (buildException != null) {
			 throw buildException;
		 }
	 }
	 public File resolveFile(String fileName, File rootDir) {
		 return FILE_UTILS.resolveFile(rootDir, fileName);
	 }
	 public File resolveFile(String fileName) {
		 return FILE_UTILS.resolveFile(baseDir, fileName);
	 }
	 public static String translatePath(String toProcess) {
		 return FileUtils.translatePath(toProcess);
	 }
	 public void copyFile(String sourceFile, String destFile) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering, boolean overwrite) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering, boolean overwrite, boolean preserveLastModified) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite, preserveLastModified);
	 }
	 public void copyFile(File sourceFile, File destFile) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering, boolean overwrite) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering, boolean overwrite, boolean preserveLastModified) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite, preserveLastModified);
	 }
	 public void setFileLastModified(File file, long time) throws BuildException {
		 FILE_UTILS.setFileLastModified(file, time);
		 log(""Setting modification time for "" + file, MSG_VERBOSE);
	 }
	 public static boolean toBoolean(String s) {
		 return (""on"".equalsIgnoreCase(s) || ""true"".equalsIgnoreCase(s) || ""yes"".equalsIgnoreCase(s));
	 }
	 public static Project getProject(Object o) {
		 if (o instanceof ProjectComponent) {
			 return ((ProjectComponent) o).getProject();
		 }
		 try {
			 Method m = o.getClass().getMethod(""getProject"", (Class[]) null);
			 if (Project.class == m.getReturnType()) {
				 return (Project) m.invoke(o, (Object[]) null);
			 }
		 }
		 catch (Exception e) {
		 }
		 return null;
	 }
	 public final Vector topoSort(String root, Hashtable targetTable) throws BuildException {
		 return topoSort(new String[] {
		root}
		, targetTable, true);
	 }
	 public final Vector topoSort(String root, Hashtable targetTable, boolean returnAll) throws BuildException {
		 return topoSort(new String[] {
		root}
		, targetTable, returnAll);
	 }
	 public final Vector topoSort(String[] root, Hashtable targetTable, boolean returnAll) throws BuildException {
		 Vector ret = new VectorSet();
		 Hashtable state = new Hashtable();
		 Stack visiting = new Stack();
		 for (int i = 0;
		 i < root.length;
		 i++) {
			 String st = (String) (state.get(root[i]));
			 if (st == null) {
				 tsort(root[i], targetTable, state, visiting, ret);
			 }
			 else if (st == VISITING) {
				 throw new RuntimeException(""Unexpected node in visiting state: "" + root[i]);
			 }
		 }
		 StringBuffer buf = new StringBuffer(""Build sequence for target(s)"");
		 for (int j = 0;
		 j < root.length;
		 j++) {
			 buf.append((j == 0) ? "" `"" : "", `"").append(root[j]).append('\'');
		 }
		 buf.append("" is "" + ret);
		 log(buf.toString(), MSG_VERBOSE);
		 Vector complete = (returnAll) ? ret : new Vector(ret);
		 for (Enumeration en = targetTable.keys();
		 en.hasMoreElements();
		) {
			 String curTarget = (String) en.nextElement();
			 String st = (String) state.get(curTarget);
			 if (st == null) {
				 tsort(curTarget, targetTable, state, visiting, complete);
			 }
			 else if (st == VISITING) {
				 throw new RuntimeException(""Unexpected node in visiting state: "" + curTarget);
			 }
		 }
		 log(""Complete build sequence is "" + complete, MSG_VERBOSE);
		 return ret;
	 }
	 private void tsort(String root, Hashtable targetTable, Hashtable state, Stack visiting, Vector ret) throws BuildException {
		 state.put(root, VISITING);
		 visiting.push(root);
		 Target target = (Target) targetTable.get(root);
		 if (target == null) {
			 StringBuffer sb = new StringBuffer(""Target \"""");
			 sb.append(root);
			 sb.append(""\"" does not exist in the project \"""");
			 sb.append(name);
			 sb.append(""\"". "");
			 visiting.pop();
			 if (!visiting.empty()) {
				 String parent = (String) visiting.peek();
				 sb.append(""It is used from target \"""");
				 sb.append(parent);
				 sb.append(""\""."");
			 }
			 throw new BuildException(new String(sb));
		 }
		 for (Enumeration en = target.getDependencies();
		 en.hasMoreElements();
		) {
			 String cur = (String) en.nextElement();
			 String m = (String) state.get(cur);
			 if (m == null) {
				 tsort(cur, targetTable, state, visiting, ret);
			 }
			 else if (m == VISITING) {
				 throw makeCircularException(cur, visiting);
			 }
		 }
		 String p = (String) visiting.pop();
		 if (root != p) {
			 throw new RuntimeException(""Unexpected internal error: expected to "" + ""pop "" + root + "" but got "" + p);
		 }
		 state.put(root, VISITED);
		 ret.addElement(target);
	 }
	 private static BuildException makeCircularException(String end, Stack stk) {
		 StringBuffer sb = new StringBuffer(""Circular dependency: "");
		 sb.append(end);
		 String c;
		 do {
			 c = (String) stk.pop();
			 sb.append("" <- "");
			 sb.append(c);
		 }
		 while (!c.equals(end));
		 return new BuildException(new String(sb));
	 }
	 public void inheritIDReferences(Project parent) {
		 parentIdProject = parent;
	 }
	 public void addIdReference(String id, Object value) {
		 idReferences.put(id, value);
	 }
	 public void addReference(String referenceName, Object value) {
		 Object old = ((AntRefTable) references).getReal(referenceName);
		 if (old == value) {
			 return;
		 }
		 if (old != null && !(old instanceof UnknownElement)) {
			 log(""Overriding previous definition of reference to "" + referenceName, MSG_VERBOSE);
		 }
		 log(""Adding reference: "" + referenceName, MSG_DEBUG);
		 references.put(referenceName, value);
	 }
	 public Hashtable getReferences() {
		 return references;
	 }
	 public boolean hasReference(String key) {
		 return references.containsKey(key);
	 }
	 public Map getCopyOfReferences() {
		 return new HashMap(references);
	 }
	 public Object getReference(String key) {
		 Object ret = references.get(key);
		 if (ret != null) {
			 return ret;
		 }
		 if (!key.equals(MagicNames.REFID_PROPERTY_HELPER)) {
			 try {
				 if (PropertyHelper.getPropertyHelper(this).containsProperties(key)) {
					 log(""Unresolvable reference "" + key + "" might be a misuse of property expansion syntax."", MSG_WARN);
				 }
			 }
			 catch (Exception e) {
			 }
		 }
		 return ret;
	 }
	 public String getElementName(Object element) {
		 return ComponentHelper.getComponentHelper(this).getElementName(element);
	 }
	 public void fireBuildStarted() {
		 BuildEvent event = new BuildEvent(this);
		 BuildListener[] currListeners = listeners;
		 for (int i = 0;
		 i < currListeners.length;
		 i++) {
			 currListeners[i].buildStarted(event);
		 }
	 }
	 public void fireBuildFinished(Throwable exception) {
		 BuildEvent event = new BuildEvent(this);
		 event.setException(exception);
		 BuildListener[] currListeners = listeners;
		 for (int i = 0;
		 i < currListeners.length;
		 i++) {
			 currListeners[i].buildFinished(event);
		 }
		 IntrospectionHelper.clearCache();
	 }
	 public void fireSubBuildStarted() {
		 BuildEvent event = new BuildEvent(this);
		 BuildListener[] currListeners = listeners;
		 for (int i = 0;
		 i < currListeners.length;
		 i++) {
			 if (currListeners[i] instanceof SubBuildListener) {
				 ((SubBuildListener) currListeners[i]).subBuildStarted(event);
			 }
		 }
	 }
	 public void fireSubBuildFinished(Throwable exception) {
		 BuildEvent event = new BuildEvent(this);
		 event.setException(exception);
		 BuildListener[] currListeners = listeners;
		 for (int i = 0;
		 i < currListeners.length;
		 i++) {
			 if (currListeners[i] instanceof SubBuildListener) {
				 ((SubBuildListener) currListeners[i]).subBuildFinished(event);
			 }
		 }
	 }
	 protected void fireTargetStarted(Target target) {
		 BuildEvent event = new BuildEvent(target);
		 BuildListener[] currListeners = listeners;
		 for (int i = 0;
		 i < currListeners.length;
		 i++) {
			 currListeners[i].targetStarted(event);
		 }
	 }
	 protected void fireTargetFinished(Target target, Throwable exception) {
		 BuildEvent event = new BuildEvent(target);
		 event.setException(exception);
		 BuildListener[] currListeners = listeners;
		 for (int i = 0;
		 i < currListeners.length;
		 i++) {
			 currListeners[i].targetFinished(event);
		 }
	 }
	 protected void fireTaskStarted(Task task) {
		 registerThreadTask(Thread.currentThread(), task);
		 BuildEvent event = new BuildEvent(task);
		 BuildListener[] currListeners = listeners;
		 for (int i = 0;
		 i < currListeners.length;
		 i++) {
			 currListeners[i].taskStarted(event);
		 }
	 }
	 protected void fireTaskFinished(Task task, Throwable exception) {
		 registerThreadTask(Thread.currentThread(), null);
		 System.out.flush();
		 System.err.flush();
		 BuildEvent event = new BuildEvent(task);
		 event.setException(exception);
		 BuildListener[] currListeners = listeners;
		 for (int i = 0;
		 i < currListeners.length;
		 i++) {
			 currListeners[i].taskFinished(event);
		 }
	 }
	 private void fireMessageLoggedEvent(BuildEvent event, String message, int priority) {
		 if (message == null) {
			 message = String.valueOf(message);
		 }
		 if (message.endsWith(StringUtils.LINE_SEP)) {
			 int endIndex = message.length() - StringUtils.LINE_SEP.length();
			 event.setMessage(message.substring(0, endIndex), priority);
		 }
		 else {
			 event.setMessage(message, priority);
		 }
		 if (isLoggingMessage.get() != Boolean.FALSE) {
			 return;
		 }
		 try {
			 isLoggingMessage.set(Boolean.TRUE);
			 BuildListener[] currListeners = listeners;
			 for (int i = 0;
			 i < currListeners.length;
			 i++) {
				 currListeners[i].messageLogged(event);
			 }
		 }
		 finally {
			 isLoggingMessage.set(Boolean.FALSE);
		 }
	 }
	 protected void fireMessageLogged(Project project, String message, int priority) {
		 fireMessageLogged(project, message, null, priority);
	 }
	 protected void fireMessageLogged(Project project, String message, Throwable throwable, int priority) {
		 BuildEvent event = new BuildEvent(project);
		 event.setException(throwable);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 protected void fireMessageLogged(Target target, String message, int priority) {
		 fireMessageLogged(target, message, null, priority);
	 }
	 protected void fireMessageLogged(Target target, String message, Throwable throwable, int priority) {
		 BuildEvent event = new BuildEvent(target);
		 event.setException(throwable);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 protected void fireMessageLogged(Task task, String message, int priority) {
		 fireMessageLogged(task, message, null, priority);
	 }
	 protected void fireMessageLogged(Task task, String message, Throwable throwable, int priority) {
		 BuildEvent event = new BuildEvent(task);
		 event.setException(throwable);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 public void registerThreadTask(Thread thread, Task task) {
		 synchronized(threadTasks) {
			 if (task != null) {
				 threadTasks.put(thread, task);
				 threadGroupTasks.put(thread.getThreadGroup(), task);
			 }
			 else {
				 threadTasks.remove(thread);
				 threadGroupTasks.remove(thread.getThreadGroup());
			 }
		 }
	 }
	 public Task getThreadTask(Thread thread) {
		 synchronized(threadTasks) {
			 Task task = (Task) threadTasks.get(thread);
			 if (task == null) {
				 ThreadGroup group = thread.getThreadGroup();
				 while (task == null && group != null) {
					 task = (Task) threadGroupTasks.get(group);
					 group = group.getParent();
				 }
			 }
			 return task;
		 }
	 }
	 private static class AntRefTable extends Hashtable {
		 AntRefTable() {
			 super();
		 }
		 private Object getReal(Object key) {
			 return super.get(key);
		 }
		 public Object get(Object key) {
			 Object o = getReal(key);
			 if (o instanceof UnknownElement) {
				 UnknownElement ue = (UnknownElement) o;
				 ue.maybeConfigure();
				 o = ue.getRealThing();
			 }
			 return o;
		 }
	 }
	 public final void setProjectReference(final Object obj) {
		 if (obj instanceof ProjectComponent) {
			 ((ProjectComponent) obj).setProject(this);
			 return;
		 }
		 try {
			 Method method = obj.getClass().getMethod( ""setProject"", new Class[] {
			Project.class}
			);
			 if (method != null) {
				 method.invoke(obj, new Object[] {
				this}
				);
			 }
		 }
		 catch (Throwable e) {
		 }
	 }
	 public Resource getResource(String name) {
		 return new FileResource(getBaseDir(), name);
	 }
}",1,0,0,0
"public class AddEditNameUrlDialog extends Dialog {
	AbstractNameUrlPreferenceModel model;
	Text nameText;
	Text urlText;
	String name;
	String urlString;
	private final String explanatoryText;
	protected Label errorTextLabel;
	protected Composite composite;
	private String title;
	public AddEditNameUrlDialog(Shell parent, AbstractNameUrlPreferenceModel aModel, NameUrlPair nameUrl,String headerText) {
		super(parent);
		explanatoryText = headerText;
		model = aModel;
		if (nameUrl != null) {
			name = nameUrl.getName();
			urlString = nameUrl.getUrlString();
		}
		else {
			name = null;
			urlString = null;
		}
	}
	protected Control createDialogArea(Composite parent) {
		composite = new Composite(parent, SWT.NONE);
		GridLayoutFactory.fillDefaults().numColumns(2).extendedMargins(5, 13, 10, 0).applyTo(composite);
		GridDataFactory.fillDefaults().grab(true, true).applyTo(composite);
		Label explanatoryTextLabel = new Label(composite, SWT.WRAP);
		explanatoryTextLabel.setText(explanatoryText);
		GridDataFactory.fillDefaults().grab(true, false).span(2, 1).applyTo(explanatoryTextLabel);
		Label nameLabel = new Label(composite, SWT.NONE);
		nameLabel.setText(NLS.bind(""Name:"", null));
		nameLabel.setLayoutData(new GridData(SWT.LEFT, SWT.TOP, false, false, 1, 1));
		nameText = new Text(composite, SWT.BORDER + SWT.FILL);
		GridDataFactory.fillDefaults().grab(true, false).hint(300, SWT.DEFAULT).applyTo(nameText);
		nameText.setEditable(true);
		if (name != null && name.length() > 0) {
			nameText.setText(name);
		}
		Label urlLabel = new Label(composite, SWT.NONE);
		urlLabel.setText(NLS.bind(""URL:"", null));
		urlLabel.setLayoutData(new GridData(SWT.LEFT, SWT.TOP, false, false, 1, 1));
		urlText = new Text(composite, SWT.BORDER);
		GridDataFactory.fillDefaults().grab(true, false).hint(300, SWT.DEFAULT).applyTo(urlText);
		urlText.setEditable(true);
		if (urlString != null && urlString.length() > 0) {
			urlText.setText(urlString);
		}
		urlText.addKeyListener(getUrlValidationListener());
		String errorText = """";
		errorTextLabel = new Label(composite, SWT.WRAP);
		errorTextLabel.setText(errorText);
		GridDataFactory.fillDefaults().grab(true, false).span(2, 1).applyTo(errorTextLabel);
		return composite;
	}
	public void create() {
		super.create();
		if (title != null) {
			getShell().setText(title);
		}
		getButton(IDialogConstants.OK_ID).setEnabled(validateUrl(urlString));
	}
	protected KeyListener getUrlValidationListener() {
		return new KeyListener() {
			public void keyReleased(KeyEvent e) {
				String urlString = ((Text) e.getSource()).getText().trim();
				if (!validateUrl(urlString)) {
					getButton(IDialogConstants.OK_ID).setEnabled(false);
				}
				else {
					errorTextLabel.setText("""");
					composite.update();
					getButton(IDialogConstants.OK_ID).setEnabled(true);
				}
			}
			public void keyPressed(KeyEvent e) {
			}
		}
		;
	}
	protected void okPressed() {
		name = nameText.getText();
		urlString = urlText.getText();
		if (urlString.length() > 0) {
			if (name.length() <= 0) {
				name = urlString;
			}
		}
		super.okPressed();
	}
	public String getUrlString() {
		return urlString;
	}
	public String getName() {
		return name;
	}
	protected boolean validateUrl(String urlString) {
		if (urlString != null && urlString.contains("" "")) {
			urlString = urlString.replace("" "", ""%20"");
			int caret = urlText.getCaretPosition();
			urlText.setText(urlString);
			urlText.setSelection(caret + ""%20"".length() - 1);
		}
		if (urlString == null || urlString.length() <= 0) {
			return false;
		}
		try {
			new URI(urlString);
		}
		catch (URISyntaxException e) {
			return showError();
		}
		try {
			URL url = new URL(urlString);
			if (url.getHost().isEmpty()) {
				return showError();
			}
		}
		catch (MalformedURLException e) {
			return showError();
		}
		return true;
	}
	private boolean showError() {
		errorTextLabel.setText(AddEditNameUrlDialogMessages.malformedUrl);
		composite.update();
		return false;
	}
	protected void setTitle(String title) {
		this.title = title;
	}
}",1,1,0,0
"private void bsPutint(int u) throws IOException {
	 bsW(8, (u >> 24) & 0xff);
	 bsW(8, (u >> 16) & 0xff);
	 bsW(8, (u >> 8) & 0xff);
	 bsW(8, u & 0xff);
 }",0,0,0,0
"public interface Script {
	 public Object exec(Context cx, Scriptable scope);
}",0,0,0,0
"public class TokenProduction {
	 public static final int TOKEN = 0, SKIP = 1, MORE = 2, SPECIAL = 3;
	 public static final String[] kindImage = {
	 ""TOKEN"", ""SKIP"", ""MORE"", ""SPECIAL"" }
	;
	 private int column;
	 private int line;
	 public String[] lexStates;
	 public int kind;
	 public List respecs = new ArrayList();
	 public boolean isExplicit = true;
	 public boolean ignoreCase = false;
	 public Token firstToken, lastToken;
	 public void setLine(int line) {
		 this.line = line;
	 }
	 public int getLine() {
		 return line;
	 }
	 public void setColumn(int column) {
		 this.column = column;
	 }
	 public int getColumn() {
		 return column;
	 }
}",0,1,0,0
"protected void fireTaskStarted(Task task) {
	 registerThreadTask(Thread.currentThread(), task);
	 BuildEvent event = new BuildEvent(task);
	 BuildListener[] currListeners = listeners;
	 for (int i = 0;
	 i < currListeners.length;
	 i++) {
		 currListeners[i].taskStarted(event);
	 }
 }",0,0,0,0
"protected JRBaseBreak(JRBreak breakElement, JRBaseObjectFactory factory);",0,0,0,0
"public class TestDataBag {
	 private Random rand = new Random(111);
	 private class TestMemoryManager {
		 ArrayList<Spillable> mManagedObjects = new ArrayList<Spillable>();
		 public void register(Spillable s) {
			 mManagedObjects.add(s);
		 }
		 public void forceSpill() throws IOException {
			 for (Spillable spillable : mManagedObjects) {
				 spillable.spill();
			 }
		 }
	 }
	 private class LocalBagFactory {
		 TestMemoryManager mMemMgr;
		 public LocalBagFactory(TestMemoryManager mgr) {
			 mMemMgr = mgr;
		 }
		 public DataBag newDefaultBag() {
			 DataBag bag = new DefaultDataBag();
			 mMemMgr.register(bag);
			 return bag;
		 }
		 public DataBag newSortedBag(Comparator<Tuple> comp) {
			 DataBag bag = new SortedDataBag(comp);
			 mMemMgr.register(bag);
			 return bag;
		 }
		 public DataBag newDistinctBag() {
			 DataBag bag = new DistinctDataBag();
			 mMemMgr.register(bag);
			 return bag;
		 }
	 }
	 public void tearDown() throws Exception {
		 BagFactory.resetSelf();
		 System.clearProperty(""pig.data.bag.factory.name"");
		 System.clearProperty(""pig.data.bag.factory.jar"");
	 }
	 public void testDefaultInMemory() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newDefaultBag();
		 ArrayList<Tuple> rightAnswer = new ArrayList<Tuple>(10);
		 for (int i = 0;
		 i < 10;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(i));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 Iterator<Tuple> rIter = rightAnswer.iterator();
		 while (rIter.hasNext()) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testDefaultSingleSpill() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newDefaultBag();
		 ArrayList<Tuple> rightAnswer = new ArrayList<Tuple>(10);
		 for (int i = 0;
		 i < 10;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(i));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 mgr.forceSpill();
		 Iterator<Tuple> bIter = b.iterator();
		 Iterator<Tuple> rIter = rightAnswer.iterator();
		 while (rIter.hasNext()) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testDefaultTripleSpill() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newDefaultBag();
		 ArrayList<Tuple> rightAnswer = new ArrayList<Tuple>(30);
		 for (int j = 0;
		 j < 3;
		 j++) {
			 for (int i = 0;
			 i < 10;
			 i++) {
				 Tuple t = TupleFactory.getInstance().newTuple(new Integer(i));
				 b.add(t);
				 rightAnswer.add(t);
			 }
			 mgr.forceSpill();
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 Iterator<Tuple> rIter = rightAnswer.iterator();
		 while (rIter.hasNext()) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testTypedTupleSpill() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newDefaultBag();
		 ArrayList<Tuple> rightAnswer = new ArrayList<Tuple>(30);
		 for (int j = 0;
		 j < 3;
		 j++) {
			 for (int i = 0;
			 i < 10;
			 i++) {
				 Tuple t = TupleFactory.getInstance().newTuple(new Integer(i));
				 b.add(t);
				 rightAnswer.add(t);
			 }
			 mgr.forceSpill();
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 Iterator<Tuple> rIter = rightAnswer.iterator();
		 while (rIter.hasNext()) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testDefaultInMemInFile() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newDefaultBag();
		 ArrayList<Tuple> rightAnswer = new ArrayList<Tuple>(20);
		 for (int i = 0;
		 i < 10;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(i));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 mgr.forceSpill();
		 for (int i = 0;
		 i < 10;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(i));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 Iterator<Tuple> rIter = rightAnswer.iterator();
		 while (rIter.hasNext()) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testDefaultSpillDuringRead() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newDefaultBag();
		 ArrayList<Tuple> rightAnswer = new ArrayList<Tuple>(20);
		 for (int i = 0;
		 i < 10;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(i));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 mgr.forceSpill();
		 for (int i = 0;
		 i < 10;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(i));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 Iterator<Tuple> rIter = rightAnswer.iterator();
		 for (int i = 0;
		 i < 15;
		 i++) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 mgr.forceSpill();
		 while (rIter.hasNext()) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testSortedInMemory() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newSortedBag(null);
		 PriorityQueue<Tuple> rightAnswer = new PriorityQueue<Tuple>(10);
		 for (int i = 0;
		 i < 10;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt()));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 Tuple t;
		 while ((t = rightAnswer.poll()) != null) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), t);
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testSortedSingleSpill() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newSortedBag(null);
		 PriorityQueue<Tuple> rightAnswer = new PriorityQueue<Tuple>(10);
		 for (int i = 0;
		 i < 10;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt()));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 mgr.forceSpill();
		 Iterator<Tuple> bIter = b.iterator();
		 Tuple t;
		 while ((t = rightAnswer.poll()) != null) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), t);
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testSortedTripleSpill() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newSortedBag(null);
		 PriorityQueue<Tuple> rightAnswer = new PriorityQueue<Tuple>(30);
		 for (int j = 0;
		 j < 3;
		 j++) {
			 for (int i = 0;
			 i < 10;
			 i++) {
				 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt()));
				 b.add(t);
				 rightAnswer.add(t);
			 }
			 mgr.forceSpill();
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 Tuple t;
		 while ((t = rightAnswer.poll()) != null) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), t);
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testSortedInMemInFile() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newSortedBag(null);
		 PriorityQueue<Tuple> rightAnswer = new PriorityQueue<Tuple>(20);
		 for (int i = 0;
		 i < 10;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt()));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 mgr.forceSpill();
		 for (int i = 0;
		 i < 10;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt()));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 Tuple t;
		 while ((t = rightAnswer.poll()) != null) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), t);
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testSortedSpillDuringRead() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newSortedBag(null);
		 PriorityQueue<Tuple> rightAnswer = new PriorityQueue<Tuple>(20);
		 for (int i = 0;
		 i < 10;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt()));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 mgr.forceSpill();
		 for (int i = 0;
		 i < 10;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt()));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 for (int i = 0;
		 i < 15;
		 i++) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rightAnswer.poll());
		 }
		 mgr.forceSpill();
		 Tuple t;
		 while ((t = rightAnswer.poll()) != null) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), t);
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testSortedFirstSpillDuringRead() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newSortedBag(null);
		 PriorityQueue<Tuple> rightAnswer = new PriorityQueue<Tuple>(20);
		 for (int i = 0;
		 i < 10;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt()));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 for (int i = 0;
		 i < 5;
		 i++) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rightAnswer.poll());
		 }
		 mgr.forceSpill();
		 Tuple t;
		 while ((t = rightAnswer.poll()) != null) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), t);
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testSortedPreMerge() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newSortedBag(null);
		 PriorityQueue<Tuple> rightAnswer = new PriorityQueue<Tuple>(30);
		 for (int j = 0;
		 j < 373;
		 j++) {
			 for (int i = 0;
			 i < 10;
			 i++) {
				 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt()));
				 b.add(t);
				 rightAnswer.add(t);
			 }
			 mgr.forceSpill();
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 Tuple t;
		 while ((t = rightAnswer.poll()) != null) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), t);
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testDistinctInMemory() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newDistinctBag();
		 TreeSet<Tuple> rightAnswer = new TreeSet<Tuple>();
		 for (int i = 0;
		 i < 50;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt() % 5));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 Iterator<Tuple> rIter = rightAnswer.iterator();
		 while (rIter.hasNext()) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testDistinctSingleSpill() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newDistinctBag();
		 TreeSet<Tuple> rightAnswer = new TreeSet<Tuple>();
		 for (int i = 0;
		 i < 50;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt() % 5));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 mgr.forceSpill();
		 Iterator<Tuple> bIter = b.iterator();
		 Iterator<Tuple> rIter = rightAnswer.iterator();
		 while (rIter.hasNext()) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testDistinctTripleSpill() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newDistinctBag();
		 TreeSet<Tuple> rightAnswer = new TreeSet<Tuple>();
		 for (int j = 0;
		 j < 3;
		 j++) {
			 for (int i = 0;
			 i < 50;
			 i++) {
				 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt() % 5));
				 b.add(t);
				 rightAnswer.add(t);
			 }
			 mgr.forceSpill();
		 }
		 assertEquals(""Size of distinct data bag is incorrect"", rightAnswer.size(), b.size());
		 Iterator<Tuple> bIter = b.iterator();
		 Iterator<Tuple> rIter = rightAnswer.iterator();
		 while (rIter.hasNext()) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testDistinctInMemInFile() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newDistinctBag();
		 TreeSet<Tuple> rightAnswer = new TreeSet<Tuple>();
		 for (int i = 0;
		 i < 50;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt() % 5));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 mgr.forceSpill();
		 for (int i = 0;
		 i < 50;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(i));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 Iterator<Tuple> rIter = rightAnswer.iterator();
		 while (rIter.hasNext()) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testDistinctSpillDuringRead() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newDistinctBag();
		 TreeSet<Tuple> rightAnswer = new TreeSet<Tuple>();
		 for (int i = 0;
		 i < 50;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt() % 5));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 mgr.forceSpill();
		 for (int i = 0;
		 i < 50;
		 i++) {
			 Tuple t = TupleFactory.getInstance().newTuple(new Integer(i));
			 b.add(t);
			 rightAnswer.add(t);
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 Iterator<Tuple> rIter = rightAnswer.iterator();
		 for (int i = 0;
		 i < 5;
		 i++) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 mgr.forceSpill();
		 while (rIter.hasNext()) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testDistinctPreMerge() throws Exception {
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag b = factory.newDistinctBag();
		 TreeSet<Tuple> rightAnswer = new TreeSet<Tuple>();
		 for (int j = 0;
		 j < 321;
		 j++) {
			 for (int i = 0;
			 i < 50;
			 i++) {
				 Tuple t = TupleFactory.getInstance().newTuple(new Integer(rand.nextInt() % 5));
				 b.add(t);
				 rightAnswer.add(t);
			 }
			 mgr.forceSpill();
		 }
		 Iterator<Tuple> bIter = b.iterator();
		 Iterator<Tuple> rIter = rightAnswer.iterator();
		 while (rIter.hasNext()) {
			 assertTrue(""bag ran out of tuples before answer"", bIter.hasNext());
			 assertEquals(""tuples should be the same"", bIter.next(), rIter.next());
		 }
		 assertFalse(""right answer ran out of tuples before the bag"", bIter.hasNext());
	 }
	 public void testDefaultBagFactory() throws Exception {
		 BagFactory f = BagFactory.getInstance();
		 DataBag bag = f.newDefaultBag();
		 DataBag sorted = f.newSortedBag(null);
		 DataBag limitedSorted = f.newLimitedSortedBag(null, 1);
		 DataBag distinct = f.newDistinctBag();
		 assertTrue(""Expected a default bag"", (bag instanceof DefaultDataBag));
		 assertTrue(""Expected a sorted bag"", (sorted instanceof SortedDataBag));
		 assertTrue(""Expected a limited sorted bag"", (limitedSorted instanceof LimitedSortedDataBag));
		 assertTrue(""Expected a distinct bag"", (distinct instanceof DistinctDataBag));
	 }
	 public void testProvidedBagFactory() throws Exception {
		 BagFactory.resetSelf();
		 System.setProperty(""pig.data.bag.factory.name"", ""no such class"");
		 System.setProperty(""pig.data.bag.factory.jar"", ""file:./pig.jar"");
		 boolean caughtIt = false;
		 try {
			 BagFactory f = BagFactory.getInstance();
		 }
		 catch (RuntimeException re) {
			 assertEquals(""Expected Unable to instantiate message"", ""Unable to instantiate bag factory no such class"", re.getMessage());
			 caughtIt = true;
		 }
		 assertTrue(""Expected to catch exception"", caughtIt);
		 BagFactory.resetSelf();
		 System.setProperty(""pig.data.bag.factory.name"", ""org.apache.pig.test.TestDataBag"");
		 System.setProperty(""pig.data.bag.factory.jar"", ""file:./pig.jar"");
		 caughtIt = false;
		 try {
			 BagFactory f = BagFactory.getInstance();
		 }
		 catch (RuntimeException re) {
			 assertEquals(""Expected does not extend BagFactory message"", ""Provided factory org.apache.pig.test.TestDataBag does not extend BagFactory!"", re.getMessage());
			 caughtIt = true;
		 }
		 assertTrue(""Expected to catch exception"", caughtIt);
		 BagFactory.resetSelf();
		 System.setProperty(""pig.data.bag.factory.name"", ""org.apache.pig.test.NonDefaultBagFactory"");
		 System.setProperty(""pig.data.bag.factory.jar"", ""file:./pig.jar"");
		 BagFactory f = BagFactory.getInstance();
		 DataBag b = f.newDefaultBag();
		 b = f.newSortedBag(null);
		 b = f.newDistinctBag();
		 BagFactory.resetSelf();
	 }
	 public void testNonSpillableDataBagEquals1() throws Exception {
		 String[][] tupleContents = new String[][] {
			{
			""a"", ""b""}
			,{
			""c"", ""d"" }
			, {
			 ""e"", ""f""}
		 }
		;
		 NonSpillableDataBag bg1 = new NonSpillableDataBag();
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg1.add(Util.createTuple(tupleContents[i]));
		 }
		 NonSpillableDataBag bg2 = new NonSpillableDataBag();
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg2.add(Util.createTuple(tupleContents[i]));
		 }
		 assertEquals(bg1, bg2);
	 }
	 public void testNonSpillableDataBagEquals2() throws Exception {
		 String[][] tupleContents = new String[][] {
			{
			""a"", ""b""}
			,{
			""c"", ""d"" }
			, {
			 ""e"", ""f""}
		 }
		;
		 NonSpillableDataBag bg1 = new NonSpillableDataBag();
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg1.add(Util.createTuple(tupleContents[i]));
		 }
		 tupleContents = new String[][] {
			{
			""c"", ""d"" }
			, {
			""a"", ""b""}
			,{
			 ""e"", ""f""}
		 }
		;
		 NonSpillableDataBag bg2 = new NonSpillableDataBag();
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg2.add(Util.createTuple(tupleContents[i]));
		 }
		 assertEquals(bg1, bg2);
	 }
	 public void testDefaultDataBagEquals1() throws Exception {
		 String[][] tupleContents = new String[][] {
			{
			""a"", ""b""}
			,{
			""c"", ""d"" }
			, {
			 ""e"", ""f""}
		 }
		;
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag bg1 = factory.newDefaultBag();
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg1.add(Util.createTuple(tupleContents[i]));
		 }
		 DataBag bg2 = factory.newDefaultBag();
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg2.add(Util.createTuple(tupleContents[i]));
		 }
		 assertEquals(bg1, bg2);
	 }
	 public void testDefaultDataBagEquals2() throws Exception {
		 String[][] tupleContents = new String[][] {
			{
			""a"", ""b""}
			,{
			""c"", ""d"" }
			, {
			 ""e"", ""f""}
		 }
		;
		 TestMemoryManager mgr = new TestMemoryManager();
		 LocalBagFactory factory = new LocalBagFactory(mgr);
		 DataBag bg1 = factory.newDefaultBag();
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg1.add(Util.createTuple(tupleContents[i]));
		 }
		 tupleContents = new String[][] {
			{
			""c"", ""d"" }
			, {
			""a"", ""b""}
			,{
			 ""e"", ""f""}
		 }
		;
		 DataBag bg2 = factory.newDefaultBag();
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg2.add(Util.createTuple(tupleContents[i]));
		 }
		 assertEquals(bg1, bg2);
	 }
	 public void testInternalCachedBag() throws Exception {
		 DataBag bg0 = new InternalCachedBag();
		 bg0.add(TupleFactory.getInstance().newTuple());
		 bg0.add(TupleFactory.getInstance().newTuple());
		 assertEquals(bg0.size(), 2);
		 DataBag bg1 = new InternalCachedBag(1, 0.5f);
		 assertEquals(bg1.size(), 0);
		 String[][] tupleContents = new String[][] {
			{
			""a"", ""b""}
			,{
			""c"", ""d"" }
			, {
			 ""e"", ""f""}
		 }
		;
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg1.add(Util.createTuple(tupleContents[i]));
		 }
		 assertEquals(bg1.size(), 3);
		 assertFalse(bg1.isSorted());
		 assertFalse(bg1.isDistinct());
		 tupleContents = new String[][] {
			{
			""c"", ""d"" }
			, {
			""a"", ""b""}
			,{
			 ""e"", ""f""}
		 }
		;
		 DataBag bg2 = new InternalCachedBag(1, 0.5f);
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg2.add(Util.createTuple(tupleContents[i]));
		 }
		 assertEquals(bg1, bg2);
		 DataBag bg3 = new InternalCachedBag(1, 0.0f);
		 tupleContents = new String[][] {
			{
			 ""e"", ""f""}
			, {
			""c"", ""d"" }
			, {
			""a"", ""b""}
		}
		;
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg3.add(Util.createTuple(tupleContents[i]));
		 }
		 assertEquals(bg1, bg3);
		 Iterator<Tuple> iter = bg3.iterator();
		 DataBag bg4 = new InternalCachedBag(1, 0.0f);
		 while(iter.hasNext()) {
			 bg4.add(iter.next());
		 }
		 assertEquals(bg3, bg4);
		 iter = bg3.iterator();
		 assertTrue(iter.hasNext());
		 assertTrue(iter.hasNext());
		 DataBag bg5 = new InternalCachedBag(1, 0.0f);
		 bg5.add(iter.next());
		 bg5.add(iter.next());
		 assertTrue(iter.hasNext());
		 bg5.add(iter.next());
		 assertFalse(iter.hasNext());
		 assertFalse(iter.hasNext());
		 assertEquals(bg3, bg5);
		 bg4.clear();
		 assertEquals(bg4.size(), 0);
	 }
	 public void testInternalSortedBag() throws Exception {
		 DataBag bg0 = new InternalSortedBag();
		 bg0.add(TupleFactory.getInstance().newTuple());
		 bg0.add(TupleFactory.getInstance().newTuple());
		 assertEquals(bg0.size(), 2);
		 DataBag bg1 = new InternalSortedBag();
		 assertEquals(bg1.size(), 0);
		 String[][] tupleContents = new String[][] {
			{
			 ""e"", ""f""}
			, {
			""a"", ""b""}
			, {
			""c"", ""d"" }
		}
		;
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg1.add(Util.createTuple(tupleContents[i]));
		 }
		 assertEquals(bg1.size(), 3);
		 assertTrue(bg1.isSorted());
		 assertFalse(bg1.isDistinct());
		 tupleContents = new String[][] {
			{
			""c"", ""d"" }
			, {
			""a"", ""b""}
			,{
			 ""e"", ""f""}
		 }
		;
		 DataBag bg2 = new InternalSortedBag();
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg2.add(Util.createTuple(tupleContents[i]));
		 }
		 assertEquals(bg1, bg2);
		 Iterator<Tuple> iter = bg1.iterator();
		 iter.next().equals(Util.createTuple(new String[] {
		""a"", ""b""}
		));
		 iter.next().equals(Util.createTuple(new String[] {
		""c"", ""d""}
		));
		 iter.next().equals(Util.createTuple(new String[] {
		""e"", ""f""}
		));
		 DataBag bg3 = new InternalSortedBag(1, 0.0f, null);
		 tupleContents = new String[][] {
			{
			 ""e"", ""f""}
			, {
			""c"", ""d"" }
			, {
			""a"", ""b""}
		}
		;
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg3.add(Util.createTuple(tupleContents[i]));
		 }
		 assertEquals(bg1, bg3);
		 iter = bg3.iterator();
		 iter.next().equals(Util.createTuple(new String[] {
		""a"", ""b""}
		));
		 iter.next().equals(Util.createTuple(new String[] {
		""c"", ""d""}
		));
		 iter.next().equals(Util.createTuple(new String[] {
		""e"", ""f""}
		));
		 iter = bg3.iterator();
		 assertTrue(iter.hasNext());
		 assertTrue(iter.hasNext());
		 DataBag bg4 = new InternalSortedBag(1, 0.0f, null);
		 bg4.add(iter.next());
		 bg4.add(iter.next());
		 assertTrue(iter.hasNext());
		 bg4.add(iter.next());
		 assertFalse(iter.hasNext());
		 assertFalse(iter.hasNext());
		 assertEquals(bg3, bg4);
		 bg3.clear();
		 assertEquals(bg3.size(), 0);
		 DataBag bg5 = new InternalSortedBag();
		 for(int j=0;
		 j<3;
		 j++) {
			 for (int i = 0;
			 i < tupleContents.length;
			 i++) {
				 bg5.add(Util.createTuple(tupleContents[i]));
			 }
			 bg5.spill();
		 }
		 assertEquals(bg5.size(), 9);
		 iter = bg5.iterator();
		 for(int i=0;
		 i<3;
		 i++) {
			 iter.next().equals(Util.createTuple(new String[] {
			""a"", ""b""}
			));
		 }
		 for(int i=0;
		 i<3;
		 i++) {
			 iter.next().equals(Util.createTuple(new String[] {
			""c"", ""d""}
			));
		 }
		 for(int i=0;
		 i<3;
		 i++) {
			 iter.next().equals(Util.createTuple(new String[] {
			""e"", ""f""}
			));
		 }
		 DataBag bg6 = new InternalSortedBag();
		 for(int j=0;
		 j<104;
		 j++) {
			 for (int i = 0;
			 i < tupleContents.length;
			 i++) {
				 bg6.add(Util.createTuple(tupleContents[i]));
			 }
			 if (j != 103) {
				 bg6.spill();
			 }
		 }
		 assertEquals(bg6.size(), 104*3);
		 iter = bg6.iterator();
		 for(int i=0;
		 i<104;
		 i++) {
			 iter.next().equals(Util.createTuple(new String[] {
			""a"", ""b""}
			));
		 }
		 for(int i=0;
		 i<104;
		 i++) {
			 iter.next().equals(Util.createTuple(new String[] {
			""c"", ""d""}
			));
		 }
		 for(int i=0;
		 i<104;
		 i++) {
			 iter.next().equals(Util.createTuple(new String[] {
			""e"", ""f""}
			));
		 }
		 DataBag bg7 = new SortedDataBag(null);
		 for(int j=0;
		 j<104;
		 j++) {
			 for (int i = 0;
			 i < tupleContents.length;
			 i++) {
				 bg7.add(Util.createTuple(tupleContents[i]));
			 }
			 if (j != 103) {
				 bg7.spill();
			 }
		 }
		 assertEquals(bg6, bg7);
	 }
	 public void testInternalDistinctBag() throws Exception {
		 DataBag bg0 = new InternalDistinctBag();
		 bg0.add(TupleFactory.getInstance().newTuple());
		 bg0.add(TupleFactory.getInstance().newTuple());
		 assertEquals(bg0.size(), 1);
		 DataBag bg1 = new InternalDistinctBag();
		 assertEquals(bg1.size(), 0);
		 String[][] tupleContents = new String[][] {
			{
			 ""e"", ""f""}
			, {
			""a"", ""b""}
			, {
			""e"", ""d"" }
			, {
			""a"", ""b""}
			, {
			""e"", ""f""}
		}
		;
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg1.add(Util.createTuple(tupleContents[i]));
		 }
		 assertEquals(bg1.size(), 3);
		 assertFalse(bg1.isSorted());
		 assertTrue(bg1.isDistinct());
		 tupleContents = new String[][] {
			{
			""a"", ""b"" }
			, {
			""e"", ""d""}
			, {
			""e"", ""d""}
			, {
			 ""e"", ""f""}
		 }
		;
		 DataBag bg2 = new InternalDistinctBag();
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg2.add(Util.createTuple(tupleContents[i]));
		 }
		 assertEquals(bg1, bg2);
		 Iterator<Tuple> iter = bg1.iterator();
		 iter.next().equals(Util.createTuple(new String[] {
		""a"", ""b""}
		));
		 iter.next().equals(Util.createTuple(new String[] {
		""c"", ""d""}
		));
		 iter.next().equals(Util.createTuple(new String[] {
		""e"", ""f""}
		));
		 DataBag bg3 = new InternalDistinctBag(1, 0.0f);
		 tupleContents = new String[][] {
			{
			 ""e"", ""f""}
			, {
			""a"", ""b""}
			, {
			""e"", ""d"" }
			, {
			""a"", ""b""}
			, {
			""e"", ""f""}
		}
		;
		 for (int i = 0;
		 i < tupleContents.length;
		 i++) {
			 bg3.add(Util.createTuple(tupleContents[i]));
		 }
		 assertEquals(bg2, bg3);
		 assertEquals(bg3.size(), 3);
		 iter = bg3.iterator();
		 assertTrue(iter.hasNext());
		 assertTrue(iter.hasNext());
		 DataBag bg4 = new InternalDistinctBag(1, 0.0f);
		 bg4.add(iter.next());
		 bg4.add(iter.next());
		 assertTrue(iter.hasNext());
		 bg4.add(iter.next());
		 assertFalse(iter.hasNext());
		 assertFalse(iter.hasNext());
		 assertEquals(bg3, bg4);
		 bg3.clear();
		 assertEquals(bg3.size(), 0);
		 DataBag bg5 = new InternalDistinctBag();
		 for(int j=0;
		 j<3;
		 j++) {
			 for (int i = 0;
			 i < tupleContents.length;
			 i++) {
				 bg5.add(Util.createTuple(tupleContents[i]));
			 }
			 bg5.spill();
		 }
		 assertEquals(bg5.size(), 3);
		 DataBag bg6 = new InternalDistinctBag();
		 for(int j=0;
		 j<104;
		 j++) {
			 for (int i = 0;
			 i < tupleContents.length;
			 i++) {
				 bg6.add(Util.createTuple(tupleContents[i]));
			 }
			 if (j != 103) {
				 bg6.spill();
			 }
		 }
		 assertEquals(bg6.size(), 3);
		 DataBag bg7 = new DistinctDataBag();
		 for(int j=0;
		 j<104;
		 j++) {
			 for (int i = 0;
			 i < tupleContents.length;
			 i++) {
				 bg7.add(Util.createTuple(tupleContents[i]));
			 }
			 if (j != 103) {
				 bg7.spill();
			 }
		 }
		 assertEquals(bg6, bg7);
	 }
	 public void testDataBagIterIdempotent() throws Exception {
		 DataBag bg0 = new DefaultDataBag();
		 processDataBag(bg0, true);
		 DataBag bg1 = new DistinctDataBag();
		 processDataBag(bg1, true);
		 DataBag bg2 = new InternalDistinctBag();
		 processDataBag(bg2, true);
		 DataBag bg3 = new InternalSortedBag();
		 processDataBag(bg3, true);
		 DataBag bg4 = new SortedDataBag(null);
		 processDataBag(bg4, true);
		 DataBag bg5 = new InternalCachedBag(0, 0);
		 processDataBag(bg5, false);
	 }
	 public void testSerializeSingleTupleBag() throws Exception {
		 Tuple t = Util.createTuple(new String[] {
		""foo"", ""bar"", ""baz""}
		);
		 DataBag stBag = new SingleTupleBag(t);
		 PipedOutputStream pos = new PipedOutputStream();
		 DataOutputStream dos = new DataOutputStream(pos);
		 PipedInputStream pis = new PipedInputStream(pos);
		 DataInputStream dis = new DataInputStream(pis);
		 stBag.write(dos);
		 DataBag dfBag = new DefaultDataBag();
		 dfBag.readFields(dis);
		 assertTrue(dfBag.equals(stBag));
	 }
	 static class MyCustomTuple extends DefaultTuple {
		 private static final long serialVersionUID = 8156382697467819543L;
		 public MyCustomTuple() {
			 super();
		 }
		 public MyCustomTuple(Object t) {
			 super();
			 append(t);
		 }
	 }
	 public void testSpillCustomTuple() throws Exception {
		 DataBag bag = new DefaultDataBag();
		 Tuple t = new MyCustomTuple();
		 t.append(1);
		 t.append(""hello"");
		 bag.add(t);
		 bag.spill();
		 Iterator<Tuple> iter = bag.iterator();
		 Tuple t2 = iter.next();
		 assertTrue(t2.equals(t));
	 }
	 public void testSpillArrayBackedList() throws Exception {
		 Tuple[] tuples = new Tuple[2];
		 tuples[0] = TupleFactory.getInstance().newTuple(1);
		 tuples[0].set(0, ""first"");
		 tuples[1] = TupleFactory.getInstance().newTuple(1);
		 tuples[1].set(0, ""second"");
		 DefaultDataBag bag = new DefaultDataBag(Arrays.asList(tuples));
		 bag.spill();
		 Iterator<Tuple> iter = bag.iterator();
		 assertEquals(tuples[0], iter.next());
		 assertEquals(tuples[1], iter.next());
		 assertFalse(iter.hasNext());
	 }
	 void processDataBag(DataBag bg, boolean doSpill) {
		 Tuple t = TupleFactory.getInstance().newTuple(new Integer(0));
		 bg.add(t);
		 if (doSpill) bg.spill();
		 Iterator<Tuple> iter = bg.iterator();
		 assertTrue(iter.hasNext());
		 iter.next();
		 assertFalse(iter.hasNext());
		 assertFalse(""hasNext should be idempotent"", iter.hasNext());
	 }
	 public void testLimitedSortedBag() throws ExecException {
		 DataBag bag = new LimitedSortedDataBag(null, 2);
		 Tuple t;
		 t = TupleFactory.getInstance().newTuple(1);
		 t.set(0, 2);
		 bag.add(t);
		 t = TupleFactory.getInstance().newTuple(1);
		 t.set(0, 0);
		 bag.add(t);
		 t = TupleFactory.getInstance().newTuple(1);
		 t.set(0, 1);
		 bag.add(t);
		 assertEquals(bag.size(), 2);
		 assertTrue(bag.isSorted());
		 assertFalse(bag.isDistinct());
		 Iterator<Tuple> it = bag.iterator();
		 assertEquals(it.next().get(0), 0);
		 assertEquals(it.next().get(0), 1);
		 assertEquals(it.hasNext(), false);
		 DataBag bag1 = new LimitedSortedDataBag(null, 1);
		 bag1.addAll(bag);
		 assertEquals(bag1.size(), 1);
		 assertEquals(bag.compareTo(bag), 0);
		 assertEquals(bag.compareTo(bag1), 1);
		 bag1.clear();
		 assertEquals(bag1.size(), 0);
	 }
}",1,0,0,0
"public class SunJavah implements JavahAdapter {
	 public static final String IMPLEMENTATION_NAME = ""sun"";
	 public boolean compile(Javah javah) throws BuildException {
		 Commandline cmd = setupJavahCommand(javah);
		 ExecuteJava ej = new ExecuteJava();
		 Class c = null;
		 try {
			 try {
				 c = Class.forName(""com.sun.tools.javah.oldjavah.Main"");
			 }
			 catch (ClassNotFoundException cnfe) {
				 c = Class.forName(""com.sun.tools.javah.Main"");
			 }
		 }
		 catch (ClassNotFoundException ex) {
			 throw new BuildException( ""Can't load javah"", ex, javah.getLocation());
		 }
		 cmd.setExecutable(c.getName());
		 ej.setJavaCommand(cmd);
		 File f = Locator.getClassSource(c);
		 if (f != null) {
			 ej.setClasspath(new Path(javah.getProject(), f.getPath()));
		 }
		 return ej.fork(javah) == 0;
	 }
	 private Commandline setupJavahCommand(Javah javah) {
		 Commandline cmd = new Commandline();
		 if (javah.getDestdir() != null) {
			 cmd.createArgument().setValue(""-d"");
			 cmd.createArgument().setFile(javah.getDestdir());
		 }
		 if (javah.getOutputfile() != null) {
			 cmd.createArgument().setValue(""-o"");
			 cmd.createArgument().setFile(javah.getOutputfile());
		 }
		 if (javah.getClasspath() != null) {
			 cmd.createArgument().setValue(""-classpath"");
			 cmd.createArgument().setPath(javah.getClasspath());
		 }
		 if (javah.getVerbose()) {
			 cmd.createArgument().setValue(""-verbose"");
		 }
		 if (javah.getOld()) {
			 cmd.createArgument().setValue(""-old"");
		 }
		 if (javah.getForce()) {
			 cmd.createArgument().setValue(""-force"");
		 }
		 if (javah.getStubs() && !javah.getOld()) {
			 throw new BuildException( ""stubs only available in old mode."", javah.getLocation());
		 }
		 if (javah.getStubs()) {
			 cmd.createArgument().setValue(""-stubs"");
		 }
		 Path bcp = new Path(javah.getProject());
		 if (javah.getBootclasspath() != null) {
			 bcp.append(javah.getBootclasspath());
		 }
		 bcp = bcp.concatSystemBootClasspath(""ignore"");
		 if (bcp.size() > 0) {
			 cmd.createArgument().setValue(""-bootclasspath"");
			 cmd.createArgument().setPath(bcp);
		 }
		 cmd.addArguments(javah.getCurrentArgs());
		 javah.logAndAddFiles(cmd);
		 return cmd;
	 }
}",0,0,0,0
"public void writeEntityRef(String ent) throws XMLStreamException {
	 delegate.writeEntityRef(ent);
 }",0,0,0,0
"private Invocation next() {
	 if (interceptors.hasNext()) {
		 final Interceptor interceptor = interceptors.next();
		 final Object nextInstance = interceptor.getInstance();
		 final Method nextMethod = interceptor.getMethod();
		 if (nextMethod.getParameterTypes().length == 1 && nextMethod.getParameterTypes()[0] == InvocationContext.class) {
			 return new InterceptorInvocation(nextInstance, nextMethod, this);
		 }
		 else {
			 return new LifecycleInvocation(nextInstance, nextMethod, this, parameters);
		 }
	 }
	 else if (method != null) {
		 final Object[] methodParameters;
		 if (operation.equals(Operation.TIMEOUT) && method.getParameterTypes().length == 0) {
			 methodParameters = new Object[0];
		 }
		 else {
			 methodParameters = parameters;
		 }
		 return new BeanInvocation(target, method, methodParameters);
	 }
	 else {
		 return new NoOpInvocation();
	 }
 }",0,0,1,0
"static void accumCubic(double bounds[], double t, double curx, double cury, double cpx0, double cpy0, double cpx1, double cpy1, double endx, double endy);",0,0,0,1
"protected static void nativeGetPointerCoords( long nativePtr, int pointerIndex, int historyPos, PointerCoords outPointerCoordsObj) {
	 NativeInput.MotionEvent event = getNativeMotionEvent(nativePtr);
	 int pointerCount = event.getPointerCount();
	 validatePointerIndex(pointerIndex, pointerCount);
	 validatePointerCoords(outPointerCoordsObj);
	 NativeInput.PointerCoords rawPointerCoords;
	 if (historyPos == HISTORY_CURRENT) {
		 rawPointerCoords = event.getRawPointerCoords(pointerIndex);
	 }
	 else {
		 int historySize = event.getHistorySize();
		 validateHistoryPos(historyPos, historySize);
		 rawPointerCoords = event.getHistoricalRawPointerCoords(pointerIndex, historyPos);
	 }
	 pointerCoordsFromNative( rawPointerCoords, event.getXOffset(), event.getYOffset(), outPointerCoordsObj);
 }",0,0,1,0
"public RBuiltinNode getBuiltin() {
	 return builtin;
 }",0,0,0,0
"public class JString extends JCompType {
	 public JString() {
		 super("" ::std::string"", ""Text"", ""String"", ""Text"");
	 }
	 public String getSignature() {
		 return ""s"";
	 }
	 public String genJavaReadWrapper(String fname, String tag, boolean decl) {
		 String ret = """";
		 if (decl) {
			 ret = "" Text ""+fname+"";
			\n"";
		 }
		 return ret + "" ""+fname+""=a_.readString(\""""+tag+""\"");
		\n"";
	 }
	 public String genJavaWriteWrapper(String fname, String tag) {
		 return "" a_.writeString(""+fname+"",\""""+tag+""\"");
		\n"";
	 }
}",0,0,0,0
"public static _Fields findByThriftId(int fieldId) {
	 switch(fieldId) {
		 case 1: return LOGIN;
		 case 2: return TABLE_NAME;
		 case 3: return VERSIONING_ITER;
		 case 4: return TYPE;
		 default: return null;
	 }
 }",0,0,0,0
"public State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state) {
	 text = commentsHelper.rewrite(tok, maxWidth, state.column);
	 int firstLineLength = text.length() - Iterators.getLast(Newlines.lineOffsetIterator(text));
	 return state.withColumn(state.column + firstLineLength);
 }",0,0,1,0
"public interface MapJoinRowContainer extends AbstractRowContainer<List<Object>> {
	 byte getAliasFilter() throws HiveException;
	 MapJoinRowContainer copy() throws HiveException;
	 void addRow(Object[] value) throws HiveException;
	 void write(MapJoinObjectSerDeContext valueContext, ObjectOutputStream out) throws IOException, SerDeException;
}",0,0,0,0
"public class CheckboxTableDecorator extends TableDecorator{
	 private String id = ""id"";
	 private Map params;
	 private List checkedIds;
	 private String fieldName = ""_chk"";
	 public void setId(String id) {
		 this.id = id;
	 }
	 public void setFieldName(String fieldName) {
		 this.fieldName = fieldName;
	 }
	 public void init(PageContext pageContext, Object decorated, TableModel tableModel) {
		 super.init(pageContext, decorated, tableModel);
		 String[] params = pageContext.getRequest().getParameterValues(fieldName);
		 checkedIds = params != null ? new ArrayList(Arrays.asList(params)) : new ArrayList(0);
	 }
	 public void finish() {
		 if (!checkedIds.isEmpty()) {
			 JspWriter writer = getPageContext().getOut();
			 for (Iterator it = checkedIds.iterator();
			 it.hasNext();
			) {
				 String name = (String) it.next();
				 StringBuffer buffer = new StringBuffer();
				 buffer.append(""<input type=\""hidden\"" name=\"""");
				 buffer.append(fieldName);
				 buffer.append(""\"" value=\"""");
				 buffer.append(name);
				 buffer.append(""\"">"");
				 try {
					 writer.write(buffer.toString());
				 }
				 catch (IOException e) {
				 }
			 }
		 }
		 super.finish();
	 }
	 public String getCheckbox() {
		 String evaluatedId = ObjectUtils.toString(evaluate(id));
		 boolean checked = checkedIds.contains(evaluatedId);
		 StringBuffer buffer = new StringBuffer();
		 buffer.append(""<input type=\""checkbox\"" name=\""_chk\"" value=\"""");
		 buffer.append(evaluatedId);
		 buffer.append(""\"""");
		 if (checked) {
			 checkedIds.remove(evaluatedId);
			 buffer.append("" checked=\""checked\"""");
		 }
		 buffer.append(""/>"");
		 return buffer.toString();
	 }
}",0,0,0,0
"public String getFilesystem() throws IOException {
	 doDF();
	 return filesystem;
 }",0,0,0,0
"public class XmiWriterCasConsumer extends CasConsumer_ImplBase {
	 public static final String PARAM_OUTPUTDIR = ""OutputDirectory"";
	 private File mOutputDir;
	 private int mDocNum;
	 public void initialize() throws ResourceInitializationException {
		 mDocNum = 0;
		 mOutputDir = new File((String) getConfigParameterValue(PARAM_OUTPUTDIR));
		 if (!mOutputDir.exists()) {
			 mOutputDir.mkdirs();
		 }
	 }
	 public void processCas(CAS aCAS) throws ResourceProcessException {
		 String modelFileName = null;
		 JCas jcas;
		 try {
			 jcas = aCAS.getJCas();
		 }
		 catch (CASException e) {
			 throw new ResourceProcessException(e);
		 }
		 FSIterator it = jcas.getAnnotationIndex(SourceDocumentInformation.type).iterator();
		 File outFile = null;
		 if (it.hasNext()) {
			 SourceDocumentInformation fileLoc = (SourceDocumentInformation) it.next();
			 File inFile;
			 try {
				 inFile = new File(new URL(fileLoc.getUri()).getPath());
				 String outFileName = inFile.getName();
				 if (fileLoc.getOffsetInSource() > 0) {
					 outFileName += (""_"" + fileLoc.getOffsetInSource());
				 }
				 outFileName += "".xmi"";
				 outFile = new File(mOutputDir, outFileName);
				 modelFileName = mOutputDir.getAbsolutePath() + ""/"" + inFile.getName() + "".ecore"";
			 }
			 catch (MalformedURLException e1) {
			 }
		 }
		 if (outFile == null) {
			 outFile = new File(mOutputDir, ""doc"" + mDocNum++ + "".xmi"");
		 }
		 try {
			 writeXmi(jcas.getCas(), outFile, modelFileName);
		 }
		 catch (IOException e) {
			 throw new ResourceProcessException(e);
		 }
		 catch (SAXException e) {
			 throw new ResourceProcessException(e);
		 }
	 }
	 private void writeXmi(CAS aCas, File name, String modelFileName) throws IOException, SAXException {
		 FileOutputStream out = null;
		 try {
			 out = new FileOutputStream(name);
			 XmiCasSerializer ser = new XmiCasSerializer(aCas.getTypeSystem());
			 XMLSerializer xmlSer = new XMLSerializer(out, false);
			 ser.serialize(aCas, xmlSer.getContentHandler());
		 }
		 finally {
			 if (out != null) {
				 out.close();
			 }
		 }
	 }
}",1,0,0,0
"public void setFile(final File file) {
	 myFile = file;
 }",0,0,0,0
"public class NodeAnnounceMessage extends PacketImpl {
	 protected String nodeID;
	 protected String backupGroupName;
	 protected boolean backup;
	 protected long currentEventID;
	 protected TransportConfiguration connector;
	 protected TransportConfiguration backupConnector;
	 private String scaleDownGroupName;
	 public NodeAnnounceMessage(final long currentEventID, final String nodeID, final String backupGroupName, final String scaleDownGroupName, final boolean backup, final TransportConfiguration tc, final TransportConfiguration backupConnector) {
		 super(NODE_ANNOUNCE);
		 this.currentEventID = currentEventID;
		 this.nodeID = nodeID;
		 this.backupGroupName = backupGroupName;
		 this.backup = backup;
		 this.connector = tc;
		 this.backupConnector = backupConnector;
		 this.scaleDownGroupName = scaleDownGroupName;
	 }
	 public NodeAnnounceMessage() {
		 super(NODE_ANNOUNCE);
	 }
	 public NodeAnnounceMessage(byte nodeAnnounceMessage_V2) {
		 super(nodeAnnounceMessage_V2);
	 }
	 public String getNodeID() {
		 return nodeID;
	 }
	 public String getBackupGroupName() {
		 return backupGroupName;
	 }
	 public boolean isBackup() {
		 return backup;
	 }
	 public TransportConfiguration getConnector() {
		 return connector;
	 }
	 public TransportConfiguration getBackupConnector() {
		 return backupConnector;
	 }
	 public String getScaleDownGroupName() {
		 return scaleDownGroupName;
	 }
	 public long getCurrentEventID() {
		 return currentEventID;
	 }
	 public void encodeRest(final ActiveMQBuffer buffer) {
		 buffer.writeString(nodeID);
		 buffer.writeNullableString(backupGroupName);
		 buffer.writeBoolean(backup);
		 buffer.writeLong(currentEventID);
		 if (connector != null) {
			 buffer.writeBoolean(true);
			 connector.encode(buffer);
		 }
		 else {
			 buffer.writeBoolean(false);
		 }
		 if (backupConnector != null) {
			 buffer.writeBoolean(true);
			 backupConnector.encode(buffer);
		 }
		 else {
			 buffer.writeBoolean(false);
		 }
		 buffer.writeNullableString(scaleDownGroupName);
	 }
	 public void decodeRest(final ActiveMQBuffer buffer) {
		 this.nodeID = buffer.readString();
		 this.backupGroupName = buffer.readNullableString();
		 this.backup = buffer.readBoolean();
		 this.currentEventID = buffer.readLong();
		 if (buffer.readBoolean()) {
			 connector = new TransportConfiguration();
			 connector.decode(buffer);
		 }
		 if (buffer.readBoolean()) {
			 backupConnector = new TransportConfiguration();
			 backupConnector.decode(buffer);
		 }
		 scaleDownGroupName = buffer.readNullableString();
	 }
	 public String toString() {
		 return ""NodeAnnounceMessage [backup="" + backup + "", connector="" + connector + "", nodeID="" + nodeID + "", toString()="" + super.toString() + ""]"";
	 }
	 public int hashCode() {
		 final int prime = 31;
		 int result = super.hashCode();
		 result = prime * result + (backup ? 1231 : 1237);
		 result = prime * result + ((backupConnector == null) ? 0 : backupConnector.hashCode());
		 result = prime * result + ((connector == null) ? 0 : connector.hashCode());
		 result = prime * result + (int) (currentEventID ^ (currentEventID >>> 32));
		 result = prime * result + ((nodeID == null) ? 0 : nodeID.hashCode());
		 result = prime * result + ((scaleDownGroupName == null) ? 0 : scaleDownGroupName.hashCode());
		 return result;
	 }
	 public boolean equals(Object obj) {
		 if (this == obj) {
			 return true;
		 }
		 if (!super.equals(obj)) {
			 return false;
		 }
		 if (!(obj instanceof NodeAnnounceMessage)) {
			 return false;
		 }
		 NodeAnnounceMessage other = (NodeAnnounceMessage) obj;
		 if (backup != other.backup) {
			 return false;
		 }
		 if (backupConnector == null) {
			 if (other.backupConnector != null) {
				 return false;
			 }
		 }
		 else if (!backupConnector.equals(other.backupConnector)) {
			 return false;
		 }
		 if (connector == null) {
			 if (other.connector != null) {
				 return false;
			 }
		 }
		 else if (!connector.equals(other.connector)) {
			 return false;
		 }
		 if (currentEventID != other.currentEventID) {
			 return false;
		 }
		 if (nodeID == null) {
			 if (other.nodeID != null) {
				 return false;
			 }
		 }
		 else if (!nodeID.equals(other.nodeID)) {
			 return false;
		 }
		 else if (!scaleDownGroupName.equals(other.scaleDownGroupName)) {
			 return false;
		 }
		 return true;
	 }
}",1,1,0,0
"public String[] normalizePaths(java.io.File filebase, boolean toRelativePath) {
	Vector result = new Vector();
	m_iconLocation = checkRelativePath(filebase, m_iconLocation, result, ""Icon location"", toRelativePath);
	m_jarLocation = checkRelativePath(filebase, m_jarLocation, result, ""Jar location"", toRelativePath);
	m_bundledJVM = checkRelativePath(filebase, m_bundledJVM, result, ""Bundle JVM location"", toRelativePath);
	 m_executableName = checkRelativePath(filebase, m_executableName, result, ""Executable location"", toRelativePath);
	if (m_executableName != null) {
		File exebase = new File(m_executableName);
		if (exebase.isAbsolute() == false) exebase = new File(filebase, exebase.toString()).getParentFile();
		if ((m_currentDirectory != null) && (m_currentDirectory.indexOf(""${
			"")>=0)) m_currentDirectory = checkRelativePath(exebase, m_currentDirectory, result, ""Current directory"", toRelativePath);
		 }
		 if (m_classPath != null) {
			for (int i=0;
			 i<m_classPath.length;
			 i++) {
				m_classPath[i] = checkRelativePath(filebase, m_classPath[i], result, ""Classpath entry ("" + i + "")"", toRelativePath);
			 }
		 }
		if (result.size() == 0) return null;
		String[] res = new String[result.size()];
		result.toArray(res);
		return res;
	 }",0,0,0,0
"int accumDefaultEntity( Writer writer, char ch, int i, char[] chars, int len, boolean fromTextNode, boolean escLF) throws IOException;",0,0,0,1
"public void dumpTo(File destination) throws IOException, CloneNotSupportedException {
	int outputcount = 0;
	FileOutputStream fos = new FileOutputStream(destination);
	FileChannel out = fos.getChannel();
	PEOldMSHeader oldmsheader = (PEOldMSHeader) this.m_oldmsheader.clone();
	PEHeader peheader = (PEHeader) m_header.clone();
	Vector sections = new Vector();
	for (int i=0;
	 i<m_sections.size();
	 i++) {
		PESection sect = (PESection)m_sections.get(i);
		PESection cs = (PESection)sect.clone();
		sections.add(cs);
	 }
	long newexeoffset = oldmsheader.e_lfanew;
	ByteBuffer msheadbuffer = oldmsheader.get();
	outputcount = out.write(msheadbuffer);
	this.m_channel.position(64);
	out.transferFrom(this.m_channel, 64, newexeoffset - 64);
	ByteBuffer headbuffer = peheader.get();
	out.position(newexeoffset);
	outputcount = out.write(headbuffer);
	long offset = oldmsheader.e_lfanew + (m_header.NumberOfRvaAndSizes * 8) + 24 + 96;
	out.position(offset);
	for (int i=0;
	 i<sections.size();
	 i++) {
		PESection sect = (PESection) sections.get(i);
		ByteBuffer buf = sect.get();
		outputcount = out.write(buf);
	 }
	offset = 1024;
	long virtualAddress = offset;
	if ((virtualAddress % peheader.SectionAlignment)>0) virtualAddress += peheader.SectionAlignment - (virtualAddress%peheader.SectionAlignment);
	long resourceoffset = m_header.ResourceDirectory_VA;
	for (int i=0;
	 i<sections.size();
	 i++) {
		PESection sect = (PESection) sections.get(i);
		if (resourceoffset == sect.VirtualAddress) {
			out.position(offset);
			long sectoffset = offset;
			PEResourceDirectory prd = this.getResourceDirectory();
			ByteBuffer resbuf = prd.buildResource(sect.VirtualAddress);
			resbuf.position(0);
			out.write(resbuf);
			offset += resbuf.capacity();
			long rem = offset % this.m_header.FileAlignment;
			if (rem != 0) offset += this.m_header.FileAlignment - rem;
			if (out.size()+1 < offset) {
				ByteBuffer padder = ByteBuffer.allocate(1);
				out.write(padder, offset - 1);
			 }
			long virtualSize = resbuf.capacity();
			if ((virtualSize % peheader.FileAlignment)>0) virtualSize += peheader.SectionAlignment - (virtualSize%peheader.SectionAlignment);
			sect.PointerToRawData = sectoffset;
			sect.SizeOfRawData = resbuf.capacity();
			if ((sect.SizeOfRawData%this.m_header.FileAlignment)>0) sect.SizeOfRawData += (this.m_header.FileAlignment-(sect.SizeOfRawData%this.m_header.FileAlignment));
			sect.VirtualAddress = virtualAddress;
			sect.VirtualSize = virtualSize;
			virtualAddress += virtualSize;
		 }
		else if (sect.PointerToRawData > 0) {
			out.position(offset);
			this.m_channel.position(sect.PointerToRawData);
			long sectoffset = offset;
			out.position(offset + sect.SizeOfRawData);
			ByteBuffer padder = ByteBuffer.allocate(1);
			out.write(padder, offset + sect.SizeOfRawData - 1);
			long outted = out.transferFrom(this.m_channel, offset, sect.SizeOfRawData);
			offset += sect.SizeOfRawData;
			long rem = offset % this.m_header.FileAlignment;
			if (rem != 0) {
				offset += this.m_header.FileAlignment - rem;
			 }
			sect.PointerToRawData = sectoffset;
			sect.VirtualAddress = virtualAddress;
			virtualAddress += sect.VirtualSize;
			 if ((virtualAddress % peheader.SectionAlignment)>0) virtualAddress += peheader.SectionAlignment - (virtualAddress%peheader.SectionAlignment);
		 }
		else {
			long virtualSize = sect.VirtualSize;
			if ((virtualSize % peheader.SectionAlignment)>0) virtualSize += peheader.SectionAlignment - (virtualSize%peheader.SectionAlignment);
			sect.VirtualAddress = virtualAddress;
			virtualAddress += virtualSize;
		 }
	 }
	peheader.updateVAAndSize(m_sections, sections);
	 headbuffer = peheader.get();
	 out.position(newexeoffset);
	 outputcount = out.write(headbuffer);
	 offset = oldmsheader.e_lfanew + (m_header.NumberOfRvaAndSizes * 8) + 24 + 96;
	 out.position(offset);
	for (int i=0;
	 i<sections.size();
	 i++) {
		PESection sect = (PESection) sections.get(i);
		ByteBuffer buf = sect.get();
		outputcount = out.write(buf);
	 }
	fos.flush();
	fos.close();
 }",0,0,1,0
"final class NativeError extends IdScriptableObject{
	 private static final Object ERROR_TAG = new Object();
	 static void init(Context cx, Scriptable scope, boolean sealed) {
		 NativeError obj = new NativeError();
		 ScriptableObject.putProperty(obj, ""name"", ""Error"");
		 ScriptableObject.putProperty(obj, ""message"", """");
		 ScriptableObject.putProperty(obj, ""fileName"", """");
		 ScriptableObject.putProperty(obj, ""lineNumber"", new Integer(0));
		 obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
	 }
	 static NativeError make(Context cx, Scriptable scope, IdFunctionObject ctorObj, Object[] args) {
		 Scriptable proto = (Scriptable)(ctorObj.get(""prototype"", ctorObj));
		 NativeError obj = new NativeError();
		 obj.setPrototype(proto);
		 obj.setParentScope(scope);
		 if (args.length >= 1) {
			 ScriptableObject.putProperty(obj, ""message"", ScriptRuntime.toString(args[0]));
			 if (args.length >= 2) {
				 ScriptableObject.putProperty(obj, ""fileName"", args[1]);
				 if (args.length >= 3) {
					 int line = ScriptRuntime.toInt32(args[2]);
					 ScriptableObject.putProperty(obj, ""lineNumber"", new Integer(line));
				 }
			 }
		 }
		 return obj;
	 }
	 public String getClassName() {
		 return ""Error"";
	 }
	 public String toString() {
		 return js_toString(this);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_constructor: arity=1;
			 s=""constructor"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(ERROR_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(ERROR_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case Id_constructor: return make(cx, scope, f, args);
			 case Id_toString: return js_toString(thisObj);
			 case Id_toSource: return js_toSource(cx, scope, thisObj);
		 }
		 throw new IllegalArgumentException(String.valueOf(id));
	 }
	 private static String js_toString(Scriptable thisObj) {
		 return getString(thisObj, ""name"")+"": ""+getString(thisObj, ""message"");
	 }
	 private static String js_toSource(Context cx, Scriptable scope, Scriptable thisObj) {
		 Object name = ScriptableObject.getProperty(thisObj, ""name"");
		 Object message = ScriptableObject.getProperty(thisObj, ""message"");
		 Object fileName = ScriptableObject.getProperty(thisObj, ""fileName"");
		 Object lineNumber = ScriptableObject.getProperty(thisObj, ""lineNumber"");
		 StringBuffer sb = new StringBuffer();
		 sb.append(""(new "");
		 if (name == NOT_FOUND) {
			 name = Undefined.instance;
		 }
		 sb.append(ScriptRuntime.toString(name));
		 sb.append(""("");
		 if (message != NOT_FOUND || fileName != NOT_FOUND || lineNumber != NOT_FOUND) {
			 if (message == NOT_FOUND) {
				 message = """";
			 }
			 sb.append(ScriptRuntime.uneval(cx, scope, message));
			 if (fileName != NOT_FOUND || lineNumber != NOT_FOUND) {
				 sb.append("", "");
				 if (fileName == NOT_FOUND) {
					 fileName = """";
				 }
				 sb.append(ScriptRuntime.uneval(cx, scope, fileName));
				 if (lineNumber != NOT_FOUND) {
					 int line = ScriptRuntime.toInt32(lineNumber);
					 if (line != 0) {
						 sb.append("", "");
						 sb.append(ScriptRuntime.toString(line));
					 }
				 }
			 }
		 }
		 sb.append(""))"");
		 return sb.toString();
	 }
	 private static String getString(Scriptable obj, String id) {
		 Object value = ScriptableObject.getProperty(obj, id);
		 if (value == NOT_FOUND) return """";
		 return ScriptRuntime.toString(value);
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 int s_length = s.length();
			 if (s_length==8) {
				 c=s.charAt(3);
				 if (c=='o') {
					 X=""toSource"";
					id=Id_toSource;
				 }
				 else if (c=='t') {
					 X=""toString"";
					id=Id_toString;
				 }
			 }
			 else if (s_length==11) {
				 X=""constructor"";
				id=Id_constructor;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int Id_constructor = 1, Id_toString = 2, Id_toSource = 3, MAX_PROTOTYPE_ID = 3;
}",0,0,0,0
"public RangeDecoderFromBuffer(int inputSizeMax, ArrayCache arrayCache) {
	 buf = arrayCache.getByteArray(inputSizeMax - INIT_SIZE, false);
	 pos = buf.length;
 }",0,0,0,0
"public class AntVersion extends Task implements Condition {
	 private String atLeast = null;
	 private String exactly = null;
	 private String propertyname = null;
	 public void execute() throws BuildException {
		 if (propertyname == null) {
			 throw new BuildException(""'property' must be set."");
		 }
		 if (atLeast != null || exactly != null) {
			 if (eval()) {
				 getProject().setNewProperty(propertyname, getVersion().toString());
			 }
		 }
		 else {
			 getProject().setNewProperty(propertyname, getVersion().toString());
		 }
	 }
	 public boolean eval() throws BuildException {
		 validate();
		 DeweyDecimal actual = getVersion();
		 if (null != atLeast) {
			 return actual.isGreaterThanOrEqual(new DeweyDecimal(atLeast));
		 }
		 if (null != exactly) {
			 return actual.isEqual(new DeweyDecimal(exactly));
		 }
		 return false;
	 }
	 private void validate() throws BuildException {
		 if (atLeast != null && exactly != null) {
			 throw new BuildException(""Only one of atleast or exactly may be set."");
		 }
		 if (null == atLeast && null == exactly) {
			 throw new BuildException(""One of atleast or exactly must be set."");
		 }
		 if (atLeast != null) {
			 try {
				 new DeweyDecimal(atLeast);
			 }
			 catch (NumberFormatException e) {
				 throw new BuildException( ""The 'atleast' attribute is not a Dewey Decimal eg 1.1.0 : "" + atLeast);
			 }
		 }
		 else {
			 try {
				 new DeweyDecimal(exactly);
			 }
			 catch (NumberFormatException e) {
				 throw new BuildException( ""The 'exactly' attribute is not a Dewey Decimal eg 1.1.0 : "" + exactly);
			 }
		 }
	 }
	 private DeweyDecimal getVersion() {
		 Project p = new Project();
		 p.init();
		 char[] versionString = p.getProperty(""ant.version"").toCharArray();
		 StringBuffer sb = new StringBuffer();
		 boolean foundFirstDigit = false;
		 for (int i = 0;
		 i < versionString.length;
		 i++) {
			 if (Character.isDigit(versionString[i])) {
				 sb.append(versionString[i]);
				 foundFirstDigit = true;
			 }
			 if (versionString[i] == '.' && foundFirstDigit) {
				 sb.append(versionString[i]);
			 }
			 if (Character.isLetter(versionString[i]) && foundFirstDigit) {
				 break;
			 }
		 }
		 return new DeweyDecimal(sb.toString());
	 }
	 public String getAtLeast() {
		 return atLeast;
	 }
	 public void setAtLeast(String atLeast) {
		 this.atLeast = atLeast;
	 }
	 public String getExactly() {
		 return exactly;
	 }
	 public void setExactly(String exactly) {
		 this.exactly = exactly;
	 }
	 public String getProperty() {
		 return propertyname;
	 }
	 public void setProperty(String propertyname) {
		 this.propertyname = propertyname;
	 }
}",0,0,0,0
"public class ModelDataGenerator {
	 private static final Logger logger = LoggerFactory.getLogger(ModelDataGenerator.class);
	 final private DataModelDesc model;
	 final private int targetRows;
	 final private ResourceStore outputStore;
	 final private String outputPath;
	 boolean outprint = false;
	 public ModelDataGenerator(DataModelDesc model, int nRows) {
		 this(model, nRows, ResourceStore.getStore(model.getConfig()));
	 }
	 private ModelDataGenerator(DataModelDesc model, int nRows, ResourceStore outputStore) {
		 this(model, nRows, outputStore, ""/data"");
	 }
	 private ModelDataGenerator(DataModelDesc model, int nRows, ResourceStore outputStore, String outputPath) {
		 this.model = model;
		 this.targetRows = nRows;
		 this.outputStore = outputStore;
		 this.outputPath = outputPath;
	 }
	 public void generate() throws IOException {
		 Set<TableDesc> generated = new HashSet<>();
		 Set<TableDesc> allTableDesc = new LinkedHashSet<>();
		 JoinTableDesc[] allTables = model.getJoinTables();
		 for (int i = allTables.length - 1;
		 i >= -1;
		 i--) {
			 TableDesc table = (i == -1) ? model.getRootFactTable().getTableDesc() : allTables[i].getTableRef().getTableDesc();
			 allTableDesc.add(table);
			 if (generated.contains(table)) continue;
			 logger.info(String.format(Locale.ROOT, ""generating data for %s"", table));
			 boolean gen = generateTable(table);
			 if (gen) generated.add(table);
		 }
		 generateDDL(allTableDesc);
	 }
	 private boolean generateTable(TableDesc table) throws IOException {
		 TableGenConfig config = new TableGenConfig(table, this);
		 if (!config.needGen) return false;
		 ByteArrayOutputStream bout = new ByteArrayOutputStream();
		 PrintWriter pout = new PrintWriter(new OutputStreamWriter(bout, StandardCharsets.UTF_8));
		 generateTableInternal(table, config, pout);
		 pout.close();
		 bout.close();
		 saveResource(bout.toByteArray(), path(table));
		 return true;
	 }
	 private void generateTableInternal(TableDesc table, TableGenConfig config, PrintWriter out) throws IOException {
		 ColumnDesc[] columns = table.getColumns();
		 ColumnGenerator[] colGens = new ColumnGenerator[columns.length];
		 Iterator<String>[] colIters = new Iterator[columns.length];
		 int tableRows = (int) ((config.rows > 1) ? config.rows : targetRows * config.rows);
		 tableRows = Math.max(1, tableRows);
		 long seed = System.currentTimeMillis();
		 for (int i = 0;
		 i < columns.length;
		 i++) {
			 colGens[i] = new ColumnGenerator(columns[i], tableRows, this);
			 colIters[i] = colGens[i].generate(seed);
		 }
		 for (int i = 0;
		 i < tableRows;
		 i++) {
			 for (int c = 0;
			 c < columns.length;
			 c++) {
				 if (c > 0) out.print("","");
				 String v = colIters[c].next();
				 Preconditions.checkState(v == null || !v.contains("",""));
				 out.print(v);
			 }
			 out.print(""\n"");
		 }
	 }
	 private void generateDDL(Set<TableDesc> tables) throws IOException {
		 ByteArrayOutputStream bout = new ByteArrayOutputStream();
		 PrintWriter pout = new PrintWriter(new OutputStreamWriter(bout, StandardCharsets.UTF_8));
		 generateDatabaseDDL(tables, pout);
		 generateCreateTableDDL(tables, pout);
		 generateLoadDataDDL(tables, pout);
		 pout.close();
		 bout.close();
		 saveResource(bout.toByteArray(), path(model));
	 }
	 private void generateDatabaseDDL(Set<TableDesc> tables, PrintWriter out) {
		 Set<String> dbs = new HashSet<>();
		 for (TableDesc t : tables) {
			 String db = t.getDatabase();
			 if (StringUtils.isBlank(db) == false && ""DEFAULT"".equals(db) == false) dbs.add(db);
		 }
		 for (String db : dbs) {
			 out.print(""CREATE DATABASE IF NOT EXISTS "" + normHiveIdentifier(db) + "";
			\n"");
		 }
		 out.print(""\n"");
	 }
	 private void generateCreateTableDDL(Set<TableDesc> tables, PrintWriter out) {
		 for (TableDesc t : tables) {
			 if (t.isView()) continue;
			 out.print(""DROP TABLE IF EXISTS "" + normHiveIdentifier(t.getIdentity()) + "";
			\n"");
			 out.print(""CREATE TABLE "" + normHiveIdentifier(t.getIdentity()) + ""("" + ""\n"");
			 for (int i = 0;
			 i < t.getColumns().length;
			 i++) {
				 ColumnDesc col = t.getColumns()[i];
				 out.print("" "");
				 if (i > 0) {
					 out.print("","");
				 }
				 out.print(normHiveIdentifier(col.getName()) + "" "" + hiveType(col.getType()) + ""\n"");
			 }
			 out.print("")"" + ""\n"");
			 out.print(""ROW FORMAT DELIMITED FIELDS TERMINATED BY ','"" + ""\n"");
			 out.print(""STORED AS TEXTFILE"" + "";
			\n"");
			 out.print(""\n"");
		 }
	 }
	 private String normHiveIdentifier(String orig) {
		 return ""`"" + orig + ""`"";
	 }
	 private String hiveType(DataType type) {
		 String t = type.toString();
		 if (t.startsWith(""varchar"")) return ""string"";
		 else if (t.startsWith(""integer"")) return ""int"";
		 else return t;
	 }
	 private void generateLoadDataDDL(Set<TableDesc> tables, PrintWriter out) {
		 for (TableDesc t : tables) {
			 if (t.isView()) {
				 out.print(""-- "" + t.getIdentity() + "" is view \n"");
				 continue;
			 }
			 out.print(""LOAD DATA LOCAL INPATH '"" + t.getIdentity() + "".csv' OVERWRITE INTO TABLE "" + normHiveIdentifier(t.getIdentity()) + "";
			\n"");
		 }
	 }
	 public boolean existsInStore(TableDesc table) throws IOException {
		 return outputStore.exists(path(table));
	 }
	 public boolean isPK(ColumnDesc col) {
		 for (JoinTableDesc joinTable : model.getJoinTables()) {
			 JoinDesc join = joinTable.getJoin();
			 for (TblColRef pk : join.getPrimaryKeyColumns()) {
				 if (pk.getColumnDesc().equals(col)) return true;
			 }
		 }
		 return false;
	 }
	 public List<String> getPkValuesIfIsFk(ColumnDesc fk) throws IOException {
		 JoinTableDesc[] joinTables = model.getJoinTables();
		 for (int i = 0;
		 i < joinTables.length;
		 i++) {
			 JoinTableDesc joinTable = joinTables[i];
			 ColumnDesc pk = findPk(joinTable, fk);
			 if (pk == null) continue;
			 List<String> pkValues = getPkValues(pk);
			 if (pkValues != null) return pkValues;
		 }
		 return null;
	 }
	 private ColumnDesc findPk(JoinTableDesc joinTable, ColumnDesc fk) {
		 TblColRef[] fkCols = joinTable.getJoin().getForeignKeyColumns();
		 for (int i = 0;
		 i < fkCols.length;
		 i++) {
			 if (fkCols[i].getColumnDesc().equals(fk)) return joinTable.getJoin().getPrimaryKeyColumns()[i].getColumnDesc();
		 }
		 return null;
	 }
	 public List<String> getPkValues(ColumnDesc pk) throws IOException {
		 if (existsInStore(pk.getTable()) == false) return null;
		 List<String> r = new ArrayList<>();
		 BufferedReader in = new BufferedReader( new InputStreamReader(outputStore.getResource(path(pk.getTable())).content(), ""UTF-8""));
		 try {
			 String line;
			 while ((line = in.readLine()) != null) {
				 r.add(line.split("","")[pk.getZeroBasedIndex()]);
			 }
		 }
		 finally {
			 IOUtils.closeQuietly(in);
		 }
		 return r;
	 }
	 private void saveResource(byte[] content, String path) throws IOException {
		 System.out.println(""Generated "" + outputStore.getReadableResourcePath(path));
		 if (outprint) {
			 System.out.println(Bytes.toString(content));
		 }
		 outputStore.putResource(path, new ByteArrayInputStream(content), System.currentTimeMillis());
	 }
	 private String path(TableDesc table) {
		 return outputPath + ""/"" + table.getIdentity() + "".csv"";
	 }
	 private String path(DataModelDesc model) {
		 return outputPath + ""/"" + ""ddl_"" + model.getName() + "".sql"";
	 }
	 public DataModelDesc getModle() {
		 return model;
	 }
	 public static void main(String[] args) throws IOException {
		 String modelName = args[0];
		 int nRows = Integer.parseInt(args[1]);
		 String outputDir = args.length > 2 ? args[2] : null;
		 KylinConfig conf = KylinConfig.getInstanceFromEnv();
		 DataModelDesc model = DataModelManager.getInstance(conf).getDataModelDesc(modelName);
		 ResourceStore store = outputDir == null ? ResourceStore.getStore(conf) : ResourceStore.getStore(mockup(outputDir));
		 ModelDataGenerator gen = new ModelDataGenerator(model, nRows, store);
		 gen.generate();
	 }
	 private static KylinConfig mockup(String outputDir) {
		 KylinConfig mockup = KylinConfig.createKylinConfig(KylinConfig.getInstanceFromEnv());
		 mockup.setMetadataUrl(new File(outputDir).getAbsolutePath());
		 return mockup;
	 }
}",1,0,0,0
"public final class ConfigBoolean extends ConfigVariable{
	 public ConfigBoolean(OptionSpec spec) {
		 super(spec);
		 this.enabled = false;
		 this.isSet = false;
	 }
	 public ConfigBoolean(OptionSpec spec, boolean enabled) {
		 super(spec);
		 this.set(enabled);
	 }
	 private boolean enabled;
	 private boolean isSet;
	 public void set(boolean value) {
		 this.enabled = value;
		 this.isSet = true;
	 }
	 public void set(String value) {
		 this.enabled = parseValue(value);
		 this.isSet = true;
	 }
	 public boolean isSet() {
		 return isSet;
	 }
	 public void addToCommandline(Commandline cmdline) {
		 if (isSet) cmdline.createArgument(true).setValue(""-"" + spec.getFullName() + ""="" + enabled);
	 }
	 private boolean parseValue(String value) {
		 return value.toLowerCase().matches(""\\s*(true|yes|on)\\s*"");
	 }
}",0,1,0,0
"public class POLocalRearrange extends PhysicalOperator {
	 private static final Log log = LogFactory.getLog(POLocalRearrange.class);
	 protected static final long serialVersionUID = 1L;
	 private static final Result ERR_RESULT = new Result();
	 protected List<PhysicalPlan> plans;
	 protected List<PhysicalPlan> secondaryPlans;
	 protected List<ExpressionOperator> leafOps;
	 protected List<ExpressionOperator> secondaryLeafOps;
	 protected byte index;
	 protected byte keyType;
	 protected byte mainKeyType;
	 protected byte secondaryKeyType;
	 protected boolean mIsDistinct = false;
	 protected boolean isCross = false;
	 private final Map<Integer, Integer> mProjectedColsMap;
	 private final Map<Integer, Integer> mSecondaryProjectedColsMap;
	 protected Tuple mFakeTuple = null;
	private boolean mProjectStar = false;
	private boolean mSecondaryProjectStar = false;
	 private boolean isKeyTuple = false;
	 private boolean isKeyCompound = false;
	 private boolean isSecondaryKeyTuple = false;
	 private int mProjectedColsMapSize = 0;
	 private int mSecondaryProjectedColsMapSize = 0;
	 private boolean useSecondaryKey = false;
	 private boolean stripKeyFromValue = true;
	 protected transient Result inp;
	 public POLocalRearrange(OperatorKey k) {
		 this(k, -1, null);
	 }
	 public POLocalRearrange(OperatorKey k, int rp) {
		 this(k, rp, null);
	 }
	 public POLocalRearrange(OperatorKey k, List<PhysicalOperator> inp) {
		 this(k, -1, inp);
	 }
	 public POLocalRearrange(OperatorKey k, int rp, List<PhysicalOperator> inp) {
		 super(k, rp, inp);
		 index = -1;
		 leafOps = new ArrayList<ExpressionOperator>();
		 secondaryLeafOps = new ArrayList<ExpressionOperator>();
		 mProjectedColsMap = new HashMap<Integer, Integer>();
		 mSecondaryProjectedColsMap = new HashMap<Integer, Integer>();
	 }
	 public POLocalRearrange(POLocalRearrange copy) {
		 super(copy);
		 this.plans = copy.plans;
		 this.secondaryPlans = copy.secondaryPlans;
		 this.leafOps = copy.leafOps;
		 this.secondaryLeafOps = copy.secondaryLeafOps;
		 this.index = copy.index;
		 this.keyType = copy.keyType;
		 this.mainKeyType = copy.mainKeyType;
		 this.secondaryKeyType = copy.secondaryKeyType;
		 this.mIsDistinct = copy.mIsDistinct;
		 this.isCross = copy.isCross;
		 this.mProjectedColsMap = copy.mProjectedColsMap;
		 this.mSecondaryProjectedColsMap = copy.mSecondaryProjectedColsMap;
		 this.mFakeTuple = copy.mFakeTuple;
		 this.mProjectStar = copy.mProjectStar;
		 this.mSecondaryProjectStar = copy.mSecondaryProjectStar;
		 this.isKeyTuple = copy.isKeyTuple;
		 this.isKeyCompound = copy.isKeyCompound;
		 this.isSecondaryKeyTuple = copy.isSecondaryKeyTuple;
		 this.mProjectedColsMapSize = copy.mProjectedColsMapSize;
		 this.mSecondaryProjectedColsMapSize = copy.mSecondaryProjectedColsMapSize;
		 this.useSecondaryKey = copy.useSecondaryKey;
		 this.stripKeyFromValue = copy.stripKeyFromValue;
	 }
	 public void visit(PhyPlanVisitor v) throws VisitorException {
		 v.visitLocalRearrange(this);
	 }
	 public String name() {
		 return getAliasString() + ""Local Rearrange"" + ""["" + DataType.findTypeName(resultType) + ""]"" + ""{
		"" + DataType.findTypeName(keyType) + ""}
		"" + ""("" + mIsDistinct + "") - "" + mKey.toString();
	 }
	 public boolean supportsMultipleInputs() {
		 return false;
	 }
	 public boolean supportsMultipleOutputs() {
		 return false;
	 }
	 public byte getIndex() {
		 return index;
	 }
	 public void setIndex(int index) throws ExecException {
		 setIndex(index, false);
	 }
	 public void setMultiQueryIndex(int index) throws ExecException {
		 setIndex(index, true);
	 }
	 private void setIndex(int index, boolean multiQuery) throws ExecException {
		 if (index > PigNullableWritable.idxSpace) {
			 int errCode = 1082;
			 String msg = multiQuery? ""Merge more than 127 map-reduce jobs not supported."" : ""Cogroups with more than 127 inputs not supported."";
			 throw new ExecException(msg, errCode, PigException.INPUT);
		 }
		 else {
			 this.index = multiQuery ? (byte)(index | PigNullableWritable.mqFlag) : (byte)index;
		 }
	 }
	 public boolean isDistinct() {
		 return mIsDistinct;
	 }
	 public void setDistinct(boolean isDistinct) {
		 mIsDistinct = isDistinct;
		 if (mIsDistinct) {
			 mFakeTuple = mTupleFactory.newTuple();
		 }
	 }
	 public void attachInput(Tuple t) {
		 super.attachInput(t);
	 }
	 public Result getNextTuple() throws ExecException {
		 inp = null;
		 Result res = ERR_RESULT;
		 while (true) {
			 inp = processInput();
			 if (inp.returnStatus == POStatus.STATUS_EOP || inp.returnStatus == POStatus.STATUS_ERR) {
				 break;
			 }
			 if (inp.returnStatus == POStatus.STATUS_NULL) {
				 continue;
			 }
			 for (PhysicalPlan ep : plans) {
				 ep.attachInput((Tuple)inp.result);
			 }
			 List<Result> resLst = new ArrayList<Result>();
			 if (secondaryPlans!=null) {
				 for (PhysicalPlan ep : secondaryPlans) {
					 ep.attachInput((Tuple)inp.result);
				 }
			 }
			 List<Result> secondaryResLst = null;
			 if (secondaryLeafOps!=null) {
				 secondaryResLst = new ArrayList<Result>();
			 }
			 for (ExpressionOperator op : leafOps){
				 switch(op.getResultType()){
					 case DataType.BAG: case DataType.BOOLEAN: case DataType.BYTEARRAY: case DataType.CHARARRAY: case DataType.DOUBLE: case DataType.FLOAT: case DataType.INTEGER: case DataType.LONG: case DataType.BIGINTEGER: case DataType.BIGDECIMAL: case DataType.DATETIME: case DataType.MAP: case DataType.TUPLE: res = op.getNext(op.getResultType());
					 break;
					 default: log.error(""Invalid result type: "" + DataType.findType(op.getResultType()));
					 break;
				 }
				 if (res.returnStatus != POStatus.STATUS_OK) {
					 return res;
				 }
				 resLst.add(res);
			 }
			 if (secondaryLeafOps!=null) {
				 for (ExpressionOperator op : secondaryLeafOps){
					 switch(op.getResultType()){
						 case DataType.BAG: case DataType.BOOLEAN: case DataType.BYTEARRAY: case DataType.CHARARRAY: case DataType.DOUBLE: case DataType.BIGINTEGER: case DataType.BIGDECIMAL: case DataType.FLOAT: case DataType.INTEGER: case DataType.LONG: case DataType.DATETIME: case DataType.MAP: case DataType.TUPLE: res = op.getNext(op.getResultType());
						 break;
						 default: log.error(""Invalid result type: "" + DataType.findType(op.getResultType()));
						 break;
					 }
					 if (res.returnStatus != POStatus.STATUS_OK && res.returnStatus != POStatus.STATUS_NULL) {
						 return new Result();
					 }
					 secondaryResLst.add(res);
				 }
			 }
			 res.result = constructLROutput(resLst,secondaryResLst,(Tuple)inp.result);
			 res.returnStatus = POStatus.STATUS_OK;
			 detachPlans(plans);
			 if(secondaryPlans != null) {
				 detachPlans(secondaryPlans);
			 }
			 res.result = illustratorMarkup(inp.result, res.result, 0);
			 return res;
		 }
		 return inp;
	 }
	 private void detachPlans(List<PhysicalPlan> plans) {
		 for (PhysicalPlan ep : plans) {
			 ep.detachInput();
		 }
	 }
	 protected Object getKeyFromResult(List<Result> resLst, byte type) throws ExecException {
		 Object key;
		 if(resLst.size()>1){
			 Tuple t = mTupleFactory.newTuple(resLst.size());
			 int i=-1;
			 for(Result res : resLst) {
				 t.set(++i, res.result);
			 }
			 key = t;
		 }
		 else if (resLst.size() == 1 && type == DataType.TUPLE) {
			 Object obj = resLst.get(0).result;
			 if (obj instanceof Tuple) {
				 key = obj;
			 }
			 else {
				 Tuple t = mTupleFactory.newTuple(1);
				 t.set(0, resLst.get(0).result);
				 key = t;
			 }
		 }
		 else{
			 key = resLst.get(0).result;
		 }
		 return key;
	 }
	 protected Tuple constructLROutput(List<Result> resLst, List<Result> secondaryResLst, Tuple value) throws ExecException{
		 Tuple lrOutput = mTupleFactory.newTuple(3);
		 lrOutput.set(0, Byte.valueOf(this.index));
		 Object key;
		 Object secondaryKey=null;
		 if (secondaryResLst!=null && secondaryResLst.size()>0) {
			 key = getKeyFromResult(resLst, mainKeyType);
			 secondaryKey = getKeyFromResult(secondaryResLst, secondaryKeyType);
		 }
		 else {
			 key = getKeyFromResult(resLst, keyType);
		 }
		 if(!stripKeyFromValue){
			 lrOutput.set(1, key);
			 lrOutput.set(2, value);
			 return lrOutput;
		 }
		 if (mIsDistinct) {
			 lrOutput.set(1, key);
			 if (illustrator != null) lrOutput.set(2, key);
			 else lrOutput.set(2, mFakeTuple);
			 return lrOutput;
		 }
		 else if(isCross){
			 for(int i=0;
			i<plans.size();
			i++) {
				 value.getAll().remove(0);
			 }
			 lrOutput.set(1, key);
			 lrOutput.set(2, value);
			 return lrOutput;
		 }
		 else {
			 if (useSecondaryKey) {
				 Tuple compoundKey = mTupleFactory.newTuple(2);
				 compoundKey.set(0, key);
				 compoundKey.set(1, secondaryKey);
				 lrOutput.set(1, compoundKey);
			 }
			 else {
				 lrOutput.set(1, key);
			 }
			 if(mProjectedColsMapSize != 0 || mProjectStar == true) {
				 Tuple minimalValue = null;
				 if(!mProjectStar) {
					 minimalValue = mTupleFactory.newTuple();
					 for (int i = 0;
					 i < value.size();
					 i++) {
						 if(mProjectedColsMap.get(i) == null) {
							 minimalValue.append(value.get(i));
						 }
					 }
					 minimalValue = illustratorMarkup(value, minimalValue, -1);
				 }
				 else {
					 minimalValue = mTupleFactory.newTuple(0);
				 }
				 lrOutput.set(2, minimalValue);
			 }
			 else {
				 lrOutput.set(2, value);
			 }
			 return lrOutput;
		 }
	 }
	 public byte getKeyType() {
		 return keyType;
	 }
	 public byte getMainKeyType() {
		 return mainKeyType;
	 }
	 public void setKeyType(byte keyType) {
		 if (useSecondaryKey) {
			 this.mainKeyType = keyType;
		 }
		 else {
			 this.keyType = keyType;
			 this.mainKeyType = keyType;
		 }
	 }
	 public List<PhysicalPlan> getPlans() {
		 return plans;
	 }
	 public void setUseSecondaryKey(boolean useSecondaryKey) {
		 this.useSecondaryKey = useSecondaryKey;
		 mainKeyType = keyType;
	 }
	 public void setPlans(List<PhysicalPlan> plans) throws PlanException {
		 this.plans = plans;
		 leafOps.clear();
		 int keyIndex = 0;
		 for (PhysicalPlan plan : plans) {
			 ExpressionOperator leaf = (ExpressionOperator)plan.getLeaves().get(0);
			 leafOps.add(leaf);
			 if(!isCross) {
				 if(leaf instanceof POProject) {
					 POProject project = (POProject) leaf;
					 if(project.isStar()) {
						 mProjectStar = true;
						 isKeyTuple = true;
						 break;
					 }
					 else if(project.isProjectToEnd()){
						 List<PhysicalOperator> preds = plan.getPredecessors(project);
						 if(preds != null && preds.size() != 0){
							 throw new AssertionError(""project-range has predecessors"");
						 }
						 break;
					 }
					 else {
						 try {
							 List<PhysicalOperator> preds = plan.getPredecessors(leaf);
							 if (preds==null || !(preds.get(0) instanceof POProject)) {
								 mProjectedColsMap.put(project.getColumn(), keyIndex);
							 }
						 }
						 catch (ExecException e) {
							 int errCode = 2070;
							 String msg = ""Problem in accessing column from project operator."";
							 throw new PlanException(msg, errCode, PigException.BUG);
						 }
					 }
					 if(project.getResultType() == DataType.TUPLE) {
						 isKeyTuple = true;
					 }
				 }
				 keyIndex++;
			 }
		 }
		 if(keyIndex > 1) {
			 isKeyTuple = true;
			 isKeyCompound = true;
		 }
		 mProjectedColsMapSize = mProjectedColsMap.size();
	 }
	 public void setSecondaryPlans(List<PhysicalPlan> plans) throws PlanException {
		 this.secondaryPlans = plans;
		 secondaryLeafOps.clear();
		 int keyIndex = 0;
		 for (PhysicalPlan plan : plans) {
			 ExpressionOperator leaf = (ExpressionOperator)plan.getLeaves().get(0);
			 secondaryLeafOps.add(leaf);
			 if(!isCross) {
				 if(leaf instanceof POProject) {
					 POProject project = (POProject) leaf;
					 if(project.isStar()) {
						 mSecondaryProjectStar = true;
						 isSecondaryKeyTuple = true;
						 break;
					 }
					 else if(project.isProjectToEnd()){
						 List<PhysicalOperator> preds = plan.getPredecessors(project);
						 if(preds != null && preds.size() != 0){
							 throw new AssertionError(""project-range has predecessors"");
						 }
						 break;
					 }
					 else {
						 try {
							 List<PhysicalOperator> preds = plan.getPredecessors(leaf);
							 if (preds==null || !(preds.get(0) instanceof POProject)) {
								 mSecondaryProjectedColsMap.put(project.getColumn(), keyIndex);
							 }
						 }
						 catch (ExecException e) {
							 int errCode = 2070;
							 String msg = ""Problem in accessing column from project operator."";
							 throw new PlanException(msg, errCode, PigException.BUG);
						 }
					 }
					 if(project.getResultType() == DataType.TUPLE) {
						 isSecondaryKeyTuple = true;
					 }
				 }
				 keyIndex++;
			 }
		 }
		 if(keyIndex > 1) {
			 isSecondaryKeyTuple = true;
		 }
		 mainKeyType = keyType;
		 keyType = DataType.TUPLE;
		 if (plans.size()>1) {
			 secondaryKeyType = DataType.TUPLE;
		 }
		 else {
			 secondaryKeyType = plans.get(0).getLeaves().get(0).getResultType();
		 }
		 mSecondaryProjectedColsMapSize = mSecondaryProjectedColsMap.size();
	 }
	 public POLocalRearrange clone() throws CloneNotSupportedException {
		 POLocalRearrange clone = (POLocalRearrange) super.clone();
		 clone.leafOps = new ArrayList<ExpressionOperator>();
		 clone.secondaryLeafOps = new ArrayList<ExpressionOperator>();
		 clone.setDistinct(mIsDistinct);
		 if (useSecondaryKey) {
			 clone.keyType = mainKeyType;
		 }
		 try {
			 clone.setPlans(clonePlans(plans));
			 if (secondaryPlans != null) {
				 clone.setSecondaryPlans(clonePlans(secondaryPlans));
			 }
		 }
		 catch (PlanException pe) {
			 CloneNotSupportedException cnse = new CloneNotSupportedException(""Problem with setting plans of "" + this.getClass().getSimpleName());
			 cnse.initCause(pe);
			 throw cnse;
		 }
		 return clone;
	 }
	 public boolean isCross() {
		 return isCross;
	 }
	 public void setCross(boolean isCross) {
		 this.isCross = isCross;
	 }
	 public Map<Integer, Integer> getProjectedColsMap() {
		 return mProjectedColsMap;
	 }
	 public Map<Integer, Integer> getSecondaryProjectedColsMap() {
		 return mSecondaryProjectedColsMap;
	 }
	 public boolean isProjectStar() {
		 return mProjectStar;
	 }
	 public boolean isSecondaryProjectStar() {
		 return mSecondaryProjectStar;
	 }
	 public boolean isKeyTuple() {
		 return isKeyTuple;
	 }
	 public boolean isKeyCompound() {
		 return isKeyCompound;
	 }
	 public boolean isSecondaryKeyTuple() {
		 return isSecondaryKeyTuple;
	 }
	 public void setPlansFromCombiner(List<PhysicalPlan> plans) throws PlanException {
		 this.plans = plans;
		 leafOps.clear();
		 mProjectedColsMap.clear();
		 int keyIndex = 0;
		 for (PhysicalPlan plan : plans) {
			 ExpressionOperator leaf = (ExpressionOperator)plan.getLeaves().get(0);
			 leafOps.add(leaf);
			 if(!isCross) {
				 if(leaf instanceof POProject) {
					 POProject project = (POProject) leaf;
					 if(project.isProjectToEnd()) {
						 int errCode = 2021;
						 String msg = ""Internal error. Unexpected operator project(*) "" + ""or (..) in local rearrange inner plan."";
						 throw new PlanException(msg, errCode, PigException.BUG);
					 }
					 else {
						 try {
							 mProjectedColsMap.put(project.getColumn(), keyIndex);
						 }
						 catch (ExecException e) {
							 int errCode = 2070;
							 String msg = ""Problem in accessing column from project operator."";
							 throw new PlanException(msg, errCode, PigException.BUG);
						 }
					 }
					 if(project.getResultType() == DataType.TUPLE) {
						 isKeyTuple = true;
					 }
				 }
				 keyIndex++;
			 }
		 }
		 if(keyIndex > 1) {
			 isKeyTuple = true;
		 }
		 mProjectedColsMapSize = mProjectedColsMap.size();
	 }
	 protected void setStripKeyFromValue(boolean stripKeyFromValue) {
		 this.stripKeyFromValue = stripKeyFromValue;
	 }
	 public Tuple illustratorMarkup(Object in, Object out, int eqClassIndex) {
		 if (illustrator != null) {
			 if (!(out instanceof ExampleTuple)) {
				 ExampleTuple tOut = new ExampleTuple((Tuple) out);
				 illustrator.getLineage().insert(tOut);
				 illustrator.addData(tOut);
				 illustrator.getLineage().union(tOut, (Tuple) in);
				 tOut.synthetic = ((ExampleTuple) in).synthetic;
				 return tOut;
			 }
		 }
		 return (Tuple) out;
	 }
}",1,0,0,0
"private void processNormalVideo(ParsedHookData data) {
	String file = data.getFile();
	String type = data.getContentType();
	if (type == null) {
		type = """";
	}
	if (StringUtils.isNullOrEmptyOrBlank(file)) {
		file = XDMUtils.getFileName(data.getUrl());
	}
	String ext = """";
	if (type.contains(""video/mp4"")) {
		ext = ""mp4"";
	}
	 else if (type.contains(""video/x-flv"")) {
		ext = ""flv"";
	}
	 else if (type.contains(""video/webm"")) {
		ext = ""mkv"";
	}
	 else if (type.contains(""matroska"") || type.contains(""mkv"")) {
		ext = ""mkv"";
	}
	 else if (type.equals(""audio/mpeg"") || type.contains(""audio/mp3"")) {
		ext = ""mp3"";
	}
	 else if (type.contains(""audio/aac"")) {
		ext = ""aac"";
	}
	 else if (type.contains(""audio/mp4"")) {
		ext = ""m4a"";
	}
	 else {
		return;
	}
	file += ""."" + ext;
	if (data.getContentLength() < Config.getInstance().getMinVidSize()) {
		Logger.log(""video less than min size"");
		return;
	}
	HttpMetadata metadata = new HttpMetadata();
	metadata.setUrl(data.getUrl());
	metadata.setHeaders(data.getRequestHeaders());
	metadata.setSize(data.getContentLength());
	long size = data.getContentLength();
	if (size > 0) {
		if (data.isPartialResponse()) {
			size = -1;
		}
	}
	String sz = (size > 0 ? FormatUtilities.formatSize(size) : """");
	if (ext.length() > 0) {
		sz += "" "" + ext.toUpperCase();
	}
	XDMApp.getInstance().addMedia(metadata, file, sz);
}",0,0,1,0
"class Segment {
	 private byte segmentType;
	 Segment(byte segmentType) {
		 this.segmentType = segmentType;
	 }
	 public byte getSegmentType() {
		 return segmentType;
	 }
}",0,1,0,0
"public class Project implements ResourceFactory {
	 private static final String LINE_SEP = System.getProperty(""line.separator"");
	 public static final int MSG_ERR = 0;
	 public static final int MSG_WARN = 1;
	 public static final int MSG_INFO = 2;
	 public static final int MSG_VERBOSE = 3;
	 public static final int MSG_DEBUG = 4;
	 private static final String VISITING = ""VISITING"";
	 private static final String VISITED = ""VISITED"";
	 public static final String JAVA_1_0 = JavaEnvUtils.JAVA_1_0;
	 public static final String JAVA_1_1 = JavaEnvUtils.JAVA_1_1;
	 public static final String JAVA_1_2 = JavaEnvUtils.JAVA_1_2;
	 public static final String JAVA_1_3 = JavaEnvUtils.JAVA_1_3;
	 public static final String JAVA_1_4 = JavaEnvUtils.JAVA_1_4;
	 public static final String TOKEN_START = FilterSet.DEFAULT_TOKEN_START;
	 public static final String TOKEN_END = FilterSet.DEFAULT_TOKEN_END;
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private String name;
	 private String description;
	 private Hashtable references = new AntRefTable();
	 private HashMap idReferences = new HashMap();
	 private Project parentIdProject = null;
	 private String defaultTarget;
	 private Hashtable targets = new Hashtable();
	 private FilterSet globalFilterSet = new FilterSet();
	 {
		 globalFilterSet.setProject(this);
	 }
	 private FilterSetCollection globalFilters = new FilterSetCollection(globalFilterSet);
	 private File baseDir;
	 private Vector listeners = new Vector();
	 private ClassLoader coreLoader = null;
	 private Map threadTasks = Collections.synchronizedMap(new WeakHashMap());
	 private Map threadGroupTasks = Collections.synchronizedMap(new WeakHashMap());
	 private InputHandler inputHandler = null;
	 private InputStream defaultInputStream = null;
	 private boolean keepGoingMode = false;
	 private boolean loggingMessage = false;
	 public void setInputHandler(InputHandler handler) {
		 inputHandler = handler;
	 }
	 public void setDefaultInputStream(InputStream defaultInputStream) {
		 this.defaultInputStream = defaultInputStream;
	 }
	 public InputStream getDefaultInputStream() {
		 return defaultInputStream;
	 }
	 public InputHandler getInputHandler() {
		 return inputHandler;
	 }
	 public Project() {
		 inputHandler = new DefaultInputHandler();
	 }
	 public Project createSubProject() {
		 Project subProject = null;
		 try {
			 subProject = (Project) (getClass().newInstance());
		 }
		 catch (Exception e) {
			 subProject = new Project();
		 }
		 initSubProject(subProject);
		 return subProject;
	 }
	 public void initSubProject(Project subProject) {
		 ComponentHelper.getComponentHelper(subProject) .initSubProject(ComponentHelper.getComponentHelper(this));
		 subProject.setDefaultInputStream(getDefaultInputStream());
		 subProject.setKeepGoingMode(this.isKeepGoingMode());
		 subProject.setExecutor(getExecutor().getSubProjectExecutor());
	 }
	 public void init() throws BuildException {
		 initProperties();
		 ComponentHelper.getComponentHelper(this).initDefaultDefinitions();
	 }
	 public void initProperties() throws BuildException {
		 setJavaVersionProperty();
		 setSystemProperties();
		 setPropertyInternal(MagicNames.ANT_VERSION, Main.getAntVersion());
		 setAntLib();
	 }
	 private void setAntLib() {
		 File antlib = org.apache.tools.ant.launch.Locator.getClassSource( Project.class);
		 if (antlib != null) {
			 setPropertyInternal(MagicNames.ANT_LIB, antlib.getAbsolutePath());
		 }
	 }
	 public AntClassLoader createClassLoader(Path path) {
		 return new AntClassLoader( getClass().getClassLoader(), this, path);
	 }
	 public AntClassLoader createClassLoader( ClassLoader parent, Path path) {
		 return new AntClassLoader(parent, this, path);
	 }
	 public void setCoreLoader(ClassLoader coreLoader) {
		 this.coreLoader = coreLoader;
	 }
	 public ClassLoader getCoreLoader() {
		 return coreLoader;
	 }
	 public synchronized void addBuildListener(BuildListener listener) {
		 if (listeners.contains(listener)) {
			 return;
		 }
		 Vector newListeners = getBuildListeners();
		 newListeners.addElement(listener);
		 listeners = newListeners;
	 }
	 public synchronized void removeBuildListener(BuildListener listener) {
		 Vector newListeners = getBuildListeners();
		 newListeners.removeElement(listener);
		 listeners = newListeners;
	 }
	 public Vector getBuildListeners() {
		 return (Vector) listeners.clone();
	 }
	 public void log(String message) {
		 log(message, MSG_INFO);
	 }
	 public void log(String message, int msgLevel) {
		 log(message, null, msgLevel);
	 }
	 public void log(String message, Throwable throwable, int msgLevel) {
		 fireMessageLogged(this, message, throwable, msgLevel);
	 }
	 public void log(Task task, String message, int msgLevel) {
		 fireMessageLogged(task, message, null, msgLevel);
	 }
	 public void log(Task task, String message, Throwable throwable, int msgLevel) {
		 fireMessageLogged(task, message, throwable, msgLevel);
	 }
	 public void log(Target target, String message, int msgLevel) {
		 log(target, message, null, msgLevel);
	 }
	 public void log(Target target, String message, Throwable throwable, int msgLevel) {
		 fireMessageLogged(target, message, throwable, msgLevel);
	 }
	 public FilterSet getGlobalFilterSet() {
		 return globalFilterSet;
	 }
	 public void setProperty(String name, String value) {
		 PropertyHelper.getPropertyHelper(this). setProperty(null, name, value, true);
	 }
	 public void setNewProperty(String name, String value) {
		 PropertyHelper.getPropertyHelper(this).setNewProperty(null, name, value);
	 }
	 public void setUserProperty(String name, String value) {
		 PropertyHelper.getPropertyHelper(this).setUserProperty(null, name, value);
	 }
	 public void setInheritedProperty(String name, String value) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 ph.setInheritedProperty(null, name, value);
	 }
	 private void setPropertyInternal(String name, String value) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 ph.setProperty(null, name, value, false);
	 }
	 public String getProperty(String propertyName) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return (String) ph.getProperty(null, propertyName);
	 }
	 public String replaceProperties(String value) throws BuildException {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return ph.replaceProperties(null, value, null);
	 }
	 public String getUserProperty(String propertyName) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return (String) ph.getUserProperty(null, propertyName);
	 }
	 public Hashtable getProperties() {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return ph.getProperties();
	 }
	 public Hashtable getUserProperties() {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return ph.getUserProperties();
	 }
	 public void copyUserProperties(Project other) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 ph.copyUserProperties(other);
	 }
	 public void copyInheritedProperties(Project other) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 ph.copyInheritedProperties(other);
	 }
	 public void setDefaultTarget(String defaultTarget) {
		 this.defaultTarget = defaultTarget;
	 }
	 public String getDefaultTarget() {
		 return defaultTarget;
	 }
	 public void setDefault(String defaultTarget) {
		 this.defaultTarget = defaultTarget;
	 }
	 public void setName(String name) {
		 setUserProperty(""ant.project.name"", name);
		 this.name = name;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setDescription(String description) {
		 this.description = description;
	 }
	 public String getDescription() {
		 if (description == null) {
			 description = Description.getDescription(this);
		 }
		 return description;
	 }
	 public void addFilter(String token, String value) {
		 if (token == null) {
			 return;
		 }
		 globalFilterSet.addFilter(new FilterSet.Filter(token, value));
	 }
	 public Hashtable getFilters() {
		 return globalFilterSet.getFilterHash();
	 }
	 public void setBasedir(String baseD) throws BuildException {
		 setBaseDir(new File(baseD));
	 }
	 public void setBaseDir(File baseDir) throws BuildException {
		 baseDir = FILE_UTILS.normalize(baseDir.getAbsolutePath());
		 if (!baseDir.exists()) {
			 throw new BuildException(""Basedir "" + baseDir.getAbsolutePath() + "" does not exist"");
		 }
		 if (!baseDir.isDirectory()) {
			 throw new BuildException(""Basedir "" + baseDir.getAbsolutePath() + "" is not a directory"");
		 }
		 this.baseDir = baseDir;
		 setPropertyInternal(MagicNames.PROJECT_BASEDIR, this.baseDir.getPath());
		 String msg = ""Project base dir set to: "" + this.baseDir;
		 log(msg, MSG_VERBOSE);
	 }
	 public File getBaseDir() {
		 if (baseDir == null) {
			 try {
				 setBasedir(""."");
			 }
			 catch (BuildException ex) {
				 ex.printStackTrace();
			 }
		 }
		 return baseDir;
	 }
	 public void setKeepGoingMode(boolean keepGoingMode) {
		 this.keepGoingMode = keepGoingMode;
	 }
	 public boolean isKeepGoingMode() {
		 return this.keepGoingMode;
	 }
	 public static String getJavaVersion() {
		 return JavaEnvUtils.getJavaVersion();
	 }
	 public void setJavaVersionProperty() throws BuildException {
		 String javaVersion = JavaEnvUtils.getJavaVersion();
		 setPropertyInternal(MagicNames.ANT_JAVA_VERSION, javaVersion);
		 if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_0) || JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_1)) {
			 throw new BuildException(""Ant cannot work on Java 1.0 / 1.1"");
		 }
		 log(""Detected Java version: "" + javaVersion + "" in: "" + System.getProperty(""java.home""), MSG_VERBOSE);
		 log(""Detected OS: "" + System.getProperty(""os.name""), MSG_VERBOSE);
	 }
	 public void setSystemProperties() {
		 Properties systemP = System.getProperties();
		 Enumeration e = systemP.propertyNames();
		 while (e.hasMoreElements()) {
			 String propertyName = (String) e.nextElement();
			 String value = systemP.getProperty(propertyName);
			 this.setPropertyInternal(propertyName, value);
		 }
	 }
	 public void addTaskDefinition(String taskName, Class taskClass) throws BuildException {
		 ComponentHelper.getComponentHelper(this).addTaskDefinition(taskName, taskClass);
	 }
	 public void checkTaskClass(final Class taskClass) throws BuildException {
		 ComponentHelper.getComponentHelper(this).checkTaskClass(taskClass);
		 if (!Modifier.isPublic(taskClass.getModifiers())) {
			 final String message = taskClass + "" is not public"";
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message);
		 }
		 if (Modifier.isAbstract(taskClass.getModifiers())) {
			 final String message = taskClass + "" is abstract"";
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message);
		 }
		 try {
			 taskClass.getConstructor((Class[]) null);
		 }
		 catch (NoSuchMethodException e) {
			 final String message = ""No public no-arg constructor in "" + taskClass;
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message);
		 }
		 catch (LinkageError e) {
			 String message = ""Could not load "" + taskClass + "": "" + e;
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message, e);
		 }
		 if (!Task.class.isAssignableFrom(taskClass)) {
			 TaskAdapter.checkTaskClass(taskClass, this);
		 }
	 }
	 public Hashtable getTaskDefinitions() {
		 return ComponentHelper.getComponentHelper(this).getTaskDefinitions();
	 }
	 public void addDataTypeDefinition(String typeName, Class typeClass) {
		 ComponentHelper.getComponentHelper(this).addDataTypeDefinition(typeName, typeClass);
	 }
	 public Hashtable getDataTypeDefinitions() {
		 return ComponentHelper.getComponentHelper(this).getDataTypeDefinitions();
	 }
	 public void addTarget(Target target) throws BuildException {
		 addTarget(target.getName(), target);
	 }
	 public void addTarget(String targetName, Target target) throws BuildException {
		 if (targets.get(targetName) != null) {
			 throw new BuildException(""Duplicate target: `"" + targetName + ""'"");
		 }
		 addOrReplaceTarget(targetName, target);
	 }
	 public void addOrReplaceTarget(Target target) {
		 addOrReplaceTarget(target.getName(), target);
	 }
	 public void addOrReplaceTarget(String targetName, Target target) {
		 String msg = "" +Target: "" + targetName;
		 log(msg, MSG_DEBUG);
		 target.setProject(this);
		 targets.put(targetName, target);
	 }
	 public Hashtable getTargets() {
		 return targets;
	 }
	 public Task createTask(String taskType) throws BuildException {
		 return ComponentHelper.getComponentHelper(this).createTask(taskType);
	 }
	 public Object createDataType(String typeName) throws BuildException {
		 return ComponentHelper.getComponentHelper(this).createDataType(typeName);
	 }
	 public void setExecutor(Executor e) {
		 addReference(MagicNames.ANT_EXECUTOR_REFERENCE, e);
	 }
	 public Executor getExecutor() {
		 Object o = getReference(MagicNames.ANT_EXECUTOR_REFERENCE);
		 if (o == null) {
			 String classname = getProperty(MagicNames.ANT_EXECUTOR_CLASSNAME);
			 if (classname == null) {
				 classname = DefaultExecutor.class.getName();
			 }
			 log(""Attempting to create object of type "" + classname, MSG_DEBUG);
			 try {
				 o = Class.forName(classname, true, coreLoader).newInstance();
			 }
			 catch (ClassNotFoundException seaEnEfEx) {
				 try {
					 o = Class.forName(classname).newInstance();
				 }
				 catch (Exception ex) {
					 log(ex.toString(), MSG_ERR);
				 }
			 }
			 catch (Exception ex) {
				 log(ex.toString(), MSG_ERR);
			 }
			 if (o == null) {
				 throw new BuildException( ""Unable to obtain a Target Executor instance."");
			 }
			 setExecutor((Executor) o);
		 }
		 return (Executor) o;
	 }
	 public void executeTargets(Vector names) throws BuildException {
		 getExecutor().executeTargets(this, (String[]) (names.toArray(new String[names.size()])));
	 }
	 public void demuxOutput(String output, boolean isWarning) {
		 Task task = getThreadTask(Thread.currentThread());
		 if (task == null) {
			 log(output, isWarning ? MSG_WARN : MSG_INFO);
		 }
		 else {
			 if (isWarning) {
				 task.handleErrorOutput(output);
			 }
			 else {
				 task.handleOutput(output);
			 }
		 }
	 }
	 public int defaultInput(byte[] buffer, int offset, int length) throws IOException {
		 if (defaultInputStream != null) {
			 System.out.flush();
			 return defaultInputStream.read(buffer, offset, length);
		 }
		 else {
			 throw new EOFException(""No input provided for project"");
		 }
	 }
	 public int demuxInput(byte[] buffer, int offset, int length) throws IOException {
		 Task task = getThreadTask(Thread.currentThread());
		 if (task == null) {
			 return defaultInput(buffer, offset, length);
		 }
		 else {
			 return task.handleInput(buffer, offset, length);
		 }
	 }
	 public void demuxFlush(String output, boolean isError) {
		 Task task = getThreadTask(Thread.currentThread());
		 if (task == null) {
			 fireMessageLogged(this, output, isError ? MSG_ERR : MSG_INFO);
		 }
		 else {
			 if (isError) {
				 task.handleErrorFlush(output);
			 }
			 else {
				 task.handleFlush(output);
			 }
		 }
	 }
	 public void executeTarget(String targetName) throws BuildException {
		 if (targetName == null) {
			 String msg = ""No target specified"";
			 throw new BuildException(msg);
		 }
		 executeSortedTargets(topoSort(targetName, targets, false));
	 }
	 public void executeSortedTargets(Vector sortedTargets) throws BuildException {
		 Set succeededTargets = new HashSet();
		 BuildException buildException = null;
		 for (Enumeration iter = sortedTargets.elements();
		 iter.hasMoreElements();
		) {
			 Target curtarget = (Target) iter.nextElement();
			 boolean canExecute = true;
			 for (Enumeration depIter = curtarget.getDependencies();
			 depIter.hasMoreElements();
			) {
				 String dependencyName = ((String) depIter.nextElement());
				 if (!succeededTargets.contains(dependencyName)) {
					 canExecute = false;
					 log(curtarget, ""Cannot execute '"" + curtarget.getName() + ""' - '"" + dependencyName + ""' failed or was not executed."", MSG_ERR);
					 break;
				 }
			 }
			 if (canExecute) {
				 Throwable thrownException = null;
				 try {
					 curtarget.performTasks();
					 succeededTargets.add(curtarget.getName());
				 }
				 catch (RuntimeException ex) {
					 if (!(keepGoingMode)) {
						 throw ex;
					 }
					 thrownException = ex;
				 }
				 catch (Throwable ex) {
					 if (!(keepGoingMode)) {
						 throw new BuildException(ex);
					 }
					 thrownException = ex;
				 }
				 if (thrownException != null) {
					 if (thrownException instanceof BuildException) {
						 log(curtarget, ""Target '"" + curtarget.getName() + ""' failed with message '"" + thrownException.getMessage() + ""'."", MSG_ERR);
						 if (buildException == null) {
							 buildException = (BuildException) thrownException;
						 }
					 }
					 else {
						 log(curtarget, ""Target '"" + curtarget.getName() + ""' failed with message '"" + thrownException.getMessage() + ""'."", MSG_ERR);
						 thrownException.printStackTrace(System.err);
						 if (buildException == null) {
							 buildException = new BuildException(thrownException);
						 }
					 }
				 }
			 }
		 }
		 if (buildException != null) {
			 throw buildException;
		 }
	 }
	 public File resolveFile(String fileName, File rootDir) {
		 return FILE_UTILS.resolveFile(rootDir, fileName);
	 }
	 public File resolveFile(String fileName) {
		 return FILE_UTILS.resolveFile(baseDir, fileName);
	 }
	 public static String translatePath(String toProcess) {
		 return FileUtils.translatePath(toProcess);
	 }
	 public void copyFile(String sourceFile, String destFile) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering, boolean overwrite) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering, boolean overwrite, boolean preserveLastModified) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite, preserveLastModified);
	 }
	 public void copyFile(File sourceFile, File destFile) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering, boolean overwrite) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering, boolean overwrite, boolean preserveLastModified) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite, preserveLastModified);
	 }
	 public void setFileLastModified(File file, long time) throws BuildException {
		 FILE_UTILS.setFileLastModified(file, time);
		 log(""Setting modification time for "" + file, MSG_VERBOSE);
	 }
	 public static boolean toBoolean(String s) {
		 return (""on"".equalsIgnoreCase(s) || ""true"".equalsIgnoreCase(s) || ""yes"".equalsIgnoreCase(s));
	 }
	 public final Vector topoSort(String root, Hashtable targetTable) throws BuildException {
		 return topoSort(new String[] {
		root}
		, targetTable, true);
	 }
	 public final Vector topoSort(String root, Hashtable targetTable, boolean returnAll) throws BuildException {
		 return topoSort(new String[] {
		root}
		, targetTable, returnAll);
	 }
	 public final Vector topoSort(String[] root, Hashtable targetTable, boolean returnAll) throws BuildException {
		 Vector ret = new Vector();
		 Hashtable state = new Hashtable();
		 Stack visiting = new Stack();
		 for (int i = 0;
		 i < root.length;
		 i++) {
			 String st = (String) (state.get(root[i]));
			 if (st == null) {
				 tsort(root[i], targetTable, state, visiting, ret);
			 }
			 else if (st == VISITING) {
				 throw new RuntimeException(""Unexpected node in visiting state: "" + root[i]);
			 }
		 }
		 StringBuffer buf = new StringBuffer(""Build sequence for target(s)"");
		 for (int j = 0;
		 j < root.length;
		 j++) {
			 buf.append((j == 0) ? "" `"" : "", `"").append(root[j]).append('\'');
		 }
		 buf.append("" is "" + ret);
		 log(buf.toString(), MSG_VERBOSE);
		 Vector complete = (returnAll) ? ret : new Vector(ret);
		 for (Enumeration en = targetTable.keys();
		 en.hasMoreElements();
		) {
			 String curTarget = (String) en.nextElement();
			 String st = (String) state.get(curTarget);
			 if (st == null) {
				 tsort(curTarget, targetTable, state, visiting, complete);
			 }
			 else if (st == VISITING) {
				 throw new RuntimeException(""Unexpected node in visiting state: "" + curTarget);
			 }
		 }
		 log(""Complete build sequence is "" + complete, MSG_VERBOSE);
		 return ret;
	 }
	 private void tsort(String root, Hashtable targetTable, Hashtable state, Stack visiting, Vector ret) throws BuildException {
		 state.put(root, VISITING);
		 visiting.push(root);
		 Target target = (Target) targetTable.get(root);
		 if (target == null) {
			 StringBuffer sb = new StringBuffer(""Target \"""");
			 sb.append(root);
			 sb.append(""\"" does not exist in the project \"""");
			 sb.append(name);
			 sb.append(""\"". "");
			 visiting.pop();
			 if (!visiting.empty()) {
				 String parent = (String) visiting.peek();
				 sb.append(""It is used from target \"""");
				 sb.append(parent);
				 sb.append(""\""."");
			 }
			 throw new BuildException(new String(sb));
		 }
		 for (Enumeration en = target.getDependencies();
		 en.hasMoreElements();
		) {
			 String cur = (String) en.nextElement();
			 String m = (String) state.get(cur);
			 if (m == null) {
				 tsort(cur, targetTable, state, visiting, ret);
			 }
			 else if (m == VISITING) {
				 throw makeCircularException(cur, visiting);
			 }
		 }
		 String p = (String) visiting.pop();
		 if (root != p) {
			 throw new RuntimeException(""Unexpected internal error: expected to "" + ""pop "" + root + "" but got "" + p);
		 }
		 state.put(root, VISITED);
		 ret.addElement(target);
	 }
	 private static BuildException makeCircularException(String end, Stack stk) {
		 StringBuffer sb = new StringBuffer(""Circular dependency: "");
		 sb.append(end);
		 String c;
		 do {
			 c = (String) stk.pop();
			 sb.append("" <- "");
			 sb.append(c);
		 }
		 while (!c.equals(end));
		 return new BuildException(new String(sb));
	 }
	 public void inheritIDReferences(Project parent) {
		 parentIdProject = parent;
	 }
	 private Object resolveIdReference(String key, Project callerProject) {
		 UnknownElement origUE = (UnknownElement) idReferences.get(key);
		 if (origUE == null) {
			 return parentIdProject == null ? null : parentIdProject.resolveIdReference(key, callerProject);
		 }
		 callerProject.log( ""Warning: Reference "" + key + "" has not been set at runtime,"" + "" but was found during"" + LINE_SEP + ""build file parsing, attempting to resolve."" + "" Future versions of Ant may support"" + LINE_SEP + "" referencing ids defined in non-executed targets."", MSG_WARN);
		 UnknownElement copyUE = origUE.copy(callerProject);
		 copyUE.maybeConfigure();
		 return copyUE.getRealThing();
	 }
	 public void addIdReference(String id, Object value) {
		 idReferences.put(id, value);
	 }
	 public void addReference(String referenceName, Object value) {
		 synchronized (references) {
			 Object old = ((AntRefTable) references).getReal(referenceName);
			 if (old == value) {
				 return;
			 }
			 if (old != null && !(old instanceof UnknownElement)) {
				 log(""Overriding previous definition of reference to "" + referenceName, MSG_VERBOSE);
			 }
			 log(""Adding reference: "" + referenceName, MSG_DEBUG);
			 references.put(referenceName, value);
		 }
	 }
	 public Hashtable getReferences() {
		 return references;
	 }
	 public Object getReference(String key) {
		 Object ret = references.get(key);
		 if (ret != null) {
			 return ret;
		 }
		 ret = resolveIdReference(key, this);
		 if (ret == null && !key.equals(MagicNames.REFID_PROPERTY_HELPER)) {
			 Vector p = new Vector();
			 PropertyHelper.getPropertyHelper(this).parsePropertyString( key, new Vector(), p);
			 if (p.size() == 1) {
				 log(""Unresolvable reference "" + key + "" might be a misuse of property expansion syntax."", MSG_WARN);
			 }
		 }
		 return ret;
	 }
	 public String getElementName(Object element) {
		 return ComponentHelper.getComponentHelper(this).getElementName(element);
	 }
	 public void fireBuildStarted() {
		 BuildEvent event = new BuildEvent(this);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.buildStarted(event);
		 }
	 }
	 public void fireBuildFinished(Throwable exception) {
		 BuildEvent event = new BuildEvent(this);
		 event.setException(exception);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.buildFinished(event);
		 }
		 IntrospectionHelper.clearCache();
	 }
	 public void fireSubBuildStarted() {
		 BuildEvent event = new BuildEvent(this);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 Object listener = iter.next();
			 if (listener instanceof SubBuildListener) {
				 ((SubBuildListener) listener).subBuildStarted(event);
			 }
		 }
	 }
	 public void fireSubBuildFinished(Throwable exception) {
		 BuildEvent event = new BuildEvent(this);
		 event.setException(exception);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 Object listener = iter.next();
			 if (listener instanceof SubBuildListener) {
				 ((SubBuildListener) listener).subBuildFinished(event);
			 }
		 }
	 }
	 protected void fireTargetStarted(Target target) {
		 BuildEvent event = new BuildEvent(target);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.targetStarted(event);
		 }
	 }
	 protected void fireTargetFinished(Target target, Throwable exception) {
		 BuildEvent event = new BuildEvent(target);
		 event.setException(exception);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.targetFinished(event);
		 }
	 }
	 protected void fireTaskStarted(Task task) {
		 registerThreadTask(Thread.currentThread(), task);
		 BuildEvent event = new BuildEvent(task);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.taskStarted(event);
		 }
	 }
	 protected void fireTaskFinished(Task task, Throwable exception) {
		 registerThreadTask(Thread.currentThread(), null);
		 System.out.flush();
		 System.err.flush();
		 BuildEvent event = new BuildEvent(task);
		 event.setException(exception);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.taskFinished(event);
		 }
	 }
	 private void fireMessageLoggedEvent(BuildEvent event, String message, int priority) {
		 if (message.endsWith(StringUtils.LINE_SEP)) {
			 int endIndex = message.length() - StringUtils.LINE_SEP.length();
			 event.setMessage(message.substring(0, endIndex), priority);
		 }
		 else {
			 event.setMessage(message, priority);
		 }
		 synchronized (this) {
			 if (loggingMessage) {
				 return;
			 }
			 try {
				 loggingMessage = true;
				 Iterator iter = listeners.iterator();
				 while (iter.hasNext()) {
					 BuildListener listener = (BuildListener) iter.next();
					 listener.messageLogged(event);
				 }
			 }
			 finally {
				 loggingMessage = false;
			 }
		 }
	 }
	 protected void fireMessageLogged(Project project, String message, int priority) {
		 fireMessageLogged(project, message, null, priority);
	 }
	 protected void fireMessageLogged(Project project, String message, Throwable throwable, int priority) {
		 BuildEvent event = new BuildEvent(project);
		 event.setException(throwable);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 protected void fireMessageLogged(Target target, String message, int priority) {
		 fireMessageLogged(target, message, null, priority);
	 }
	 protected void fireMessageLogged(Target target, String message, Throwable throwable, int priority) {
		 BuildEvent event = new BuildEvent(target);
		 event.setException(throwable);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 protected void fireMessageLogged(Task task, String message, int priority) {
		 fireMessageLogged(task, message, null, priority);
	 }
	 protected void fireMessageLogged(Task task, String message, Throwable throwable, int priority) {
		 BuildEvent event = new BuildEvent(task);
		 event.setException(throwable);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 public synchronized void registerThreadTask(Thread thread, Task task) {
		 if (task != null) {
			 threadTasks.put(thread, task);
			 threadGroupTasks.put(thread.getThreadGroup(), task);
		 }
		 else {
			 threadTasks.remove(thread);
			 threadGroupTasks.remove(thread.getThreadGroup());
		 }
	 }
	 public Task getThreadTask(Thread thread) {
		 Task task = (Task) threadTasks.get(thread);
		 if (task == null) {
			 ThreadGroup group = thread.getThreadGroup();
			 while (task == null && group != null) {
				 task = (Task) threadGroupTasks.get(group);
				 group = group.getParent();
			 }
		 }
		 return task;
	 }
	 private static class AntRefTable extends Hashtable {
		 AntRefTable() {
			 super();
		 }
		 private Object getReal(Object key) {
			 return super.get(key);
		 }
		 public Object get(Object key) {
			 Object o = getReal(key);
			 if (o instanceof UnknownElement) {
				 UnknownElement ue = (UnknownElement) o;
				 ue.maybeConfigure();
				 o = ue.getRealThing();
			 }
			 return o;
		 }
	 }
	 public final void setProjectReference(final Object obj) {
		 if (obj instanceof ProjectComponent) {
			 ((ProjectComponent) obj).setProject(this);
			 return;
		 }
		 try {
			 Method method = obj.getClass().getMethod( ""setProject"", new Class[] {
			Project.class}
			);
			 if (method != null) {
				 method.invoke(obj, new Object[] {
				this}
				);
			 }
		 }
		 catch (Throwable e) {
		 }
	 }
	 public Resource getResource(String name) {
		 return new FileResource(getBaseDir(), name);
	 }
}",1,0,0,0
"public class GraphicsNodeRable8Bit extends AbstractRable implements GraphicsNodeRable, PaintRable {
	 private AffineTransform cachedGn2dev = null;
	 private AffineTransform cachedUsr2dev = null;
	 private CachableRed cachedRed = null;
	 private Rectangle2D cachedBounds = null;
	 private boolean usePrimitivePaint = true;
	 public boolean getUsePrimitivePaint() {
		 return usePrimitivePaint;
	 }
	 public void setUsePrimitivePaint(boolean usePrimitivePaint) {
		 this.usePrimitivePaint = usePrimitivePaint;
	 }
	 private GraphicsNode node;
	 public GraphicsNode getGraphicsNode(){
		 return node;
	 }
	 public void setGraphicsNode(GraphicsNode node){
		 if(node == null){
			 throw new IllegalArgumentException();
		 }
		 this.node = node;
	 }
	 public void clearCache() {
		 cachedRed = null;
		 cachedUsr2dev = null;
		 cachedGn2dev = null;
		 cachedBounds = null;
	 }
	 public GraphicsNodeRable8Bit(GraphicsNode node){
		 if(node == null) throw new IllegalArgumentException();
		 this.node = node;
		 this.usePrimitivePaint = true;
	 }
	 public GraphicsNodeRable8Bit(GraphicsNode node, Map props){
		 super((Filter)null, props);
		 if(node == null) throw new IllegalArgumentException();
		 this.node = node;
		 this.usePrimitivePaint = true;
	 }
	 public GraphicsNodeRable8Bit(GraphicsNode node, boolean usePrimitivePaint){
		 if(node == null) throw new IllegalArgumentException();
		 this.node = node;
		 this.usePrimitivePaint = usePrimitivePaint;
	 }
	 public Rectangle2D getBounds2D(){
		 if (usePrimitivePaint){
			 Rectangle2D primitiveBounds = node.getPrimitiveBounds();
			 if(primitiveBounds == null) return new Rectangle2D.Double(0, 0, 0, 0);
			 return (Rectangle2D)(primitiveBounds.clone());
		 }
		 Rectangle2D bounds = node.getBounds();
		 if(bounds == null){
			 return new Rectangle2D.Double(0, 0, 0, 0);
		 }
		 AffineTransform at = node.getTransform();
		 if (at != null){
			 bounds = at.createTransformedShape(bounds).getBounds2D();
		 }
		 return bounds;
	 }
	 public boolean isDynamic(){
		 return false;
	 }
	 public boolean paintRable(Graphics2D g2d) {
		 Composite c = g2d.getComposite();
		 if (!SVGComposite.OVER.equals(c)) return false;
		 ColorSpace g2dCS = GraphicsUtil.getDestinationColorSpace(g2d);
		 if ((g2dCS == null) || (g2dCS != ColorSpace.getInstance(ColorSpace.CS_sRGB))){
			 return false;
		 }
		 GraphicsNode gn = getGraphicsNode();
		 if (getUsePrimitivePaint()){
			 gn.primitivePaint(g2d);
		 }
		 else{
			 gn.paint(g2d);
		 }
		 return true;
	 }
	 public RenderedImage createRendering(RenderContext renderContext){
		 AffineTransform usr2dev = renderContext.getTransform();
		 AffineTransform gn2dev;
		 if (usr2dev == null) {
			 usr2dev = new AffineTransform();
			 gn2dev = usr2dev;
		 }
		 else {
			 gn2dev = (AffineTransform)usr2dev.clone();
		 }
		 AffineTransform gn2usr = node.getTransform();
		 if (gn2usr != null) {
			 gn2dev.concatenate(gn2usr);
		 }
		 Rectangle2D bounds2D = getBounds2D();
		 if ((cachedBounds != null) && (cachedGn2dev != null) && (cachedBounds.equals(bounds2D)) && (gn2dev.getScaleX() == cachedGn2dev.getScaleX()) && (gn2dev.getScaleY() == cachedGn2dev.getScaleY()) && (gn2dev.getShearX() == cachedGn2dev.getShearX()) && (gn2dev.getShearY() == cachedGn2dev.getShearY())) {
			 double deltaX = (usr2dev.getTranslateX() - cachedUsr2dev.getTranslateX());
			 double deltaY = (usr2dev.getTranslateY() - cachedUsr2dev.getTranslateY());
			 if ((deltaX ==0) && (deltaY == 0)) return cachedRed;
			 if ((deltaX == (int)deltaX) && (deltaY == (int)deltaY)) {
				 return new TranslateRed (cachedRed, (int)Math.round(cachedRed.getMinX()+deltaX), (int)Math.round(cachedRed.getMinY()+deltaY));
			 }
		 }
		 if (false) {
			 System.out.println(""Not using Cached Red: "" + usr2dev);
			 System.out.println(""Old: "" + cachedUsr2dev);
		 }
		 if((bounds2D.getWidth() > 0) && (bounds2D.getHeight() > 0)) {
			 cachedUsr2dev = (AffineTransform)usr2dev.clone();
			 cachedGn2dev = gn2dev;
			 cachedBounds = bounds2D;
			 cachedRed = new GraphicsNodeRed8Bit (node, usr2dev, usePrimitivePaint, renderContext.getRenderingHints());
			 return cachedRed;
		 }
		 cachedUsr2dev = null;
		 cachedGn2dev = null;
		 cachedBounds = null;
		 cachedRed = null;
		 return null;
	 }
}",1,1,0,0
"class Foo {
	 static void doit() throws Exception {
		 System.out.println(""*** About to invoke getThreadContextClassLoader().getResource()"");
		 URL r = Thread.currentThread().getContextClassLoader().getResource(""/org/apache/aries/spifly/test/blah.txt"");
		 System.out.println(""*** Found resource: "" + r);
		 System.out.println(""*** First line of content: "" + new BufferedReader(new InputStreamReader(r.openStream())).readLine());
	 }
}",0,0,0,0
"public class TestLoaderStorerShipCacheFilesTez extends TestLoaderStorerShipCacheFiles {
	 protected void checkPlan(PhysicalPlan pp, String[] expectedFiles, int size, PigContext pigContext) throws Exception {
		 TezLauncher launcher = new TezLauncher();
		 TezPlanContainer tezPlanContainer = launcher.compile(pp, pigContext);
		 assertPlanContains(tezPlanContainer.getRoots().get(0).getTezOperPlan(), expectedFiles, size);
	 }
	 private void assertPlanContains(TezOperPlan plan, String[] expectedFiles, int size) throws VisitorException {
		 TezPOUserFuncVisitor udfVisitor = new TezPOUserFuncVisitor(plan);
		 udfVisitor.visit();
		 List<String> shipFiles = new ArrayList<String>();
		 shipFiles.addAll(udfVisitor.getShipFiles());
		 Assert.assertEquals(shipFiles.size(), size);
		 assertContains(shipFiles, expectedFiles);
	 }
}",1,0,0,0
"public static class Builder extends BaseServer.Builder<MetadataServer> {
	 public MetadataServer build() {
		 validate();
		 return new MetadataServer(getOpts());
	 }
 }",0,0,0,0
"public class MemberMatrix {
	final static String[] COLS = {
	 ""owned"", ""inherited"", ""implemented"" }
	;
	final static int OWNED = 0;
	final static int INHERITED = 1;
	final static int IMPLEMENTED = 2;
	final static int CONSUMED = 3;
	final static int SOURCE_COUNT_WITHOUT_CONSUMED = 3;
	 final static int MEMBER_TYPE_COUNT = MemberType.values().length;
	 private final Set<TMember> consumed;
	private final MemberList<TMember>[][] memberMatrix;
	private final MemberList<TMember> nonImplemented;
	public class SourceAwareIterator implements Iterator<TMember> {
		private int lastRetrievedSource = -1;
		private TMember lastRetrievedElement;
		protected int source;
		protected Iterator<TMember> currentIter;
		private TMember next;
		final private boolean returnConsumed;
		SourceAwareIterator(boolean returnConsumed) {
			this.returnConsumed = returnConsumed;
			initIter();
			next = findNext();
		}
		protected void initIter() {
			source = OWNED;
			currentIter = members(source).iterator();
		}
		public boolean isActualMember() {
			return lastRetrievedSource == OWNED || lastRetrievedSource == CONSUMED|| (lastRetrievedSource == INHERITED && isActuallyInherited(lastRetrievedElement));
		}
		public boolean isInterfaceMember() {
			return lastRetrievedSource == IMPLEMENTED;
		}
		public boolean isInheritedMember() {
			return lastRetrievedSource == INHERITED;
		}
		public boolean isOwnedMember() {
			return lastRetrievedSource == OWNED;
		}
		protected TMember findNext() {
			do {
				while (currentIter.hasNext()) {
					TMember m = currentIter.next();
					if (!returnConsumed || source != IMPLEMENTED || !consumed.contains(m)) {
						return m;
					}
				}
				currentIter = nextIter();
			}
			 while (source >= 0);
			return null;
		}
		protected Iterator<TMember> nextIter() {
			switch (source) {
				case OWNED:if (returnConsumed) {
					source = CONSUMED;
					return consumed.iterator();
				}
				 case CONSUMED: {
					source = INHERITED;
					return members(source).iterator();
				}
				case INHERITED: {
					source = IMPLEMENTED;
					return members(source).iterator();
				}
				case IMPLEMENTED:default:source = -1;
				return null;
			}
		}
		public boolean hasNext() {
			return source >= 0;
		}
		public TMember next() {
			if (!hasNext()) {
				throw new NoSuchElementException();
			}
			lastRetrievedElement = next;
			lastRetrievedSource = source;
			next = findNext();
			return lastRetrievedElement;
		}
	}
	public class ActuallyInheritedAndConsumedMembersIterator extends SourceAwareIterator {
		ActuallyInheritedAndConsumedMembersIterator() {
			super(true);
		}
		protected void initIter() {
			source = CONSUMED;
			currentIter = consumed.iterator();
		}
		protected TMember findNext() {
			do {
				while (currentIter.hasNext()) {
					TMember m = currentIter.next();
					if (source == CONSUMED || isActuallyInherited(m)) {
						return m;
					}
				}
				currentIter = nextIter();
			}
			 while (source >= 0);
			return null;
		}
		protected Iterator<TMember> nextIter() {
			switch (source) {
				case CONSUMED: {
					source = INHERITED;
					return members(source).iterator();
				}
				default:source = -1;
				return null;
			}
		}
	}
	public MemberMatrix() {
		memberMatrix = new MemberList[SOURCE_COUNT_WITHOUT_CONSUMED][MEMBER_TYPE_COUNT];
		consumed = new HashSet<>(2);
		nonImplemented = new MemberList<>(2);
	}
	public void markConsumed(MemberList<TMember> consumedMembers) {
		consumed.addAll(consumedMembers);
	}
	public boolean isConsumed(TMember member) {
		return consumed.contains(member);
	}
	public boolean hasOwnedAccessorPair() {
		return !members(OWNED, GETTER).isEmpty() && !members(OWNED, SETTER).isEmpty();
	}
	public boolean hasMixedAccessorPair() {
		boolean hasOwnedGetter = !members(OWNED, GETTER).isEmpty();
		boolean hasOwnedSetter = !members(OWNED, SETTER).isEmpty();
		boolean hasInheritedGetter = !members(INHERITED, GETTER).isEmpty();
		boolean hasInheritedSetter = !members(INHERITED, SETTER).isEmpty();
		return (!hasOwnedGetter && hasInheritedGetter && hasOwnedSetter) ||(hasOwnedGetter && hasInheritedSetter && !hasOwnedSetter);
	}
	public boolean hasAccessorPair() {
		return (!members(OWNED, GETTER).isEmpty() || !members(INHERITED, GETTER).isEmpty()|| !members(IMPLEMENTED, GETTER).isEmpty()) &&(!members(OWNED, SETTER).isEmpty() || !members(INHERITED, SETTER).isEmpty()|| !members(IMPLEMENTED, SETTER).isEmpty());
	}
	public SourceAwareIterator allMembers() {
		return new SourceAwareIterator(false);
	}
	public ActuallyInheritedAndConsumedMembersIterator actuallyInheritedAndMixedMembers() {
		return new ActuallyInheritedAndConsumedMembersIterator();
	}
	public SourceAwareIterator ownedConsumedInheritedImplemented() {
		return new SourceAwareIterator(true);
	}
	private <T extends TMember> MemberList<T> members(int source, MemberType type) {
		MemberList<T> list = (MemberList<T>) memberMatrix[source][type.getValue()];
		if (list == null) {
			return MemberList.emptyList();
		}
		return list;
	}
	private boolean hasOwnedOrNotAbstractMember(int source, MemberType type) {
		MemberList<TMember> list = members(source, type);
		if (list.isEmpty()) {
			return false;
		}
		if (source == OWNED) {
			return true;
		}
		return list.stream().anyMatch(m -> !m.isAbstract());
	}
	public Iterable<TMember> owned() {
		return members(OWNED);
	}
	public Iterable<TMember> inherited() {
		return members(INHERITED);
	}
	public Iterable<TMember> implemented() {
		return members(IMPLEMENTED);
	}
	private Iterable<TMember> members(int source) {
		return hasSource(source) ? Iterables.concat(members(source, GETTER),members(source, SETTER),members(source, FIELD),members(source, METHOD)) : MemberList.emptyList();
	}
	public Iterable<TMember> nonImplemented() {
		return nonImplemented;
	}
	public boolean hasOwned() {
		return hasSource(OWNED);
	}
	public boolean hasInherited() {
		return hasSource(INHERITED);
	}
	public boolean hasImplemented() {
		return hasSource(IMPLEMENTED);
	}
	public boolean hasNonImplemented() {
		return !nonImplemented.isEmpty();
	}
	private boolean hasSource(int source) {
		for (int i = 0;
		 i < MEMBER_TYPE_COUNT;
		 i++) {
			if (memberMatrix[source][i] != null) {
				return true;
			}
		}
		return false;
	}
	boolean isActuallyInherited(TMember m) {
		if (hasOwned()) {
			if (m.getMemberType() == GETTER) {
				if (hasOwnedOrNotAbstractMember(OWNED, FIELD)|| hasOwnedOrNotAbstractMember(OWNED, GETTER)|| hasOwnedOrNotAbstractMember(OWNED, METHOD)) {
					return false;
				}
			}
			 else if (m.getMemberType() == SETTER) {
				if (hasOwnedOrNotAbstractMember(OWNED, FIELD)|| hasOwnedOrNotAbstractMember(OWNED, SETTER)|| hasOwnedOrNotAbstractMember(OWNED, METHOD)) {
					return false;
				}
			}
			 else {
				return false;
			}
		}
		if (m.isField() || !m.isAbstract()) {
			return true;
		}
		if (hasImplemented()) {
			if (m.getMemberType() == GETTER) {
				if (hasOwnedOrNotAbstractMember(IMPLEMENTED, FIELD)|| hasOwnedOrNotAbstractMember(IMPLEMENTED, GETTER)|| hasOwnedOrNotAbstractMember(IMPLEMENTED, METHOD)) {
					return false;
				}
			}
			 else if (m.getMemberType() == SETTER) {
				if (hasOwnedOrNotAbstractMember(IMPLEMENTED, FIELD)|| hasOwnedOrNotAbstractMember(IMPLEMENTED, SETTER)|| hasOwnedOrNotAbstractMember(IMPLEMENTED, METHOD)) {
					return false;
				}
			}
			 else {
				return false;
			}
		}
		return true;
	}
	public void add(int source, TMember member) {
		if (source == IMPLEMENTED && member.isStatic() && member.getContainingType() instanceof TInterface) {
			nonImplemented.add(member);
			return;
		}
		int row = member.getMemberType().getValue();
		MemberList<TMember> list = memberMatrix[source][row];
		if (list == null) {
			list = new MemberList<>();
			memberMatrix[source][row] = list;
		}
		list.add(member);
	}
	public String toString() {
		if (!allMembers().hasNext()) {
			return ""MemberMatrix not initialized yet."";
		}
		TMember first = allMembers().next();
		StringBuilder strb = new StringBuilder(""MemberMatrix: "");
		if (first.isStatic()) {
			strb.append(""static "");
		}
		strb.append(first.getName());
		strb.append(""\n"");
		final int tab = 15;
		StringBuilder row = new StringBuilder();
		tab(row, 10);
		for (int source = 0;
		 source < SOURCE_COUNT_WITHOUT_CONSUMED;
		 source++) {
			row.append(COLS[source]);
			if (source < 2) {
				tab(row, 10 + (1 + source) * tab);
			}
		}
		strb.append(row);
		for (MemberType type : MemberType.values()) {
			row.setLength(0);
			row.append(type.getName()).append("": "");
			tab(row, 10);
			for (int source = 0;
			 source < SOURCE_COUNT_WITHOUT_CONSUMED;
			 source++) {
				row.append(members(source, type).stream().map(m -> m.getContainingType().getName()).collect(Collectors.joining("","")));
				if (source < 2) {
					tab(row, 10 + (1 + source) * tab);
				}
			}
			strb.append(""\n"").append(row);
		}
		strb.append(""\n"");
		if (!consumed.isEmpty()) {
			strb.append(""consumed: "");
			strb.append(consumed.stream().map(m -> m != null ? m.getMemberType() + "" "" + m.getContainingType().getName() + "".""+ m.getName() : ""null"").collect(Collectors.joining("","")));
		}
		return strb.toString();
	}
	private void tab(StringBuilder strb, int offset) {
		UtilN4.fill(strb, offset);
		strb.append('|');
	}
	String toShortString() {
		if (!allMembers().hasNext()) {
			return ""MemberMatrix not initialized yet."";
		}
		StringBuilder strb = new StringBuilder(""["");
		for (MemberType type : MemberType.values()) {
			for (int source = 0;
			 source < SOURCE_COUNT_WITHOUT_CONSUMED;
			 source++) {
				strb.append(members(source, type).stream().map(m -> m.getMemberType().getName().charAt(0) + "" "" + m.getContainingType().getName()).collect(Collectors.joining("","")));
			}
		}
		if (!consumed.isEmpty()) {
			strb.append("", consumed: "");
			strb.append(consumed.stream().map(m -> m != null ? m.getMemberType().getName().charAt(0) + "" ""+ m.getContainingType().getName() : ""null"").collect(Collectors.joining("","")));
		}
		strb.append(""]"");
		return strb.toString();
	}
	public TMember possibleOverrideCandidateOrError(TMember member) {
		TMember result = null;
		for (TMember m : Iterables.concat(implemented(), inherited())) {
			if (!TypeUtils.isAccessorPair(member, m)) {
				if (m.getMemberAccessModifier() == MemberAccessModifier.PRIVATE) {
					result = m;
				}
				 else {
					return m;
				}
			}
		}
		return result;
	}
}",1,0,0,0
"private final class UserAcceptedListener implements CustomEventListener<UserAcceptedMessage> {
	 public void onCustomEvent(AffinityTopologyVersion topVer, ClusterNode snd, UserAcceptedMessage msg) {
		 if (!isEnabled || ctx.isStopping()) return;
		 if (log.isDebugEnabled()) log.debug(msg.toString());
		 synchronized (mux) {
			 UserOperationFinishFuture f = opFinishFuts.get(msg.operationId());
			 if (f != null) {
				 if (msg.error() != null) f.onDone(null, msg.error());
				 else f.onDone();
			 }
		 }
	 }
 }",0,0,0,0
"public final class HSLFException extends RuntimeException {
	 public HSLFException() {
		 super();
	 }
	 public HSLFException(String message) {
		 super(message);
	 }
	 public HSLFException(String message, Throwable cause) {
		 super(message, cause);
	 }
	 public HSLFException(Throwable cause) {
		 super(cause);
	 }
}",0,0,0,0
"public class CompositeReactiveHealthIndicator implements ReactiveHealthIndicator {
	private final ReactiveHealthIndicatorRegistry registry;
	private final HealthAggregator healthAggregator;
	private Long timeout;
	private Health timeoutHealth;
	private final Function<Mono<Health>, Mono<Health>> timeoutCompose;
	public CompositeReactiveHealthIndicator(HealthAggregator healthAggregator,ReactiveHealthIndicatorRegistry registry) {
		this.registry = registry;
		this.healthAggregator = healthAggregator;
		this.timeoutCompose = (mono) -> (this.timeout != null) ? mono.timeout(Duration.ofMillis(this.timeout), Mono.just(this.timeoutHealth)) : mono;
	}
	public CompositeReactiveHealthIndicator timeoutStrategy(long timeout,Health timeoutHealth) {
		this.timeout = timeout;
		this.timeoutHealth = (timeoutHealth != null) ? timeoutHealth: Health.unknown().build();
		return this;
	}
	ReactiveHealthIndicatorRegistry getRegistry() {
		return this.registry;
	}
	public Mono<Health> health() {
		return Flux.fromIterable(this.registry.getAll().entrySet()).flatMap((entry) -> Mono.zip(Mono.just(entry.getKey()),entry.getValue().health().compose(this.timeoutCompose))).collectMap(Tuple2::getT1, Tuple2::getT2).map(this.healthAggregator::aggregate);
	}
}",0,0,0,0
"public void resolve(ColumnFamily cf) {
	 if (cf == null) return;
	 addAll(cf);
 }",0,0,0,0
"public class FileSystem extends ResourceComparator {
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 protected int resourceCompare(Resource foo, Resource bar) {
		 FileProvider fooFP = (FileProvider) foo.as(FileProvider.class);
		 if (fooFP == null) {
			 throw new ClassCastException(foo.getClass() + "" doesn't provide files"");
		 }
		 File foofile = fooFP.getFile();
		 FileProvider barFP = (FileProvider) bar.as(FileProvider.class);
		 if (barFP == null) {
			 throw new ClassCastException(bar.getClass() + "" doesn't provide files"");
		 }
		 File barfile = barFP.getFile();
		 return foofile.equals(barfile) ? 0 : FILE_UTILS.isLeadingPath(foofile, barfile) ? -1 : FILE_UTILS.normalize(foofile.getAbsolutePath()).compareTo( FILE_UTILS.normalize(barfile.getAbsolutePath()));
	 }
}",0,0,0,0
"public class AdUserModuleProcessor implements MvnAdModuleProcessor {
	 private static final Log log = LogFactory.getLog(AdUserModuleProcessor.class);
	 private static int count;
	 private final String ORIGINAL_REQUEST = ""ad.user.OriginalRequest"";
	 private HttpServlet userServlet = null;
	 protected ServletContext servletContext = null;
	 private OnlineUserManager onlineUserManager = OnlineUserManager.getInstance();
	 private AdUserModuleURLMapHandler urlMapHandler = new AdUserModuleURLMapHandler();
	 private AdUserWebHandler adUserWebHandler = new AdUserWebHandler();
	 public AdUserModuleProcessor() {
		 count++;
		 AssertionUtil.doAssert(count == 1, ""Assertion: Must have only one instance."");
	 }
	 public void setServlet(HttpServlet servlet) {
		 userServlet = servlet;
		 servletContext = userServlet.getServletContext();
	 }
	 public String process(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
		 long start = 0;
		 String requestURI = StringUtil.getEmptyStringIfNull(request.getPathInfo());
		 String responseURI = null;
		 OnlineUser onlineUser = null;
		 if (log.isDebugEnabled()) {
			 start = System.currentTimeMillis();
			 log.debug(""AdUserModuleProcessor : requestURI = "" + requestURI);
		 }
		 GenericRequest genericRequest = new GenericRequestServletImpl(request, servletContext);
		 try {
			 onlineUser = onlineUserManager.getOnlineUser(request);
			 MVNForumPermission permission = onlineUser.getPermission();
			 if (!requestURI.equals("""") && !requestURI.equals(""/"") && !requestURI.equals(""/login"") && !requestURI.equals(""/loginprocess"") && !requestURI.equals(""/logout"")) {
				 permission.ensureIsAuthenticated();
				 if (onlineUser.getAuthenticationType() == OnlineUser.AUTHENTICATION_TYPE_COOKIE) {
					 throw new AuthenticationException(NotLoginException.COOKIE_NOT_ALLOWED);
				 }
			 }
			 if (requestURI.equals(""/logout"")) {
				 onlineUserManager.logout(request, response);
				 request.setAttribute(""Reason"", ""Logout successfully."");
			 }
			 else if (requestURI.equals(""/listbanners"")) {
				 adUserWebHandler.listBanners(genericRequest);
			 }
			 else if (requestURI.equals(""/loginprocess"")) {
				 if (MVNForumConfig.getEnableLogin() == false) {
					 throw new AuthenticationException(NotLoginException.LOGIN_DISABLED);
				 }
				 onlineUserManager.processLogin(request, response);
				 adUserWebHandler.listBanners(genericRequest);
				 String originalRequest = ParamUtil.getAttribute(request.getSession(), ORIGINAL_REQUEST);
				 if (originalRequest.length() > 0) {
					 request.getSession().setAttribute(ORIGINAL_REQUEST, """");
					 responseURI = originalRequest;
				 }
			 }
		 }
		 catch (AuthenticationException e) {
			 boolean shouldSaveOriginalRequest = (e.getReason() == NotLoginException.NOT_LOGIN) || (e.getReason() == NotLoginException.NOT_ENOUGH_RIGHTS);
			 if (shouldSaveOriginalRequest && (request.getMethod().equals(""GET""))) {
				 String url = AdUserModuleConfig.getUrlPattern() + requestURI + ""?"" + StringUtil.getEmptyStringIfNull(request.getQueryString());
				 request.getSession().setAttribute(ORIGINAL_REQUEST, url);
			 }
			 requestURI = ""/login"";
			 request.setAttribute(""Reason"", e.getReasonExplanation(onlineUser.getLocale()));
		 }
		 catch (Throwable e) {
			 if (e instanceof BadInputException) {
				 log.warn(""Exception in AdUserModuleProcessor e = "" + e.getMessage(), e);
			 }
			 else if (e instanceof AssertionError) {
				 log.fatal(""Exception in AdUserModuleProcessor e = "" + e.getMessage(), e);
			 }
			 else {
				 log.error(""Exception in AdUserModuleProcessor ["" + e.getClass().getName() + ""] : "" + e.getMessage(), e);
			 }
			 requestURI = ""/error"";
			 request.getSession().setAttribute(""ErrorMessage"", StringUtil.getEmptyStringIfNull(e.getMessage()));
		 }
		 try {
			 Action action = new ActionInUserModule(genericRequest, requestURI);
			 onlineUserManager.updateOnlineUserAction(genericRequest, action);
			 if (responseURI == null) {
				 URLMap map = urlMapHandler.getMap(requestURI, request);
				 responseURI = map.getResponse();
			 }
		 }
		 catch (MissingURLMapEntryException e) {
			 log.error(""Exception: missing urlmap entry in ad user module: requestURI = "" + requestURI);
			 responseURI = ""/mvnplugin/mvnad/user/error.jsp"";
			 request.getSession().setAttribute(""ErrorMessage"", e.getMessage());
		 }
		 catch (Throwable e) {
			 responseURI = ""/mvnplugin/mvnad/user/error.jsp"";
			 request.getSession().setAttribute(""ErrorMessage"", e.getMessage());
		 }
		 if (log.isDebugEnabled()) {
			 long duration = System.currentTimeMillis() - start;
			 log.debug(""AdUserModuleProcessor : responseURI = "" + responseURI + "". ("" + duration + "" ms)\n"");
		 }
		 return responseURI;
	 }
}",1,0,0,0
"public class JpaEntityFactoryMetadata extends AbstractItdTypeDetailsProvidingMetadataItem {
	 private static final String INDEX_VAR = ""index"";
	 private static final JavaSymbolName INDEX_SYMBOL = new JavaSymbolName(INDEX_VAR);
	 private static final JavaSymbolName MAX_SYMBOL = new JavaSymbolName(""max"");
	 private static final JavaSymbolName MIN_SYMBOL = new JavaSymbolName(""min"");
	 private static final String OBJ_VAR = ""obj"";
	 private static final JavaSymbolName OBJ_SYMBOL = new JavaSymbolName(OBJ_VAR);
	 private static final JavaSymbolName VALUE = new JavaSymbolName(""value"");
	 private static final JavaSymbolName CREATE_FACTORY_METHOD_NAME = new JavaSymbolName(""create"");
	 public static final JavaSymbolName SPECIFIC_METHOD_PREFIX = new JavaSymbolName(""getSpecific"");
	 private static final String PROVIDES_TYPE_STRING = JpaEntityFactoryMetadata.class.getName();
	 private static final String PROVIDES_TYPE = MetadataIdentificationUtils .create(PROVIDES_TYPE_STRING);
	 public static String createIdentifier(final JavaType javaType, final LogicalPath path) {
		 return PhysicalTypeIdentifierNamingUtils.createIdentifier(PROVIDES_TYPE_STRING, javaType, path);
	 }
	 public static String createIdentifier(ClassOrInterfaceTypeDetails details) {
		 final LogicalPath logicalPath = PhysicalTypeIdentifier.getPath(details.getDeclaredByMetadataId());
		 return createIdentifier(details.getType(), logicalPath);
	 }
	 public static JavaType getJavaType(final String metadataIdentificationString) {
		 return PhysicalTypeIdentifierNamingUtils.getJavaType(PROVIDES_TYPE_STRING, metadataIdentificationString);
	 }
	 public static String getMetadataIdentiferType() {
		 return PROVIDES_TYPE;
	 }
	 public static LogicalPath getPath(final String metadataIdentificationString) {
		 return PhysicalTypeIdentifierNamingUtils.getPath(PROVIDES_TYPE_STRING, metadataIdentificationString);
	 }
	 public static boolean isValid(final String metadataIdentificationString) {
		 return PhysicalTypeIdentifierNamingUtils.isValid(PROVIDES_TYPE_STRING, metadataIdentificationString);
	 }
	 private JavaType entity;
	 private final List<JavaType> requiredDataOnDemandCollaborators = new ArrayList<JavaType>();
	 private MethodMetadata randomPersistentEntityMethod;
	 private final Map<FieldMetadata, Map<FieldMetadata, String>> embeddedFieldInitializers = new LinkedHashMap<FieldMetadata, Map<FieldMetadata, String>>();
	 private final Map<FieldMetadata, String> fieldInitializers = new LinkedHashMap<FieldMetadata, String>();
	 private EmbeddedIdHolder embeddedIdHolder;
	 private List<EmbeddedHolder> embeddedHolders;
	 private Map<FieldMetadata, JpaEntityFactoryMetadata> locatedFields;
	 private final MemberDetails entityMemberDetails;
	 public JpaEntityFactoryMetadata(final String identifier, final JavaType aspectName, final PhysicalTypeMetadata governorPhysicalTypeMetadata, final JavaType entity, MemberDetails entityMemberDetails, final Map<FieldMetadata, JpaEntityFactoryMetadata> locatedFields, final List<EmbeddedHolder> embeddedHolders, Set<ClassOrInterfaceTypeDetails> entityFactoryClasses, final EmbeddedIdHolder embeddedIdHolder) {
		 super(identifier, aspectName, governorPhysicalTypeMetadata);
		 Validate.notNull(locatedFields, ""Located fields map required"");
		 Validate.notNull(embeddedHolders, ""Embedded holders list required"");
		 this.entity = entity;
		 this.entityMemberDetails = entityMemberDetails;
		 this.embeddedIdHolder = embeddedIdHolder;
		 this.embeddedHolders = embeddedHolders;
		 this.locatedFields = locatedFields;
		 builder.addMethod(getCreateMethod());
		 for (final Map.Entry<FieldMetadata, JpaEntityFactoryMetadata> entry : locatedFields.entrySet()) {
			 final FieldMetadata field = entry.getKey();
			 final String initializer = getFieldInitializer(field, entry.getValue(), entityFactoryClasses);
			 if (!StringUtils.isBlank(initializer)) {
				 this.fieldInitializers.put(field, initializer);
			 }
		 }
		 for (final EmbeddedHolder embeddedHolder : embeddedHolders) {
			 final Map<FieldMetadata, String> initializers = new LinkedHashMap<FieldMetadata, String>();
			 for (final FieldMetadata field : embeddedHolder.getFields()) {
				 initializers.put(field, getFieldInitializer(field, null, entityFactoryClasses));
			 }
			 this.embeddedFieldInitializers.put(embeddedHolder.getEmbeddedField(), initializers);
		 }
		 for (final EmbeddedHolder embeddedHolder : embeddedHolders) {
			 builder.addMethod(getEmbeddedClassMutatorMethod(embeddedHolder));
			 addEmbeddedClassFieldMutatorMethodsToBuilder(embeddedHolder, entityFactoryClasses);
		 }
		 for (final MethodMetadataBuilder fieldInitializerMethod : getFieldMutatorMethods()) {
			 builder.addMethod(fieldInitializerMethod);
		 }
		 addCollaboratingFieldsToBuilder(entityFactoryClasses);
		 builder.addMethod(getEmbeddedIdMutatorMethod(entityFactoryClasses));
		 itdTypeDetails = builder.build();
	 }
	 private void addCollaboratingFieldsToBuilder( final Set<ClassOrInterfaceTypeDetails> entityFactoryClasses) {
		 final Set<JavaSymbolName> fields = new LinkedHashSet<JavaSymbolName>();
		 for (final JavaType entityNeedingCollaborator : this.requiredDataOnDemandCollaborators) {
			 final JavaType collaboratorType = getCollaboratingType(entityNeedingCollaborator, entityFactoryClasses);
			 if (collaboratorType != null) {
				 final String collaboratingFieldName = getCollaboratingFieldName(entityNeedingCollaborator, entityFactoryClasses) .getSymbolName();
				 final JavaSymbolName fieldSymbolName = new JavaSymbolName(collaboratingFieldName);
				 final FieldMetadata candidate = governorTypeDetails.getField(fieldSymbolName);
				 if (candidate != null) {
					 Validate .isTrue(candidate.getFieldType().equals(collaboratorType), ""Field '%s' on '%s' must be of type '%s'"", collaboratingFieldName, destination.getFullyQualifiedTypeName(), collaboratorType.getFullyQualifiedTypeName());
					 Validate.isTrue(Modifier.isPrivate(candidate.getModifier()), ""Field '%s' on '%s' must be private"", collaboratingFieldName, destination.getFullyQualifiedTypeName());
					 Validate.notNull( MemberFindingUtils.getAnnotationOfType(candidate.getAnnotations(), AUTOWIRED), ""Field '%s' on '%s' must be "", collaboratingFieldName, destination.getFullyQualifiedTypeName());
					 continue;
				 }
				 if (!fields.contains(fieldSymbolName)) {
					 final List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();
					 annotations.add(new AnnotationMetadataBuilder(AUTOWIRED));
					 builder.addField(new FieldMetadataBuilder(getId(), 0, annotations, fieldSymbolName, collaboratorType));
					 fields.add(fieldSymbolName);
				 }
			 }
		 }
	 }
	 private void addEmbeddedClassFieldMutatorMethodsToBuilder(final EmbeddedHolder embeddedHolder, final Set<ClassOrInterfaceTypeDetails> dataOnDemandClasses) {
		 final JavaType embeddedFieldType = embeddedHolder.getEmbeddedField().getFieldType();
		 final JavaType[] parameterTypes = {
		embeddedFieldType, JavaType.INT_PRIMITIVE}
		;
		 final List<JavaSymbolName> parameterNames = Arrays.asList(OBJ_SYMBOL, INDEX_SYMBOL);
		 for (final FieldMetadata field : embeddedHolder.getFields()) {
			 final String initializer = getFieldInitializer(field, null, dataOnDemandClasses);
			 final JavaSymbolName fieldMutatorMethodName = BeanInfoUtils.getMutatorMethodName(field.getFieldName());
			 final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();
			 bodyBuilder.append(getFieldValidationBody(field, initializer, fieldMutatorMethodName, false));
			 final JavaSymbolName embeddedClassMethodName = getEmbeddedFieldMutatorMethodName(embeddedHolder.getEmbeddedField().getFieldName(), field.getFieldName());
			 if (governorHasMethod(embeddedClassMethodName, parameterTypes)) {
				 continue;
			 }
			 builder.addMethod(new MethodMetadataBuilder(getId(), Modifier.PUBLIC, embeddedClassMethodName, JavaType.VOID_PRIMITIVE, AnnotatedJavaType .convertFromJavaTypes(parameterTypes), parameterNames, bodyBuilder));
		 }
	 }
	 private String getColumnPrecisionAndScaleBody(final FieldMetadata field, final Map<String, Object> values, final String suffix) {
		 if (values == null || !values.containsKey(""precision"")) {
			 return InvocableMemberBodyBuilder.getInstance().getOutput();
		 }
		 final String fieldName = field.getFieldName().getSymbolName();
		 final JavaType fieldType = field.getFieldType();
		 Integer precision = (Integer) values.get(""precision"");
		 Integer scale = (Integer) values.get(""scale"");
		 if (precision != null && scale != null && precision < scale) {
			 scale = 0;
		 }
		 final BigDecimal maxValue;
		 if (scale == null || scale == 0) {
			 maxValue = new BigDecimal(StringUtils.rightPad(""9"", precision, '9'));
		 }
		 else {
			 maxValue = new BigDecimal(StringUtils.rightPad(""9"", precision - scale, '9') + ""."" + StringUtils.rightPad(""9"", scale, '9'));
		 }
		 final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();
		 if (fieldType.equals(BIG_DECIMAL)) {
			 bodyBuilder.appendFormalLine(""if ("" + fieldName + "".compareTo(new "" + BIG_DECIMAL.getSimpleTypeName() + ""(\"""" + maxValue + ""\"")) == 1) {
				"");
				 bodyBuilder.indent();
				 bodyBuilder.appendFormalLine(fieldName + "" = new "" + BIG_DECIMAL.getSimpleTypeName() + ""(\"""" + maxValue + ""\"");
				"");
			 }
			 else {
				 bodyBuilder.appendFormalLine(""if ("" + fieldName + "" > "" + maxValue.doubleValue() + suffix + "") {
					"");
					 bodyBuilder.indent();
					 bodyBuilder.appendFormalLine(fieldName + "" = "" + maxValue.doubleValue() + suffix + "";
					"");
				 }
				 bodyBuilder.indentRemove();
			 bodyBuilder.appendFormalLine(""}
			"");
			 return bodyBuilder.getOutput();
		 }
		 private JavaSymbolName getCollaboratingFieldName(final JavaType entity, final Set<ClassOrInterfaceTypeDetails> dataOnDemandClasses) {
			 JavaSymbolName symbolName = null;
			 JavaType collaboratingType = getCollaboratingType(entity, dataOnDemandClasses);
			 if (collaboratingType != null) {
				 symbolName = new JavaSymbolName(StringUtils.uncapitalize(collaboratingType.getSimpleTypeName()));
			 }
			 return symbolName;
		 }
		 private JavaType getCollaboratingType(final JavaType entity, final Set<ClassOrInterfaceTypeDetails> entityFactoryClasses) {
			 JavaType dataOnDemand = null;
			 for (ClassOrInterfaceTypeDetails dataOnDemandClass : entityFactoryClasses) {
				 String searchDataOnDemand = entity.getSimpleTypeName().concat(""DataOnDemand"");
				 if (dataOnDemandClass.getType().getSimpleTypeName().equals(searchDataOnDemand) && governorTypeDetails.getType().getModule() .equals(dataOnDemandClass.getType().getModule())) {
					 dataOnDemand = dataOnDemandClass.getType();
				 }
			 }
			 return dataOnDemand;
		 }
		 private MethodMetadata getCreateMethod() {
			 final JavaSymbolName methodName = CREATE_FACTORY_METHOD_NAME;
			 List<JavaType> parameterTypes = new ArrayList<JavaType>();
			 parameterTypes.add(JavaType.INT_PRIMITIVE);
			 MethodMetadata existingMethod = getGovernorMethod(methodName, parameterTypes);
			 if (existingMethod != null) {
				 return existingMethod;
			 }
			 List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();
			 parameterNames.add(INDEX_SYMBOL);
			 InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();
			 List<ConstructorMetadata> constructors = entityMemberDetails.getConstructors();
			 boolean hasDefaultConstructor = false;
			 for (ConstructorMetadata constructor : constructors) {
				 if (constructor.getParameterTypes().isEmpty() && Modifier.isPublic(constructor.getModifier())) {
					 hasDefaultConstructor = true;
					 break;
				 }
			 }
			 if (constructors.isEmpty() || hasDefaultConstructor) {
				 generateDefaultCreateMethodBody(bodyBuilder);
			 }
			 else {
				 generateNoConstructorCreateMethodBody(bodyBuilder);
			 }
			 MethodMetadataBuilder method = new MethodMetadataBuilder(this.getId(), Modifier.PUBLIC, methodName, this.entity, AnnotatedJavaType.convertFromJavaTypes(parameterTypes), parameterNames, bodyBuilder);
			 CommentStructure commentStructure = new CommentStructure();
			 List<String> paramsInfo = new ArrayList<String>();
			 paramsInfo.add(String.format(""%s position of the %s"", INDEX_VAR, this.entity.getSimpleTypeName()));
			 JavadocComment comment = new JavadocComment(String.format(""Creates a new {
			 %s}
			 with the given %s."", this.entity.getSimpleTypeName(), INDEX_VAR), paramsInfo, String.format( ""a new transient %s"", this.entity.getSimpleTypeName()), null);
			 commentStructure.addComment(comment, CommentLocation.BEGINNING);
			 method.setCommentStructure(commentStructure);
			 return method.build();
		 }
		 private void generateDefaultCreateMethodBody(InvocableMemberBodyBuilder bodyBuilder) {
			 bodyBuilder.appendFormalLine(""%1$s %2$s = new %1$s();
			"", getNameOfJavaType(this.entity), OBJ_SYMBOL);
			 for (final Map.Entry<FieldMetadata, JpaEntityFactoryMetadata> entry : locatedFields.entrySet()) {
				 bodyBuilder.appendFormalLine(""%s(%s, %s);
				"", BeanInfoUtils.getMutatorMethodName(entry.getKey()), OBJ_SYMBOL, INDEX_SYMBOL);
			 }
			 bodyBuilder.appendFormalLine(""return %s;
			"", OBJ_SYMBOL);
		 }
		 private void generateNoConstructorCreateMethodBody(InvocableMemberBodyBuilder bodyBuilder) {
			 bodyBuilder .appendFormalLine( ""throw new IllegalStateException(\""No no-argument constructor found for the entity \""+ %s.class.getName() +\"". This is required by the JPA especification. Please provide a default constructor for the related class and open the Spring Roo console again.\"");
			"", getNameOfJavaType(this.entity));
		 }
		 private String getDecimalMinAndDecimalMaxBody(final FieldMetadata field, final AnnotationMetadata decimalMinAnnotation, final AnnotationMetadata decimalMaxAnnotation, final String suffix) {
			 final String fieldName = field.getFieldName().getSymbolName();
			 final JavaType fieldType = field.getFieldType();
			 final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();
			 if (decimalMinAnnotation != null && decimalMaxAnnotation == null) {
				 final String minValue = (String) decimalMinAnnotation.getAttribute(VALUE).getValue();
				 if (fieldType.equals(BIG_DECIMAL)) {
					 bodyBuilder.appendFormalLine(""if ("" + fieldName + "".compareTo(new "" + BIG_DECIMAL.getSimpleTypeName() + ""(\"""" + minValue + ""\"")) == -1) {
						"");
						 bodyBuilder.indent();
						 bodyBuilder.appendFormalLine(fieldName + "" = new "" + BIG_DECIMAL.getSimpleTypeName() + ""(\"""" + minValue + ""\"");
						"");
					 }
					 else {
						 bodyBuilder.appendFormalLine(""if ("" + fieldName + "" < "" + minValue + suffix + "") {
							"");
							 bodyBuilder.indent();
							 bodyBuilder.appendFormalLine(fieldName + "" = "" + minValue + suffix + "";
							"");
						 }
						 bodyBuilder.indentRemove();
					 bodyBuilder.appendFormalLine(""}
					"");
				 }
				 else if (decimalMinAnnotation == null && decimalMaxAnnotation != null) {
					 final String maxValue = (String) decimalMaxAnnotation.getAttribute(VALUE).getValue();
					 if (fieldType.equals(BIG_DECIMAL)) {
						 bodyBuilder.appendFormalLine(""if ("" + fieldName + "".compareTo(new "" + BIG_DECIMAL.getSimpleTypeName() + ""(\"""" + maxValue + ""\"")) == 1) {
							"");
							 bodyBuilder.indent();
							 bodyBuilder.appendFormalLine(fieldName + "" = new "" + BIG_DECIMAL.getSimpleTypeName() + ""(\"""" + maxValue + ""\"");
							"");
						 }
						 else {
							 bodyBuilder.appendFormalLine(""if ("" + fieldName + "" > "" + maxValue + suffix + "") {
								"");
								 bodyBuilder.indent();
								 bodyBuilder.appendFormalLine(fieldName + "" = "" + maxValue + suffix + "";
								"");
							 }
							 bodyBuilder.indentRemove();
						 bodyBuilder.appendFormalLine(""}
						"");
					 }
					 else if (decimalMinAnnotation != null && decimalMaxAnnotation != null) {
						 final String minValue = (String) decimalMinAnnotation.getAttribute(VALUE).getValue();
						 final String maxValue = (String) decimalMaxAnnotation.getAttribute(VALUE).getValue();
						 Validate .isTrue( Double.parseDouble(maxValue) >= Double.parseDouble(minValue), ""The value of must be greater or equal to the value of for field %s"", fieldName);
						 if (fieldType.equals(BIG_DECIMAL)) {
							 bodyBuilder.appendFormalLine(""if ("" + fieldName + "".compareTo(new "" + BIG_DECIMAL.getSimpleTypeName() + ""(\"""" + minValue + ""\"")) == -1 || "" + fieldName + "".compareTo(new "" + BIG_DECIMAL.getSimpleTypeName() + ""(\"""" + maxValue + ""\"")) == 1) {
								"");
								 bodyBuilder.indent();
								 bodyBuilder.appendFormalLine(fieldName + "" = new "" + BIG_DECIMAL.getSimpleTypeName() + ""(\"""" + maxValue + ""\"");
								"");
							 }
							 else {
								 bodyBuilder.appendFormalLine(""if ("" + fieldName + "" < "" + minValue + suffix + "" || "" + fieldName + "" > "" + maxValue + suffix + "") {
									"");
									 bodyBuilder.indent();
									 bodyBuilder.appendFormalLine(fieldName + "" = "" + maxValue + suffix + "";
									"");
								 }
								 bodyBuilder.indentRemove();
							 bodyBuilder.appendFormalLine(""}
							"");
						 }
						 return bodyBuilder.getOutput();
					 }
					 private String getDigitsBody(final FieldMetadata field, final AnnotationMetadata digitsAnnotation, final String suffix) {
						 final String fieldName = field.getFieldName().getSymbolName();
						 final JavaType fieldType = field.getFieldType();
						 final Integer integerValue = (Integer) digitsAnnotation.getAttribute(new JavaSymbolName(""integer"")).getValue();
						 final Integer fractionValue = (Integer) digitsAnnotation.getAttribute(new JavaSymbolName(""fraction"")).getValue();
						 final BigDecimal maxValue = new BigDecimal(StringUtils.rightPad(""9"", integerValue, '9') + ""."" + StringUtils.rightPad(""9"", fractionValue, '9'));
						 final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();
						 if (fieldType.equals(BIG_DECIMAL)) {
							 bodyBuilder.appendFormalLine(""if ("" + fieldName + "".compareTo(new "" + BIG_DECIMAL.getSimpleTypeName() + ""(\"""" + maxValue + ""\"")) == 1) {
								"");
								 bodyBuilder.indent();
								 bodyBuilder.appendFormalLine(fieldName + "" = new "" + BIG_DECIMAL.getSimpleTypeName() + ""(\"""" + maxValue + ""\"");
								"");
							 }
							 else {
								 bodyBuilder.appendFormalLine(""if ("" + fieldName + "" > "" + maxValue.doubleValue() + suffix + "") {
									"");
									 bodyBuilder.indent();
									 bodyBuilder.appendFormalLine(fieldName + "" = "" + maxValue.doubleValue() + suffix + "";
									"");
								 }
								 bodyBuilder.indentRemove();
							 bodyBuilder.appendFormalLine(""}
							"");
							 return bodyBuilder.getOutput();
						 }
						 private String getFieldInitializer(final FieldMetadata field, final JpaEntityFactoryMetadata collaboratingMetadata, final Set<ClassOrInterfaceTypeDetails> dataOnDemandClasses) {
							 final JavaType fieldType = field.getFieldType();
							 final String fieldName = field.getFieldName().getSymbolName();
							 String initializer = ""null"";
							 final String fieldInitializer = field.getFieldInitializer();
							 final Set<Object> fieldCustomDataKeys = field.getCustomData().keySet();
							 if (fieldType.equals(DATE)) {
								 if (MemberFindingUtils.getAnnotationOfType(field.getAnnotations(), PAST) != null) {
									 builder.getImportRegistrationResolver().addImport(DATE);
									 initializer = ""new Date(new Date().getTime() - 10000000L)"";
								 }
								 else if (MemberFindingUtils.getAnnotationOfType(field.getAnnotations(), FUTURE) != null) {
									 builder.getImportRegistrationResolver().addImport(DATE);
									 initializer = ""new Date(new Date().getTime() + 10000000L)"";
								 }
								 else {
									 builder.getImportRegistrationResolver().addImports(CALENDAR, GREGORIAN_CALENDAR);
									 initializer = ""new GregorianCalendar(Calendar.getInstance().get(Calendar.YEAR), \n\t\t\tCalendar.getInstance().get(Calendar.MONTH), \n\t\t\tCalendar.getInstance().get(Calendar.DAY_OF_MONTH), \n\t\t\tCalendar.getInstance().get(Calendar.HOUR_OF_DAY), \n\t\t\tCalendar.getInstance().get(Calendar.MINUTE), \n\t\t\tCalendar.getInstance().get(Calendar.SECOND) + \n\t\t\tnew Double(Math.random() * 1000).intValue()).getTime()"";
								 }
							 }
							 else if (fieldType.equals(CALENDAR)) {
								 builder.getImportRegistrationResolver().addImports(CALENDAR, GREGORIAN_CALENDAR);
								 final String calendarString = ""new GregorianCalendar(Calendar.getInstance().get(Calendar.YEAR), \n\t\t\tCalendar.getInstance().get(Calendar.MONTH), \n\t\t\tCalendar.getInstance().get(Calendar.DAY_OF_MONTH)"";
								 if (MemberFindingUtils.getAnnotationOfType(field.getAnnotations(), PAST) != null) {
									 initializer = calendarString + "" - 1)"";
								 }
								 else if (MemberFindingUtils.getAnnotationOfType(field.getAnnotations(), FUTURE) != null) {
									 initializer = calendarString + "" + 1)"";
								 }
								 else {
									 initializer = ""Calendar.getInstance()"";
								 }
							 }
							 else if (fieldType.equals(TIMESTAMP)) {
								 builder.getImportRegistrationResolver().addImports(CALENDAR, GREGORIAN_CALENDAR, TIMESTAMP);
								 initializer = ""new Timestamp(new GregorianCalendar(Calendar.getInstance().get(Calendar.YEAR), \n\t\t\tCalendar.getInstance().get(Calendar.MONTH), \n\t\t\tCalendar.getInstance().get(Calendar.DAY_OF_MONTH), \n\t\t\tCalendar.getInstance().get(Calendar.HOUR_OF_DAY), \n\t\t\tCalendar.getInstance().get(Calendar.MINUTE), \n\t\t\tCalendar.getInstance().get(Calendar.SECOND) + \n\t\t\tnew Double(Math.random() * 1000).intValue()).getTime().getTime())"";
							 }
							 else if (fieldType.equals(STRING)) {
								 if (fieldInitializer != null && fieldInitializer.contains(""\"""")) {
									 final int offset = fieldInitializer.indexOf(""\"""");
									 initializer = fieldInitializer.substring(offset + 1, fieldInitializer.lastIndexOf(""\""""));
								 }
								 else {
									 initializer = fieldName;
								 }
								 if (MemberFindingUtils.getAnnotationOfType(field.getAnnotations(), VALIDATOR_CONSTRAINTS_EMAIL) != null || fieldName.toLowerCase().contains(""email"")) {
									 initializer = ""\""foo\"" + "" + INDEX_VAR + "" + \""\"""";
								 }
								 else {
									 int maxLength = Integer.MAX_VALUE;
									 final AnnotationMetadata sizeAnnotation = MemberFindingUtils.getAnnotationOfType(field.getAnnotations(), SIZE);
									 if (sizeAnnotation != null) {
										 final AnnotationAttributeValue<?> maxValue = sizeAnnotation.getAttribute(MAX_SYMBOL);
										 if (maxValue != null) {
											 validateNumericAnnotationAttribute(fieldName, """", ""max"", maxValue.getValue());
											 maxLength = ((Integer) maxValue.getValue()).intValue();
										 }
										 final AnnotationAttributeValue<?> minValue = sizeAnnotation.getAttribute(MIN_SYMBOL);
										 if (minValue != null) {
											 validateNumericAnnotationAttribute(fieldName, """", ""min"", minValue.getValue());
											 final int minLength = ((Integer) minValue.getValue()).intValue();
											 Validate.isTrue(maxLength >= minLength, "" attribute 'max' must be greater than 'min' for field '%s' in %s"", fieldName, entity.getFullyQualifiedTypeName());
											 if (initializer.length() + 2 < minLength) {
												 initializer = String.format(""%1$-"" + (minLength - 2) + ""s"", initializer).replace(' ', 'x');
											 }
										 }
									 }
									 else {
										 if (field.getCustomData().keySet().contains(CustomDataKeys.COLUMN_FIELD)) {
											 final Map<String, Object> columnValues = (Map<String, Object>) field.getCustomData().get(CustomDataKeys.COLUMN_FIELD);
											 if (columnValues.keySet().contains(""length"")) {
												 final Object lengthValue = columnValues.get(""length"");
												 validateNumericAnnotationAttribute(fieldName, """", ""length"", lengthValue);
												 maxLength = ((Integer) lengthValue).intValue();
											 }
										 }
									 }
									 switch (maxLength) {
										 case 0: initializer = ""\""\"""";
										 break;
										 case 1: initializer = ""String.valueOf("" + INDEX_VAR + "")"";
										 break;
										 case 2: initializer = ""\"""" + initializer.charAt(0) + ""\"" + "" + INDEX_VAR;
										 break;
										 default: if (initializer.length() + 2 > maxLength) {
											 initializer = ""\"""" + initializer.substring(0, maxLength - 2) + ""_\"" + "" + INDEX_VAR;
										 }
										 else {
											 initializer = ""\"""" + initializer + ""_\"" + "" + INDEX_VAR;
										 }
									 }
								 }
							 }
							 else if (fieldType.equals(new JavaType(STRING.getFullyQualifiedTypeName(), 1, DataType.TYPE, null, null))) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""{
								 \""Y\"", \""N\"" }
								"");
							 }
							 else if (fieldType.equals(JavaType.BOOLEAN_OBJECT)) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""Boolean.TRUE"");
							 }
							 else if (fieldType.equals(JavaType.BOOLEAN_PRIMITIVE)) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""true"");
							 }
							 else if (fieldType.equals(JavaType.INT_OBJECT)) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""new Integer("" + INDEX_VAR + "")"");
							 }
							 else if (fieldType.equals(JavaType.INT_PRIMITIVE)) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, INDEX_VAR);
							 }
							 else if (fieldType.equals(new JavaType(JavaType.INT_OBJECT.getFullyQualifiedTypeName(), 1, DataType.PRIMITIVE, null, null))) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""{
								 "" + INDEX_VAR + "", "" + INDEX_VAR + "" }
								"");
							 }
							 else if (fieldType.equals(JavaType.DOUBLE_OBJECT)) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""new Integer("" + INDEX_VAR + "").doubleValue()"");
							 }
							 else if (fieldType.equals(JavaType.DOUBLE_PRIMITIVE)) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""new Integer("" + INDEX_VAR + "").doubleValue()"");
							 }
							 else if (fieldType.equals(new JavaType(JavaType.DOUBLE_OBJECT.getFullyQualifiedTypeName(), 1, DataType.PRIMITIVE, null, null))) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""{
								 new Integer("" + INDEX_VAR + "").doubleValue(), new Integer("" + INDEX_VAR + "").doubleValue() }
								"");
							 }
							 else if (fieldType.equals(JavaType.FLOAT_OBJECT)) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""new Integer("" + INDEX_VAR + "").floatValue()"");
							 }
							 else if (fieldType.equals(JavaType.FLOAT_PRIMITIVE)) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""new Integer("" + INDEX_VAR + "").floatValue()"");
							 }
							 else if (fieldType.equals(new JavaType(JavaType.FLOAT_OBJECT.getFullyQualifiedTypeName(), 1, DataType.PRIMITIVE, null, null))) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""{
								 new Integer("" + INDEX_VAR + "").floatValue(), new Integer("" + INDEX_VAR + "").floatValue() }
								"");
							 }
							 else if (fieldType.equals(JavaType.LONG_OBJECT)) {
								 initializer = StringUtils .defaultIfEmpty(fieldInitializer, ""new Integer("" + INDEX_VAR + "").longValue()"");
							 }
							 else if (fieldType.equals(JavaType.LONG_PRIMITIVE)) {
								 initializer = StringUtils .defaultIfEmpty(fieldInitializer, ""new Integer("" + INDEX_VAR + "").longValue()"");
							 }
							 else if (fieldType.equals(new JavaType(JavaType.LONG_OBJECT.getFullyQualifiedTypeName(), 1, DataType.PRIMITIVE, null, null))) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""{
								 new Integer("" + INDEX_VAR + "").longValue(), new Integer("" + INDEX_VAR + "").longValue() }
								"");
							 }
							 else if (fieldType.equals(JavaType.SHORT_OBJECT)) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""new Integer("" + INDEX_VAR + "").shortValue()"");
							 }
							 else if (fieldType.equals(JavaType.SHORT_PRIMITIVE)) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""new Integer("" + INDEX_VAR + "").shortValue()"");
							 }
							 else if (fieldType.equals(new JavaType(JavaType.SHORT_OBJECT.getFullyQualifiedTypeName(), 1, DataType.PRIMITIVE, null, null))) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""{
								 new Integer("" + INDEX_VAR + "").shortValue(), new Integer("" + INDEX_VAR + "").shortValue() }
								"");
							 }
							 else if (fieldType.equals(JavaType.CHAR_OBJECT)) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""new Character('N')"");
							 }
							 else if (fieldType.equals(JavaType.CHAR_PRIMITIVE)) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""'N'"");
							 }
							 else if (fieldType.equals(new JavaType(JavaType.CHAR_OBJECT.getFullyQualifiedTypeName(), 1, DataType.PRIMITIVE, null, null))) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""{
								 'Y', 'N' }
								"");
							 }
							 else if (fieldType.equals(BIG_DECIMAL)) {
								 builder.getImportRegistrationResolver().addImport(BIG_DECIMAL);
								 initializer = BIG_DECIMAL.getSimpleTypeName() + "".valueOf("" + INDEX_VAR + "")"";
							 }
							 else if (fieldType.equals(BIG_INTEGER)) {
								 builder.getImportRegistrationResolver().addImport(BIG_INTEGER);
								 initializer = BIG_INTEGER.getSimpleTypeName() + "".valueOf("" + INDEX_VAR + "")"";
							 }
							 else if (fieldType.equals(JavaType.BYTE_OBJECT)) {
								 initializer = ""new Byte("" + StringUtils.defaultIfEmpty(fieldInitializer, ""\""1\"""") + "")"";
							 }
							 else if (fieldType.equals(JavaType.BYTE_PRIMITIVE)) {
								 initializer = ""new Byte("" + StringUtils.defaultIfEmpty(fieldInitializer, ""\""1\"""") + "").byteValue()"";
							 }
							 else if (fieldType.equals(JavaType.BYTE_ARRAY_PRIMITIVE)) {
								 initializer = StringUtils.defaultIfEmpty(fieldInitializer, ""String.valueOf("" + INDEX_VAR + "").getBytes()"");
							 }
							 else if (fieldType.equals(entity)) {
								 initializer = OBJ_VAR;
							 }
							 else if (fieldCustomDataKeys.contains(CustomDataKeys.ENUMERATED_FIELD)) {
								 builder.getImportRegistrationResolver().addImport(fieldType);
								 initializer = fieldType.getSimpleTypeName() + "".class.getEnumConstants()[0]"";
							 }
							 else if (collaboratingMetadata != null && collaboratingMetadata.getEntityType() != null) {
								 requiredDataOnDemandCollaborators.add(fieldType);
								 initializer = getFieldInitializerForRelatedEntity(field, collaboratingMetadata, fieldCustomDataKeys, dataOnDemandClasses);
							 }
							 return initializer;
						 }
						 private String getFieldInitializerForRelatedEntity(final FieldMetadata field, final JpaEntityFactoryMetadata collaboratingMetadata, final Set<?> fieldCustomDataKeys, final Set<ClassOrInterfaceTypeDetails> dataOnDemandClasses) {
							 final boolean nullableField = field.getAnnotation(NOT_NULL) == null && isNullableJoinColumn(field);
							 if (nullableField) {
								 return null;
							 }
							 JavaSymbolName collaboratingFieldName = getCollaboratingFieldName(field.getFieldType(), dataOnDemandClasses);
							 if (collaboratingFieldName != null) {
								 final String collaboratingName = collaboratingFieldName.getSymbolName();
								 if (fieldCustomDataKeys.contains(CustomDataKeys.ONE_TO_ONE_FIELD)) {
									 return collaboratingName + ""."" + SPECIFIC_METHOD_PREFIX.getSymbolName() + ""("" + INDEX_VAR + "")"";
								 }
								 return collaboratingName + ""."" + collaboratingMetadata.getRandomPersistentEntityMethod().getMethodName().getSymbolName() + ""()"";
							 }
							 else {
								 return null;
							 }
						 }
						 private List<MethodMetadataBuilder> getFieldMutatorMethods() {
							 final List<MethodMetadataBuilder> fieldMutatorMethods = new ArrayList<MethodMetadataBuilder>();
							 final List<JavaSymbolName> parameterNames = Arrays.asList(OBJ_SYMBOL, INDEX_SYMBOL);
							 final JavaType[] parameterTypes = {
							entity, JavaType.INT_PRIMITIVE}
							;
							 for (final Map.Entry<FieldMetadata, String> entry : fieldInitializers.entrySet()) {
								 final FieldMetadata field = entry.getKey();
								 final JavaSymbolName mutatorName = BeanInfoUtils.getMutatorMethodName(field.getFieldName());
								 if (governorHasMethod(mutatorName, parameterTypes)) {
									 continue;
								 }
								 final String initializer = entry.getValue();
								 if (!StringUtils.isBlank(initializer)) {
									 final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();
									 bodyBuilder.append(getFieldValidationBody(field, initializer, mutatorName, false));
									 fieldMutatorMethods.add(new MethodMetadataBuilder(getId(), Modifier.PUBLIC, mutatorName, JavaType.VOID_PRIMITIVE, AnnotatedJavaType.convertFromJavaTypes(parameterTypes), parameterNames, bodyBuilder));
								 }
							 }
							 return fieldMutatorMethods;
						 }
						 private String getFieldValidationBody(final FieldMetadata field, final String initializer, final JavaSymbolName mutatorName, final boolean isFieldOfEmbeddableType) {
							 final String fieldName = field.getFieldName().getSymbolName();
							 final JavaType fieldType = field.getFieldType();
							 String suffix = """";
							 if (fieldType.equals(JavaType.LONG_OBJECT) || fieldType.equals(JavaType.LONG_PRIMITIVE)) {
								 suffix = ""L"";
							 }
							 else if (fieldType.equals(JavaType.FLOAT_OBJECT) || fieldType.equals(JavaType.FLOAT_PRIMITIVE)) {
								 suffix = ""F"";
							 }
							 else if (fieldType.equals(JavaType.DOUBLE_OBJECT) || fieldType.equals(JavaType.DOUBLE_PRIMITIVE)) {
								 suffix = ""D"";
							 }
							 final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();
							 bodyBuilder.appendFormalLine(getTypeStr(fieldType) + "" "" + fieldName + "" = "" + initializer + "";
							"");
							 if (fieldType.equals(JavaType.STRING)) {
								 boolean isUnique = isFieldOfEmbeddableType;
								 final Map<String, Object> values = (Map<String, Object>) field.getCustomData().get(CustomDataKeys.COLUMN_FIELD);
								 if (!isUnique && values != null && values.containsKey(""unique"")) {
									 isUnique = (Boolean) values.get(""unique"");
								 }
								 final AnnotationMetadata sizeAnnotation = MemberFindingUtils.getAnnotationOfType(field.getAnnotations(), SIZE);
								 if (sizeAnnotation != null && sizeAnnotation.getAttribute(MAX_SYMBOL) != null) {
									 final Integer maxValue = (Integer) sizeAnnotation.getAttribute(MAX_SYMBOL).getValue();
									 bodyBuilder.appendFormalLine(""if ("" + fieldName + "".length() > "" + maxValue + "") {
										"");
										 bodyBuilder.indent();
										 if (isUnique) {
											 bodyBuilder.appendFormalLine(fieldName + "" = new Random().nextInt(10) + "" + fieldName + "".substring(1, "" + maxValue + "");
											"");
										 }
										 else {
											 bodyBuilder.appendFormalLine(fieldName + "" = "" + fieldName + "".substring(0, "" + maxValue + "");
											"");
										 }
										 bodyBuilder.indentRemove();
									 bodyBuilder.appendFormalLine(""}
									"");
								 }
								 else if (sizeAnnotation == null && values != null) {
									 if (values.containsKey(""length"")) {
										 final Integer lengthValue = (Integer) values.get(""length"");
										 bodyBuilder.appendFormalLine(""if ("" + fieldName + "".length() > "" + lengthValue + "") {
											"");
											 bodyBuilder.indent();
											 if (isUnique) {
												 bodyBuilder.appendFormalLine(fieldName + "" = new Random().nextInt(10) + "" + fieldName + "".substring(1, "" + lengthValue + "");
												"");
											 }
											 else {
												 bodyBuilder.appendFormalLine(fieldName + "" = "" + fieldName + "".substring(0, "" + lengthValue + "");
												"");
											 }
											 bodyBuilder.indentRemove();
										 bodyBuilder.appendFormalLine(""}
										"");
									 }
								 }
							 }
							 else if (JdkJavaType.isDecimalType(fieldType)) {
								 final AnnotationMetadata digitsAnnotation = MemberFindingUtils.getAnnotationOfType(field.getAnnotations(), DIGITS);
								 final AnnotationMetadata decimalMinAnnotation = MemberFindingUtils.getAnnotationOfType(field.getAnnotations(), DECIMAL_MIN);
								 final AnnotationMetadata decimalMaxAnnotation = MemberFindingUtils.getAnnotationOfType(field.getAnnotations(), DECIMAL_MAX);
								 if (digitsAnnotation != null) {
									 bodyBuilder.append(getDigitsBody(field, digitsAnnotation, suffix));
								 }
								 else if (decimalMinAnnotation != null || decimalMaxAnnotation != null) {
									 bodyBuilder.append(getDecimalMinAndDecimalMaxBody(field, decimalMinAnnotation, decimalMaxAnnotation, suffix));
								 }
								 else if (field.getCustomData().keySet().contains(CustomDataKeys.COLUMN_FIELD)) {
									 final Map<String, Object> values = (Map<String, Object>) field.getCustomData().get(CustomDataKeys.COLUMN_FIELD);
									 bodyBuilder.append(getColumnPrecisionAndScaleBody(field, values, suffix));
								 }
							 }
							 else if (JdkJavaType.isIntegerType(fieldType)) {
								 bodyBuilder.append(getMinAndMaxBody(field, suffix));
							 }
							 if (mutatorName != null) {
								 bodyBuilder.appendFormalLine(OBJ_VAR + ""."" + mutatorName.getSymbolName() + ""("" + fieldName + "");
								"");
							 }
							 return bodyBuilder.getOutput();
						 }
						 private MethodMetadataBuilder getEmbeddedClassMutatorMethod(final EmbeddedHolder embeddedHolder) {
							 final JavaSymbolName methodName = getEmbeddedFieldMutatorMethodName(embeddedHolder.getEmbeddedField().getFieldName());
							 final JavaType[] parameterTypes = {
							entity, JavaType.INT_PRIMITIVE}
							;
							 if (governorHasMethod(methodName, parameterTypes)) {
								 return null;
							 }
							 final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();
							 final JavaType embeddedFieldType = embeddedHolder.getEmbeddedField().getFieldType();
							 builder.getImportRegistrationResolver().addImport(embeddedFieldType);
							 bodyBuilder.appendFormalLine(embeddedFieldType.getSimpleTypeName() + "" embeddedClass = new "" + embeddedFieldType.getSimpleTypeName() + ""();
							"");
							 for (final FieldMetadata field : embeddedHolder.getFields()) {
								 bodyBuilder.appendFormalLine(getEmbeddedFieldMutatorMethodName( embeddedHolder.getEmbeddedField().getFieldName(), field.getFieldName()).getSymbolName() + ""(embeddedClass, "" + INDEX_VAR + "");
								"");
							 }
							 bodyBuilder.appendFormalLine(OBJ_VAR + ""."" + embeddedHolder.getEmbeddedMutatorMethodName() + ""(embeddedClass);
							"");
							 final List<JavaSymbolName> parameterNames = Arrays.asList(OBJ_SYMBOL, INDEX_SYMBOL);
							 return new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, JavaType.VOID_PRIMITIVE, AnnotatedJavaType.convertFromJavaTypes(parameterTypes), parameterNames, bodyBuilder);
						 }
						 private MethodMetadataBuilder getEmbeddedIdMutatorMethod( final Set<ClassOrInterfaceTypeDetails> dataOnDemandClasses) {
							 if (!hasEmbeddedIdentifier()) {
								 return null;
							 }
							 final JavaSymbolName embeddedIdMutator = embeddedIdHolder.getEmbeddedIdMutator();
							 final JavaSymbolName methodName = getEmbeddedIdMutatorMethodName();
							 final JavaType[] parameterTypes = {
							entity, JavaType.INT_PRIMITIVE}
							;
							 if (governorHasMethod(methodName, parameterTypes)) {
								 return null;
							 }
							 final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();
							 final JavaType embeddedIdFieldType = embeddedIdHolder.getEmbeddedIdField().getFieldType();
							 builder.getImportRegistrationResolver().addImport(embeddedIdFieldType);
							 final StringBuilder sb = new StringBuilder();
							 final List<FieldMetadata> identifierFields = embeddedIdHolder.getIdFields();
							 for (int i = 0, n = identifierFields.size();
							 i < n;
							 i++) {
								 if (i > 0) {
									 sb.append("", "");
								 }
								 final FieldMetadata field = identifierFields.get(i);
								 final String fieldName = field.getFieldName().getSymbolName();
								 final JavaType fieldType = field.getFieldType();
								 builder.getImportRegistrationResolver().addImport(fieldType);
								 final String initializer = getFieldInitializer(field, null, dataOnDemandClasses);
								 bodyBuilder.append(getFieldValidationBody(field, initializer, null, true));
								 sb.append(fieldName);
							 }
							 bodyBuilder.appendFormalLine("""");
							 bodyBuilder.appendFormalLine(embeddedIdFieldType.getSimpleTypeName() + "" embeddedIdClass = new "" + embeddedIdFieldType.getSimpleTypeName() + ""("" + sb.toString() + "");
							"");
							 bodyBuilder.appendFormalLine(OBJ_VAR + ""."" + embeddedIdMutator + ""(embeddedIdClass);
							"");
							 final List<JavaSymbolName> parameterNames = Arrays.asList(OBJ_SYMBOL, INDEX_SYMBOL);
							 return new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, JavaType.VOID_PRIMITIVE, AnnotatedJavaType.convertFromJavaTypes(parameterTypes), parameterNames, bodyBuilder);
						 }
						 private String getMinAndMaxBody(final FieldMetadata field, final String suffix) {
							 final String fieldName = field.getFieldName().getSymbolName();
							 final JavaType fieldType = field.getFieldType();
							 final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();
							 final AnnotationMetadata minAnnotation = MemberFindingUtils.getAnnotationOfType(field.getAnnotations(), MIN);
							 final AnnotationMetadata maxAnnotation = MemberFindingUtils.getAnnotationOfType(field.getAnnotations(), MAX);
							 if (minAnnotation != null && maxAnnotation == null) {
								 final Number minValue = (Number) minAnnotation.getAttribute(VALUE).getValue();
								 if (fieldType.equals(BIG_INTEGER)) {
									 bodyBuilder.appendFormalLine(""if ("" + fieldName + "".compareTo(new "" + BIG_INTEGER.getSimpleTypeName() + ""(\"""" + minValue + ""\"")) == -1) {
										"");
										 bodyBuilder.indent();
										 bodyBuilder.appendFormalLine(fieldName + "" = new "" + BIG_INTEGER.getSimpleTypeName() + ""(\"""" + minValue + ""\"");
										"");
									 }
									 else {
										 bodyBuilder.appendFormalLine(""if ("" + fieldName + "" < "" + minValue + suffix + "") {
											"");
											 bodyBuilder.indent();
											 bodyBuilder.appendFormalLine(fieldName + "" = "" + minValue + suffix + "";
											"");
										 }
										 bodyBuilder.indentRemove();
									 bodyBuilder.appendFormalLine(""}
									"");
								 }
								 else if (minAnnotation == null && maxAnnotation != null) {
									 final Number maxValue = (Number) maxAnnotation.getAttribute(VALUE).getValue();
									 if (fieldType.equals(BIG_INTEGER)) {
										 bodyBuilder.appendFormalLine(""if ("" + fieldName + "".compareTo(new "" + BIG_INTEGER.getSimpleTypeName() + ""(\"""" + maxValue + ""\"")) == 1) {
											"");
											 bodyBuilder.indent();
											 bodyBuilder.appendFormalLine(fieldName + "" = new "" + BIG_INTEGER.getSimpleTypeName() + ""(\"""" + maxValue + ""\"");
											"");
										 }
										 else {
											 bodyBuilder.appendFormalLine(""if ("" + fieldName + "" > "" + maxValue + suffix + "") {
												"");
												 bodyBuilder.indent();
												 bodyBuilder.appendFormalLine(fieldName + "" = "" + maxValue + suffix + "";
												"");
											 }
											 bodyBuilder.indentRemove();
										 bodyBuilder.appendFormalLine(""}
										"");
									 }
									 else if (minAnnotation != null && maxAnnotation != null) {
										 final Number minValue = (Number) minAnnotation.getAttribute(VALUE).getValue();
										 final Number maxValue = (Number) maxAnnotation.getAttribute(VALUE).getValue();
										 Validate .isTrue(maxValue.longValue() >= minValue.longValue(), ""The value of must be greater or equal to the value of for field %s"", fieldName);
										 if (fieldType.equals(BIG_INTEGER)) {
											 bodyBuilder.appendFormalLine(""if ("" + fieldName + "".compareTo(new "" + BIG_INTEGER.getSimpleTypeName() + ""(\"""" + minValue + ""\"")) == -1 || "" + fieldName + "".compareTo(new "" + BIG_INTEGER.getSimpleTypeName() + ""(\"""" + maxValue + ""\"")) == 1) {
												"");
												 bodyBuilder.indent();
												 bodyBuilder.appendFormalLine(fieldName + "" = new "" + BIG_INTEGER.getSimpleTypeName() + ""(\"""" + maxValue + ""\"");
												"");
											 }
											 else {
												 bodyBuilder.appendFormalLine(""if ("" + fieldName + "" < "" + minValue + suffix + "" || "" + fieldName + "" > "" + maxValue + suffix + "") {
													"");
													 bodyBuilder.indent();
													 bodyBuilder.appendFormalLine(fieldName + "" = "" + maxValue + suffix + "";
													"");
												 }
												 bodyBuilder.indentRemove();
											 bodyBuilder.appendFormalLine(""}
											"");
										 }
										 return bodyBuilder.getOutput();
									 }
									 private String getTypeStr(final JavaType fieldType) {
										 builder.getImportRegistrationResolver().addImport(fieldType);
										 final String arrayStr = fieldType.isArray() ? ""[]"" : """";
										 String typeStr = fieldType.getSimpleTypeName();
										 if (fieldType.getFullyQualifiedTypeName().equals( JavaType.FLOAT_PRIMITIVE.getFullyQualifiedTypeName()) && fieldType.isPrimitive()) {
											 typeStr = ""float"" + arrayStr;
										 }
										 else if (fieldType.getFullyQualifiedTypeName().equals( JavaType.DOUBLE_PRIMITIVE.getFullyQualifiedTypeName()) && fieldType.isPrimitive()) {
											 typeStr = ""double"" + arrayStr;
										 }
										 else if (fieldType.getFullyQualifiedTypeName().equals( JavaType.INT_PRIMITIVE.getFullyQualifiedTypeName()) && fieldType.isPrimitive()) {
											 typeStr = ""int"" + arrayStr;
										 }
										 else if (fieldType.getFullyQualifiedTypeName().equals( JavaType.SHORT_PRIMITIVE.getFullyQualifiedTypeName()) && fieldType.isPrimitive()) {
											 typeStr = ""short"" + arrayStr;
										 }
										 else if (fieldType.getFullyQualifiedTypeName().equals( JavaType.BYTE_PRIMITIVE.getFullyQualifiedTypeName()) && fieldType.isPrimitive()) {
											 typeStr = ""byte"" + arrayStr;
										 }
										 else if (fieldType.getFullyQualifiedTypeName().equals( JavaType.CHAR_PRIMITIVE.getFullyQualifiedTypeName()) && fieldType.isPrimitive()) {
											 typeStr = ""char"" + arrayStr;
										 }
										 else if (fieldType.equals(new JavaType(STRING.getFullyQualifiedTypeName(), 1, DataType.TYPE, null, null))) {
											 typeStr = ""String[]"";
										 }
										 return typeStr;
									 }
									 private boolean isNullableJoinColumn(final FieldMetadata field) {
										 final AnnotationMetadata joinColumnAnnotation = field.getAnnotation(JOIN_COLUMN);
										 if (joinColumnAnnotation == null) {
											 return true;
										 }
										 final AnnotationAttributeValue<?> nullableAttr = joinColumnAnnotation.getAttribute(new JavaSymbolName(""nullable""));
										 return nullableAttr == null || (Boolean) nullableAttr.getValue();
									 }
									 private void validateNumericAnnotationAttribute(final String fieldName, final String annotationName, final String attributeName, final Object object) {
										 Validate.isTrue(NumberUtils.isNumber(object.toString()), ""%s '%s' attribute for field '%s' in backing type %s must be numeric"", annotationName, attributeName, fieldName, entity.getFullyQualifiedTypeName());
									 }
									 public JavaSymbolName getCreateFactoryMethodName() {
										 return JpaEntityFactoryMetadata.CREATE_FACTORY_METHOD_NAME;
									 }
									 public JavaSymbolName getEmbeddedFieldMutatorMethodName(final JavaSymbolName fieldName) {
										 return BeanInfoUtils.getMutatorMethodName(fieldName);
									 }
									 public JavaSymbolName getEmbeddedFieldMutatorMethodName(final JavaSymbolName embeddedFieldName, final JavaSymbolName fieldName) {
										 return getEmbeddedFieldMutatorMethodName(new JavaSymbolName(embeddedFieldName.getSymbolName() + StringUtils.capitalize(fieldName.getSymbolName())));
									 }
									 public List<EmbeddedHolder> getEmbeddedHolders() {
										 return this.embeddedHolders;
									 }
									 public JavaSymbolName getEmbeddedIdMutatorMethodName() {
										 final List<JavaSymbolName> fieldNames = new ArrayList<JavaSymbolName>();
										 for (final FieldMetadata field : fieldInitializers.keySet()) {
											 fieldNames.add(field.getFieldName());
										 }
										 int index = -1;
										 JavaSymbolName embeddedIdField;
										 while (true) {
											 index++;
											 embeddedIdField = new JavaSymbolName(""embeddedIdClass"" + StringUtils.repeat(""_"", index));
											 if (!fieldNames.contains(embeddedIdField)) {
												 break;
											 }
										 }
										 return BeanInfoUtils.getMutatorMethodName(embeddedIdField);
									 }
									 public JavaType getEntityType() {
										 return this.entity;
									 }
									 public JavaType getGovernorType() {
										 return this.governorPhysicalTypeMetadata.getType();
									 }
									 public MethodMetadata getRandomPersistentEntityMethod() {
										 return randomPersistentEntityMethod;
									 }
									 public boolean hasEmbeddedIdentifier() {
										 return this.embeddedIdHolder != null;
									 }
									 public String toString() {
										 final ToStringBuilder builder = new ToStringBuilder(this);
										 builder.append(""identifier"", getId());
										 builder.append(""valid"", valid);
										 builder.append(""aspectName"", aspectName);
										 builder.append(""destinationType"", destination);
										 builder.append(""governor"", governorPhysicalTypeMetadata.getId());
										 builder.append(""itdTypeDetails"", itdTypeDetails);
										 return builder.toString();
									 }
								}",1,0,0,0
"private LdapComparator<T> classLoadComparator( SchemaManager schemaManager, String oid, String className, Attribute byteCode ) throws LdapException {
	 LdapComparator<T> comparator;
	 Class<T> clazz;
	 String byteCodeStr = StringConstants.EMPTY;
	 if ( byteCode == null ) {
		 try {
			 clazz = Class.forName( className );
		 }
		 catch ( ClassNotFoundException cnfe ) {
			 LOG.error( I18n.err( I18n.ERR_16056_CANNOT_FIND_CMP_CTOR, className ) );
			 throw new LdapSchemaException( I18n.err( I18n.ERR_16057_CANNOT_FIND_CMP_CLASS, cnfe.getMessage() ) );
		 }
	 }
	 else {
		 classLoader.setAttribute( byteCode );
		 try {
			 clazz = classLoader.loadClass( className );
		 }
		 catch ( ClassNotFoundException cnfe ) {
			 LOG.error( I18n.err( I18n.ERR_16058_CANNOT_LOAD_CMP_CTOR, className ) );
			 throw new LdapSchemaException( I18n.err( I18n.ERR_16059_CANNOT_LOAD_CMP_CLASS, cnfe.getMessage() ) );
		 }
		 byteCodeStr = new String( Base64.encode( byteCode.getBytes() ) );
	 }
	 try {
		 Constructor<T> constructor = clazz.getConstructor( new Class[] {
		 String.class }
		 );
		 try {
			 comparator = ( LdapComparator<T> ) constructor.newInstance( oid );
		 }
		 catch ( InvocationTargetException ite ) {
			 LOG.error( I18n.err( I18n.ERR_16060_CANNOT_INVOKE_CMP_CTOR, className ) );
			 throw new LdapSchemaException( I18n.err( I18n.ERR_16061_CANNOT_INVOKE_CMP_CLASS, ite.getMessage() ) );
		 }
		 catch ( InstantiationException ie ) {
			 LOG.error( I18n.err( I18n.ERR_16062_CANNOT_INST_CMP_CTOR_CLASS, className ) );
			 throw new LdapSchemaException( I18n.err( I18n.ERR_16063_CANNOT_INST_CMP_CLASS, ie.getMessage() ) );
		 }
		 catch ( IllegalAccessException ie ) {
			 LOG.error( I18n.err( I18n.ERR_16064_CANNOT_ACCESS_CMP_CTOR, className ) );
			 throw new LdapSchemaException( I18n.err( I18n.ERR_16065_CANNOT_ACCESS_CMP_CLASS, ie.getMessage() ) );
		 }
	 }
	 catch ( NoSuchMethodException nsme ) {
		 try {
			 clazz.getConstructor();
		 }
		 catch ( NoSuchMethodException nsme2 ) {
			 LOG.error( I18n.err( I18n.ERR_16066_CANNOT_FIND_CMP_CTOR_METH_CLASS, className ) );
			 throw new LdapSchemaException( I18n.err( I18n.ERR_16067_CANNOT_FIND_CMP_CTOR_METH, nsme2.getMessage() ) );
		 }
		 try {
			 comparator = ( LdapComparator<T> ) clazz.newInstance();
		 }
		 catch ( InstantiationException ie ) {
			 LOG.error( I18n.err( I18n.ERR_16062_CANNOT_INST_CMP_CTOR_CLASS, className ) );
			 throw new LdapSchemaException( I18n.err( I18n.ERR_16063_CANNOT_INST_CMP_CLASS, ie.getMessage() ) );
		 }
		 catch ( IllegalAccessException iae ) {
			 LOG.error( I18n.err( I18n.ERR_16064_CANNOT_ACCESS_CMP_CTOR, className ) );
			 throw new LdapSchemaException( I18n.err( I18n.ERR_16065_CANNOT_ACCESS_CMP_CLASS, iae.getMessage() ) );
		 }
		 if ( !comparator.getOid().equals( oid ) ) {
			 String msg = I18n.err( I18n.ERR_16021_DIFFERENT_COMPARATOR_OID, oid, comparator.getOid() );
			 throw new LdapInvalidAttributeValueException( ResultCodeEnum.UNWILLING_TO_PERFORM, msg, nsme );
		 }
	 }
	 comparator.setBytecode( byteCodeStr );
	 comparator.setFqcn( className );
	 comparator.setSchemaManager( schemaManager );
	 return comparator;
 }",0,0,1,0
"final protected Node internalRemoveNamedItemNS(String namespaceURI, String name, boolean raiseEx) {
	 CoreDocumentImpl ownerDocument = ownerNode.ownerDocument();
	 if (ownerDocument.errorChecking && isReadOnly()) {
		 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, ""NO_MODIFICATION_ALLOWED_ERR"", null);
		 throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);
	 }
	 int i = findNamePoint(namespaceURI, name);
	 if (i < 0) {
		 if (raiseEx) {
			 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, ""NOT_FOUND_ERR"", null);
			 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
		 }
		 else {
			 return null;
		 }
	 }
	 AttrImpl n = (AttrImpl)nodes.get(i);
	 if (n.isIdAttribute()) {
		 ownerDocument.removeIdentifier(n.getValue());
	 }
	 String nodeName = n.getNodeName();
	 if (hasDefaults()) {
		 NamedNodeMapImpl defaults = ((ElementImpl) ownerNode).getDefaultAttributes();
		 Node d;
		 if (defaults != null && (d = defaults.getNamedItem(nodeName)) != null) {
			 int j = findNamePoint(nodeName,0);
			 if (j>=0 && findNamePoint(nodeName, j+1) < 0) {
				 NodeImpl clone = (NodeImpl)d.cloneNode(true);
				 clone.ownerNode = ownerNode;
				 if (d.getLocalName() != null) {
					 ((AttrNSImpl)clone).namespaceURI = namespaceURI;
				 }
				 clone.isOwned(true);
				 clone.isSpecified(false);
				 nodes.set(i, clone);
				 if (clone.isIdAttribute()) {
					 ownerDocument.putIdentifier(clone.getNodeValue(), (ElementImpl)ownerNode);
				 }
			 }
			 else {
				 nodes.remove(i);
			 }
		 }
		 else {
			 nodes.remove(i);
		 }
	 }
	 else {
		 nodes.remove(i);
	 }
	 n.ownerNode = ownerDocument;
	 n.isOwned(false);
	 n.isSpecified(true);
	 n.isIdAttribute(false);
	 ownerDocument.removedAttrNode(n, ownerNode, name);
	 return n;
 }",0,0,1,0
"protected Server createJettyServer(JettyHttpHandlerAdapter servlet) {
	int port = (getPort() >= 0) ? getPort() : 0;
	InetSocketAddress address = new InetSocketAddress(getAddress(), port);
	Server server = new Server(getThreadPool());
	server.addConnector(createConnector(address, server));
	ServletHolder servletHolder = new ServletHolder(servlet);
	servletHolder.setAsyncSupported(true);
	ServletContextHandler contextHandler = new ServletContextHandler(server, """",false, false);
	contextHandler.addServlet(servletHolder, ""/"");
	server.setHandler(addHandlerWrappers(contextHandler));
	JettyReactiveWebServerFactory.logger.info(""Server initialized with port: "" + port);
	if (getSsl() != null && getSsl().isEnabled()) {
		customizeSsl(server, address);
	}
	for (JettyServerCustomizer customizer : getServerCustomizers()) {
		customizer.customize(server);
	}
	if (this.useForwardHeaders) {
		new ForwardHeadersCustomizer().customize(server);
	}
	return server;
}",0,0,1,0
public boolean waitForAllAcks(long timeout) throws TimeoutException;,0,0,0,0
"public class ManifestReadingException extends RuntimeException{
	 public ManifestReadingException() {
		 super();
	 }
	 public ManifestReadingException( String message, Throwable cause ) {
		 super( message, cause );
	 }
	 public ManifestReadingException( String message ) {
		 super( message );
	 }
	 public ManifestReadingException( Throwable cause ) {
		 super( cause );
	 }
}",0,0,0,0
"public class FileDiskCacheAttributes extends AbstractDiskCacheAttributes{
	 private static final long serialVersionUID = -7371586172678836062L;
	 public static final int DEFAULT_MAX_NUMBER_OF_FILES = -1;
	 private int maxNumberOfFiles = DEFAULT_MAX_NUMBER_OF_FILES;
	 public static final int DEFAULT_MAX_RETRIES_ON_DELETE = 10;
	 private int maxRetriesOnDelete = DEFAULT_MAX_RETRIES_ON_DELETE;
	 public static final boolean DEFAULT_TOUCH_ON_GET = false;
	 public static final int DEFAULT_MAX_RETRIES_ON_TOUCH = 10;
	 private int maxRetriesOnTouch = DEFAULT_MAX_RETRIES_ON_TOUCH;
	 private boolean touchOnGet = DEFAULT_TOUCH_ON_GET;
	 public void setMaxNumberOfFiles( int maxNumberOfFiles ) {
		 this.maxNumberOfFiles = maxNumberOfFiles;
	 }
	 public int getMaxNumberOfFiles() {
		 return maxNumberOfFiles;
	 }
	 public void setMaxRetriesOnDelete( int maxRetriesOnDelete ) {
		 this.maxRetriesOnDelete = maxRetriesOnDelete;
	 }
	 public int getMaxRetriesOnDelete() {
		 return maxRetriesOnDelete;
	 }
	 public void setTouchOnGet( boolean touchOnGet ) {
		 this.touchOnGet = touchOnGet;
	 }
	 public boolean isTouchOnGet() {
		 return touchOnGet;
	 }
	 public void setMaxRetriesOnTouch( int maxRetriesOnTouch ) {
		 this.maxRetriesOnTouch = maxRetriesOnTouch;
	 }
	 public int getMaxRetriesOnTouch() {
		 return maxRetriesOnTouch;
	 }
	 public String toString() {
		 StringBuilder str = new StringBuilder();
		 str.append( ""DiskFileCacheAttributes "" );
		 str.append( ""\n diskPath = "" + super.getDiskPath() );
		 str.append( ""\n maxNumberOfFiles = "" + getMaxNumberOfFiles() );
		 str.append( ""\n maxRetriesOnDelete = "" + getMaxRetriesOnDelete() );
		 return str.toString();
	 }
}",0,1,0,0
"public int serializationFlags() {
	 return ColumnSerializer.DELETION_MASK;
 }",0,0,0,0
"public class BasicAttributeSensor<T> extends BasicSensor<T> implements AttributeSensor<T> {
	 private static final long serialVersionUID = -2493209215974820300L;
	 private final SensorPersistenceMode persistence;
	 public BasicAttributeSensor(Class<T> type, String name) {
		 this(type, name, name);
	 }
	 public BasicAttributeSensor(Class<T> type, String name, String description) {
		 this(type, name, description, SensorPersistenceMode.REQUIRED);
	 }
	 public BasicAttributeSensor(TypeToken<T> typeToken, String name) {
		 this(typeToken, name, name);
	 }
	 public BasicAttributeSensor(TypeToken<T> typeToken, String name, String description) {
		 this(typeToken, name, description, SensorPersistenceMode.REQUIRED);
	 }
	 public BasicAttributeSensor(Class<T> type, String name, String description, SensorPersistenceMode persistence) {
		 this(type, null, name, description, persistence);
	 }
	 public BasicAttributeSensor(TypeToken<T> typeToken, String name, String description, SensorPersistenceMode persistence) {
		 this(null, typeToken, name, description, persistence);
	 }
	 public BasicAttributeSensor(Class<T> type, TypeToken<T> typeToken, String name, String description, SensorPersistenceMode persistence) {
		 super(type, typeToken, name, description);
		 this.persistence = checkNotNull(persistence, ""persistence"");
	 }
	 public SensorPersistenceMode getPersistenceMode() {
		 return (persistence != null) ? persistence : SensorPersistenceMode.REQUIRED;
	 }
}",0,1,0,0
"public class Network {
	 public static Builder builder() {
		 return new Builder();
	 }
	 public static class Builder {
		 protected String name;
		 protected String description;
		 public Builder name(String name) {
			 this.name = name;
			 return this;
		 }
		 public Builder description(String description) {
			 this.description = description;
			 return this;
		 }
		 public Network build() {
			 return new Network(name, description);
		 }
		 public Builder fromNetwork(Network in) {
			 return name(in.getName()).description(in.getDescription());
		 }
	 }
	 private final String name;
	 private final String description;
	 public Network(String name, String description) {
		 this.name = name;
		 this.description = description;
	 }
	 public int hashCode() {
		 final int prime = 31;
		 int result = 1;
		 result = prime * result + ((description == null) ? 0 : description.hashCode());
		 result = prime * result + ((name == null) ? 0 : name.hashCode());
		 return result;
	 }
	 public boolean equals(Object obj) {
		 if (this == obj) return true;
		 if (obj == null) return false;
		 if (getClass() != obj.getClass()) return false;
		 Network other = (Network) obj;
		 if (description == null) {
			 if (other.description != null) return false;
		 }
		 else if (!description.equals(other.description)) return false;
		 if (name == null) {
			 if (other.name != null) return false;
		 }
		 else if (!name.equals(other.name)) return false;
		 return true;
	 }
	 public String toString() {
		 return ""[name="" + name + "", description="" + description + ""]"";
	 }
	 public String getName() {
		 return name;
	 }
	 public String getDescription() {
		 return description;
	 }
}",0,0,0,0
"protected NetworkVO getDefaultNetworkForAdvancedZone(DataCenter dc) {
	 if (dc.getNetworkType() != NetworkType.Advanced) {
		 throw new CloudRuntimeException(""Zone "" + dc + "" is not advanced."");
	 }
	 if (dc.isSecurityGroupEnabled()) {
		 List<NetworkVO> networks = _networkDao.listByZoneSecurityGroup(dc.getId());
		 if (CollectionUtils.isEmpty(networks)) {
			 throw new CloudRuntimeException(""Can not found security enabled network in SG Zone "" + dc);
		 }
		 return networks.get(0);
	 }
	 else {
		 TrafficType defaultTrafficType = TrafficType.Public;
		 List<NetworkVO> defaultNetworks = _networkDao.listByZoneAndTrafficType(dc.getId(), defaultTrafficType);
		 if (defaultNetworks.size() != 1) {
			 throw new CloudRuntimeException(""Found "" + defaultNetworks.size() + "" networks of type "" + defaultTrafficType + "" when expect to find 1"");
		 }
		 return defaultNetworks.get(0);
	 }
 }",0,0,1,0
"private static class Function_FirstDayOfFiscalQuarter extends Function_temp{
	private static final long serialVersionUID = 1L;
	Function_FirstDayOfFiscalQuarter( ){
		minParamCount = 1;
		maxParamCount = 2;
	}
	protected Object getValue( Object[] args, IScriptFunctionContext context ) throws BirtException{
		if ( existNullValue( args ) ){
			return null;
		}
		Calendar current;
		if ( args[0] instanceof Number ){
			current = getFiscalYearStateDate( context, args );
			current.add( Calendar.MONTH,( ( (Number) args[0] ).intValue( ) - 1 ) * 3 );
		}
		else{
			current = getCalendar( DataTypeUtil.toDate( args[0] ) );
			Calendar start = getFiscalYearStateDate( context, args );
			adjustFiscalMonth( current, start );
			int monthRemaindary = ( current.get( Calendar.MONTH )- start.get( Calendar.MONTH ) + 12 ) % 3;
			current.add( Calendar.MONTH, -monthRemaindary );
			current.set( Calendar.DATE,Math.min( start.get( Calendar.DATE ),current.getActualMaximum( Calendar.DATE ) ) );
		}
		return current.getTime( );
	}
}",0,0,0,0
"public static class NotificationsAggregatorState {
	 public long recentEventLogsCount;
	 public long activeRequestsCount;
 }",0,1,0,0
"public class DefaultResourceService implements ResourceService {
	private String servletPath = """";
	public void setServletPath(String servletPath) {
		this.servletPath = servletPath;
	}
	public String getServletPath() {
		return servletPath;
	}
}",0,1,0,0
"public interface Transaction<OpResultT> {
	 interface Op<OpResultT> {
		 void commit(OpResultT r);
		 void abort(Throwable t, OpResultT r);
	 }
	 interface OpListener<OpResultT> {
		 void onCommit(OpResultT r);
		 void onAbort(Throwable t);
	 }
	 void addOp(Op<OpResultT> operation);
	 CompletableFuture<Void> execute();
	 void abort(Throwable reason);
}",0,0,0,0
"static JFreeChart createWindPlot(String title, String xAxisLabel, String yAxisLabel, WindDataset dataset, boolean legend, boolean tooltips, boolean urls);",0,0,0,1
"public class CheckGroupPage extends WicketExamplePage{
	public CheckGroupPage(){
		final CheckGroup<Person> group = new CheckGroup<>(""group"", new ArrayList<Person>());
		Form<Void> form = new Form<Void>(""form""){
			protected void onSubmit(){
				info(""selected person(s): "" + group.getDefaultModelObjectAsString());
			}
		}
		;
		add(form);
		form.add(group);
		group.add(new CheckGroupSelector(""groupselector""));
		ListView<Person> persons = new ListView<Person>(""persons"",ComponentReferenceApplication.getPersons()){
			protected void populateItem(ListItem<Person> item){
				item.add(new Check<>(""checkbox"", item.getModel()));
				item.add(new Label(""name"",new PropertyModel<>(item.getDefaultModel(), ""name"")));
				item.add(new Label(""lastName"", new PropertyModel<String>(item.getDefaultModel(),""lastName"")));
			}
		}
		;
		persons.setReuseItems(true);
		group.add(persons);
		add(new FeedbackPanel(""feedback""));
	}
	protected void explain(){
		String html = ""<form wicket:id=\""form\"">\n"" + ""<span wicket:id=\""group\"">\n""+ ""<input type=\""checkbox\"" wicket:id=\""groupselector\"">check/uncheck all</input>\n""+ ""<tr wicket:id=\""persons\"">\n""+ ""<td><input type=\""checkbox\"" wicket:id=\""checkbox\""/></td>\n""+ ""<td><span wicket:id=\""name\"">[this is where name will be]</span></td>\n""+ ""<td><span wicket:id=\""lastName\"">[this is where lastname will be]</span></td>\n""+ ""</tr>\n</span>\n</form>"";
		String code = ""&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		Form f=new Form(\""form\"");
		<br/>""+ ""&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		add(f);
		<br/>""+ ""&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		CheckGroup group=new CheckGroup(\""group\"");
		<br/>""+ ""&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		form.add(group);
		<br/>""+ ""&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		group.add(new CheckGroupSelector(\""groupselector\""));
		<br/>""+ ""&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		ListView persons=new ListView(\""persons\"", getPersons()) {
			<br/>""+ ""&nbsp;
			&nbsp;
			&nbsp;
			&nbsp;
			protected void populateItem(ListItem item) {
				<br/>""+ ""&nbsp;
				&nbsp;
				&nbsp;
				&nbsp;
				&nbsp;
				&nbsp;
				item.add(new Check(\""check\"", item.getModel()));
				<br/>""+ ""&nbsp;
				&nbsp;
				&nbsp;
				&nbsp;
				&nbsp;
				&nbsp;
				item.add(new Label(\""name\"", new PropertyModel(item.getModel(), \""name\"")));
				<br/>""+ ""&nbsp;
				&nbsp;
				&nbsp;
				&nbsp;
				&nbsp;
				&nbsp;
				item.add(new Label(\""lastName\"", new PropertyModel(item.getModel(), \""lastName\"")));
				<br/>""+ ""&nbsp;
				&nbsp;
				&nbsp;
				&nbsp;
			}
			;
			<br/>""+ ""&nbsp;
			&nbsp;
			&nbsp;
			&nbsp;
			persons.setReuseItems(true);
			<br/>""+ ""&nbsp;
			&nbsp;
			&nbsp;
			&nbsp;
			group.add(persons);
			<br/>"";
			add(new ExplainPanel(html, code));
		}
	}",0,0,0,0
"public class AnnealingLayoutSettings extends JPanel implements JGraphLayoutSettings {
	 public final static String KEY_TITLE = ""Simulated Annealing"";
	 public final static String KEY_CONFIG_NAME = ""CONFIG_NAME"";
	 public final static String KEY_INIT_TEMPERATURE = ""Start Temperature"";
	 public final static String KEY_MIN_TEMPERATURE = ""min. Temperature"";
	 public final static String KEY_MIN_DISTANCE = ""min. Distance"";
	 public final static String KEY_TEMP_SCALE_FACTOR = ""Temperature Scalefactor"";
	 public final static String KEY_COMPUTE_PERMUTATION = ""should compute per Permutation"";
	 public final static String KEY_IS_UPHILL_MOVE_ALLOWED = ""are Uphill-Moves allowed"";
	 public final static String KEY_MAX_ROUNDS = ""max. Rounds"";
	 public final static String KEY_TRIES_PER_CELL = ""tries per cell"";
	 public final static String KEY_COST_FUNCTION_CONFIG = ""Costfunction Config"";
	 public final static String KEY_LAMBDA = ""Lambda"";
	 public final static String KEY_BOUNDS = ""Bounds of resulting graph"";
	 public final static String KEY_LAYOUT_UPDATE_INIT_TEMPERATURE = ""Layout Update Start Temperature"";
	 public final static String KEY_LAYOUT_UPDATE_MIN_TEMPERATURE = ""Layout Update min. Temperature"";
	 public final static String KEY_LAYOUT_UPDATE_MIN_DISTANCE = ""Layout Update min. Distance"";
	 public final static String KEY_LAYOUT_UPDATE_TEMP_SCALE_FACTOR = ""Layout Update Temperature Scalefactor"";
	 public final static String KEY_LAYOUT_UPDATE_COMPUTE_PERMUTATION = ""Layout Update should compute per Permutation"";
	 public final static String KEY_LAYOUT_UPDATE_IS_UPHILL_MOVE_ALLOWED = ""Layout Update are Uphill-Moves allowed"";
	 public final static String KEY_LAYOUT_UPDATE_MAX_ROUNDS = ""Layout Update max. Rounds"";
	 public final static String KEY_LAYOUT_UPDATE_TRIES_PER_CELL = ""Layout Update tries per cell"";
	 public final static String KEY_LAYOUT_UPDATE_COST_FUNCTION_CONFIG = ""Layout Update Costfunction Config"";
	 public final static String KEY_LAYOUT_UPDATE_LAMBDA = ""Layout Update Lambda"";
	 public final static String KEY_LAYOUT_UPDATE_BOUNDS = ""Layout Update Bounds of resulting graph"";
	 public final static String KEY_LAYOUT_UPDATE_METHOD = ""Layout Update Method"";
	 public final static String KEY_LAYOUT_UPDATE_METHOD_NEIGHBORS_ONLY = ""Layout Update Method Neighbors only"";
	 public final static String KEY_LAYOUT_UPDATE_METHOD_PERIMETER = ""Layout Update Method Perimeter"";
	 public final static String KEY_LAYOUT_UPDATE_METHOD_NEIGHBORS_DEPTH = ""Layout Update Method Neighbors depth"";
	 public final static String KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS= ""Layout Update Method Perimeter radius"";
	 public final static String KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS_INCREASE = ""Layout Update Method Perimeter radius increase"";
	 public final static String KEY_LAYOUT_UPDATE_ENABLED = ""Layout Update enabled"";
	 public final static String KEY_LAYOUT_UPDATE_CLUSTERING_ENABLED = ""Layout Update clustering enabled"";
	 public final static String KEY_LAYOUT_UPDATE_CLUSTERING_FACTOR = ""Layout Update clustering factor"";
	 public final static String KEY_LAYOUT_UPDATE_CLUSTERING_MOVE_SCALE = ""Layout Update clustering move scaling factor"";
	protected AnnealingLayoutAlgorithm layout;
	 private JTextField tf_initTemperature;
	 private JTextField tf_minTemperature;
	 private JTextField tf_minDistance;
	 private JTextField tf_tempScaleFactor;
	 private JTextField tf_maxRounds;
	 private JTextField tf_triesPerCell;
	 private JTextField tf_lambdaNodeDistribution;
	 private JTextField tf_lambdaBorderline;
	 private JTextField tf_lambdaEdgeLength;
	 private JTextField tf_lambdaEdgeCrossing;
	 private JTextField tf_lambdaEdgeDistribution;
	 private JTextField tf_lambdaNodeDistance;
	 private JTextField tf_boundsWidth;
	 private JTextField tf_boundsHeight;
	 private JCheckBox cb_computePermutation;
	 private JCheckBox cb_uphillMovesAllowed;
	 private JCheckBox cb_useNodeDistribution;
	 private JCheckBox cb_useBorderline;
	 private JCheckBox cb_useEdgeLength;
	 private JCheckBox cb_useEdgeCrossing;
	 private JCheckBox cb_useEdgeDistribution;
	 private JCheckBox cb_useNodeDistance;
	 private JButton button_takeViewportSize;
	 private JCheckBox cb_enableLayoutUpdate;
	 private JTextField tf_lu_initTemperature;
	 private JTextField tf_lu_minTemperature;
	 private JTextField tf_lu_minDistance;
	 private JTextField tf_lu_tempScaleFactor;
	 private JTextField tf_lu_maxRounds;
	 private JTextField tf_lu_triesPerCell;
	 private JTextField tf_lu_lambdaNodeDistribution;
	 private JTextField tf_lu_lambdaBorderline;
	 private JTextField tf_lu_lambdaEdgeLength;
	 private JTextField tf_lu_lambdaEdgeCrossing;
	 private JTextField tf_lu_lambdaEdgeDistribution;
	 private JTextField tf_lu_lambdaNodeDistance;
	 private JTextField tf_lu_boundsWidth;
	 private JTextField tf_lu_boundsHeight;
	 private JTextField tf_lu_method_neighborsDepth;
	 private JTextField tf_lu_method_perimeterRadius;
	 private JTextField tf_lu_method_perimeterRadiusInc;
	 private JTextField tf_lu_clustering_factor;
	 private JTextField tf_lu_clustering_moveScale;
	 private JCheckBox cb_lu_computePermutation;
	 private JCheckBox cb_lu_uphillMovesAllowed;
	 private JCheckBox cb_lu_useNodeDistribution;
	 private JCheckBox cb_lu_useBorderline;
	 private JCheckBox cb_lu_useEdgeLength;
	 private JCheckBox cb_lu_useEdgeCrossing;
	 private JCheckBox cb_lu_useEdgeDistribution;
	 private JCheckBox cb_lu_useNodeDistance;
	 private JCheckBox cb_lu_clustering_enable;
	 private JButton button_lu_takeViewportSize;
	 private JComboBox comb_loadPreSets;
	 private JComboBox comb_lu_Method;
	 protected Properties[] preSetConfigs;
	 private JPanel panelSurface;
	 private JPanel panelLUSurface;
	private JTabbedPane tp_main;
	JScrollPane panelSurfaceWrapper;
	JScrollPane panelLUSurfaceWrapper;
	 private boolean isOptimizer;
	 public AnnealingLayoutSettings(AnnealingLayoutAlgorithm layout, boolean isOptimizationAlgorithm) {
		 this.layout = layout;
		 Properties[] config = new Properties[2];
		 config[0] = new Properties();
		 config[0].put(KEY_CONFIG_NAME ,""Default Values"");
		 config[0].put(KEY_INIT_TEMPERATURE , ""300.0"");
		 config[0].put(KEY_MIN_TEMPERATURE , ""2.0"");
		 config[0].put(KEY_MIN_DISTANCE , ""50.0"");
		 config[0].put(KEY_TEMP_SCALE_FACTOR , ""0.95"");
		 config[0].put(KEY_COMPUTE_PERMUTATION ,""true"");
		 config[0].put(KEY_IS_UPHILL_MOVE_ALLOWED,""true"");
		 config[0].put(KEY_MAX_ROUNDS , ""10000"");
		 config[0].put(KEY_TRIES_PER_CELL , ""8"");
		 config[0].put(KEY_COST_FUNCTION_CONFIG ,""111110"");
		 ArrayList lambda1 = new ArrayList();
		 lambda1.add(new Double(1000.0));
		 lambda1.add(new Double(100000.0));
		 lambda1.add(new Double(0.02));
		 lambda1.add(new Double(2000.0));
		 lambda1.add(new Double(150.0));
		 lambda1.add(new Double(1000000.0));
		 config[0].put(KEY_LAMBDA ,lambda1);
		 Rectangle bounds1 = new Rectangle(0,0,1000,700);
		 config[0].put(KEY_BOUNDS ,bounds1);
		 config[0].put(KEY_LAYOUT_UPDATE_ENABLED ,""false"");
		 config[0].put(KEY_LAYOUT_UPDATE_INIT_TEMPERATURE , ""40.0"");
		 config[0].put(KEY_LAYOUT_UPDATE_MIN_TEMPERATURE , ""2.0"");
		 config[0].put(KEY_LAYOUT_UPDATE_MIN_DISTANCE , ""50.0"");
		 config[0].put(KEY_LAYOUT_UPDATE_TEMP_SCALE_FACTOR , ""0.95"");
		 config[0].put(KEY_LAYOUT_UPDATE_COMPUTE_PERMUTATION ,""true"");
		 config[0].put(KEY_LAYOUT_UPDATE_IS_UPHILL_MOVE_ALLOWED,""true"");
		 config[0].put(KEY_LAYOUT_UPDATE_MAX_ROUNDS , ""10000"");
		 config[0].put(KEY_LAYOUT_UPDATE_TRIES_PER_CELL , ""8"");
		 config[0].put(KEY_LAYOUT_UPDATE_COST_FUNCTION_CONFIG ,""111110"");
		 config[0].put(KEY_LAYOUT_UPDATE_METHOD ,KEY_LAYOUT_UPDATE_METHOD_PERIMETER);
		 config[0].put(KEY_LAYOUT_UPDATE_METHOD_NEIGHBORS_DEPTH,""1"");
		 config[0].put(KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS,""100.0"");
		 config[0].put(KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS_INCREASE,""20.0"");
		 ArrayList lambdaLU1 = new ArrayList();
		 lambdaLU1.add(new Double(1000.0));
		 lambdaLU1.add(new Double(100000.0));
		 lambdaLU1.add(new Double(0.02));
		 lambdaLU1.add(new Double(2000.0));
		 lambdaLU1.add(new Double(150.0));
		 lambdaLU1.add(new Double(1000000.0));
		 config[0].put(KEY_LAYOUT_UPDATE_LAMBDA ,lambdaLU1);
		 Rectangle boundsLU1 = new Rectangle(0,0,1000,700);
		 config[0].put(KEY_LAYOUT_UPDATE_BOUNDS ,boundsLU1);
		 config[0].put(KEY_LAYOUT_UPDATE_CLUSTERING_ENABLED,""true"");
		 config[0].put(KEY_LAYOUT_UPDATE_CLUSTERING_FACTOR,""8.0"");
		 config[0].put(KEY_LAYOUT_UPDATE_CLUSTERING_MOVE_SCALE,""0.1"");
		 config[1] = new Properties();
		 config[1].put(KEY_CONFIG_NAME ,""Heavy Values"");
		 config[1].put(KEY_INIT_TEMPERATURE , ""500.0"");
		 config[1].put(KEY_MIN_TEMPERATURE , ""0.5"");
		 config[1].put(KEY_MIN_DISTANCE , ""50.0"");
		 config[1].put(KEY_TEMP_SCALE_FACTOR , ""0.97"");
		 config[1].put(KEY_COMPUTE_PERMUTATION ,""true"");
		 config[1].put(KEY_IS_UPHILL_MOVE_ALLOWED,""true"");
		 config[1].put(KEY_MAX_ROUNDS , ""10000"");
		 config[1].put(KEY_TRIES_PER_CELL , ""8"");
		 config[1].put(KEY_COST_FUNCTION_CONFIG ,""111111"");
		 config[1].put(KEY_BOUNDS , ""0.0"");
		 ArrayList lambda2 = new ArrayList();
		 lambda2.add(new Double(1000.0));
		 lambda2.add(new Double(100000.0));
		 lambda2.add(new Double(0.02));
		 lambda2.add(new Double(2000.0));
		 lambda2.add(new Double(150.0));
		 lambda2.add(new Double(1000000.0));
		 config[1].put(KEY_LAMBDA ,lambda2);
		 Rectangle bounds2 = new Rectangle(0,0,1000,700);
		 config[1].put(KEY_BOUNDS ,bounds2);
		 config[1].put(KEY_LAYOUT_UPDATE_ENABLED ,""true"");
		 config[1].put(KEY_LAYOUT_UPDATE_INIT_TEMPERATURE , ""40.0"");
		 config[1].put(KEY_LAYOUT_UPDATE_MIN_TEMPERATURE , ""2.0"");
		 config[1].put(KEY_LAYOUT_UPDATE_MIN_DISTANCE , ""50.0"");
		 config[1].put(KEY_LAYOUT_UPDATE_TEMP_SCALE_FACTOR , ""0.97"");
		 config[1].put(KEY_LAYOUT_UPDATE_COMPUTE_PERMUTATION ,""true"");
		 config[1].put(KEY_LAYOUT_UPDATE_IS_UPHILL_MOVE_ALLOWED,""true"");
		 config[1].put(KEY_LAYOUT_UPDATE_MAX_ROUNDS , ""10000"");
		 config[1].put(KEY_LAYOUT_UPDATE_TRIES_PER_CELL , ""8"");
		 config[1].put(KEY_LAYOUT_UPDATE_COST_FUNCTION_CONFIG ,""111111"");
		 config[1].put(KEY_LAYOUT_UPDATE_METHOD ,KEY_LAYOUT_UPDATE_METHOD_PERIMETER);
		 config[1].put(KEY_LAYOUT_UPDATE_METHOD_NEIGHBORS_DEPTH,""2"");
		 config[1].put(KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS,""200.0"");
		 config[1].put(KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS_INCREASE,""40.0"");
		 ArrayList lambdaLU2 = new ArrayList();
		 lambdaLU2.add(new Double(1000.0));
		 lambdaLU2.add(new Double(100000.0));
		 lambdaLU2.add(new Double(0.02));
		 lambdaLU2.add(new Double(2000.0));
		 lambdaLU2.add(new Double(150.0));
		 lambdaLU2.add(new Double(1000000.0));
		 config[1].put(KEY_LAYOUT_UPDATE_LAMBDA ,lambdaLU2);
		 Rectangle boundsLU2 = new Rectangle(0,0,1000,700);
		 config[1].put(KEY_LAYOUT_UPDATE_BOUNDS ,boundsLU2);
		 config[1].put(KEY_LAYOUT_UPDATE_CLUSTERING_ENABLED,""true"");
		 config[1].put(KEY_LAYOUT_UPDATE_CLUSTERING_FACTOR,""12.0"");
		 config[1].put(KEY_LAYOUT_UPDATE_CLUSTERING_MOVE_SCALE,""0.2"");
		 isOptimizer = isOptimizationAlgorithm;
		 preSetConfigs = config;
		 initComponents();
		 action_LoadPreSets(0);
	 }
	public void revert() {
	}
	 public void apply() {
		 layout.setPresetConfig(getConfiguration());
	 }
	 public void setConfiguration(Properties config) {
		 setInitTemperature( Double.parseDouble( (String)config.get(KEY_INIT_TEMPERATURE)));
		 setMinTemperature( Double.parseDouble( (String)config.get(KEY_MIN_TEMPERATURE)));
		 setMinDistance( Double.parseDouble( (String)config.get(KEY_MIN_DISTANCE)));
		 setTemperatureScaleFactor( Double.parseDouble( (String)config.get(KEY_TEMP_SCALE_FACTOR)));
		 setComputePermutation( isTrue( (String)config.get(KEY_COMPUTE_PERMUTATION)));
		 setUphillMovesAllowed( isTrue( (String)config.get(KEY_IS_UPHILL_MOVE_ALLOWED)));
		 setMaxRounds( Integer.parseInt( (String)config.get(KEY_MAX_ROUNDS)));
		 setTriesPerCell( Integer.parseInt( (String)config.get(KEY_TRIES_PER_CELL)));
		 setCostFunctionConfiguration( Integer.parseInt( (String)config.get(KEY_COST_FUNCTION_CONFIG),2));
		 setLambda((ArrayList)config.get(KEY_LAMBDA));
		 setResultBounds((Rectangle)config.get(KEY_BOUNDS));
		 setLayoutUpdateEnabled(isTrue((String)config.get(KEY_LAYOUT_UPDATE_ENABLED)));
		 setLayoutUpdateInitTemperature( Double.parseDouble( (String)config.get(KEY_LAYOUT_UPDATE_INIT_TEMPERATURE)));
		 setLayoutUpdateMinTemperature( Double.parseDouble( (String)config.get(KEY_LAYOUT_UPDATE_MIN_TEMPERATURE)));
		 setLayoutUpdateMinDistance( Double.parseDouble( (String)config.get(KEY_LAYOUT_UPDATE_MIN_DISTANCE)));
		 setLayoutUpdateTemperatureScaleFactor( Double.parseDouble( (String)config.get(KEY_LAYOUT_UPDATE_TEMP_SCALE_FACTOR)));
		 setLayoutUpdateComputePermutation( isTrue( (String)config.get(KEY_LAYOUT_UPDATE_COMPUTE_PERMUTATION)));
		 setLayoutUpdateUphillMovesAllowed( isTrue( (String)config.get(KEY_LAYOUT_UPDATE_IS_UPHILL_MOVE_ALLOWED)));
		 setLayoutUpdateMaxRounds( Integer.parseInt( (String)config.get(KEY_LAYOUT_UPDATE_MAX_ROUNDS)));
		 setLayoutUpdateTriesPerCell( Integer.parseInt( (String)config.get(KEY_LAYOUT_UPDATE_TRIES_PER_CELL)));
		 setLayoutUpdateCostFunctionConfiguration( Integer.parseInt( (String)config.get(KEY_LAYOUT_UPDATE_COST_FUNCTION_CONFIG),2));
		 setLayoutUpdateLambda( (ArrayList)config.get(KEY_LAYOUT_UPDATE_LAMBDA));
		 setLayoutUpdateResultBounds( (Rectangle)config.get(KEY_LAYOUT_UPDATE_BOUNDS));
		 setLayoutUpdateMethod( (String)config.get(KEY_LAYOUT_UPDATE_METHOD));
		 setLayoutUpdateMethodNeighborsDepth( Integer.parseInt( (String)config.get(KEY_LAYOUT_UPDATE_METHOD_NEIGHBORS_DEPTH)));
		 setLayoutUpdateMethodPerimeterRadius( Double.parseDouble( (String)config.get(KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS)));
		 setLayoutUpdateMethodPerimeterRadiusIncrease( Double.parseDouble( (String)config.get( KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS_INCREASE)));
		 setLayoutUpdateClusteringEnabled( isTrue( (String)config.get(KEY_LAYOUT_UPDATE_CLUSTERING_ENABLED)));
		 setLayoutUpdateClusteringFactor( Double.parseDouble( (String)config.get(KEY_LAYOUT_UPDATE_CLUSTERING_FACTOR)));
		 setLayoutUpdateClusteringMoveScaleFactor( Double.parseDouble( (String)config.get(KEY_LAYOUT_UPDATE_CLUSTERING_MOVE_SCALE)));
	 }
	 public Properties getConfiguration() {
		 Properties config = new Properties();
		 config.put(""CAPTION"" ,KEY_TITLE);
		 config.put(KEY_INIT_TEMPERATURE ,String.valueOf(getInitTemperature()));
		 config.put(KEY_MIN_TEMPERATURE ,String.valueOf(getMinTemperature()));
		 config.put(KEY_MIN_DISTANCE ,String.valueOf(getMinDistance()));
		 config.put(KEY_TEMP_SCALE_FACTOR ,String.valueOf(getTemperatureScaleFactor()));
		 config.put(KEY_COMPUTE_PERMUTATION ,String.valueOf(getComputePermutation()));
		 config.put(KEY_IS_UPHILL_MOVE_ALLOWED,String.valueOf(getUphillMovesAllowed()));
		 config.put(KEY_MAX_ROUNDS ,String.valueOf(getMaxRounds()));
		 config.put(KEY_TRIES_PER_CELL ,String.valueOf(getTriesPerCell()));
		 config.put(KEY_COST_FUNCTION_CONFIG ,String.valueOf(Integer.toBinaryString(getCostFunctionConfiguration())));
		 config.put(KEY_LAMBDA ,getLambda());
		 config.put(KEY_BOUNDS ,getResultBounds());
		 config.put(KEY_LAYOUT_UPDATE_ENABLED ,String.valueOf(getLayoutUpdateEnabled()));
		 config.put(KEY_LAYOUT_UPDATE_INIT_TEMPERATURE ,String.valueOf(getLayoutUpdateInitTemperature()));
		 config.put(KEY_LAYOUT_UPDATE_MIN_TEMPERATURE ,String.valueOf(getLayoutUpdateMinTemperature()));
		 config.put(KEY_LAYOUT_UPDATE_MIN_DISTANCE ,String.valueOf(getLayoutUpdateMinDistance()));
		 config.put(KEY_LAYOUT_UPDATE_TEMP_SCALE_FACTOR ,String.valueOf(getLayoutUpdateTemperatureScaleFactor()));
		 config.put(KEY_LAYOUT_UPDATE_COMPUTE_PERMUTATION ,String.valueOf(getLayoutUpdateComputePermutation()));
		 config.put(KEY_LAYOUT_UPDATE_IS_UPHILL_MOVE_ALLOWED,String.valueOf(getLayoutUpdateUphillMovesAllowed()));
		 config.put(KEY_LAYOUT_UPDATE_MAX_ROUNDS ,String.valueOf(getLayoutUpdateMaxRounds()));
		 config.put(KEY_LAYOUT_UPDATE_TRIES_PER_CELL ,String.valueOf(getLayoutUpdateTriesPerCell()));
		 config.put(KEY_LAYOUT_UPDATE_COST_FUNCTION_CONFIG ,String.valueOf(Integer.toBinaryString(getLayoutUpdateCostFunctionConfiguration())));
		 config.put(KEY_LAYOUT_UPDATE_LAMBDA ,getLayoutUpdateLambda());
		 config.put(KEY_LAYOUT_UPDATE_BOUNDS ,getLayoutUpdateResultBounds());
		 config.put(KEY_LAYOUT_UPDATE_METHOD ,getLayoutUpdateMethod());
		 config.put(KEY_LAYOUT_UPDATE_METHOD_NEIGHBORS_DEPTH,String.valueOf(getLayoutUpdateMethodNeighborsDepth()));
		 config.put(KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS,String.valueOf(getLayoutUpdateMethodPerimeterRadius()));
		 config.put(KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS_INCREASE,String.valueOf(getLayoutUpdateMethodPerimeterRadiusIncrease()));
		 config.put(KEY_LAYOUT_UPDATE_CLUSTERING_ENABLED, String.valueOf(getLayoutUpdateClusteringEnabled()));
		 config.put(KEY_LAYOUT_UPDATE_CLUSTERING_FACTOR, String.valueOf(getLayoutUpdateClusteringFactor()));
		 config.put(KEY_LAYOUT_UPDATE_CLUSTERING_MOVE_SCALE,String.valueOf(getLayoutUpdateClusteringMoveScaleFactor()));
		 return config;
	 }
	 protected void action_LoadPreSets(int index){
		 Properties config = preSetConfigs[index];
		 tf_initTemperature .setText((String)config.get(KEY_INIT_TEMPERATURE));
		 tf_minTemperature .setText((String)config.get(KEY_MIN_TEMPERATURE));
		 tf_minDistance .setText((String)config.get(KEY_MIN_DISTANCE));
		 tf_tempScaleFactor .setText((String)config.get(KEY_TEMP_SCALE_FACTOR));
		 tf_maxRounds .setText((String)config.get(KEY_MAX_ROUNDS));
		 tf_triesPerCell .setText((String)config.get(KEY_TRIES_PER_CELL));
		 ArrayList lambda = (ArrayList) config.get(KEY_LAMBDA);
		 tf_lambdaNodeDistribution.setText(String.valueOf(((Double)lambda.get(0)).doubleValue()));
		 tf_lambdaBorderline .setText(String.valueOf(((Double)lambda.get(1)).doubleValue()));
		 tf_lambdaEdgeLength .setText(String.valueOf(((Double)lambda.get(2)).doubleValue()));
		 tf_lambdaEdgeCrossing .setText(String.valueOf(((Double)lambda.get(3)).doubleValue()));
		 tf_lambdaEdgeDistribution.setText(String.valueOf(((Double)lambda.get(4)).doubleValue()));
		 tf_lambdaNodeDistance .setText(String.valueOf(((Double)lambda.get(5)).doubleValue()));
		 Rectangle bounds = (Rectangle) config.get(KEY_BOUNDS);
		 tf_boundsWidth.setText(String.valueOf((int)bounds.getWidth()));
		 tf_boundsHeight.setText(String.valueOf((int)bounds.getHeight()));
		 cb_computePermutation.setSelected(isTrue((String)config.get(KEY_COMPUTE_PERMUTATION)));
		 cb_uphillMovesAllowed.setSelected(isTrue((String)config.get(KEY_IS_UPHILL_MOVE_ALLOWED)));
		 int costFunctionConfig = Integer.parseInt((String)config.get(KEY_COST_FUNCTION_CONFIG),2);
		 setCostFunctionConfiguration(costFunctionConfig);
		 cb_enableLayoutUpdate.setSelected(isTrue((String)config.get(KEY_LAYOUT_UPDATE_ENABLED)));
		 tf_lu_initTemperature .setText((String)config.get(KEY_LAYOUT_UPDATE_INIT_TEMPERATURE));
		 tf_lu_minTemperature .setText((String)config.get(KEY_LAYOUT_UPDATE_MIN_TEMPERATURE));
		 tf_lu_minDistance .setText((String)config.get(KEY_LAYOUT_UPDATE_MIN_DISTANCE));
		 tf_lu_tempScaleFactor .setText((String)config.get(KEY_LAYOUT_UPDATE_TEMP_SCALE_FACTOR));
		 tf_lu_maxRounds .setText((String)config.get(KEY_LAYOUT_UPDATE_MAX_ROUNDS));
		 tf_lu_triesPerCell .setText((String)config.get(KEY_LAYOUT_UPDATE_TRIES_PER_CELL));
		 ArrayList lambdaLU = (ArrayList) config.get(KEY_LAYOUT_UPDATE_LAMBDA);
		 tf_lu_lambdaNodeDistribution.setText(String.valueOf(((Double)lambdaLU.get(0)).doubleValue()));
		 tf_lu_lambdaBorderline .setText(String.valueOf(((Double)lambdaLU.get(1)).doubleValue()));
		 tf_lu_lambdaEdgeLength .setText(String.valueOf(((Double)lambdaLU.get(2)).doubleValue()));
		 tf_lu_lambdaEdgeCrossing .setText(String.valueOf(((Double)lambdaLU.get(3)).doubleValue()));
		 tf_lu_lambdaEdgeDistribution.setText(String.valueOf(((Double)lambdaLU.get(4)).doubleValue()));
		 tf_lu_lambdaNodeDistance .setText(String.valueOf(((Double)lambdaLU.get(5)).doubleValue()));
		 Rectangle boundsLU = (Rectangle) config.get(KEY_LAYOUT_UPDATE_BOUNDS);
		 tf_lu_boundsWidth.setText(String.valueOf((int)boundsLU.getWidth()));
		 tf_lu_boundsHeight.setText(String.valueOf((int)boundsLU.getHeight()));
		 cb_lu_computePermutation.setSelected(isTrue((String)config.get(KEY_LAYOUT_UPDATE_COMPUTE_PERMUTATION)));
		 cb_lu_uphillMovesAllowed.setSelected(isTrue((String)config.get(KEY_LAYOUT_UPDATE_IS_UPHILL_MOVE_ALLOWED)));
		 int costFunctionConfigLU = Integer.parseInt((String)config.get(KEY_LAYOUT_UPDATE_COST_FUNCTION_CONFIG),2);
		 setLayoutUpdateCostFunctionConfiguration(costFunctionConfigLU);
		 tf_lu_method_neighborsDepth.setText((String)config.get(KEY_LAYOUT_UPDATE_METHOD_NEIGHBORS_DEPTH));
		 tf_lu_method_perimeterRadius.setText((String)config.get(KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS));
		 tf_lu_method_perimeterRadiusInc.setText((String)config.get(KEY_LAYOUT_UPDATE_METHOD_PERIMETER_RADIUS_INCREASE));
		 tf_lu_clustering_factor.setText((String)config.get(KEY_LAYOUT_UPDATE_CLUSTERING_FACTOR));
		 tf_lu_clustering_moveScale.setText((String)config.get(KEY_LAYOUT_UPDATE_CLUSTERING_MOVE_SCALE));
		 cb_lu_clustering_enable.setSelected(isTrue((String)config.get(KEY_LAYOUT_UPDATE_CLUSTERING_ENABLED)));
		 comb_lu_Method.setSelectedItem(config.get(KEY_LAYOUT_UPDATE_METHOD));
		 switchLayoutUpdatePanel();
		 action_CheckBoxSwitch();
	 }
	 protected boolean isTrue(String boolValue){
		 if( boolValue != null ){
			 if( ""TRUE"".equals(boolValue.toUpperCase()) ){
				 return true;
			 }
			 else if( ""FALSE"".equals(boolValue.toUpperCase()) ){
				 return false;
			 }
		 }
		 return false;
	 }
	 protected void check() {
		 boolean isOK = true;
		 ArrayList errList = new ArrayList();
		 isOK &= assertDouble(tf_initTemperature.getText(), KEY_INIT_TEMPERATURE,errList);
		 isOK &= assertDouble(tf_minTemperature.getText(), KEY_MIN_TEMPERATURE,errList);
		 isOK &= assertDouble(tf_minDistance.getText(), KEY_MIN_DISTANCE,errList);
		 isOK &= assertDouble(tf_tempScaleFactor.getText(), KEY_TEMP_SCALE_FACTOR,errList);
		 isOK &= assertInteger(tf_maxRounds.getText(), KEY_MAX_ROUNDS,errList);
		 isOK &= assertInteger(tf_triesPerCell.getText(), KEY_TRIES_PER_CELL,errList);
		 isOK &= assertDouble(tf_lambdaNodeDistribution.getText(),""Node Distribution"",errList);
		 isOK &= assertDouble(tf_lambdaBorderline.getText(), ""Borderline"",errList);
		 isOK &= assertDouble(tf_lambdaEdgeLength.getText(), ""Edgelength"",errList);
		 isOK &= assertDouble(tf_lambdaEdgeCrossing.getText(), ""Edgecrossing"",errList);
		 isOK &= assertDouble(tf_lambdaEdgeDistribution.getText(),""Node-Edge Distribution"",errList);
		 isOK &= assertDouble(tf_lambdaNodeDistance.getText(), ""Node Overlapping"",errList);
		 isOK &= assertInteger(tf_boundsWidth.getText(), ""max. width"",errList);
		 isOK &= assertInteger(tf_boundsHeight.getText(), ""max. height"",errList);
		 isOK &= assertDouble(tf_lu_initTemperature.getText(), KEY_LAYOUT_UPDATE_INIT_TEMPERATURE,errList);
		 isOK &= assertDouble(tf_lu_minTemperature.getText(), KEY_LAYOUT_UPDATE_MIN_TEMPERATURE,errList);
		 isOK &= assertDouble(tf_lu_minDistance.getText(), KEY_LAYOUT_UPDATE_MIN_DISTANCE,errList);
		 isOK &= assertDouble(tf_lu_tempScaleFactor.getText(), KEY_LAYOUT_UPDATE_TEMP_SCALE_FACTOR,errList);
		 isOK &= assertInteger(tf_lu_maxRounds.getText(), KEY_LAYOUT_UPDATE_MAX_ROUNDS,errList);
		 isOK &= assertInteger(tf_lu_triesPerCell.getText(), KEY_LAYOUT_UPDATE_TRIES_PER_CELL,errList);
		 isOK &= assertDouble(tf_lu_lambdaNodeDistribution.getText(),""Layout Update Node Distribution"",errList);
		 isOK &= assertDouble(tf_lu_lambdaBorderline.getText(), ""Layout Update Borderline"",errList);
		 isOK &= assertDouble(tf_lu_lambdaEdgeLength.getText(), ""Layout Update Edgelength"",errList);
		 isOK &= assertDouble(tf_lu_lambdaEdgeCrossing.getText(), ""Layout Update Edgecrossing"",errList);
		 isOK &= assertDouble(tf_lu_lambdaEdgeDistribution.getText(),""Layout Update Node-Edge Distribution"",errList);
		 isOK &= assertDouble(tf_lu_lambdaNodeDistance.getText(), ""Layout Update Node Overlapping"",errList);
		 isOK &= assertInteger(tf_lu_boundsWidth.getText(), ""Layout Update max. width"",errList);
		 isOK &= assertInteger(tf_lu_boundsHeight.getText(), ""Layout Update max. height"",errList);
		 isOK &= assertDouble(tf_lu_clustering_factor.getText(), KEY_LAYOUT_UPDATE_CLUSTERING_FACTOR,errList);
		 isOK &= assertDouble(tf_lu_clustering_moveScale.getText(),KEY_LAYOUT_UPDATE_CLUSTERING_MOVE_SCALE,errList);
		 if( isOK ){
			 isOK &= assertDoublePositiveSign(tf_initTemperature.getText(),false,KEY_INIT_TEMPERATURE,errList);
			 isOK &= assertDoublePositiveSign(tf_initTemperature.getText(),false,KEY_INIT_TEMPERATURE,errList);
			 isOK &= assertDoublePositiveSign(tf_minTemperature.getText(),false,KEY_MIN_TEMPERATURE,errList);
			 isOK &= assertDoublePositiveSign(tf_minDistance.getText(),false,KEY_MIN_DISTANCE,errList);
			 isOK &= assertRange(tf_tempScaleFactor.getText(),0.0,1.0,false,false,KEY_TEMP_SCALE_FACTOR,errList);
			 isOK &= assertIntegerPositiveSign(tf_maxRounds.getText(),false,KEY_MAX_ROUNDS,errList);
			 isOK &= assertRange(tf_triesPerCell.getText(),8,99,true,true,KEY_TRIES_PER_CELL,errList);
			 isOK &= assertIntegerPositiveSign(tf_boundsWidth.getText(),false,""max. width"",errList);
			 isOK &= assertIntegerPositiveSign(tf_boundsWidth.getText(),false,""max. height"",errList);
			 isOK &= assertDoublePositiveSign(tf_lambdaNodeDistribution.getText(),false,""Node Distribution"",errList);
			 isOK &= assertDoublePositiveSign(tf_lambdaBorderline.getText() ,false,""Borderline"",errList);
			 isOK &= assertDoublePositiveSign(tf_lambdaEdgeLength.getText() ,false,""Edgelength"",errList);
			 isOK &= assertDoublePositiveSign(tf_lambdaEdgeCrossing.getText() ,false,""Edgecrossing"",errList);
			 isOK &= assertDoublePositiveSign(tf_lambdaEdgeDistribution.getText(),false,""Node-Edge Distribution"",errList);
			 isOK &= assertDoublePositiveSign(tf_lambdaNodeDistance.getText() ,false,""Node Overlapping"",errList);
			 isOK &= assertDoublePositiveSign(tf_lu_initTemperature.getText(),false,KEY_LAYOUT_UPDATE_INIT_TEMPERATURE,errList);
			 isOK &= assertDoublePositiveSign(tf_lu_initTemperature.getText(),false,KEY_LAYOUT_UPDATE_INIT_TEMPERATURE,errList);
			 isOK &= assertDoublePositiveSign(tf_lu_minTemperature.getText(),false,KEY_LAYOUT_UPDATE_MIN_TEMPERATURE,errList);
			 isOK &= assertDoublePositiveSign(tf_lu_minDistance.getText(),false,KEY_LAYOUT_UPDATE_MIN_DISTANCE,errList);
			 isOK &= assertRange(tf_lu_tempScaleFactor.getText(),0.0,1.0,false,false,KEY_LAYOUT_UPDATE_TEMP_SCALE_FACTOR,errList);
			 isOK &= assertIntegerPositiveSign(tf_lu_maxRounds.getText(),false,KEY_LAYOUT_UPDATE_MAX_ROUNDS,errList);
			 isOK &= assertRange(tf_lu_triesPerCell.getText(),8,99,true,true,KEY_LAYOUT_UPDATE_TRIES_PER_CELL,errList);
			 isOK &= assertIntegerPositiveSign(tf_lu_boundsWidth.getText(),false,""Layout Update max. width"",errList);
			 isOK &= assertIntegerPositiveSign(tf_lu_boundsWidth.getText(),false,""Layout Update max. height"",errList);
			 isOK &= assertDoublePositiveSign(tf_lu_lambdaNodeDistribution.getText(),false,""Layout Update Node Distribution"",errList);
			 isOK &= assertDoublePositiveSign(tf_lu_lambdaBorderline.getText() ,false,""Layout Update Borderline"",errList);
			 isOK &= assertDoublePositiveSign(tf_lu_lambdaEdgeLength.getText() ,false,""Layout Update Edgelength"",errList);
			 isOK &= assertDoublePositiveSign(tf_lu_lambdaEdgeCrossing.getText() ,false,""Layout Update Edgecrossing"",errList);
			 isOK &= assertDoublePositiveSign(tf_lu_lambdaEdgeDistribution.getText(),false,""Layout Update Node-Edge Distribution"",errList);
			 isOK &= assertDoublePositiveSign(tf_lu_lambdaNodeDistance.getText() ,false,""Layout Update Node Overlapping"",errList);
			 isOK &= assertDoublePositiveSign(tf_lu_clustering_factor.getText(),false,KEY_LAYOUT_UPDATE_CLUSTERING_FACTOR,errList);
			 isOK &= assertRange(tf_lu_clustering_moveScale.getText(),0.0,1.0,false,true,KEY_LAYOUT_UPDATE_CLUSTERING_MOVE_SCALE,errList);
		 }
		 if (!isOK) {
			 String errorMsg = new String();
			 for( int i = 0;
			 i < errList.size();
			 i++ ){
				 errorMsg += (String)errList.get(i);
				 if( i != errList.size() - 1 ) errorMsg += ""\n"";
			 }
			 throw new IllegalArgumentException(errorMsg);
		 }
	 }
	 private void initComponents() {
		 panelSurface = new JPanel(new BorderLayout(5,10));
		 panelSurface.setBackground(new Color(205,207,215));
		 setLayout(new BorderLayout(5,10));
		tp_main = new JTabbedPane();
		 add(tp_main, BorderLayout.CENTER);
		 JPanel panelLabels = new JPanel(new GridLayout(8,1, 0,5));
		 JPanel panelFields = new JPanel(new GridLayout(8,1, 0,5));
		 JPanel panelVars = new JPanel(new BorderLayout(5,10));
		 JPanel panelLambda = new JPanel(new GridBagLayout());
		 JPanel panelButtons = new JPanel(new GridLayout(1,3,10,0));
		 JPanel panelBounds = new JPanel(new GridBagLayout());
		 JPanel panelCenter = new JPanel(new BorderLayout(5,10));
		 panelLabels .setOpaque(false);
		 panelFields .setOpaque(false);
		 panelVars .setOpaque(false);
		 panelLambda .setOpaque(false);
		 panelButtons.setOpaque(false);
		 panelBounds .setOpaque(false);
		 panelCenter .setOpaque(false);
		 add(panelButtons,BorderLayout.SOUTH);
		 panelVars.add(panelLabels,BorderLayout.WEST);
		 panelVars.add(panelFields,BorderLayout.CENTER);
		 panelCenter.add(panelLambda,BorderLayout.CENTER);
		 panelCenter.add(panelBounds,BorderLayout.SOUTH);
		 panelSurface.add(panelVars ,BorderLayout.NORTH);
		 panelSurface.add(panelCenter ,BorderLayout.WEST);
		 panelSurface.add(new JPanel(),BorderLayout.SOUTH);
		 panelLabels.add( new JLabel(""start temperature :""));
		 panelLabels.add( new JLabel(""min. temperature :""));
		 panelLabels.add( new JLabel(""min. distance :""));
		 panelLabels.add( new JLabel(""temperature scaling factor :""));
		 panelLabels.add( new JLabel(""max. rounds :""));
		 panelLabels.add( new JLabel(""tries per cell :""));
		 panelLabels.add( new JLabel(""are uphill-moves allowed :""));
		 panelLabels.add( new JLabel(""compute permutations :""));
		 tf_initTemperature = new JTextField();
		 tf_minTemperature = new JTextField();
		 tf_minDistance = new JTextField();
		 tf_tempScaleFactor = new JTextField();
		 tf_maxRounds = new JTextField();
		 tf_triesPerCell = new JTextField();
		 tf_lambdaNodeDistribution = new JTextField();
		 tf_lambdaBorderline = new JTextField();
		 tf_lambdaEdgeLength = new JTextField();
		 tf_lambdaEdgeCrossing = new JTextField();
		 tf_lambdaEdgeDistribution = new JTextField();
		 tf_lambdaNodeDistance = new JTextField();
		 cb_computePermutation = new JCheckBox();
		 cb_uphillMovesAllowed = new JCheckBox();
		 cb_useNodeDistribution = new JCheckBox();
		 cb_useBorderline = new JCheckBox();
		 cb_useEdgeLength = new JCheckBox();
		 cb_useEdgeCrossing = new JCheckBox();
		 cb_useEdgeDistribution = new JCheckBox();
		 cb_useNodeDistance = new JCheckBox();
		 cb_computePermutation .setOpaque(false);
		 cb_uphillMovesAllowed .setOpaque(false);
		 cb_useNodeDistribution.setOpaque(false);
		 cb_useBorderline .setOpaque(false);
		 cb_useEdgeLength .setOpaque(false);
		 cb_useEdgeCrossing .setOpaque(false);
		 cb_useEdgeDistribution.setOpaque(false);
		 cb_useNodeDistance .setOpaque(false);
		 registerCheckBoxAction(cb_useNodeDistribution);
		 registerCheckBoxAction(cb_useBorderline);
		 registerCheckBoxAction(cb_useEdgeLength);
		 registerCheckBoxAction(cb_useEdgeCrossing);
		 registerCheckBoxAction(cb_useEdgeDistribution);
		 registerCheckBoxAction(cb_useNodeDistance);
		 panelFields.add(tf_initTemperature);
		 panelFields.add(tf_minTemperature);
		 panelFields.add(tf_minDistance);
		 panelFields.add(tf_tempScaleFactor);
		 panelFields.add(tf_maxRounds);
		 panelFields.add(tf_triesPerCell);
		 panelFields.add(cb_computePermutation);
		 panelFields.add(cb_uphillMovesAllowed);
		 panelLambda.add(new JLabel(""Costfunction Nodedistribution :""), new GridBagConstraints(0, 0, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,0), 0,0) );
		 panelLambda.add(new JLabel(""Costfunction Borderline :""), new GridBagConstraints(0, 1, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,0), 0,0) );
		 panelLambda.add(new JLabel(""Costfunction Edgelength :""), new GridBagConstraints(0, 2, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,0), 0,0) );
		 panelLambda.add(new JLabel(""Costfunction Edgecrossing :""), new GridBagConstraints(0, 3, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,0), 0,0) );
		 panelLambda.add(new JLabel(""Costfunction Edge Distribution :""), new GridBagConstraints(0, 4, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,0), 0,0) );
		 panelLambda.add(new JLabel(""Costfunction Node Overlapping :""), new GridBagConstraints(0, 5, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,0), 0,0) );
		 panelLambda.add(cb_useNodeDistribution, new GridBagConstraints(1, 0, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 panelLambda.add(cb_useBorderline, new GridBagConstraints(1, 1, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 panelLambda.add(cb_useEdgeLength, new GridBagConstraints(1, 2, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 panelLambda.add(cb_useEdgeCrossing, new GridBagConstraints(1, 3, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 panelLambda.add(cb_useEdgeDistribution, new GridBagConstraints(1, 4, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 panelLambda.add(cb_useNodeDistance, new GridBagConstraints(1, 5, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 panelLambda.add(tf_lambdaNodeDistribution, new GridBagConstraints(2, 0, 1, 1, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 panelLambda.add(tf_lambdaBorderline, new GridBagConstraints(2, 1, 1, 1, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 panelLambda.add(tf_lambdaEdgeLength, new GridBagConstraints(2, 2, 1, 1, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 panelLambda.add(tf_lambdaEdgeCrossing, new GridBagConstraints(2, 3, 1, 1, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 panelLambda.add(tf_lambdaEdgeDistribution, new GridBagConstraints(2, 4, 1, 1, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 panelLambda.add(tf_lambdaNodeDistance, new GridBagConstraints(2, 5, 1, 1, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 JLabel[] label_AdditionalCF = getAdditionalCostFunctionLabels();
		 JTextField[] tf_AdditionalCF = getAdditionalCostFunctionTextFields();
		 JCheckBox[] cb_AdditionalCF = getAdditionalCostFunctionCheckBoxes();
		 for( int i = 0;
		 i < label_AdditionalCF.length;
		 i++ ) panelLambda.add(label_AdditionalCF[i], new GridBagConstraints(0, AnnealingLayoutAlgorithm.COUT_COSTFUNCTION + i, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,0), 0,0) );
		 for( int i = 0;
		 i < cb_AdditionalCF.length;
		 i++ ) panelLambda.add(cb_AdditionalCF[i], new GridBagConstraints(1, AnnealingLayoutAlgorithm.COUT_COSTFUNCTION + i, 1, 1, 0.5, 0.5, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 for( int i = 0;
		 i < tf_AdditionalCF.length;
		 i++ ) panelLambda.add(tf_AdditionalCF[i], new GridBagConstraints(2, AnnealingLayoutAlgorithm.COUT_COSTFUNCTION + i, 1, 1, 0.5, 0.5, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 button_takeViewportSize = new JButton(""take viewport size"");
		 button_takeViewportSize.setOpaque(false);
		 JLabel labelBoundsWidth = new JLabel(""max. width :"");
		 JLabel labelBoundsHeight = new JLabel(""max. height :"");
		 tf_boundsWidth = new JTextField();
		 tf_boundsHeight = new JTextField();
		 panelBounds.add(button_takeViewportSize, new GridBagConstraints(0, 0, 1, 2, 0.5, 1.0, GridBagConstraints.SOUTHEAST, GridBagConstraints.HORIZONTAL, new Insets(25,20,15,30), 0,0) );
		 panelBounds.add(labelBoundsWidth, new GridBagConstraints(1, 0, 1, 1, 1.0, 1.0, GridBagConstraints.SOUTH, GridBagConstraints.HORIZONTAL, new Insets(15,0,5,0), 0,0) );
		 panelBounds.add(labelBoundsHeight, new GridBagConstraints(1, 1, 1, 1, 1.0, 1.0, GridBagConstraints.NORTH, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 panelBounds.add(tf_boundsWidth, new GridBagConstraints(2, 0, 1, 1, 1.0, 1.0, GridBagConstraints.SOUTH, GridBagConstraints.HORIZONTAL, new Insets(15,0,5,0), 0,0) );
		 panelBounds.add(tf_boundsHeight, new GridBagConstraints(2, 1, 1, 1, 1.0, 1.0, GridBagConstraints.NORTH, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 panelLUSurface = new JPanel(new BorderLayout(5,10));
		 panelLUSurface.setBackground(new Color(220,205,205));
		 JPanel panelLULabels = new JPanel(new GridLayout(8,1, 0,5));
		 JPanel panelLUFields = new JPanel(new GridLayout(8,1, 0,5));
		 JPanel panelLUVars = new JPanel(new BorderLayout(5,10));
		 JPanel panelLULambda = new JPanel(new GridBagLayout());
		 JPanel panelLUBounds = new JPanel(new GridBagLayout());
		 JPanel panelLUCenter = new JPanel(new BorderLayout(5,10));
		 JPanel panelLUMethod = new JPanel(new BorderLayout(5,10));
		 panelLULabels.setOpaque(false);
		 panelLUFields.setOpaque(false);
		 panelLUVars .setOpaque(false);
		 panelLULambda.setOpaque(false);
		 panelLUBounds.setOpaque(false);
		 panelLUCenter.setOpaque(false);
		 panelLUMethod.setOpaque(false);
		 panelLUVars.add(panelLULabels,BorderLayout.WEST);
		 panelLUVars.add(panelLUFields,BorderLayout.CENTER);
		 panelLUCenter.add(panelLULambda,BorderLayout.WEST);
		 panelLUCenter.add(panelLUBounds,BorderLayout.SOUTH);
		 panelLUSurface.add(panelLUVars ,BorderLayout.NORTH);
		 panelLUSurface.add(panelLUCenter ,BorderLayout.CENTER);
		 panelLUSurface.add(panelLUMethod ,BorderLayout.SOUTH);
		 panelLULabels.add( new JLabel(""start temperature :""));
		 panelLULabels.add( new JLabel(""min. temperature :""));
		 panelLULabels.add( new JLabel(""min. distance :""));
		 panelLULabels.add( new JLabel(""temperature scaling factor :""));
		 panelLULabels.add( new JLabel(""max. rounds :""));
		 panelLULabels.add( new JLabel(""tries per cell :""));
		 panelLULabels.add( new JLabel(""are uphill-moves allowed :""));
		 panelLULabels.add( new JLabel(""compute permutations :""));
		 tf_lu_initTemperature = new JTextField();
		 tf_lu_minTemperature = new JTextField();
		 tf_lu_minDistance = new JTextField();
		 tf_lu_tempScaleFactor = new JTextField();
		 tf_lu_maxRounds = new JTextField();
		 tf_lu_triesPerCell = new JTextField();
		 tf_lu_lambdaNodeDistribution = new JTextField();
		 tf_lu_lambdaBorderline = new JTextField();
		 tf_lu_lambdaEdgeLength = new JTextField();
		 tf_lu_lambdaEdgeCrossing = new JTextField();
		 tf_lu_lambdaEdgeDistribution = new JTextField();
		 tf_lu_lambdaNodeDistance = new JTextField();
		 cb_lu_computePermutation = new JCheckBox();
		 cb_lu_uphillMovesAllowed = new JCheckBox();
		 cb_lu_useNodeDistribution = new JCheckBox();
		 cb_lu_useBorderline = new JCheckBox();
		 cb_lu_useEdgeLength = new JCheckBox();
		 cb_lu_useEdgeCrossing = new JCheckBox();
		 cb_lu_useEdgeDistribution = new JCheckBox();
		 cb_lu_useNodeDistance = new JCheckBox();
		 cb_lu_computePermutation .setOpaque(false);
		 cb_lu_uphillMovesAllowed .setOpaque(false);
		 cb_lu_useNodeDistribution.setOpaque(false);
		 cb_lu_useBorderline .setOpaque(false);
		 cb_lu_useEdgeLength .setOpaque(false);
		 cb_lu_useEdgeCrossing .setOpaque(false);
		 cb_lu_useEdgeDistribution.setOpaque(false);
		 cb_lu_useNodeDistance .setOpaque(false);
		 registerCheckBoxAction(cb_lu_useNodeDistribution);
		 registerCheckBoxAction(cb_lu_useBorderline);
		 registerCheckBoxAction(cb_lu_useEdgeLength);
		 registerCheckBoxAction(cb_lu_useEdgeCrossing);
		 registerCheckBoxAction(cb_lu_useEdgeDistribution);
		 registerCheckBoxAction(cb_lu_useNodeDistance);
		 panelLUFields.add(tf_lu_initTemperature);
		 panelLUFields.add(tf_lu_minTemperature);
		 panelLUFields.add(tf_lu_minDistance);
		 panelLUFields.add(tf_lu_tempScaleFactor);
		 panelLUFields.add(tf_lu_maxRounds);
		 panelLUFields.add(tf_lu_triesPerCell);
		 panelLUFields.add(cb_lu_computePermutation);
		 panelLUFields.add(cb_lu_uphillMovesAllowed);
		 panelLULambda.add(new JLabel(""Costfunction Nodedistribution :""), new GridBagConstraints(0, 0, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,0), 0,0) );
		 panelLULambda.add(new JLabel(""Costfunction Borderline :""), new GridBagConstraints(0, 1, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,0), 0,0) );
		 panelLULambda.add(new JLabel(""Costfunction Edgelength :""), new GridBagConstraints(0, 2, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,0), 0,0) );
		 panelLULambda.add(new JLabel(""Costfunction Edgecrossing :""), new GridBagConstraints(0, 3, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,0), 0,0) );
		 panelLULambda.add(new JLabel(""Costfunction Edge Distribution :""), new GridBagConstraints(0, 4, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,-20), 0,0) );
		 panelLULambda.add(new JLabel(""Costfunction Node Overlapping :""), new GridBagConstraints(0, 5, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,-20), 0,0) );
		 panelLULambda.add(cb_lu_useNodeDistribution, new GridBagConstraints(1, 0, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 panelLULambda.add(cb_lu_useBorderline, new GridBagConstraints(1, 1, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 panelLULambda.add(cb_lu_useEdgeLength, new GridBagConstraints(1, 2, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 panelLULambda.add(cb_lu_useEdgeCrossing, new GridBagConstraints(1, 3, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 panelLULambda.add(cb_lu_useEdgeDistribution, new GridBagConstraints(1, 4, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 panelLULambda.add(cb_lu_useNodeDistance, new GridBagConstraints(1, 5, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 panelLULambda.add(tf_lu_lambdaNodeDistribution, new GridBagConstraints(2, 0, 1, 1, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 panelLULambda.add(tf_lu_lambdaBorderline, new GridBagConstraints(2, 1, 1, 1, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 panelLULambda.add(tf_lu_lambdaEdgeLength, new GridBagConstraints(2, 2, 1, 1, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 panelLULambda.add(tf_lu_lambdaEdgeCrossing, new GridBagConstraints(2, 3, 1, 1, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 panelLULambda.add(tf_lu_lambdaEdgeDistribution, new GridBagConstraints(2, 4, 1, 1, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 panelLULambda.add(tf_lu_lambdaNodeDistance, new GridBagConstraints(2, 5, 1, 1, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 JLabel[] label_lu_AdditionalCF = getAdditionalLUCostFunctionLabels();
		 JTextField[] tf_lu_AdditionalCF = getAdditionalLUCostFunctionTextFields();
		 JCheckBox[] cb_lu_AdditionalCF = getAdditionalLUCostFunctionCheckBoxes();
		 for( int i = 0;
		 i < label_lu_AdditionalCF.length;
		 i++ ) panelLULambda.add(label_lu_AdditionalCF[i], new GridBagConstraints(0, AnnealingLayoutAlgorithm.COUT_COSTFUNCTION + i, 1, 1, 0.5, 0.5, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,0,0,0), 0,0) );
		 for( int i = 0;
		 i < cb_lu_AdditionalCF.length;
		 i++ ) panelLULambda.add(cb_lu_AdditionalCF[i], new GridBagConstraints(1, AnnealingLayoutAlgorithm.COUT_COSTFUNCTION + i, 1, 1, 0.5, 0.5, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0,20,0,0), 0,0) );
		 for( int i = 0;
		 i < tf_lu_AdditionalCF.length;
		 i++ ) panelLULambda.add(tf_lu_AdditionalCF[i], new GridBagConstraints(2, AnnealingLayoutAlgorithm.COUT_COSTFUNCTION + i, 1, 1, 0.5, 0.5, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 button_lu_takeViewportSize = new JButton(""take viewport size"");
		 button_lu_takeViewportSize.setOpaque(false);
		 JLabel labelLUBoundsWidth = new JLabel(""max. width :"");
		 JLabel labelLUBoundsHeight = new JLabel(""max. height :"");
		 tf_lu_boundsWidth = new JTextField();
		 tf_lu_boundsHeight = new JTextField();
		 panelLUBounds.add(button_lu_takeViewportSize, new GridBagConstraints(0, 0, 1, 2, 0.5, 1.0, GridBagConstraints.SOUTHEAST, GridBagConstraints.HORIZONTAL, new Insets(25,20,15,30), 0,0) );
		 panelLUBounds.add(labelLUBoundsWidth, new GridBagConstraints(1, 0, 1, 1, 1.0, 1.0, GridBagConstraints.SOUTH, GridBagConstraints.HORIZONTAL, new Insets(15,0,5,0), 0,0) );
		 panelLUBounds.add(labelLUBoundsHeight, new GridBagConstraints(1, 1, 1, 1, 1.0, 1.0, GridBagConstraints.NORTH, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 panelLUBounds.add(tf_lu_boundsWidth, new GridBagConstraints(2, 0, 1, 1, 1.0, 1.0, GridBagConstraints.SOUTH, GridBagConstraints.HORIZONTAL, new Insets(15,0,5,0), 0,0) );
		 panelLUBounds.add(tf_lu_boundsHeight, new GridBagConstraints(2, 1, 1, 1, 1.0, 1.0, GridBagConstraints.NORTH, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 tf_lu_method_neighborsDepth = new JTextField();
		 tf_lu_method_perimeterRadius = new JTextField();
		 tf_lu_method_perimeterRadiusInc = new JTextField();
		 comb_lu_Method = new JComboBox();
		 comb_lu_Method.addItem( KEY_LAYOUT_UPDATE_METHOD_NEIGHBORS_ONLY);
		 comb_lu_Method.addItem( KEY_LAYOUT_UPDATE_METHOD_PERIMETER);
		 comb_lu_Method.setBackground(panelLUSurface.getBackground());
		 comb_lu_Method.setOpaque(false);
		 comb_lu_Method.addActionListener(new ActionListener(){
			 public void actionPerformed(ActionEvent e){
				 action_CheckBoxSwitch();
			 }
		 }
		);
		 JPanel panelLUMethodLabels = new JPanel(new GridLayout(4,1,10,5));
		 JPanel panelLUMethodFields = new JPanel(new GridLayout(4,1,10,5));
		 panelLUMethodLabels.setOpaque(false);
		 panelLUMethodFields.setOpaque(false);
		 panelLUMethod.setBorder( BorderFactory.createTitledBorder( BorderFactory.createRaisedBevelBorder(), ""Layout Update Method""));
		 panelLUMethod.add(panelLUMethodLabels,BorderLayout.WEST);
		 panelLUMethod.add(panelLUMethodFields,BorderLayout.EAST);
		 panelLUMethodLabels.add(new JLabel(""Method for Layout Updates :""));
		 panelLUMethodLabels.add(new JLabel(""Edge Distance to Neighbors :""));
		 panelLUMethodLabels.add(new JLabel(""Optical Distance to Neighbors :""));
		 panelLUMethodLabels.add(new JLabel(""Increase of optical Distance :""));
		 panelLUMethodFields.add(comb_lu_Method);
		 panelLUMethodFields.add(tf_lu_method_neighborsDepth);
		 panelLUMethodFields.add(tf_lu_method_perimeterRadius);
		 panelLUMethodFields.add(tf_lu_method_perimeterRadiusInc);
		 JPanel panelLUMethodClustering = new JPanel(new GridLayout(3,2,10,5));
		 JPanel panelLUMethodClusteringSwitch = new JPanel(new GridLayout(1,2,10,5));
		 JPanel panelLUMethodClusteringEmpty = new JPanel();
		 panelLUMethodClustering.setOpaque(false);
		 panelLUMethodClusteringSwitch.setOpaque(false);
		 panelLUMethodClusteringEmpty.setOpaque(false);
		 tf_lu_clustering_factor = new JTextField();
		 cb_lu_clustering_enable = new JCheckBox();
		 tf_lu_clustering_moveScale = new JTextField();
		 cb_lu_clustering_enable.setOpaque(false);
		 registerCheckBoxAction(cb_lu_clustering_enable);
		 panelLUMethodClusteringSwitch.add(new JLabel(""on/off""));
		 panelLUMethodClusteringSwitch.add(cb_lu_clustering_enable);
		 panelLUMethodClustering.setBorder( BorderFactory.createTitledBorder( BorderFactory.createRaisedBevelBorder(), ""Clustering""));
		 panelLUMethodClustering.add(panelLUMethodClusteringSwitch);
		 panelLUMethodClustering.add(panelLUMethodClusteringEmpty);
		 panelLUMethodClustering.add(new JLabel(""Clustering factor :""));
		 panelLUMethodClustering.add(tf_lu_clustering_factor);
		 panelLUMethodClustering.add(new JLabel( ""Cluster move scale factor :""));
		 panelLUMethodClustering.add(tf_lu_clustering_moveScale);
		 panelLUMethod.add(panelLUMethodClustering,BorderLayout.SOUTH);
		 cb_enableLayoutUpdate = new JCheckBox();
		 if( !isOptimizer ){
			 JPanel panelGlobal = new JPanel(new GridBagLayout());
			 add(panelGlobal,BorderLayout.NORTH);
			 cb_enableLayoutUpdate.addActionListener(new ActionListener(){
				 public void actionPerformed(ActionEvent e ){
					 switchLayoutUpdatePanel();
				 }
			 }
			);
			 panelGlobal.add(new JLabel(""Run permanent:""), new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,5,0,30), 0,0) );
			 panelGlobal.add(cb_enableLayoutUpdate, new GridBagConstraints(1, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0), 0,0) );
		 }
		 comb_loadPreSets = new JComboBox();
		 for( int i = 0;
		 i < preSetConfigs.length;
		 i++ ) comb_loadPreSets.addItem(preSetConfigs[i].get( KEY_CONFIG_NAME));
		 panelButtons.add(comb_loadPreSets);
		 comb_loadPreSets.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e){
				 action_LoadPreSets(((JComboBox)e.getSource()). getSelectedIndex());
			 }
		 }
		);
		panelSurfaceWrapper = new JScrollPane(panelSurface);
		Dimension innerSize = new Dimension(550, 350);
		panelSurfaceWrapper .setPreferredSize(innerSize);
		panelLUSurfaceWrapper= new JScrollPane(panelLUSurface);
		panelLUSurfaceWrapper.setPreferredSize(innerSize);
		tp_main.addTab(""Values for main run"", panelSurfaceWrapper);
		 setToolTipTexts();
	 }
	 private void registerCheckBoxAction(JCheckBox cb){
		 cb.addActionListener(new ActionListener(){
			 public void actionPerformed(ActionEvent e){
				 action_CheckBoxSwitch();
			 }
		 }
		);
	 }
	 protected JLabel[] getAdditionalCostFunctionLabels(){
		 return new JLabel[0];
	 }
	 protected JCheckBox[] getAdditionalCostFunctionCheckBoxes(){
		 return new JCheckBox[0];
	 }
	 protected JTextField[] getAdditionalCostFunctionTextFields(){
		 return new JTextField[0];
	 }
	 protected JLabel[] getAdditionalLUCostFunctionLabels(){
		 return new JLabel[0];
	 }
	 protected JCheckBox[] getAdditionalLUCostFunctionCheckBoxes(){
		 return new JCheckBox[0];
	 }
	 protected JTextField[] getAdditionalLUCostFunctionTextFields(){
		 return new JTextField[0];
	 }
	 private void switchLayoutUpdatePanel(){
		if( cb_enableLayoutUpdate.isSelected() && !isOptimizer){
			tp_main.addTab(""Values for Layout updates"", panelLUSurfaceWrapper);
		}
		else {
			tp_main.remove(panelLUSurfaceWrapper);
		}
	 }
	 protected void setToolTipTexts(){
		 tf_initTemperature .setToolTipText(""starting value for temperature"");
		 tf_minTemperature .setToolTipText(""if temperature reaches this value, the algorithm finishes"");
		 tf_minDistance .setToolTipText(""minimal distance, vertices should have to each other before causing more costs"");
		 tf_tempScaleFactor .setToolTipText(""factor the temperature is multiplied every round"");
		 tf_maxRounds .setToolTipText(""maximum number of rounds, if not finished by temperature before"");
		 tf_triesPerCell .setToolTipText(""number of segments around a vertex. The vertex will be placed on each to find a new position. Costs are calculated for every segment, so don't choose your value too high"");
		 tf_lambdaNodeDistribution .setToolTipText(""Factor, the costs of the node distribution function are multiplied. Low distances between Vertices make heigher costs"");
		 tf_lambdaBorderline .setToolTipText(""Factor, the costs of the borderline function are multiplied. Border can be configured with \""max. width\"" and \""max. height\"" below. Vertices near or beyond cause higher costs"");
		 tf_lambdaEdgeLength .setToolTipText(""Factor, the costs of the edge length function are multiplied. Long edges cause higher costs"");
		 tf_lambdaEdgeCrossing .setToolTipText(""Factor, the costs of the edge crossing function are multiplied. For every crossing Edge the costs increase"");
		 tf_lambdaEdgeDistribution .setToolTipText(""Factor, the costs of the edge distribution function are multiplied. This function evaluates the distances between edges and vertices. A low distance increases the costs"");
		 tf_lambdaNodeDistance .setToolTipText(""Factor, the costs of the node distance function are multiplied. Nodes to close to each other or overlapping increases the costs"");
		 tf_boundsWidth .setToolTipText(""width of the field the graph should be layouted on"");
		 tf_boundsHeight .setToolTipText(""height of the field the graph should be layouted on"");
		 cb_computePermutation .setToolTipText(""define if the vertices are computed every round with the same order or a random order (permutation)"");
		 cb_uphillMovesAllowed .setToolTipText(""defines if moves of vertices are allowed, which increases the costs slightly"");
		 cb_useNodeDistribution .setToolTipText(""switches the costfunction for node distribution on/off"");
		 cb_useBorderline .setToolTipText(""switches the costfunction for borderline on/off"");
		 cb_useEdgeLength .setToolTipText(""switches the costfunction for edge length on/off"");
		 cb_useEdgeCrossing .setToolTipText(""switches the costfunction for edge crossings on/off"");
		 cb_useEdgeDistribution .setToolTipText(""switches the costfunction for edge distribution on/off"");
		 cb_useNodeDistance .setToolTipText(""switches the costfunction for node distance on/off"");
		 button_takeViewportSize .setToolTipText(""takes the size of the viewport for the graph (FEATURE NOT IMPLEMENTED YET!!!)"");
		 cb_enableLayoutUpdate .setToolTipText(""enables the algorithm to run, when vertices are removed/added"");
		 tf_lu_initTemperature .setToolTipText(tf_initTemperature.getToolTipText());
		 tf_lu_minTemperature .setToolTipText(tf_minTemperature.getToolTipText());
		 tf_lu_minDistance .setToolTipText(tf_minDistance.getToolTipText());
		 tf_lu_tempScaleFactor .setToolTipText(tf_tempScaleFactor.getToolTipText());
		 tf_lu_maxRounds .setToolTipText(tf_maxRounds.getToolTipText());
		 tf_lu_triesPerCell .setToolTipText(tf_triesPerCell.getToolTipText());
		 tf_lu_lambdaNodeDistribution .setToolTipText(tf_lambdaNodeDistribution.getToolTipText());
		 tf_lu_lambdaBorderline .setToolTipText(tf_lambdaBorderline.getToolTipText());
		 tf_lu_lambdaEdgeLength .setToolTipText(tf_lambdaEdgeLength.getToolTipText());
		 tf_lu_lambdaEdgeCrossing .setToolTipText(tf_lambdaEdgeCrossing.getToolTipText());
		 tf_lu_lambdaEdgeDistribution .setToolTipText(tf_lambdaEdgeDistribution.getToolTipText());
		 tf_lu_lambdaNodeDistance .setToolTipText(tf_lambdaNodeDistance.getToolTipText());
		 tf_lu_boundsWidth .setToolTipText(tf_boundsWidth.getToolTipText());
		 tf_lu_boundsHeight .setToolTipText(tf_boundsHeight.getToolTipText());
		 tf_lu_method_neighborsDepth .setToolTipText("""");
		 tf_lu_method_perimeterRadius .setToolTipText("""");
		 tf_lu_method_perimeterRadiusInc.setToolTipText("""");
		 cb_lu_computePermutation .setToolTipText(cb_computePermutation.getToolTipText());
		 cb_lu_uphillMovesAllowed .setToolTipText(cb_uphillMovesAllowed.getToolTipText());
		 cb_lu_useNodeDistribution .setToolTipText(cb_useNodeDistribution.getToolTipText());
		 cb_lu_useBorderline .setToolTipText(cb_useBorderline.getToolTipText());
		 cb_lu_useEdgeLength .setToolTipText(cb_useEdgeLength.getToolTipText());
		 cb_lu_useEdgeCrossing .setToolTipText(cb_useEdgeCrossing.getToolTipText());
		 cb_lu_useEdgeDistribution .setToolTipText(cb_useEdgeDistribution.getToolTipText());
		 cb_lu_useNodeDistance .setToolTipText(cb_useNodeDistance.getToolTipText());
		 button_lu_takeViewportSize .setToolTipText(button_takeViewportSize.getToolTipText());
		 comb_lu_Method .setToolTipText(""choose a method for Layout Updating. This method determines, which of the Neighbors around the inserted Vertices are also new layouted in order to make place for the Layout of the inserted Vertices."");
		 tf_lu_method_neighborsDepth .setToolTipText(""Neighbors are once again layouted if their distance to the inserted vertices is lower or equal this value"");
		 tf_lu_method_perimeterRadius .setToolTipText(""Neighbors within this radius around the initial position of inserted vertices are once again layouted in order to make place for the Layout of the inserted Vertices"");
		 tf_lu_method_perimeterRadiusInc.setToolTipText(""If more than one Vertice is inserted and has the same initial Position as another the perimeter radius is increase by this value"");
		 tf_lu_clustering_factor .setToolTipText(""Factor the creation of clusters. A lower value leads to more clusters, with smaller size, a higher value to fewer, bigger clusters"");
		 tf_lu_clustering_moveScale .setToolTipText(""Scales the movement of clusters. Possible values are between 0.0 and 1.0. A small value ensures, that clusters move slow and over short distances."");
	 }
	 protected void action_CheckBoxSwitch(){
		 tf_lambdaNodeDistribution.setEnabled(cb_useNodeDistribution.isSelected());
		 tf_lambdaBorderline .setEnabled(cb_useBorderline .isSelected());
		 button_takeViewportSize .setEnabled(cb_useBorderline .isSelected());
		 tf_boundsWidth .setEnabled(cb_useBorderline .isSelected());
		 tf_boundsHeight .setEnabled(cb_useBorderline .isSelected());
		 tf_lambdaEdgeLength .setEnabled(cb_useEdgeLength .isSelected());
		 tf_lambdaEdgeCrossing .setEnabled(cb_useEdgeCrossing .isSelected());
		 tf_lambdaEdgeDistribution.setEnabled(cb_useEdgeDistribution.isSelected());
		 tf_lambdaNodeDistance .setEnabled(cb_useNodeDistance .isSelected());
		 tf_lu_lambdaNodeDistribution.setEnabled(cb_lu_useNodeDistribution.isSelected());
		 tf_lu_lambdaBorderline .setEnabled(cb_lu_useBorderline .isSelected());
		 button_lu_takeViewportSize .setEnabled(cb_lu_useBorderline .isSelected());
		 tf_lu_boundsWidth .setEnabled(cb_lu_useBorderline .isSelected());
		 tf_lu_boundsHeight .setEnabled(cb_lu_useBorderline .isSelected());
		 tf_lu_lambdaEdgeLength .setEnabled(cb_lu_useEdgeLength .isSelected());
		 tf_lu_lambdaEdgeCrossing .setEnabled(cb_lu_useEdgeCrossing .isSelected());
		 tf_lu_lambdaEdgeDistribution.setEnabled(cb_lu_useEdgeDistribution.isSelected());
		 tf_lu_lambdaNodeDistance .setEnabled(cb_lu_useNodeDistance .isSelected());
		 tf_lu_clustering_factor.setEnabled(cb_lu_clustering_enable.isSelected());
		 tf_lu_clustering_moveScale.setEnabled(cb_lu_clustering_enable.isSelected());
		 String selectedLUMethod = (String) comb_lu_Method.getSelectedItem();
		 if( KEY_LAYOUT_UPDATE_METHOD_NEIGHBORS_ONLY. equals(selectedLUMethod) ){
			 tf_lu_method_neighborsDepth.setEnabled(true);
			 tf_lu_method_perimeterRadius.setEnabled(false);
			 tf_lu_method_perimeterRadiusInc.setEnabled(false);
		 }
		 else if( KEY_LAYOUT_UPDATE_METHOD_PERIMETER. equals(selectedLUMethod) ){
			 tf_lu_method_neighborsDepth.setEnabled(true);
			 tf_lu_method_perimeterRadius.setEnabled(true);
			 tf_lu_method_perimeterRadiusInc.setEnabled(true);
		 }
	 }
	 protected boolean assertDouble(String text, String name, ArrayList errList){
		 String errMsg = name+"" is NOT a double value!"";
		 try {
			 Double.parseDouble(text);
		 }
		 catch( NumberFormatException e ){
			 errList.add(errMsg);
			 return false;
		 }
		 return true;
	 }
	 protected boolean assertInteger(String text, String name, ArrayList errList){
		 String errMsg = name+"" is NOT a integer value!"";
		 try {
			 Integer.parseInt(text);
		 }
		 catch( NumberFormatException e ){
			 errList.add(errMsg);
			 return false;
		 }
		 return true;
	 }
	 protected boolean assertRange(String value, double minValue, double maxValue, boolean includeMinVal, boolean includeMaxVal, String name, ArrayList errList){
		 double val = Double.parseDouble(value);
		 boolean isOK = true;
		 if( includeMinVal ){
			 isOK &= val >= minValue;
		 }
		 else {
			 isOK &= val > minValue;
		 }
		 if( isOK ){
			 if( includeMaxVal ){
				 isOK &= val <= maxValue;
			 }
			 else {
				 isOK &= val < maxValue;
			 }
		 }
		 if( isOK ) {
			 return true;
		 }
		 else {
			 String errMsg = name+"" is out the interval "";
			 errMsg += includeMinVal ? ""["" : ""]"";
			 errMsg += minValue+"";
			""+maxValue;
			 errMsg += includeMaxVal ? ""]"" : ""["";
			 errList.add(errMsg);
			 return false;
		 }
	 }
	 protected boolean assertRange(String value, int minValue, int maxValue, boolean includeMinVal, boolean includeMaxVal, String name, ArrayList errList){
		 double val = Integer.parseInt(value);
		 boolean isOK = true;
		 if( includeMinVal ){
			 isOK &= val >= minValue;
		 }
		 else {
			 isOK &= val > minValue;
		 }
		 if( isOK ){
			 if( includeMaxVal ){
				 isOK &= val <= maxValue;
			 }
			 else {
				 isOK &= val < maxValue;
			 }
		 }
		 if( isOK ) {
			 return true;
		 }
		 else {
			 String errMsg = name+"" is out the interval "";
			 errMsg += includeMinVal ? ""["" : ""]"";
			 errMsg += minValue+"";
			""+maxValue;
			 errMsg += includeMaxVal ? ""]"" : ""["";
			 errList.add(errMsg);
			 return false;
		 }
	 }
	 protected boolean assertDoublePositiveSign(String value, boolean includeZero, String name, ArrayList errList){
		 double val = Double.parseDouble(value);
		 boolean isOK = true;
		 if( includeZero ){
			 isOK = val >= 0.0;
		 }
		 else {
			 isOK = val > 0.0;
		 }
		 if( !isOK ){
			 String errMsg = name;
			 if( includeZero ){
				 errMsg += "" has to be equal or bigger than 0.0"";
			 }
			 else {
				 errMsg += "" has to be bigger than 0.0"";
			 }
			 errList.add(errMsg);
			 return false;
		 }
		 return isOK;
	 }
	 protected boolean assertIntegerPositiveSign(String value, boolean includeZero, String name, ArrayList errList){
		 int val = Integer.parseInt(value);
		 boolean isOK = true;
		 if( includeZero ){
			 isOK = val >= 0;
		 }
		 else {
			 isOK = val > 0;
		 }
		 if( !isOK ){
			 String errMsg = name;
			 if( includeZero ){
				 errMsg += "" has to be equal or bigger than 0"";
			 }
			 else {
				 errMsg += "" has to be bigger than 0"";
			 }
			 errList.add(errList);
			 return false;
		 }
		 return isOK;
	 }
	 public double getInitTemperature(){
		 return Double.parseDouble(tf_initTemperature.getText());
	 }
	 public void setInitTemperature(double temperature){
		 tf_initTemperature.setText(String.valueOf(temperature));
	 }
	 public double getMinTemperature(){
		 return Double.parseDouble(tf_minTemperature.getText());
	 }
	 public void setMinTemperature(double temperature){
		 tf_minTemperature.setText(String.valueOf(temperature));
	 }
	 public double getMinDistance(){
		 return Double.parseDouble(tf_minDistance.getText());
	 }
	 public void setMinDistance(double distance){
		 tf_minDistance.setText(String.valueOf(distance));
	 }
	 public double getTemperatureScaleFactor(){
		 return Double.parseDouble(tf_tempScaleFactor.getText());
	 }
	 public void setTemperatureScaleFactor(double factor){
		 tf_tempScaleFactor.setText(String.valueOf(factor));
	 }
	 public int getMaxRounds(){
		 return Integer.parseInt(tf_maxRounds.getText());
	 }
	 public void setMaxRounds(int n){
		 tf_maxRounds.setText(String.valueOf(n));
	 }
	 public int getTriesPerCell(){
		 return Integer.parseInt(tf_triesPerCell.getText());
	 }
	 public void setTriesPerCell(int tries){
		 tf_triesPerCell.setText(String.valueOf(tries));
	 }
	 public int getCostFunctionConfiguration(){
		 int config = 0;
		 if( cb_useNodeDistance.isSelected() ){
			 config |= 32;
		 }
		 if( cb_useNodeDistribution.isSelected() ){
			 config |= 16;
		 }
		 if( cb_useBorderline.isSelected() ){
			 config |= 8;
		 }
		 if( cb_useEdgeLength.isSelected() ){
			 config |= 4;
		 }
		 if( cb_useEdgeCrossing.isSelected() ){
			 config |= 2;
		 }
		 if( cb_useEdgeDistribution.isSelected() ){
			 config |= 1;
		 }
		 config |= getAdditionalCostFunctionConfiguration();
		 return config;
	 }
	 protected int getAdditionalCostFunctionConfiguration(){
		 return 0;
	 }
	 public void setCostFunctionConfiguration(int config){
		 cb_useNodeDistance .setSelected((config & 32) != 0 );
		 cb_useNodeDistribution.setSelected((config & 16) != 0 );
		 cb_useBorderline .setSelected((config & 8) != 0 );
		 cb_useEdgeLength .setSelected((config & 4) != 0 );
		 cb_useEdgeCrossing .setSelected((config & 2) != 0 );
		 cb_useEdgeDistribution.setSelected((config & 1) != 0 );
	 }
	 public ArrayList getLambda(){
		 ArrayList lambda = new ArrayList();
		 lambda.add(new Double(tf_lambdaNodeDistribution.getText()));
		 lambda.add(new Double(tf_lambdaBorderline.getText()));
		 lambda.add(new Double(tf_lambdaEdgeLength.getText()));
		 lambda.add(new Double(tf_lambdaEdgeCrossing.getText()));
		 lambda.add(new Double(tf_lambdaEdgeDistribution.getText()));
		 lambda.add(new Double(tf_lambdaNodeDistance.getText()));
		 lambda = getAdditionalLambda(lambda);
		 return lambda;
	 }
	 protected ArrayList getAdditionalLambda(ArrayList lambda){
		 return lambda;
	 }
	 public void setLambda(ArrayList lambda){
		 tf_lambdaNodeDistribution.setText(String.valueOf(((Double)lambda.get(0)).doubleValue()));
		 tf_lambdaBorderline .setText(String.valueOf(((Double)lambda.get(1)).doubleValue()));
		 tf_lambdaEdgeLength .setText(String.valueOf(((Double)lambda.get(2)).doubleValue()));
		 tf_lambdaEdgeCrossing .setText(String.valueOf(((Double)lambda.get(3)).doubleValue()));
		 tf_lambdaEdgeDistribution.setText(String.valueOf(((Double)lambda.get(4)).doubleValue()));
		 tf_lambdaNodeDistance .setText(String.valueOf(((Double)lambda.get(5)).doubleValue()));
	 }
	 public boolean getUphillMovesAllowed(){
		 return cb_uphillMovesAllowed.isSelected();
	 }
	 public void setUphillMovesAllowed(boolean allow){
		 cb_uphillMovesAllowed.setSelected(allow);
	 }
	 public boolean getComputePermutation(){
		 return cb_computePermutation.isSelected();
	 }
	 public void setComputePermutation(boolean isSelected){
		 cb_computePermutation.setSelected(isSelected);
	 }
	 public Rectangle getResultBounds(){
		 int x = 0;
		 int y = 0;
		 int w = Integer.parseInt(tf_boundsWidth.getText());
		 int h = Integer.parseInt(tf_boundsHeight.getText());
		 return new Rectangle(x,y,w,h);
	 }
	 public void setResultBounds(Rectangle r){
		 tf_boundsWidth.setText(String.valueOf((int)r.getWidth()));
		 tf_boundsHeight.setText(String.valueOf((int)r.getHeight()));
	 }
	 public double getLayoutUpdateInitTemperature(){
		 return Double.parseDouble(tf_lu_initTemperature.getText());
	 }
	 public void setLayoutUpdateInitTemperature(double temperature){
		 tf_lu_initTemperature.setText(String.valueOf(temperature));
	 }
	 public double getLayoutUpdateMinTemperature(){
		 return Double.parseDouble(tf_lu_minTemperature.getText());
	 }
	 public void setLayoutUpdateMinTemperature(double temperature){
		 tf_lu_minTemperature.setText(String.valueOf(temperature));
	 }
	 public double getLayoutUpdateMinDistance(){
		 return Double.parseDouble(tf_lu_minDistance.getText());
	 }
	 public void setLayoutUpdateMinDistance(double distance){
		 tf_lu_minDistance.setText(String.valueOf(distance));
	 }
	 public double getLayoutUpdateTemperatureScaleFactor(){
		 return Double.parseDouble(tf_lu_tempScaleFactor.getText());
	 }
	 public void setLayoutUpdateTemperatureScaleFactor(double factor){
		 tf_lu_tempScaleFactor.setText(String.valueOf(factor));
	 }
	 public int getLayoutUpdateMaxRounds(){
		 return Integer.parseInt(tf_lu_maxRounds.getText());
	 }
	 public void setLayoutUpdateMaxRounds(int n){
		 tf_lu_maxRounds.setText(String.valueOf(n));
	 }
	 public void setLayoutUpdateTriesPerCell(int tries){
		 tf_lu_triesPerCell.setText(String.valueOf(tries));
	 }
	 public int getLayoutUpdateTriesPerCell(){
		 return Integer.parseInt(tf_lu_triesPerCell.getText());
	 }
	 public int getLayoutUpdateCostFunctionConfiguration(){
		 int config = 0;
		 if( cb_lu_useNodeDistance.isSelected() ){
			 config |= 32;
		 }
		 if( cb_lu_useNodeDistribution.isSelected() ){
			 config |= 16;
		 }
		 if( cb_lu_useBorderline.isSelected() ){
			 config |= 8;
		 }
		 if( cb_lu_useEdgeLength.isSelected() ){
			 config |= 4;
		 }
		 if( cb_lu_useEdgeCrossing.isSelected() ){
			 config |= 2;
		 }
		 if( cb_lu_useEdgeDistribution.isSelected() ){
			 config |= 1;
		 }
		 config |= getLayoutUpdateAdditionalCostFunctionConfiguration();
		 return config;
	 }
	 protected int getLayoutUpdateAdditionalCostFunctionConfiguration(){
		 return 0;
	 }
	 public void setLayoutUpdateCostFunctionConfiguration(int config){
		 cb_lu_useNodeDistance .setSelected((config & 32) != 0 );
		 cb_lu_useNodeDistribution.setSelected((config & 16) != 0 );
		 cb_lu_useBorderline .setSelected((config & 8) != 0 );
		 cb_lu_useEdgeLength .setSelected((config & 4) != 0 );
		 cb_lu_useEdgeCrossing .setSelected((config & 2) != 0 );
		 cb_lu_useEdgeDistribution.setSelected((config & 1) != 0 );
	 }
	 public ArrayList getLayoutUpdateLambda(){
		 ArrayList lambda = new ArrayList();
		 lambda.add(new Double(tf_lu_lambdaNodeDistribution.getText()));
		 lambda.add(new Double(tf_lu_lambdaBorderline.getText()));
		 lambda.add(new Double(tf_lu_lambdaEdgeLength.getText()));
		 lambda.add(new Double(tf_lu_lambdaEdgeCrossing.getText()));
		 lambda.add(new Double(tf_lu_lambdaEdgeDistribution.getText()));
		 lambda.add(new Double(tf_lu_lambdaNodeDistance.getText()));
		 lambda = getLayoutUpdateAdditionalLambda(lambda);
		 return lambda;
	 }
	 protected ArrayList getLayoutUpdateAdditionalLambda(ArrayList lambda){
		 return lambda;
	 }
	 public void setLayoutUpdateLambda(ArrayList lambda){
		 tf_lu_lambdaNodeDistribution.setText(String.valueOf(((Double)lambda.get(0)).doubleValue()));
		 tf_lu_lambdaBorderline .setText(String.valueOf(((Double)lambda.get(1)).doubleValue()));
		 tf_lu_lambdaEdgeLength .setText(String.valueOf(((Double)lambda.get(2)).doubleValue()));
		 tf_lu_lambdaEdgeCrossing .setText(String.valueOf(((Double)lambda.get(3)).doubleValue()));
		 tf_lu_lambdaEdgeDistribution.setText(String.valueOf(((Double)lambda.get(4)).doubleValue()));
		 tf_lu_lambdaNodeDistance .setText(String.valueOf(((Double)lambda.get(5)).doubleValue()));
	 }
	 public boolean getLayoutUpdateUphillMovesAllowed(){
		 return cb_lu_uphillMovesAllowed.isSelected();
	 }
	 public void setLayoutUpdateUphillMovesAllowed(boolean allow){
		 cb_lu_uphillMovesAllowed.setSelected(allow);
	 }
	 public boolean getLayoutUpdateComputePermutation(){
		 return cb_lu_computePermutation.isSelected();
	 }
	 public void setLayoutUpdateComputePermutation(boolean isSelected){
		 cb_lu_computePermutation.setSelected(isSelected);
	 }
	 public Rectangle getLayoutUpdateResultBounds(){
		 int x = 0;
		 int y = 0;
		 int w = Integer.parseInt(tf_lu_boundsWidth.getText());
		 int h = Integer.parseInt(tf_lu_boundsHeight.getText());
		 return new Rectangle(x,y,w,h);
	 }
	 public void setLayoutUpdateResultBounds(Rectangle r){
		 tf_lu_boundsWidth.setText(String.valueOf((int)r.getWidth()));
		 tf_lu_boundsHeight.setText(String.valueOf((int)r.getHeight()));
	 }
	 public void setLayoutUpdateEnabled(boolean enable){
		 cb_enableLayoutUpdate.setSelected(enable);
		 switchLayoutUpdatePanel();
	 }
	 public boolean getLayoutUpdateEnabled(){
		 return cb_enableLayoutUpdate.isSelected();
	 }
	 public void setLayoutUpdateMethod(String method){
		 comb_lu_Method.setSelectedItem(method);
	 }
	 public String getLayoutUpdateMethod(){
		 return (String) comb_lu_Method.getSelectedItem();
	 }
	 public void setLayoutUpdateMethodNeighborsDepth(int depth){
		 tf_lu_method_neighborsDepth.setText(String.valueOf(depth));
	 }
	 public int getLayoutUpdateMethodNeighborsDepth(){
		 return Integer.parseInt(tf_lu_method_neighborsDepth.getText());
	 }
	 public void setLayoutUpdateMethodPerimeterRadius(double radius){
		 tf_lu_method_perimeterRadius.setText(String.valueOf(radius));
	 }
	 public double getLayoutUpdateMethodPerimeterRadius(){
		 return Double.parseDouble(tf_lu_method_perimeterRadius.getText());
	 }
	 public void setLayoutUpdateMethodPerimeterRadiusIncrease(double radiusInc){
		 tf_lu_method_perimeterRadiusInc.setText(String.valueOf(radiusInc));
	 }
	 public double getLayoutUpdateMethodPerimeterRadiusIncrease(){
		 return Double.parseDouble(tf_lu_method_perimeterRadiusInc.getText());
	 }
	 public void setLayoutUpdateClusteringEnabled(boolean enable){
		 cb_lu_clustering_enable.setSelected(enable);
	 }
	 public boolean getLayoutUpdateClusteringEnabled(){
		 return cb_lu_clustering_enable.isSelected();
	 }
	 public void setLayoutUpdateClusteringFactor(double factor){
		 tf_lu_clustering_factor.setText(String.valueOf(factor));
	 }
	 public double getLayoutUpdateClusteringFactor(){
		 return Double.parseDouble(tf_lu_clustering_factor.getText());
	 }
	 public void setLayoutUpdateClusteringMoveScaleFactor(double factor){
		 tf_lu_clustering_moveScale.setText(String.valueOf(factor));
	 }
	 public double getLayoutUpdateClusteringMoveScaleFactor(){
		 return Double.parseDouble(tf_lu_clustering_moveScale.getText());
	 }
}",1,0,0,0
"public class Node{
	 public static final int FUNCTION_PROP = 1, LOCAL_PROP = 2, LOCAL_BLOCK_PROP = 3, REGEXP_PROP = 4, CASEARRAY_PROP = 5, TARGETBLOCK_PROP = 6, VARIABLE_PROP = 7, ISNUMBER_PROP = 8, DIRECTCALL_PROP = 9, SPECIALCALL_PROP = 10, SKIP_INDEXES_PROP = 11, OBJECT_IDS_PROP = 12, INCRDECR_PROP = 13, CATCH_SCOPE_PROP = 14, LABEL_ID_PROP = 15, MEMBER_TYPE_PROP = 16, NAME_PROP = 17, LAST_PROP = 17;
	 public static final int BOTH = 0, LEFT = 1, RIGHT = 2;
	 public static final int NON_SPECIALCALL = 0, SPECIALCALL_EVAL = 1, SPECIALCALL_WITH = 2;
	 public static final int DECR_FLAG = 0x1, POST_FLAG = 0x2;
	 public static final int PROPERTY_FLAG = 0x1, ATTRIBUTE_FLAG = 0x2, DESCENDANTS_FLAG = 0x4;
	 private static class NumberNode extends Node {
		 NumberNode(double number) {
			 super(Token.NUMBER);
			 this.number = number;
		 }
		 double number;
	 }
	 private static class StringNode extends Node {
		 StringNode(int type, String str) {
			 super(type);
			 this.str = str;
		 }
		 String str;
	 }
	 public static class Jump extends Node {
		 public Jump(int type) {
			 super(type);
		 }
		 Jump(int type, int lineno) {
			 super(type, lineno);
		 }
		 Jump(int type, Node child) {
			 super(type, child);
		 }
		 Jump(int type, Node child, int lineno) {
			 super(type, child, lineno);
		 }
		 public final Jump getJumpStatement() {
			 if (!(type == Token.BREAK || type == Token.CONTINUE)) Kit.codeBug();
			 return jumpNode;
		 }
		 public final void setJumpStatement(Jump jumpStatement) {
			 if (!(type == Token.BREAK || type == Token.CONTINUE)) Kit.codeBug();
			 if (jumpStatement == null) Kit.codeBug();
			 if (this.jumpNode != null) Kit.codeBug();
			 this.jumpNode = jumpStatement;
		 }
		 public final Node getDefault() {
			 if (!(type == Token.SWITCH)) Kit.codeBug();
			 return target2;
		 }
		 public final void setDefault(Node defaultTarget) {
			 if (!(type == Token.SWITCH)) Kit.codeBug();
			 if (defaultTarget.type != Token.TARGET) Kit.codeBug();
			 if (target2 != null) Kit.codeBug();
			 target2 = defaultTarget;
		 }
		 public final Node getFinally() {
			 if (!(type == Token.TRY)) Kit.codeBug();
			 return target2;
		 }
		 public final void setFinally(Node finallyTarget) {
			 if (!(type == Token.TRY)) Kit.codeBug();
			 if (finallyTarget.type != Token.TARGET) Kit.codeBug();
			 if (target2 != null) Kit.codeBug();
			 target2 = finallyTarget;
		 }
		 public final Jump getLoop() {
			 if (!(type == Token.LABEL)) Kit.codeBug();
			 return jumpNode;
		 }
		 public final void setLoop(Jump loop) {
			 if (!(type == Token.LABEL)) Kit.codeBug();
			 if (loop == null) Kit.codeBug();
			 if (jumpNode != null) Kit.codeBug();
			 jumpNode = loop;
		 }
		 public final Node getContinue() {
			 if (type != Token.LOOP) Kit.codeBug();
			 return target2;
		 }
		 public final void setContinue(Node continueTarget) {
			 if (type != Token.LOOP) Kit.codeBug();
			 if (continueTarget.type != Token.TARGET) Kit.codeBug();
			 if (target2 != null) Kit.codeBug();
			 target2 = continueTarget;
		 }
		 public Node target;
		 private Node target2;
		 private Jump jumpNode;
	 }
	 private static class PropListItem {
		 PropListItem next;
		 int type;
		 int intValue;
		 Object objectValue;
	 }
	 public Node(int nodeType) {
		 type = nodeType;
	 }
	 public Node(int nodeType, Node child) {
		 type = nodeType;
		 first = last = child;
		 child.next = null;
	 }
	 public Node(int nodeType, Node left, Node right) {
		 type = nodeType;
		 first = left;
		 last = right;
		 left.next = right;
		 right.next = null;
	 }
	 public Node(int nodeType, Node left, Node mid, Node right) {
		 type = nodeType;
		 first = left;
		 last = right;
		 left.next = mid;
		 mid.next = right;
		 right.next = null;
	 }
	 public Node(int nodeType, int line) {
		 type = nodeType;
		 lineno = line;
	 }
	 public Node(int nodeType, Node child, int line) {
		 this(nodeType, child);
		 lineno = line;
	 }
	 public Node(int nodeType, Node left, Node right, int line) {
		 this(nodeType, left, right);
		 lineno = line;
	 }
	 public Node(int nodeType, Node left, Node mid, Node right, int line) {
		 this(nodeType, left, mid, right);
		 lineno = line;
	 }
	 public static Node newNumber(double number) {
		 return new NumberNode(number);
	 }
	 public static Node newString(String str) {
		 return new StringNode(Token.STRING, str);
	 }
	 public static Node newString(int type, String str) {
		 return new StringNode(type, str);
	 }
	 public int getType() {
		 return type;
	 }
	 public void setType(int type) {
		 this.type = type;
	 }
	 public boolean hasChildren() {
		 return first != null;
	 }
	 public Node getFirstChild() {
		 return first;
	 }
	 public Node getLastChild() {
		 return last;
	 }
	 public Node getNext() {
		 return next;
	 }
	 public Node getChildBefore(Node child) {
		 if (child == first) return null;
		 Node n = first;
		 while (n.next != child) {
			 n = n.next;
			 if (n == null) throw new RuntimeException(""node is not a child"");
		 }
		 return n;
	 }
	 public Node getLastSibling() {
		 Node n = this;
		 while (n.next != null) {
			 n = n.next;
		 }
		 return n;
	 }
	 public void addChildToFront(Node child) {
		 child.next = first;
		 first = child;
		 if (last == null) {
			 last = child;
		 }
	 }
	 public void addChildToBack(Node child) {
		 child.next = null;
		 if (last == null) {
			 first = last = child;
			 return;
		 }
		 last.next = child;
		 last = child;
	 }
	 public void addChildrenToFront(Node children) {
		 Node lastSib = children.getLastSibling();
		 lastSib.next = first;
		 first = children;
		 if (last == null) {
			 last = lastSib;
		 }
	 }
	 public void addChildrenToBack(Node children) {
		 if (last != null) {
			 last.next = children;
		 }
		 last = children.getLastSibling();
		 if (first == null) {
			 first = children;
		 }
	 }
	 public void addChildBefore(Node newChild, Node node) {
		 if (newChild.next != null) throw new RuntimeException( ""newChild had siblings in addChildBefore"");
		 if (first == node) {
			 newChild.next = first;
			 first = newChild;
			 return;
		 }
		 Node prev = getChildBefore(node);
		 addChildAfter(newChild, prev);
	 }
	 public void addChildAfter(Node newChild, Node node) {
		 if (newChild.next != null) throw new RuntimeException( ""newChild had siblings in addChildAfter"");
		 newChild.next = node.next;
		 node.next = newChild;
		 if (last == node) last = newChild;
	 }
	 public void removeChild(Node child) {
		 Node prev = getChildBefore(child);
		 if (prev == null) first = first.next;
		 else prev.next = child.next;
		 if (child == last) last = prev;
		 child.next = null;
	 }
	 public void replaceChild(Node child, Node newChild) {
		 newChild.next = child.next;
		 if (child == first) {
			 first = newChild;
		 }
		 else {
			 Node prev = getChildBefore(child);
			 prev.next = newChild;
		 }
		 if (child == last) last = newChild;
		 child.next = null;
	 }
	 public void replaceChildAfter(Node prevChild, Node newChild) {
		 Node child = prevChild.next;
		 newChild.next = child.next;
		 prevChild.next = newChild;
		 if (child == last) last = newChild;
		 child.next = null;
	 }
	 private static final String propToString(int propType) {
		 if (Token.printTrees) {
			 switch (propType) {
				 case FUNCTION_PROP: return ""function"";
				 case LOCAL_PROP: return ""local"";
				 case LOCAL_BLOCK_PROP: return ""local_block"";
				 case REGEXP_PROP: return ""regexp"";
				 case CASEARRAY_PROP: return ""casearray"";
				 case TARGETBLOCK_PROP: return ""targetblock"";
				 case VARIABLE_PROP: return ""variable"";
				 case ISNUMBER_PROP: return ""isnumber"";
				 case DIRECTCALL_PROP: return ""directcall"";
				 case SPECIALCALL_PROP: return ""specialcall"";
				 case SKIP_INDEXES_PROP: return ""skip_indexes"";
				 case OBJECT_IDS_PROP: return ""object_ids_prop"";
				 case INCRDECR_PROP: return ""incrdecr_prop"";
				 case CATCH_SCOPE_PROP: return ""catch_scope_prop"";
				 case LABEL_ID_PROP: return ""label_id_prop"";
				 case MEMBER_TYPE_PROP: return ""member_type_prop"";
				 case NAME_PROP: return ""name_prop"";
				 default: Kit.codeBug();
			 }
		 }
		 return null;
	 }
	 private PropListItem lookupProperty(int propType) {
		 PropListItem x = propListHead;
		 while (x != null && propType != x.type) {
			 x = x.next;
		 }
		 return x;
	 }
	 private PropListItem ensureProperty(int propType) {
		 PropListItem item = lookupProperty(propType);
		 if (item == null) {
			 item = new PropListItem();
			 item.type = propType;
			 item.next = propListHead;
			 propListHead = item;
		 }
		 return item;
	 }
	 public void removeProp(int propType) {
		 PropListItem x = propListHead;
		 if (x != null) {
			 PropListItem prev = null;
			 while (x.type != propType) {
				 prev = x;
				 x = x.next;
				 if (x == null) {
					 return;
				 }
			 }
			 if (prev == null) {
				 propListHead = x.next;
			 }
			 else {
				 prev.next = x.next;
			 }
		 }
	 }
	 public Object getProp(int propType) {
		 PropListItem item = lookupProperty(propType);
		 if (item == null) {
			 return null;
		 }
		 return item.objectValue;
	 }
	 public int getIntProp(int propType, int defaultValue) {
		 PropListItem item = lookupProperty(propType);
		 if (item == null) {
			 return defaultValue;
		 }
		 return item.intValue;
	 }
	 public int getExistingIntProp(int propType) {
		 PropListItem item = lookupProperty(propType);
		 if (item == null) {
			 Kit.codeBug();
		 }
		 return item.intValue;
	 }
	 public void putProp(int propType, Object prop) {
		 if (prop == null) {
			 removeProp(propType);
		 }
		 else {
			 PropListItem item = ensureProperty(propType);
			 item.objectValue = prop;
		 }
	 }
	 public void putIntProp(int propType, int prop) {
		 PropListItem item = ensureProperty(propType);
		 item.intValue = prop;
	 }
	 public int getLineno() {
		 return lineno;
	 }
	 public final double getDouble() {
		 return ((NumberNode)this).number;
	 }
	 public final void setDouble(double number) {
		 ((NumberNode)this).number = number;
	 }
	 public final String getString() {
		 return ((StringNode)this).str;
	 }
	 public final void setString(String s) {
		 if (s == null) Kit.codeBug();
		 ((StringNode)this).str = s;
	 }
	 public static Node newTarget() {
		 return new Node(Token.TARGET);
	 }
	 public final int labelId() {
		 if (type != Token.TARGET) Kit.codeBug();
		 return getIntProp(LABEL_ID_PROP, -1);
	 }
	 public void labelId(int labelId) {
		 if (type != Token.TARGET) Kit.codeBug();
		 putIntProp(LABEL_ID_PROP, labelId);
	 }
	 public String toString() {
		 if (Token.printTrees) {
			 StringBuffer sb = new StringBuffer(Token.name(type));
			 if (this instanceof StringNode) {
				 sb.append(' ');
				 sb.append(getString());
			 }
			 else if (this instanceof ScriptOrFnNode) {
				 ScriptOrFnNode sof = (ScriptOrFnNode)this;
				 if (this instanceof FunctionNode) {
					 FunctionNode fn = (FunctionNode)this;
					 sb.append(' ');
					 sb.append(fn.getFunctionName());
				 }
				 sb.append("" [source name: "");
				 sb.append(sof.getSourceName());
				 sb.append(""] [encoded source length: "");
				 sb.append(sof.getEncodedSourceEnd() - sof.getEncodedSourceStart());
				 sb.append(""] [base line: "");
				 sb.append(sof.getBaseLineno());
				 sb.append(""] [end line: "");
				 sb.append(sof.getEndLineno());
				 sb.append(']');
			 }
			 else if (this instanceof Jump) {
				 Jump jump = (Jump)this;
				 if (type == Token.BREAK || type == Token.CONTINUE) {
					 sb.append("" [label: "");
					 sb.append(jump.getJumpStatement());
					 sb.append(']');
				 }
				 else if (type == Token.TRY) {
					 Node catchNode = jump.target;
					 Node finallyTarget = jump.getFinally();
					 if (catchNode != null) {
						 sb.append("" [catch: "");
						 sb.append(catchNode);
						 sb.append(']');
					 }
					 if (finallyTarget != null) {
						 sb.append("" [finally: "");
						 sb.append(finallyTarget);
						 sb.append(']');
					 }
				 }
				 else if (type == Token.LABEL || type == Token.LOOP || type == Token.SWITCH) {
					 sb.append("" [break: "");
					 sb.append(jump.target);
					 sb.append(']');
					 if (type == Token.LOOP) {
						 sb.append("" [continue: "");
						 sb.append(jump.getContinue());
						 sb.append(']');
					 }
				 }
				 else {
					 sb.append("" [target: "");
					 sb.append(jump.target);
					 sb.append(']');
				 }
			 }
			 else if (type == Token.NUMBER) {
				 sb.append(' ');
				 sb.append(getDouble());
			 }
			 if (lineno != -1) {
				 sb.append(' ');
				 sb.append(lineno);
			 }
			 for (PropListItem x = propListHead;
			 x != null;
			 x = x.next) {
				 int type = x.type;
				 sb.append("" ["");
				 sb.append(propToString(type));
				 sb.append("": "");
				 String value;
				 switch (type) {
					 case TARGETBLOCK_PROP : value = ""target block property"";
					 break;
					 case LOCAL_BLOCK_PROP : value = ""last local block"";
					 break;
					 case ISNUMBER_PROP: switch (x.intValue) {
						 case BOTH: value = ""both"";
						 break;
						 case RIGHT: value = ""right"";
						 break;
						 case LEFT: value = ""left"";
						 break;
						 default: throw Kit.codeBug();
					 }
					 break;
					 case SPECIALCALL_PROP: switch (x.intValue) {
						 case SPECIALCALL_EVAL: value = ""eval"";
						 break;
						 case SPECIALCALL_WITH: value = ""with"";
						 break;
						 default: throw Kit.codeBug();
					 }
					 break;
					 default : Object obj = x.objectValue;
					 if (obj != null) {
						 value = obj.toString();
					 }
					 else {
						 value = String.valueOf(x.intValue);
					 }
					 break;
				 }
				 sb.append(value);
				 sb.append(']');
			 }
			 return sb.toString();
		 }
		 return String.valueOf(type);
	 }
	 public String toStringTree(ScriptOrFnNode treeTop) {
		 if (Token.printTrees) {
			 StringBuffer sb = new StringBuffer();
			 toStringTreeHelper(treeTop, this, 0, sb);
			 return sb.toString();
		 }
		 return null;
	 }
	 private static void toStringTreeHelper(ScriptOrFnNode treeTop, Node n, int level, StringBuffer sb) {
		 if (Token.printTrees) {
			 for (int i = 0;
			 i != level;
			 ++i) {
				 sb.append("" "");
			 }
			 sb.append(n.toString());
			 sb.append('\n');
			 for (Node cursor = n.getFirstChild();
			 cursor != null;
			 cursor = cursor.getNext()) {
				 if (cursor.getType() == Token.FUNCTION) {
					 int fnIndex = cursor.getExistingIntProp(Node.FUNCTION_PROP);
					 FunctionNode fn = treeTop.getFunctionNode(fnIndex);
					 toStringTreeHelper(fn, fn, level + 1, sb);
				 }
				 else {
					 toStringTreeHelper(treeTop, cursor, level + 1, sb);
				 }
			 }
		 }
	 }
	 int type;
	 Node next;
	 private Node first;
	 private Node last;
	 private int lineno = -1;
	 private PropListItem propListHead;
}",1,0,0,0
